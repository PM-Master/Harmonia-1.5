package gov.nist.csd.pm.server;

import gov.nist.csd.pm.common.application.SSLSocketServer;
import gov.nist.csd.pm.common.net.ItemType;
import gov.nist.csd.pm.common.net.Packet;
import gov.nist.csd.pm.common.net.PacketException;
import gov.nist.csd.pm.common.net.PacketManager;
import gov.nist.csd.pm.common.util.RandomGUID;
import gov.nist.csd.pm.common.util.swing.DialogUtils;
import gov.nist.csd.pm.server.parser.*;

import javax.naming.*;
import javax.naming.directory.*;
import javax.swing.*;

import java.io.*;
import java.net.InetAddress;
import java.security.MessageDigest;
import java.security.SecureRandom;
import java.text.DateFormat;
import java.util.*;

import static gov.nist.csd.pm.common.info.PMCommand.ADD_HOST_APP;
import static gov.nist.csd.pm.common.net.Packet.*;

/**
 * @author gavrila@nist.gov
 * @version $Revision: 1.1 $, $Date: 2008/07/16 17:02:56 $
 * @since 1.5
 */
@SuppressWarnings("CallToThreadDumpStack")
public class PmEngine {

    public static final int PM_MAX_BLOCK_SIZE = 1024;
    public static final int PM_MAX_DISPLAYED_ASCS = 30;
    public static final String PM_FAILURE = "err ";
    public static final String PM_SUCCESS = "ok  ";
    public static final String PM_CMD = "cmd ";
    public static final String PM_EOC = "eoc ";
    public static final String PM_ARG = "arg ";
    public static final String PM_SEP = "sep ";
    public static final String PM_DATA = "data";
    public static final String PM_EOD = "eod ";
    public static final String PM_BYE = "bye ";
    public static final String PM_PROP_DELIM = "=";
    public static final String PM_FIELD_DELIM = ":";
    public static final String PM_ALT_FIELD_DELIM = "|";
    public static final String PM_ALT_DELIM_PATTERN = "\\|";
    public static final String PM_TERMINATOR = ".";
    public static final String PM_LIST_MEMBER_SEP = ",";
    public static final String PM_IMPORT_COMMENT_START = "#";
    public static final String PM_CONNECTOR_NAME = "PM";
    public static final String PM_CONNECTOR_ID = "1";
    public static final String PM_ADMIN_NAME = "admin";
    public static final String PM_ADMIN_ID = "2";
    public static final String PM_SUPER_ADMIN_NAME = "superAdmin";
    public static final String PM_SUPER_ADMIN_ID = "3";
    public static final String PM_SUPER_NAME = "super";
    public static final String PM_SUPER_PASS = "super";
    public static final String PM_SUPER_ID = "4";
    public static final String PM_EVERYTHING_NAME = "everything";
    public static final String PM_EVERYTHING_ID = "5";
    public static final String PM_EVERYTHING_ASSOC_ID = "6";
    public static final String PM_ALL_OPS_NAME = "all ops";
    public static final String PM_ALL_OPS_ID = "7";
    // Classes of actual objects
    public static final String PM_CLASS_CLASS_NAME = "class";
    public static final String PM_CLASS_CLASS_ID = "8";
    public static final String PM_CLASS_FILE_NAME = "File";
    public static final String PM_CLASS_FILE_ID = "9";
    public static final String PM_CLASS_DIR_NAME = "Directory";
    public static final String PM_CLASS_DIR_ID = "10";
    public static final String PM_CLASS_USER_NAME = "User";
    public static final String PM_CLASS_USER_ID = "11";
    public static final String PM_CLASS_UATTR_NAME = "User attribute";
    public static final String PM_CLASS_UATTR_ID = "12";
    public static final String PM_CLASS_OBJ_NAME = "Object";
    public static final String PM_CLASS_OBJ_ID = "13";
    public static final String PM_CLASS_OATTR_NAME = "Object attribute";
    public static final String PM_CLASS_OATTR_ID = "14";
    public static final String PM_CLASS_CONN_NAME = "Connector";
    public static final String PM_CLASS_CONN_ID = "15";
    public static final String PM_CLASS_POL_NAME = "Policy class";
    public static final String PM_CLASS_POL_ID = "16";
    public static final String PM_CLASS_OPSET_NAME = "Operation set";
    public static final String PM_CLASS_OPSET_ID = "17";
    public static final String PM_CLASS_ANY_NAME = "*";
    public static final String PM_CLASS_ANY_ID = "18";
    public static final String PM_CLASS_CLIPBOARD_NAME = "Clipboard";
    public static final String PM_CLASS_CLIPBOARD_ID = "19";
    public static final String PM_CLASS_RECORD_NAME = "Record";
    public static final String PM_CLASS_RECORD_ID = "20";
    public static final String PM_CLASS_SESSION_NAME = "Session";
    public static final String PM_CLASS_SESSION_ID = "21";
    public static final String PM_CLASS_CREATE_CLASS = "Class create class";
    public static final String PM_CLASS_DELETE_CLASS = "Class delete class";
    /**
	 * @uml.property  name="sClassOps" multiplicity="(0 -1)" dimension="1"
	 */
    private String sClassOps[] = {PM_CLASS_CREATE_CLASS, PM_CLASS_DELETE_CLASS};
    public static final String PM_DIR_MODIFY = "Dir modify";
    public static final String PM_DIR_READEXEC = "Dir read and execute";
    public static final String PM_DIR_LIST = "Dir list contents";
    public static final String PM_DIR_READ = "Dir read";
    public static final String PM_DIR_WRITE = "Dir write";
    /**
	 * @uml.property  name="sDirOps" multiplicity="(0 -1)" dimension="1"
	 */
    private String sDirOps[] = {PM_DIR_MODIFY, PM_DIR_READEXEC, PM_DIR_LIST,
            PM_DIR_READ, PM_DIR_WRITE};
    public static final String PM_FILE_MODIFY = "File modify";
    public static final String PM_FILE_READEXEC = "File read and execute";
    public static final String PM_FILE_READ = "File read";
    public static final String PM_FILE_WRITE = "File write";
    /**
	 * @uml.property  name="sFileOps" multiplicity="(0 -1)" dimension="1"
	 */
    private String sFileOps[] = {PM_FILE_MODIFY, PM_FILE_READEXEC,
            PM_FILE_READ, PM_FILE_WRITE};
    public static final String PM_ENTITY_REPRESENT = "Entity represent";
    public static final String PM_USER_CREATE_UATTR = "User create user attribute";
    public static final String PM_USER_ASSIGN = "User assign";
    public static final String PM_USER_DELETE = "User delete";
    public static final String PM_USER_DELETE_ASSIGN = "User delete assign";
    /**
	 * @uml.property  name="sUserOps" multiplicity="(0 -1)" dimension="1"
	 */
    private String sUserOps[] = {PM_USER_CREATE_UATTR, PM_USER_ASSIGN,
            PM_USER_DELETE, PM_USER_DELETE_ASSIGN, PM_ENTITY_REPRESENT};
    public static final String PM_UATTR_CREATE_UATTR = "User attribute create user attribute";
    public static final String PM_UATTR_CREATE_USER = "User attribute create user";
    public static final String PM_UATTR_DELETE_USER = "User attribute delete user";
    public static final String PM_UATTR_CREATE_OPSET = "User attribute create operation set";
    public static final String PM_UATTR_ASSIGN_TO_OPSET = "User attribute assign to operation set";
    public static final String PM_UATTR_ASSIGN = "User attribute assign";
    public static final String PM_UATTR_ASSIGN_TO = "User attribute assign to";
    public static final String PM_UATTR_DELETE = "User attribute delete";
    public static final String PM_UATTR_DELETE_ASSIGN = "User attribute delete assign";
    public static final String PM_UATTR_DELETE_ASSIGN_TO = "User attribute delete assign to";
    /**
	 * @uml.property  name="sUattrOps" multiplicity="(0 -1)" dimension="1"
	 */
    private String sUattrOps[] = {PM_UATTR_CREATE_UATTR, PM_UATTR_CREATE_USER,
            PM_UATTR_DELETE_USER, PM_UATTR_CREATE_OPSET,
            PM_UATTR_ASSIGN_TO_OPSET, PM_UATTR_ASSIGN, PM_UATTR_ASSIGN_TO,
            PM_UATTR_DELETE, PM_UATTR_DELETE_ASSIGN, PM_UATTR_DELETE_ASSIGN_TO,
            PM_ENTITY_REPRESENT};
    public static final String PM_OBJ_DELETE = "Object delete";
    /**
	 * @uml.property  name="sObjOps" multiplicity="(0 -1)" dimension="1"
	 */
    private String sObjOps[] = {PM_OBJ_DELETE};
    public static final String PM_OATTR_CREATE_OBJ = "Object attribute create object";
    public static final String PM_OATTR_DELETE_OBJ = "Object attribute delete object";
    public static final String PM_OATTR_CREATE_OATTR = "Object attribute create object attribute";
    public static final String PM_OATTR_DELETE_OATTR = "Object attribute delete object attribute";
    public static final String PM_OATTR_CREATE_OPSET = "Object attribute create operation set";
    public static final String PM_OATTR_ASSIGN = "Object attribute assign";
    public static final String PM_OATTR_ASSIGN_TO = "Object attribute assign to";
    public static final String PM_OATTR_DELETE = "Object attribute delete";
    public static final String PM_OATTR_DELETE_ASSIGN = "Object attribute delete assign";
    public static final String PM_OATTR_DELETE_ASSIGN_TO = "Object attribute delete assign to";
    /**
	 * @uml.property  name="sOattrOps" multiplicity="(0 -1)" dimension="1"
	 */
    private String sOattrOps[] = {PM_OATTR_CREATE_OBJ, PM_OATTR_DELETE_OBJ,
            PM_OATTR_CREATE_OATTR, PM_OATTR_DELETE_OATTR,
            PM_OATTR_CREATE_OPSET, PM_OATTR_ASSIGN, PM_OATTR_ASSIGN_TO,
            PM_OATTR_DELETE, PM_OATTR_DELETE_ASSIGN, PM_OATTR_DELETE_ASSIGN_TO,
            PM_ENTITY_REPRESENT};
    public static final String PM_POL_CREATE_UATTR = "Policy class create user attribute";
    public static final String PM_POL_DELETE_UATTR = "Policy class delete user attribute";
    public static final String PM_POL_CREATE_OATTR = "Policy class create object attribute";
    public static final String PM_POL_DELETE_OATTR = "Policy class delete object attribute";
    public static final String PM_POL_CREATE_OBJ = "Policy class create object";
    public static final String PM_POL_ASSIGN = "Policy class assign";
    public static final String PM_POL_ASSIGN_TO = "Policy class assign to";
    public static final String PM_POL_DELETE = "Policy class delete";
    public static final String PM_POL_DELETE_ASSIGN = "Policy class delete assign";
    public static final String PM_POL_DELETE_ASSIGN_TO = "Policy class delete assign to";
    /**
	 * @uml.property  name="sPolOps" multiplicity="(0 -1)" dimension="1"
	 */
    private String sPolOps[] = {PM_POL_CREATE_UATTR, PM_POL_DELETE_UATTR,
            PM_POL_CREATE_OATTR, PM_POL_DELETE_OATTR, PM_POL_CREATE_OBJ,
            PM_POL_ASSIGN, PM_POL_ASSIGN_TO, PM_POL_DELETE,
            PM_POL_DELETE_ASSIGN, PM_POL_DELETE_ASSIGN_TO, PM_ENTITY_REPRESENT};
    public static final String PM_OPSET_ASSIGN = "Operation set assign";
    public static final String PM_OPSET_ASSIGN_TO = "Operation set assign to";
    public static final String PM_OPSET_DELETE = "Operation set delete";
    public static final String PM_OPSET_DELETE_ASSIGN = "Operation set delete assign";
    public static final String PM_OPSET_DELETE_ASSIGN_TO = "Operation set delete assign to";
    /**
	 * @uml.property  name="sOpsetOps" multiplicity="(0 -1)" dimension="1"
	 */
    private String sOpsetOps[] = {PM_OPSET_ASSIGN, PM_OPSET_ASSIGN_TO,
            PM_OPSET_DELETE, PM_OPSET_DELETE_ASSIGN, PM_OPSET_DELETE_ASSIGN_TO,
            PM_ENTITY_REPRESENT};
    public static final String PM_CONN_CREATE_POL = "Connector create policy class";
    public static final String PM_CONN_DELETE_POL = "Connector delete policy class";
    public static final String PM_CONN_CREATE_USER = "Connector create user";
    public static final String PM_CONN_DELETE_USER = "Connector delete user";
    public static final String PM_CONN_CREATE_UATTR = "Connector create user attribute";
    public static final String PM_CONN_DELETE_UATTR = "Connector delete user attribute";
    public static final String PM_CONN_CREATE_OATTR = "Connector create object attribute";
    public static final String PM_CONN_DELETE_OATTR = "Connector delete object attribute";
    public static final String PM_CONN_CREATE_OBJ = "Connector create object";
    public static final String PM_CONN_CREATE_OPSET = "Connector create operation set";
    public static final String PM_CONN_ASSIGN_TO = "Connector assign to";
    public static final String PM_CONN_DELETE_ASSIGN_TO = "Connector delete assign to";
    /**
	 * @uml.property  name="sConnOps" multiplicity="(0 -1)" dimension="1"
	 */
    private String sConnOps[] = {PM_CONN_CREATE_POL, PM_CONN_DELETE_POL,
            PM_CONN_CREATE_USER, PM_CONN_DELETE_USER, PM_CONN_CREATE_UATTR,
            PM_CONN_DELETE_UATTR, PM_CONN_CREATE_OATTR, PM_CONN_DELETE_OATTR,
            PM_CONN_CREATE_OBJ, PM_CONN_CREATE_OPSET, PM_CONN_ASSIGN_TO,
            PM_CONN_DELETE_ASSIGN_TO, PM_ENTITY_REPRESENT};
    public static final String PM_ANY_ANY = "*";
    /**
	 * @uml.property  name="sAnyOps" multiplicity="(0 -1)" dimension="1"
	 */
    private String sAnyOps[] = {PM_ANY_ANY};
    public static final String PM_GRAPH_UATTR = "ua";
    public static final String PM_GRAPH_CAPS = "ca";
    public static final String PM_GRAPH_OATTR = "oa";
    public static final String PM_GRAPH_ACES = "ac";
    public static final String PM_GRAPH_PERMS = "pe";
    public static final String PM_NODE_USER = "u";
    public static final String PM_NODE_USERA = "U";
    public static final String PM_NODE_AUATTR = "aa";// active user attribute
    public static final String PM_NODE_UATTR = "a";
    public static final String PM_NODE_UATTRA = "A";
    public static final String PM_NODE_POL = "p";
    public static final String PM_NODE_POLA = "P";
    public static final String PM_NODE_OATTR = "b";
    public static final String PM_NODE_OATTRA = "B";
    public static final String PM_NODE_ASSOC = "o";
    public static final String PM_NODE_ASSOCA = "O";
    public static final String PM_NODE_OPSET = "s";
    public static final String PM_NODE_OPSETA = "S";
    public static final String PM_NODE_CONN = "c";
    public static final String PM_NODE_CONNA = "C";
    public static final String PM_NODE_M_PREFIX = "m";
    // A user attribute used in INTRASESSION deny constraints.
    public static final String PM_NODE_INTRA = "ai";
    public static final String PM_ID = "i";
    public static final String PM_SELECTED = "s";
    public static final String PM_ARC = "r";
    public static final String PM_HOST = "h";
    public static final String PM_OBJ_CLASS = "oc";
    public static final String PM_OP = "op";
    public static final String PM_OBJ = "ob";
    public static final String PM_COMPL_OATTR = "cb";
    public static final String PM_ASET = "as";
    public static final String PM_SAC = "sac";
    public static final String PM_SESSION = "ses";
    public static final String PM_PROCESS = "proc";
    public static final String PM_RULE = "rule";
    public static final String PM_PERM = "perm";
    public static final String PM_APP_PATH = "app";
    public static final String PM_KS_PATH = "ks";
    public static final String PM_DENY = "deny";
    public static final String PM_EMAIL_ACCT = "eml";
    public static final String PM_TEMPLATE = "tpl";
    public static final String PM_KEY = "key";
    public static final String PM_CONTAINERS = "conts";
    public static final String PM_COMPONENTS = "comps";
    public static final String PM_FULL_NAME = "fn";
    public static final String PM_VALUE = "v";
    public static final String PM_RECORD = "rec";
    public static final String PM_DENY_USER_ID = "user id";
    public static final String PM_DENY_USER_SET = "user set";
    public static final String PM_DENY_SESSION = "session";
    public static final String PM_DENY_PROCESS = "process";
    public static final String PM_DENY_INTRA_SESSION = "intra session";
    public static final String PM_DENY_ACROSS_SESSIONS = "across sessions";
    public static final String PM_FUN = "f";
    public static final String PM_UNKNOWN = "k";
    public static final String PM_SCRIPT = "scr";
    public static final String PM_PROP = "prop";
    public static final String PM_TASK = "tk";
    public static final String PM_SCON = "sc";
    public static final String PM_SCONA = "sca";
    public static final String PM_CAP = "cap";
    public static final String PM_THRESHOLD = "th";
    public static final String PM_LABEL = "l";
    public static final String PM_EVENT_CREATE = "create";
    public static final String PM_EVENT_DELETE = "delete";
    // Events.
    public static final String PM_EVENT_OBJECT_CREATE = "Object create";
    public static final String PM_EVENT_OBJECT_DELETE = "Object delete";
    public static final String PM_EVENT_OBJECT_READ = "Object read";
    public static final String PM_EVENT_OBJECT_WRITE = "Object write";
    public static final String PM_EVENT_USER_CREATE = "User create";
    public static final String PM_EVENT_SESSION_CREATE = "Session create";
    public static final String PM_EVENT_SESSION_DELETE = "Session delete";
    public static final String PM_EVENT_OBJECT_SEND = "Object send";
    /**
	 * @uml.property  name="sEventNames" multiplicity="(0 -1)" dimension="1"
	 */
    private String sEventNames[] = {PM_EVENT_OBJECT_CREATE,
            PM_EVENT_OBJECT_DELETE, PM_EVENT_OBJECT_READ,
            PM_EVENT_OBJECT_WRITE, PM_EVENT_USER_CREATE,
            PM_EVENT_SESSION_CREATE, PM_EVENT_SESSION_DELETE,
            PM_EVENT_OBJECT_SEND};
    // Requested information about events and their processing.
    public static final String PM_INFO_USER_SELECTS_CONTAINERS = "User selects containers";
    public static final String PM_SELECTION_MULTIPLE = "multiple";
    public static final String PM_SELECTION_SINGLE = "single";
    public static final String PM_VOS_PRES_ADMIN = "admin";
    public static final String PM_VOS_PRES_USER = "user";
    /**
	 * @uml.property  name="sThisDomain"
	 */
    private String sThisDomain = null;
    /**
	 * @uml.property  name="sEngineHost"
	 */
    private String sEngineHost = null;
    /**
	 * @uml.property  name="debugFlag"
	 */
    private boolean debugFlag = false;
    /**
	 * @uml.property  name="sAttrSetContainerDN"
	 */
    private String sAttrSetContainerDN;
    /**
	 * @uml.property  name="sConnectorContainerDN"
	 */
    private String sConnectorContainerDN;
    /**
	 * @uml.property  name="sDenyContainerDN"
	 */
    private String sDenyContainerDN;
    /**
	 * @uml.property  name="sEventContainerDN"
	 * @uml.associationEnd  
	 */
    private String sEventContainerDN;
    /**
	 * @uml.property  name="sHostContainerDN"
	 */
    private String sHostContainerDN;
    /**
	 * @uml.property  name="sVosNodeContainerDN"
	 */
    private String sVosNodeContainerDN;
    /**
	 * @uml.property  name="sAdminVosNodeContainerDN"
	 */
    private String sAdminVosNodeContainerDN;
    /**
	 * @uml.property  name="sObjAttrContainerDN"
	 */
    private String sObjAttrContainerDN;
    /**
	 * @uml.property  name="sObjClassContainerDN"
	 */
    private String sObjClassContainerDN;
    /**
	 * @uml.property  name="sOpsetContainerDN"
	 */
    private String sOpsetContainerDN;
    /**
	 * @uml.property  name="sOsConfigContainerDN"
	 */
    private String sOsConfigContainerDN;
    /**
	 * @uml.property  name="sPolicyContainerDN"
	 */
    private String sPolicyContainerDN;
    /**
	 * @uml.property  name="sPropertyContainerDN"
	 */
    private String sPropertyContainerDN;
    /**
	 * @uml.property  name="sSacContainerDN"
	 */
    private String sSacContainerDN;
    /**
	 * @uml.property  name="sSessionContainerDN"
	 */
    private String sSessionContainerDN;
    /**
	 * @uml.property  name="sStartupContainerDN"
	 */
    private String sStartupContainerDN;
    /**
	 * @uml.property  name="sUserAttrContainerDN"
	 */
    private String sUserAttrContainerDN;
    /**
	 * @uml.property  name="sUserContainerDN"
	 */
    private String sUserContainerDN;
    /**
	 * @uml.property  name="sUserConfigContainerDN"
	 */
    private String sUserConfigContainerDN;
    /**
	 * @uml.property  name="sNameContainerDN"
	 */
    private String sNameContainerDN;
    /**
	 * @uml.property  name="sVirtualObjContainerDN"
	 */
    private String sVirtualObjContainerDN;
    /**
	 * @uml.property  name="sRuleContainerDN"
	 * @uml.associationEnd  
	 */
    private String sRuleContainerDN;
    /**
	 * @uml.property  name="sTaskContainerDN"
	 */
    private String sTaskContainerDN;
    /**
	 * @uml.property  name="sSconContainerDN"
	 */
    private String sSconContainerDN;
    /**
	 * @uml.property  name="sSconaContainerDN"
	 */
    private String sSconaContainerDN;
    /**
	 * @uml.property  name="sEmailAcctContainerDN"
	 */
    private String sEmailAcctContainerDN;
    /**
	 * @uml.property  name="sTemplateContainerDN"
	 */
    private String sTemplateContainerDN;
    // AD Classes
    /**
	 * @uml.property  name="sAttrSetClass"
	 */
    private String sAttrSetClass;
    /**
	 * @uml.property  name="sConnectorClass"
	 */
    private String sConnectorClass;
    /**
	 * @uml.property  name="sEventClass"
	 */
    private String sEventClass;
    /**
	 * @uml.property  name="sConditionClass"
	 */
    private String sConditionClass;
    /**
	 * @uml.property  name="sDenyClass"
	 */
    private String sDenyClass;
    /**
	 * @uml.property  name="sHostClass"
	 */
    private String sHostClass;
    /**
	 * @uml.property  name="sVosNodeClass"
	 */
    private String sVosNodeClass;
    /**
	 * @uml.property  name="sAdminVosNodeClass"
	 */
    private String sAdminVosNodeClass;
    /**
	 * @uml.property  name="sObjAttrClass"
	 */
    private String sObjAttrClass;
    /**
	 * @uml.property  name="sObjClassClass"
	 */
    private String sObjClassClass;
    /**
	 * @uml.property  name="sOpsetClass"
	 */
    private String sOpsetClass;
    /**
	 * @uml.property  name="sOsConfigClass"
	 */
    private String sOsConfigClass;
    /**
	 * @uml.property  name="sPolicyClass"
	 */
    private String sPolicyClass;
    /**
	 * @uml.property  name="sPropertyClass"
	 */
    private String sPropertyClass;
    /**
	 * @uml.property  name="sSacClass"
	 */
    private String sSacClass;
    /**
	 * @uml.property  name="sSessionClass"
	 */
    private String sSessionClass;
    /**
	 * @uml.property  name="sStartupClass"
	 */
    private String sStartupClass;
    /**
	 * @uml.property  name="sUserClass"
	 */
    private String sUserClass;
    /**
	 * @uml.property  name="sUserAttrClass"
	 */
    private String sUserAttrClass;
    /**
	 * @uml.property  name="sUserConfigClass"
	 */
    private String sUserConfigClass;
    /**
	 * @uml.property  name="sVirtualObjClass"
	 */
    private String sVirtualObjClass;
    /**
	 * @uml.property  name="sScriptClass"
	 */
    private String sScriptClass;
    /**
	 * @uml.property  name="sScriptSourceClass"
	 */
    private String sScriptSourceClass;
    /**
	 * @uml.property  name="sSourceLineClass"
	 */
    private String sSourceLineClass;
    /**
	 * @uml.property  name="sRuleClass"
	 */
    private String sRuleClass;
    /**
	 * @uml.property  name="sEventPatternClass"
	 */
    private String sEventPatternClass;
    /**
	 * @uml.property  name="sActionClass"
	 */
    private String sActionClass;
    /**
	 * @uml.property  name="sOperandClass"
	 */
    private String sOperandClass; 
    /**
	 * @uml.property  name="sTaskClass"
	 */
    private String sTaskClass;
    /**
	 * @uml.property  name="sSconClass"
	 */
    private String sSconClass;
    /**
	 * @uml.property  name="sSconaClass"
	 */
    private String sSconaClass;
    /**
	 * @uml.property  name="sEmailAcctClass"
	 */
    private String sEmailAcctClass;
    /**
	 * @uml.property  name="sTemplateClass"
	 */
    private String sTemplateClass;
    /**
	 * @uml.property  name="evrFunctions"
	 * @uml.associationEnd  multiplicity="(0 -1)"
	 */
    private EvrFunction[] evrFunctions = {
            new EvrFunction("object_new", "ob", null),
            new EvrFunction("oattr_with_name_of_active_attr", "b", "p"),
            new EvrFunction("oattr_corresponding_to_active_attr", "b", "p"),
            new EvrFunction("oattr_of_user_choice", "b", "p"),
            new EvrFunction("oattr_of_default_user", "b", null),
            new EvrFunction("oattr_home_of_default_user", "b", null),
            new EvrFunction("user_default", "u", null),
            new EvrFunction("prop_home_of_new_user", "k", null),
            new EvrFunction("uattr_name_of_new_user", "a", null),
            new EvrFunction("prop_name_of_new_user", "k", null),
            new EvrFunction("user_new", "u", null),
            new EvrFunction("uattr_name_of_user", "a", "u"),
            new EvrFunction("prop_name_of_user", "k", "u"),
            new EvrFunction("pol_discr", "p", null),
            new EvrFunction("pol_id", "p", null),
            new EvrFunction("pol_with_prop", "p", "k"),
            new EvrFunction("oattr_home_of_new_user", "b", null),
            new EvrFunction("oattr_home_of_user", "b", "u"),
            new EvrFunction("obj_rep_of_home_of_new_user", "ob", null),
            new EvrFunction("obj_rep_of_home_of_user", "ob", "u"),
            new EvrFunction("oattr_rep_of_home_of_new_user", "b", null),
            new EvrFunction("oattr_rep_of_home_of_user", "b", "u"),
            new EvrFunction("oattr_rep_of_discr_users", "b", null),
            new EvrFunction("uattr_discr_users", "a", null),
            new EvrFunction("oattr_of_default_obj", "b", null),
            new EvrFunction("oattr_record_of_default_obj", "b", null),
            new EvrFunction("oattr_record_of_oattr", "b", "b"),
            new EvrFunction("uattr_lowest_level", "a", null),
            new EvrFunction("oattr_direct_asc_of_and_containing", "b", "b,b"),
            new EvrFunction("uattr_direct_ascs_of_uattr", "a", "a"),
            new EvrFunction("uattr_direct_ascs_of_uattr_except", "a", "a,a"),
            new EvrFunction("uattr_active_in_default_session_and_in_uattr",
                    "a", "a"), new EvrFunction("prop_discr_users", "k", null),
            new EvrFunction("obj_rep_of_discr_users", "ob", null),
            new EvrFunction("oattr_witems_of_new_user", "b", null),
            new EvrFunction("prop_witems_of_new_user", "k", null),
            new EvrFunction("oattr_inbox_of_new_user", "b", null),
            new EvrFunction("oattr_winbox_of_new_user", "b", null),
            new EvrFunction("oattr_inbox_of_user", "b", "u"),
            new EvrFunction("oattr_winbox_of_user", "b", "u"),
            new EvrFunction("oattr_outbox_of_new_user", "b", null),
            new EvrFunction("oattr_outbox_of_user", "b", "u"),
            new EvrFunction("prop_inbox_of_new_user", "k", null),
            new EvrFunction("prop_inbox_of_user", "k", "u"),
            new EvrFunction("prop_outbox_of_new_user", "k", null),
            new EvrFunction("prop_outbox_of_user", "k", "u"),
            new EvrFunction("obj_rep_of_inbox_of_new_user", "ob", null),
            new EvrFunction("obj_rep_of_inbox_of_user", "ob", "u"),
            new EvrFunction("oattr_rep_of_inbox_of_new_user", "b", null),
            new EvrFunction("oattr_rep_of_inbox_of_user", "b", "u"),
            new EvrFunction("obj_rep_of_outbox_of_new_user", "ob", null),
            new EvrFunction("obj_rep_of_outbox_of_user", "ob", "u"),
            new EvrFunction("oattr_rep_of_outbox_of_new_user", "b", null),
            new EvrFunction("oattr_rep_of_outbox_of_user", "b", "u"),
            new EvrFunction("user_recipient", "u", null),
            new EvrFunction("oattr_inboxes", "b", null),
            new EvrFunction("oattr_outboxes", "b", null),
            new EvrFunction("oattr_witems", "b", null),
            new EvrFunction("session_default", "ses", null),
            new EvrFunction("rule_composed_of", "rule", "k"),
            new EvrFunction("id_or_name_as_string", "k", "k"),
            new EvrFunction("name_of_rep_of_oattr", "b", "k"),
            new EvrFunction("oattr_rep_of_oattr", "b", "b"),
            new EvrFunction("obj_rep_of_oattr", "ob", "b"),
            new EvrFunction("process_default", "proc", null),};
    // A global where processEvent stores the enabled script id.
    /**
	 * @uml.property  name="sEnabledScriptId"
	 */
    private String sEnabledScriptId;
    /**
	 * @uml.property  name="env"
	 * @uml.associationEnd  qualifier="constant:java.lang.String java.lang.String"
	 */
    private Hashtable<String, String> env = null;
    /**
	 * @uml.property  name="ctx"
	 * @uml.associationEnd  multiplicity="(0 -1)" elementType="java.lang.String"
	 */
    private DirContext ctx;
    // Timestamp of last update of data and relations.
    /**
	 * @uml.property  name="sLastUpdateTimestamp"
	 */
    private String sLastUpdateTimestamp;
    /**
	 * @uml.property  name="dfUpdate"
	 */
    private DateFormat dfUpdate;
    /**
	 * @uml.property  name="nMaxDspAscs"
	 */
    private int nMaxDspAscs = PM_MAX_DISPLAYED_ASCS;
    /**
	 * @uml.property  name="htSelVosNodes"
	 * @uml.associationEnd  multiplicity="(0 -1)" ordering="true" elementType="java.lang.String" qualifier="sChooserId:java.lang.String java.util.Set"
	 */
    private HashMap<String, Set<String>> htSelVosNodes = new HashMap<String, Set<String>>();

    private void setContainerNames() {
        sAttrSetContainerDN = "CN=PmAttributeSetContainer," + sThisDomain;
        sConnectorContainerDN = "CN=PmConnectorContainer," + sThisDomain;
        sDenyContainerDN = "CN=PmDenyContainer," + sThisDomain;
        sHostContainerDN = "CN=PmHostContainer," + sThisDomain;
        sObjAttrContainerDN = "CN=PmObjectAttributeContainer," + sThisDomain;
        sObjClassContainerDN = "CN=PmObjectClassContainer," + sThisDomain;
        sOpsetContainerDN = "CN=PmOperationSetContainer," + sThisDomain;
        sOsConfigContainerDN = "CN=PmOsConfigContainer," + sThisDomain;
        sPolicyContainerDN = "CN=PmPolicyContainer," + sThisDomain;
        sPropertyContainerDN = "CN=PmPropertyContainer," + sThisDomain;
        sSacContainerDN = "CN=PmSacContainer," + sThisDomain;
        sSessionContainerDN = "CN=PmSessionContainer," + sThisDomain;
        sStartupContainerDN = "CN=PmStartupContainer," + sThisDomain;
        sUserAttrContainerDN = "CN=PmUserAttributeContainer," + sThisDomain;
        sUserContainerDN = "CN=PmUserContainer," + sThisDomain;
        sUserConfigContainerDN = "CN=PmUserConfigContainer," + sThisDomain;
        sNameContainerDN = "CN=PmNameContainer," + sThisDomain;
        sEventContainerDN = "CN=PmEventContainer," + sThisDomain;
        sVosNodeContainerDN = "CN=PmVosNodeContainer," + sThisDomain;
        sAdminVosNodeContainerDN = "CN=PmAdminVosNodeContainer," + sThisDomain;
        sVirtualObjContainerDN = "CN=PmVirtualObjContainer," + sThisDomain;
        sRuleContainerDN = "CN=PmRuleContainer," + sThisDomain;
        sTaskContainerDN = "CN=PmTaskContainer," + sThisDomain;
        sSconContainerDN = "CN=PmSconContainer," + sThisDomain;
        sSconaContainerDN = "CN=PmSconaContainer," + sThisDomain;
        sEmailAcctContainerDN = "CN=PmEmailAcctContainer," + sThisDomain;
        sTemplateContainerDN = "CN=PmTemplateContainer," + sThisDomain;
    }

    private void extractClassNames() {
        try {
            sAttrSetClass = getPmClassName("AttributeSetClassName");
            sConditionClass = getPmClassName("ConditionClassName");
            sConnectorClass = getPmClassName("ConnectorClassName");
            sDenyClass = getPmClassName("DenyClassName");
            sHostClass = getPmClassName("HostClassName");
            sObjAttrClass = getPmClassName("ObjectAttributeClassName");
            sObjClassClass = getPmClassName("ObjectClassClassName");
            sOpsetClass = getPmClassName("OperationSetClassName");
            sOsConfigClass = getPmClassName("OsConfigClassName");
            sPolicyClass = getPmClassName("PolicyClassName");
            sPropertyClass = getPmClassName("PropertyClassName");
            sSacClass = getPmClassName("SacClassName");
            sSessionClass = getPmClassName("SessionClassName");
            sStartupClass = getPmClassName("StartupClassName");
            sUserClass = getPmClassName("UserClassName");
            sUserAttrClass = getPmClassName("UserAttributeClassName");
            sUserConfigClass = getPmClassName("UserConfigClassName");
            sEventClass = getPmClassName("EventClassName");
            sVosNodeClass = getPmClassName("VosNodeClassName");
            sAdminVosNodeClass = getPmClassName("AdminVosNodeClassName");
            sVirtualObjClass = getPmClassName("VirtualObjectClassName");
            sScriptClass = getPmClassName("ScriptClassName");
            sScriptSourceClass = getPmClassName("ScriptSourceClassName");
            sSourceLineClass = getPmClassName("SourceLineClassName");
            sRuleClass = getPmClassName("RuleClassName");
            sEventPatternClass = getPmClassName("EventPatternClassName");
            sActionClass = getPmClassName("ActionClassName");
            sOperandClass = getPmClassName("OperandClassName");
            sTaskClass = getPmClassName("TaskClassName");
            sSconClass = getPmClassName("StaticConstraintClassName");
            sSconaClass = getPmClassName("SconaClassName");
            sEmailAcctClass = getPmClassName("EmailAcctClassName");
            sTemplateClass = getPmClassName("TemplateClassName");
        } catch (Exception e) {
            System.out.println("Unable to extract the class names");
            e.printStackTrace();
            System.exit(1);
        }
    }

    // The PmNameContainer contains a map of all PM object classes, for example,
    // UserClassName ---> pmClassUser. The reason is that from time to time
    // the PM classes might get updated, and most often that requires a new
    // class with a changed name to be created. All one has to do is to change
    // the mapping in PmNameContainer, for example, UserClassName --->
    // pmClassUser1.
    // The actual name is kept in the attribute pmName.
    private String getPmClassName(String sClassId) throws Exception {
        Attributes attrs = ctx.getAttributes("CN=" + sClassId + ","
                + sNameContainerDN);
        Attribute attr = attrs.get("pmName");
        String sClassName = (String) attr.get();
        return sClassName;
    }

    public PmEngine(boolean bDebug, int nPort) throws Exception {
        this.debugFlag = bDebug;
        String message = "Administrator's Password:";
        String adminPass = DialogUtils.showQuestionDisplay(message, true);

        DialogUtils.getAllSystemProperties("Server");

        // cAdminPass = "myMachinePasswordHere".toCharArray();
        //TODO: REMOVE to type password. 

        // Find the domain name.
        InetAddress addr = InetAddress.getLocalHost();
        String sDomName = addr.getCanonicalHostName();
        String[] pieces = sDomName.split("\\.");
        sEngineHost = pieces[0];
        System.out.println("Using engine host " + sEngineHost);

        StringBuilder sb = new StringBuilder();

        for (int i = 1; i < pieces.length; i++) {
            if (i == 1) {
                sb.append("DC=").append(pieces[i]);
            } else {
                sb.append(",DC=").append(pieces[i]);
            }
        }
        sThisDomain = sb.toString();

        // Connect to the LDAP server
        try {
            env = new Hashtable<String, String>();
            env.put(Context.INITIAL_CONTEXT_FACTORY,
                    "com.sun.jndi.ldap.LdapCtxFactory");
            env.put(Context.SECURITY_AUTHENTICATION, "simple");
            env.put(Context.SECURITY_PRINCIPAL, "CN=Administrator,CN=Users,"
                    + sThisDomain);
            env.put(Context.SECURITY_CREDENTIALS, adminPass);
            env.put(Context.PROVIDER_URL, "ldap://" + sEngineHost + ":389/");
            env.put("java.naming.ldap.version", "3");
            ctx = new InitialDirContext(env);
        } catch (AuthenticationException e) {
            if (debugFlag) {
                e.printStackTrace();
            }
            System.out.println("PM Engine: Authentication to AD failed!" + e.getMessage());
            System.exit(1);
        } catch (Exception e) {
            if (debugFlag) {
                e.printStackTrace();
            }
            System.out.println("PM Engine: Failed to connect to AD" + e.getMessage());
            System.exit(1);
        }

        // Set the containers' names.
        setContainerNames();

        dfUpdate = DateFormat.getDateTimeInstance(DateFormat.LONG,
                DateFormat.LONG);
        setLastUpdateTimestamp();

        extractClassNames();

        createInitialObjects();

        emptyContainer(sSessionContainerDN, null);
        emptyContainer(sEventContainerDN, null);

        // Set the URL protocol handler for https
        System.setProperty("java.protocol.handler.pkgs",
                "com.sun.net.ssl.internal.www.protocol");
    }

    private void createInitialObjects() {
        String sObjName = null; // Used to locate where an exception occurred.
        Attributes attrs;
        Packet res;

        createObjClass(PM_CLASS_CLASS_NAME, PM_CLASS_CLASS_ID, sClassOps,
                "Class of all object classes");
        createObjClass(PM_CLASS_ANY_NAME, PM_CLASS_ANY_ID, sAnyOps,
                "Class any class");
        createObjClass(PM_CLASS_FILE_NAME, PM_CLASS_FILE_ID, sFileOps,
                "Class of files");
        createObjClass(PM_CLASS_DIR_NAME, PM_CLASS_DIR_ID, sDirOps,
                "Class of directories");
        createObjClass(PM_CLASS_USER_NAME, PM_CLASS_USER_ID, sUserOps,
                "Class of PM users");
        createObjClass(PM_CLASS_UATTR_NAME, PM_CLASS_UATTR_ID, sUattrOps,
                "Class of PM user attributes");
        createObjClass(PM_CLASS_OBJ_NAME, PM_CLASS_OBJ_ID, sObjOps,
                "Class of PM objects");
        createObjClass(PM_CLASS_OATTR_NAME, PM_CLASS_OATTR_ID, sOattrOps,
                "Class of PM object attributes");
        createObjClass(PM_CLASS_POL_NAME, PM_CLASS_POL_ID, sPolOps,
                "Class of PM policy classes");
        createObjClass(PM_CLASS_OPSET_NAME, PM_CLASS_OPSET_ID, sOpsetOps,
                "Class of PM operation sets");
        createObjClass(PM_CLASS_CONN_NAME, PM_CLASS_CONN_ID, sConnOps,
                "Class of the PM connector node");

        try {
            // If the connector node does not exist, create it.
            sObjName = PM_CONNECTOR_NAME;
            if (!entityExists(PM_CONNECTOR_ID, PM_NODE_CONN)) {
                attrs = new BasicAttributes(true); // true means ignoreCase
                attrs.put("objectClass", sConnectorClass);
                attrs.put("pmId", PM_CONNECTOR_ID);
                attrs.put("pmName", PM_CONNECTOR_NAME);
                ctx.bind("CN=" + PM_CONNECTOR_ID + "," + sConnectorContainerDN,
                        null, attrs);
            }

            // If the "admin" policy class does not exist, create it.
            sObjName = PM_ADMIN_NAME;
            if (!entityExists(PM_ADMIN_ID, PM_NODE_POL)) {
                res =  addPcInternal(PM_ADMIN_NAME, PM_ADMIN_ID,
                        "The admin policy class", "No other info", null);
                if (res.hasError()) {
                    System.out.println("Failed to create the \"admin\" policy class!");
                    System.exit(1);
                }
            }

            // If the "superAdmin" user attribute does not exist, create it.
            sObjName = PM_SUPER_ADMIN_NAME;
            if (!entityExists(PM_SUPER_ADMIN_ID, PM_NODE_UATTR)) {
                attrs = new BasicAttributes(true); // true means ignoreCase
                attrs.put("objectClass", sUserAttrClass);
                attrs.put("pmId", PM_SUPER_ADMIN_ID);
                attrs.put("pmName", PM_SUPER_ADMIN_NAME);
                attrs.put("pmDescription", "The superAdmin user attribute.");
                attrs.put("pmOtherInfo", "No other info.");
                ctx.bind(
                        "CN=" + PM_SUPER_ADMIN_ID + "," + sUserAttrContainerDN,
                        null, attrs);
                res =  addDoubleLink(PM_SUPER_ADMIN_ID, PM_NODE_UATTR,
                        PM_ADMIN_ID, PM_NODE_POL);
                if (res.hasError()) {
                    System.out.println("Failed to link \"superAdmin\" to policy class \"admin\"");
                    System.exit(1);
                }
            }

            // If the "super" user does not exist, create it.
            sObjName = PM_SUPER_NAME;
            if (!entityExists(PM_SUPER_ID, PM_NODE_USER)) {
                res =  addUserInternal(PM_SUPER_NAME, PM_SUPER_ID,
                        PM_SUPER_NAME, "Super administrator user",
                        PM_SUPER_NAME, PM_SUPER_ADMIN_ID, PM_NODE_UATTR);
                if (res.hasError()) {
                    System.out.println("Failed to create \"super\"");
                    System.exit(1);
                }
            }

            // Create a virtual object (and its associated oattr) to represent
            // all entities.
            sObjName = PM_EVERYTHING_NAME;
            if (!entityExists(PM_EVERYTHING_ID, PM_OBJ)) {
                res =  addObjectInternal(PM_EVERYTHING_NAME,
                        PM_EVERYTHING_ID, PM_EVERYTHING_ASSOC_ID,
                        "Object mapped to all entities.", "No info.",
                        PM_ADMIN_ID, PM_NODE_POL, PM_CLASS_CONN_NAME, null,
                        null, null, PM_CONNECTOR_NAME, PM_CONNECTOR_ID, true,
                        null, null, null, null, null, null, null);
                if (res.hasError()) {
                    System.out.println("Failed to create the \"everything\" object");
                    System.exit(1);
                }
            }

            // Create an operation set "all ops".
            sObjName = PM_ALL_OPS_NAME;
            if (!entityExists(PM_ALL_OPS_ID, PM_NODE_OPSET)) {
                res =  addOpsetAndOpInternal(PM_ALL_OPS_NAME,
                        PM_ALL_OPS_ID, "Op set containing all operations",
                        "No info.", PM_ANY_ANY, PM_SUPER_ADMIN_ID,
                        PM_NODE_UATTR, PM_EVERYTHING_ASSOC_ID, PM_NODE_OATTR);
                if (res.hasError()) {
                    System.out.println("Failed to create and assign all operations set");
                    System.exit(1);
                }
            }

            // If a host for the computer where the engine is running does not
            // exist,
            // create one.
            InetAddress ia = InetAddress.getLocalHost();
            String sCanHostName = ia.getCanonicalHostName();
            System.out.println("Engine host canonical name is " + sCanHostName);
            String[] pieces = sCanHostName.split("\\.");

            if (!entityNameExists(pieces[0], PM_HOST)) {

                JTextField workField = new JTextField();
                String message = "PM Work Area:";
                String sWorkArea;
                while (true) {
                    int result = JOptionPane.showOptionDialog(null,
                            new Object[]{message, workField}, "Work area",
                            JOptionPane.OK_CANCEL_OPTION,
                            JOptionPane.QUESTION_MESSAGE, null, null, null);
                    if (result == JOptionPane.CANCEL_OPTION) {
                        System.exit(1);
                    }
                    sWorkArea = workField.getText().trim();
                    if (sWorkArea.length() > 0) {
                        break;
                    }
                }
                res =  addHost(PM_SUPER_ID, pieces[0], sWorkArea,
                        "Ignored.", "Ignored.", "Engine host", "true");
                if (res.hasError()) {
                    System.out.println("Failed to create the engine's host!");
                    System.exit(1);
                }
            }

            /*
             * // If a discretionary policy class does not exist, create one.
             * sObjName = "Discretionary policy class"; // for possible error
             * message. String sDacPolId =
             * getEntityWithPropInternal(PM_NODE_POL, "type=discretionary"); if
             * (sDacPolId == null) { res = addPcInternal("DAC", null,
             * "Discretionary policy", "None", new String[]
             * {"type=discretionary"}); if (res.hasError()) {
             * System.out.println(
             * "Failed to create the discretionary policy class!");
             * System.exit(1); } String s = ((String)res.get(0)).substring(4);
             * pieces = s.split(PM_FIELD_DELIM); sDacPolId = pieces[1]; }
             *
             * // If a container (user attribute) containing all DAC users
             * (actually their name // attributes) does not exist, create it.
             * sObjName = "DAC uattrs"; String sDacUattrsId =
             * getEntityWithPropInternal(PM_NODE_UATTR,
             * "usersof=discretionary"); if (sDacUattrsId == null) { res =
             * addUattrInternal("DAC uattrs",
             * "Container of DAC users name attributes", "None", sDacPolId,
             * PM_NODE_POL, new String[] {"usersof=discretionary"}); if
             * (res.hasError()) {
             * System.out.println("Failed to create the \"DAC uattrs\" attribute!"
             * ); System.out.println(getMessage(res)); System.exit(1); } String
             * s = ((String)res.get(0)).substring(4); pieces =
             * s.split(PM_FIELD_DELIM); sDacUattrsId = pieces[1];
             *
             * // Create a virtual object (and its associated object attribute)
             * // to represent the above container and all its ascendants. res =
             * addObjectInternal("DAC uattrs rep", null, null,
             * "Representative of the name attributes container", "None",
             * sDacPolId, PM_NODE_POL, PM_CLASS_UATTR_NAME, null, null, null,
             * "DAC uattrs", sDacUattrsId, true, null, null, null, null); if
             * (res.hasError()) {
             * System.out.println("Failed to create the \"DAC uattrs rep\" object"
             * ); System.exit(1); } }
             *
             * // Now let's create the name attribute "Exporter". sObjName =
             * "Exporter"; String sExporterAttrId =
             * getEntityWithPropInternal(PM_NODE_UATTR, "nameof=exporter"); if
             * (sExporterAttrId == null) { res =
             * addUattrInternal("Exporter",
             * "Name attribute of the exporter user", "None", sDacUattrsId,
             * PM_NODE_UATTR, new String[] {"nameof=exporter"}); if
             * (res.hasError()) { System.out.println(
             * "Failed to create the \"Exporter\" name attribute!");
             * System.out.println(getMessage(res)); System.exit(1); } String s =
             * ((String)res.get(0)).substring(4); pieces =
             * s.split(PM_FIELD_DELIM); sExporterAttrId = pieces[1]; }
             *
             * // If the "exporter" user does not exist, create it. sObjName =
             * "exporter"; String sExporterId = getIdOfEntityWithNameAndType("exporter",
             * PM_NODE_USER); if (sExporterId == null) { res =
             * addUserInternal("exporter", null, "Exporter",
             * "Exporter of objects and email messages", "", sExporterAttrId,
             * PM_NODE_UATTR); if (res.hasError()) {
             * System.out.println("Failed to create the \"exporter\" user!");
             * System.exit(1); } }
             */

        } catch (CommunicationException e) {
            if (debugFlag) {
                e.printStackTrace();
            }
            System.out.println("AD connection error");
            System.exit(1);
        } catch (Exception e) {
            if (debugFlag) {
                e.printStackTrace();
            }
            System.out.println("Unable to create " + sObjName);
            System.exit(1);
        }
    }

    // Create a predefined object class if it does not already exist.
    private void createObjClass(String sClassName, String sClassId,
                                String[] sClassOps, String sDescr) {
        Attributes attrs;
        ModificationItem[] mods;

        if (entityExists(sClassId, PM_OBJ_CLASS)) {
            return;
        }
        attrs = new BasicAttributes(true); // true means ignoreCase
        attrs.put("objectClass", sObjClassClass);
        attrs.put("pmId", sClassId);
        attrs.put("pmName", sClassName);
        attrs.put("pmDescription", sDescr);
        attrs.put("pmOtherInfo", "No other info.");
        try {
            ctx.bind("CN=" + sClassId + "," + sObjClassContainerDN, null, attrs);
            // Add the predefined operations.
            mods = new ModificationItem[sClassOps.length];
            for (int i = 0; i < sClassOps.length; i++) {
                mods[i] = new ModificationItem(DirContext.ADD_ATTRIBUTE,
                        new BasicAttribute("pmOp", sClassOps[i]));
            }
            ctx.modifyAttributes("CN=" + sClassId + "," + sObjClassContainerDN,
                    mods);
        } catch (CommunicationException e) {
            if (debugFlag) {
                e.printStackTrace();
            }
            System.out.println("AD connection error");
            System.exit(1);
        } catch (Exception e) {
            if (debugFlag) {
                e.printStackTrace();
            }
            System.out.println("Unable to create predefined class "
                    + sClassName);
            System.exit(1);
        }
    }

    @SuppressWarnings("unused")
    public synchronized Packet executeCommand(String sClientId,
                                              Packet cmdPacket, InputStream bisFromClient,
                                              OutputStream bosToClient) {
        // Get the command code.
        String sCmdCode = cmdPacket.getStringValue(0);
        System.out.println(sCmdCode);
        System.out.println("PM Engine Dispatch " + sCmdCode);
        // Dispatch the command
        try {
            if (sCmdCode.equalsIgnoreCase("testSynchro")) {
                return testSynchro(sClientId);

            } else if (sCmdCode.equalsIgnoreCase("testDoubleLink")) {
                return testDoubleLink();

            } else if (sCmdCode.equalsIgnoreCase("connect")) {
                return successPacket(sClientId);

            } else if (sCmdCode.equalsIgnoreCase("reset")) {
                if (cmdPacket.size() < 2) {
                    return failurePacket("Too few arguments!");
                }
                String crtSessionId = cmdPacket.getStringValue(1);
                return reset(sClientId, crtSessionId);

            } else if (sCmdCode.equalsIgnoreCase("getGraph")) {
                if (cmdPacket.size() < 7) {
                    return failurePacket("Too few arguments!");
                }
                String crtSessionId = cmdPacket.getStringValue(1);
                String sType = cmdPacket.getStringValue(2);
                String sAnchorId = cmdPacket.getStringValue(3);
                String sAnchorLabel = cmdPacket.getStringValue(4);
                String sAnchorType = cmdPacket.getStringValue(5);
                String sLevel = cmdPacket.getStringValue(6);
                return getGraph(sClientId, sType, sAnchorId, sAnchorLabel,
                        sAnchorType, sLevel);

            } else if (sCmdCode.equalsIgnoreCase("getPolicyClasses")) {
                return getPolicyClasses(sClientId);

            } else if (sCmdCode.equalsIgnoreCase("addPc")) {
                if (cmdPacket.size() < 6) {
                    return failurePacket("Too few arguments!");
                }
                String sSessId = cmdPacket.getStringValue(1);
                String sProcId = cmdPacket.getStringValue(2);
                String sName = cmdPacket.getStringValue(3);
                String sDescr = cmdPacket.getStringValue(4);
                String sInfo = cmdPacket.getStringValue(5);
                // The properties start at item 5:
                String[] sProps = getItemsFromPacket(cmdPacket, 5);
                return addPc(sSessId, sProcId, sName, sDescr, sInfo, sProps);

            } else if (sCmdCode.equalsIgnoreCase("getPcInfo")) {
                if (cmdPacket.size() < 4) {
                    return failurePacket("Too few arguments!");
                }
                String sSessId = cmdPacket.getStringValue(1);
                String sPcId = cmdPacket.getStringValue(2);
                String sIsVos = cmdPacket.getStringValue(3);
                return getPcInfo(sSessId, sPcId, sIsVos);

            } else if (sCmdCode.equalsIgnoreCase("addUattr")) {
                if (cmdPacket.size() < 9) {
                    return failurePacket("Too few arguments!");
                }
                String crtSessionId = cmdPacket.getStringValue(1);
                String sProcId = cmdPacket.getStringValue(2);
                String sName = cmdPacket.getStringValue(3);
                String sDescr = cmdPacket.getStringValue(4);
                String sInfo = cmdPacket.getStringValue(5);
                String sBaseId = cmdPacket.getStringValue(6);
                String sBaseType = cmdPacket.getStringValue(7);
                String sBaseIsVos = cmdPacket.getStringValue(8);
                // The properties start at item 9:
                String[] sProps = getItemsFromPacket(cmdPacket, 9);
                return addUattr(sClientId, crtSessionId, sProcId, sName,
                        sDescr, sInfo, sBaseId, sBaseType, sBaseIsVos, sProps);

            } else if (sCmdCode.equalsIgnoreCase("addOattr")) {
                if (cmdPacket.size() < 8) {
                    return failurePacket("Too few arguments!");
                }
                String crtSessionId = cmdPacket.getStringValue(1);
                String sProcId = cmdPacket.getStringValue(2);
                String sName = cmdPacket.getStringValue(3);
                String sDescr = cmdPacket.getStringValue(4);
                String sInfo = cmdPacket.getStringValue(5);
                String sBaseId = cmdPacket.getStringValue(6);
                String sBaseType = cmdPacket.getStringValue(7);
                String sBaseIsVos = cmdPacket.getStringValue(8);
                String sAssocObjId = cmdPacket.getStringValue(9); // Could be
                // "".
                // When invoked from a client, there is no associated object id
                // (should be "").
                // The properties start at item 10.
                String[] sProps = getItemsFromPacket(cmdPacket, 10);
                if (sProps == null) {
                    System.out.println("sProps is null");
                } else {
                    for (int i = 0; i < sProps.length; i++) {
                        System.out.println(i + " " + sProps[i]);
                    }
                }
                return addOattr(crtSessionId, sProcId, sName, sDescr, sInfo,
                        sBaseId, sBaseType, sBaseIsVos, sAssocObjId, sProps);

            } else if (sCmdCode.equalsIgnoreCase("assign")) {
                if (cmdPacket.size() < 8) {
                    return failurePacket("Too few arguments!");
                }
                String sSessId = cmdPacket.getStringValue(1);
                String sProcId = cmdPacket.getStringValue(2);
                String sId1 = cmdPacket.getStringValue(3);
                String sType1 = cmdPacket.getStringValue(4);
                String sId2 = cmdPacket.getStringValue(5);
                String sType2 = cmdPacket.getStringValue(6);
                String sIsAdminVos = cmdPacket.getStringValue(7);
                return assign(sSessId, sProcId, sId1, sType1, sId2, sType2,
                        sIsAdminVos);

            } else if (sCmdCode.equalsIgnoreCase("deleteAssignment")) {
                if (cmdPacket.size() < 8) {
                    return failurePacket("Too few arguments!");
                }
                String sSessId = cmdPacket.getStringValue(1);
                String sProcId = cmdPacket.getStringValue(2);
                String sId1 = cmdPacket.getStringValue(3);
                String sType1 = cmdPacket.getStringValue(4);
                String sId2 = cmdPacket.getStringValue(5);
                String sType2 = cmdPacket.getStringValue(6);
                String sIsAdminVos = cmdPacket.getStringValue(7);
                return deleteAssignment(sSessId, sProcId, sId1, sType1, sId2,
                        sType2, sIsAdminVos);

            } else if (sCmdCode.equalsIgnoreCase("getUserAttributes")) {
                return getUserAttributes(sClientId);

            } else if (sCmdCode.equalsIgnoreCase("getUsers")) {
                return getUsers(sClientId);

            } else if (sCmdCode.equalsIgnoreCase("getAsets")) {
                return getAsets(sClientId);

            } else if (sCmdCode.equalsIgnoreCase("addAsetAndAttr")) {
                if (cmdPacket.size() < 3) {
                    return failurePacket("Too few arguments!");
                }
                String sSessId = cmdPacket.getStringValue(1);
                String sAset = cmdPacket.getStringValue(2);
                String sAttrId = cmdPacket.getStringValue(3);
                String sAttr = cmdPacket.getStringValue(4);
                return addAsetAndAttr(sSessId, sAset, sAttrId, sAttr);

            } else if (sCmdCode.equalsIgnoreCase("deleteAsetAndAttr")) {
                if (cmdPacket.size() < 3) {
                    return failurePacket("Too few arguments!");
                }
                String sSessId = cmdPacket.getStringValue(1);
                String sAsetId = cmdPacket.getStringValue(2);
                String sAttrId = cmdPacket.getStringValue(3);
                String sAttr = cmdPacket.getStringValue(4);
                return deleteAsetAndAttr(sClientId, sAsetId, sAttrId, sAttr);

            } else if (sCmdCode.equalsIgnoreCase("getAsetInfo")) {
                if (cmdPacket.size() < 3) {
                    return failurePacket("Too few arguments!");
                }
                String sSessId = cmdPacket.getStringValue(1);
                String sAsetId = cmdPacket.getStringValue(2);
                return getAsetInfo(sClientId, sAsetId);

            } else if (sCmdCode.equalsIgnoreCase("getSacs")) {
                return getSacs(sClientId);

            } else if (sCmdCode.equalsIgnoreCase("addSacAndAset")) {
                if (cmdPacket.size() < 4) {
                    return failurePacket("Too few arguments!");
                }
                String sSessId = cmdPacket.getStringValue(1);
                String sSac = cmdPacket.getStringValue(2);
                String sType = cmdPacket.getStringValue(3);
                String sAsetId = cmdPacket.getStringValue(4);
                String sAset = cmdPacket.getStringValue(5);
                return addSacAndAset(sClientId, sSac, sType, sAsetId, sAset);

            } else if (sCmdCode.equalsIgnoreCase("deleteSacAndAset")) {
                if (cmdPacket.size() < 3) {
                    return failurePacket("Too few arguments!");
                }
                String sSessId = cmdPacket.getStringValue(1);
                String sSacId = cmdPacket.getStringValue(2);
                String sAsetId = cmdPacket.getStringValue(3);
                String sAset = cmdPacket.getStringValue(4);
                return deleteSacAndAset(sSessId, sSacId, sAsetId, sAset);

            } else if (sCmdCode.equalsIgnoreCase("getSacInfo")) {
                if (cmdPacket.size() < 3) {
                    return failurePacket("Too few arguments!");
                }
                String sSessId = cmdPacket.getStringValue(1);
                String sSacId = cmdPacket.getStringValue(2);
                return getSacInfo(sSessId, sSacId);

            } else if (sCmdCode.equalsIgnoreCase("addUser")) {
                if (cmdPacket.size() < 10) {
                    return failurePacket("Too few arguments!");
                }
                String sSessId = cmdPacket.getStringValue(1);
                String sProcId = cmdPacket.getStringValue(2);
                String sName = cmdPacket.getStringValue(3);
                String sFull = cmdPacket.getStringValue(4);
                String sInfo = cmdPacket.getStringValue(5);
                String sHash = cmdPacket.getStringValue(6);
                String sBaseId = cmdPacket.getStringValue(7);
                String sBaseType = cmdPacket.getStringValue(8);
                String sBaseIsVos = cmdPacket.getStringValue(9);
                return addUser(sSessId, sProcId, sName, sFull, sInfo, sHash,
                        sBaseId, sBaseType, sBaseIsVos);

            } else if (sCmdCode.equalsIgnoreCase("deleteNode")) {
                if (cmdPacket.size() < 5) {
                    return failurePacket("Too few arguments!");
                }
                String sSessId = cmdPacket.getStringValue(1);
                String sId = cmdPacket.getStringValue(2);
                String sType = cmdPacket.getStringValue(3);
                String sIsVos = cmdPacket.getStringValue(4);
                return deleteNode(sSessId, sId, sType, sIsVos);

            } else if (sCmdCode.equalsIgnoreCase("addObjClassAndOp")) {
                if (cmdPacket.size() < 6) {
                    return failurePacket("Too few arguments!");
                }
                String sSessId = cmdPacket.getStringValue(1);
                String sClass = cmdPacket.getStringValue(2);
                String sDescr = cmdPacket.getStringValue(3);
                String sInfo = cmdPacket.getStringValue(4);
                String sOp = cmdPacket.getStringValue(5);
                return addObjClassAndOp(sClientId, sClass, sDescr, sInfo, sOp);

            } else if (sCmdCode.equalsIgnoreCase("deleteObjClassAndOp")) {
                if (cmdPacket.size() < 3) {
                    return failurePacket("Too few arguments!");
                }
                String sSessId = cmdPacket.getStringValue(1);
                String sClass = cmdPacket.getStringValue(2);
                String sOp = cmdPacket.getStringValue(3);
                return deleteObjClassAndOp(sSessId, sClass, sOp);

            } else if (sCmdCode.equalsIgnoreCase("getObjClasses")) {
                return getObjClasses(sClientId);

            } else if (sCmdCode.equalsIgnoreCase("getObjects")) {
                return getObjects(sClientId);

            } else if (sCmdCode.equalsIgnoreCase("getPmEntitiesOfClass")) {
                if (cmdPacket.size() < 3) {
                    return failurePacket("Too few arguments!");
                }
                String sSessId = cmdPacket.getStringValue(1);
                String sClass = cmdPacket.getStringValue(2);
                return getPmEntitiesOfClass(sSessId, sClass);

            } else if (sCmdCode.equalsIgnoreCase("addObject3")) {
                if (cmdPacket.size() < 13) {
                    return failurePacket("Too few arguments!");
                }
                String sSessId = cmdPacket.getStringValue(1);
                String sProcId = cmdPacket.getStringValue(2);
                String sName = cmdPacket.getStringValue(3);
                String sDescr = cmdPacket.getStringValue(4);
                String sInfo = cmdPacket.getStringValue(5);
                String sContainers = cmdPacket.getStringValue(6);
                String sClass = cmdPacket.getStringValue(7);
                String sType = cmdPacket.getStringValue(8);
                String sHost = cmdPacket.getStringValue(9);
                String sPath = cmdPacket.getStringValue(10);
                String sOrigName = cmdPacket.getStringValue(11);
                String sOrigId = cmdPacket.getStringValue(12);
                String sInh = cmdPacket.getStringValue(13);
                String sSender = cmdPacket.getStringValue(14);
                String sRecip = cmdPacket.getStringValue(15);
                String sSubject = cmdPacket.getStringValue(16);
                String sAttached = cmdPacket.getStringValue(17);
                return addObject3(sSessId, sProcId, sName, sDescr, sInfo,
                        sContainers, sClass, sType, sHost, sPath, sOrigName,
                        sOrigId, sInh, sSender, sRecip, sSubject, sAttached,
                        null, null, null);

            } else if (sCmdCode.equalsIgnoreCase("deleteObject")) {
                if (cmdPacket.size() < 3) {
                    return failurePacket("Too few arguments!");
                }
                String sSessId = cmdPacket.getStringValue(1);
                String sObjId = cmdPacket.getStringValue(2);
                return deleteObject(sSessId, sObjId);

            } else if (sCmdCode.equalsIgnoreCase("deleteObjectStrong")) {
                if (cmdPacket.size() < 3) {
                    return failurePacket("Too few arguments!");
                }
                String sSessId = cmdPacket.getStringValue(1);
                String sObjId = cmdPacket.getStringValue(2);
                return deleteObjectStrong(sSessId, sObjId);

            } else if (sCmdCode.equalsIgnoreCase("deleteContainerObjects")) {
                if (cmdPacket.size() < 3) {
                    return failurePacket("Too few arguments!");
                }
                String sSessId = cmdPacket.getStringValue(1);
                String sContainerName = cmdPacket.getStringValue(2);
                return deleteContainerObjects(sSessId, sContainerName);

            } else if (sCmdCode.equalsIgnoreCase("getAssocObj")) {
                if (cmdPacket.size() < 3) {
                    return failurePacket("Too few arguments!");
                }
                String sSessId = cmdPacket.getStringValue(1);
                String sOaId = cmdPacket.getStringValue(2);
                return getAssocObj(sClientId, sOaId);

            } else if (sCmdCode.equalsIgnoreCase("getObjNamePath")) {
                if (cmdPacket.size() < 3) {
                    return failurePacket("Too few arguments!");
                }
                String sSessId = cmdPacket.getStringValue(1);
                String sObjName = cmdPacket.getStringValue(2);
                return getObjNamePath(sObjName);

            } else if (sCmdCode.equalsIgnoreCase("getObjClassOps")) {
                if (cmdPacket.size() < 3) {
                    return failurePacket("Too few arguments!");
                }
                String sSessId = cmdPacket.getStringValue(1);
                String sClass = cmdPacket.getStringValue(2);
                return getObjClassOps(sClientId, sClass);

            } else if (sCmdCode.equalsIgnoreCase("getHosts")) {
                return getHosts(sClientId);

            } else if (sCmdCode.equalsIgnoreCase("addHost")) {
                if (cmdPacket.size() < 8) {
                    return failurePacket("Too few arguments!");
                }
                String sSessId = cmdPacket.getStringValue(1);
                String sName = cmdPacket.getStringValue(2);
                String sRepo = cmdPacket.getStringValue(3);
                String sReserved = cmdPacket.getStringValue(4);
                String sIpa = cmdPacket.getStringValue(5);
                String sDescr = cmdPacket.getStringValue(6);
                String sPdc = cmdPacket.getStringValue(7);
                return addHost(sSessId, sName, sRepo, sReserved, sIpa, sDescr,
                        sPdc);

            } else if (sCmdCode.equalsIgnoreCase("updateHost")) {
                if (cmdPacket.size() < 8) {
                    return failurePacket("Too few arguments!");
                }
                String sSessId = cmdPacket.getStringValue(1);
                String sHostId = cmdPacket.getStringValue(2);
                String sHostName = cmdPacket.getStringValue(3);
                String sRepo = cmdPacket.getStringValue(4);
                String sIpa = cmdPacket.getStringValue(5);
                String sDescr = cmdPacket.getStringValue(6);
                String sPdc = cmdPacket.getStringValue(7);
                return updateHost(sSessId, sHostId, sHostName, sRepo, sIpa,
                        sDescr, sPdc);

            } else if (sCmdCode.equalsIgnoreCase("deleteHost")) {
                if (cmdPacket.size() < 3) {
                    return failurePacket("Too few arguments!");
                }
                String sSessId = cmdPacket.getStringValue(1);
                String sHostId = cmdPacket.getStringValue(2);
                return deleteHost(sSessId, sHostId);

            } else if (sCmdCode.equalsIgnoreCase("getHostInfo")) {
                if (cmdPacket.size() < 3) {
                    return failurePacket("Too few arguments!");
                }
                String sSessId = cmdPacket.getStringValue(1);
                String sHostId = cmdPacket.getStringValue(2);
                return getHostInfo(sSessId, sHostId);

            } else if (sCmdCode.equalsIgnoreCase("getOpsets")) {
                return getOpsets(sClientId);

            } else if (sCmdCode.equalsIgnoreCase("addOpsetAndOp")) {
                if (cmdPacket.size() < 5) {
                    return failurePacket("Too few arguments!");
                }
                String sSessId = cmdPacket.getStringValue(1);
                String sOpset = cmdPacket.getStringValue(2);
                String sDescr = cmdPacket.getStringValue(3);
                String sInfo = cmdPacket.getStringValue(4);
                String sOp = cmdPacket.getStringValue(5);
                String sBaseId = cmdPacket.getStringValue(6);
                String sBaseType = cmdPacket.getStringValue(7);
                return addOpsetAndOp(sSessId, sOpset, sDescr, sInfo, sOp,
                        sBaseId, sBaseType);

            } else if (sCmdCode.equalsIgnoreCase("getOpsetOps")) {
                if (cmdPacket.size() < 3) {
                    return failurePacket("Too few arguments!");
                }
                String sSessId = cmdPacket.getStringValue(1);
                String sOpset = cmdPacket.getStringValue(2);
                return getOpsetOps(sClientId, sOpset);

            } else if (sCmdCode.equalsIgnoreCase("getOpsetClassName")) {
                if (cmdPacket.size() < 3) {
                    return failurePacket("Too few arguments!");
                }

                String sSessId = cmdPacket.getStringValue(1);
                String sOpsetId = cmdPacket.getStringValue(2);
                return getOpsetClassName(sClientId, sOpsetId);

            } else if (sCmdCode.equalsIgnoreCase("getOpsetInfo")) {
                if (cmdPacket.size() < 3) {
                    return failurePacket("Too few arguments!");
                }
                String sSessId = cmdPacket.getStringValue(1);
                String sOpsetId = cmdPacket.getStringValue(2);
                return getOpsetInfo(sClientId, sOpsetId);

            } else if (sCmdCode.equalsIgnoreCase("deleteOpsetAndOp")) {
                if (cmdPacket.size() < 3) {
                    return failurePacket("Too few arguments!");
                }
                String sSessId = cmdPacket.getStringValue(1);
                String sOpsetId = cmdPacket.getStringValue(2);
                String sOp = cmdPacket.getStringValue(3);
                return deleteOpsetAndOp(sClientId, sOpsetId, sOp);

            } else if (sCmdCode.equalsIgnoreCase("createSession")) {
                if (cmdPacket.size() < 6) {
                    return failurePacket("Too few arguments!");
                }
                String sSessId = cmdPacket.getStringValue(1);
                String sName = cmdPacket.getStringValue(2);
                String sHost = cmdPacket.getStringValue(3);
                String sUser = cmdPacket.getStringValue(4);
                String sHash = cmdPacket.getStringValue(5);
                return createSession(sClientId, sName, sHost, sUser, sHash);

            } else if (sCmdCode.equalsIgnoreCase("spawnSession")) {
                if (cmdPacket.size() < 2) {
                    return failurePacket("Too few arguments!");
                }
                String sCrtSessId = cmdPacket.getStringValue(1);
                return spawnSession(sClientId, sCrtSessId);

            } else if (sCmdCode.equalsIgnoreCase("changePassword")) {
                if (cmdPacket.size() < 6) {
                    return failurePacket("Too few arguments!");
                }
                String sCrtSessId = cmdPacket.getStringValue(1);
                String sUser = cmdPacket.getStringValue(2);
                String sOldPass = cmdPacket.getStringValue(3);
                String sNewPass = cmdPacket.getStringValue(4);
                String sConPass = cmdPacket.getStringValue(5);
                return changePassword(sClientId, sUser, sOldPass, sNewPass,
                        sConPass);

            } else if (sCmdCode.equalsIgnoreCase("deleteSession")) {
                if (cmdPacket.size() < 3) {
                    return failurePacket("Too few arguments!");
                }
                String sCrtSessId = cmdPacket.getStringValue(1);
                String sId = cmdPacket.getStringValue(2);
                return deleteSession(sClientId, sId);

            } else if (sCmdCode.equalsIgnoreCase("refMediation")) {
                if (cmdPacket.size() < 3) {
                    return failurePacket("Too few arguments!");
                }
                String sCrtSessId = cmdPacket.getStringValue(1);
                String sObjName = cmdPacket.getStringValue(2);
                return refMediation(sCrtSessId, sObjName);

            } else if (sCmdCode.equalsIgnoreCase("getPermittedOps")) {
                if (cmdPacket.size() < 3) {
                    return failurePacket("Too few arguments!");
                }
                String sCrtSessId = cmdPacket.getStringValue(1);
                String sCrtProcId = cmdPacket.getStringValue(2);
                String sObjName = cmdPacket.getStringValue(3);
                return getPermittedOps(sCrtSessId, sCrtProcId, sObjName);

            } else if (sCmdCode.equalsIgnoreCase("getObjEmailProps")) {
                if (cmdPacket.size() < 3) {
                    return failurePacket("Too few arguments!");
                }
                String sCrtSessId = cmdPacket.getStringValue(1);
                String sObjName = cmdPacket.getStringValue(2);
                return getObjEmailProps(sCrtSessId, sObjName);

            } else if (sCmdCode.equalsIgnoreCase("getVosIdProperties")) {
                if (cmdPacket.size() < 4) {
                    return failurePacket("Too few arguments!");
                }
                String sCrtSessId = cmdPacket.getStringValue(1);
                String sPresType = cmdPacket.getStringValue(2);
                String sVosId = cmdPacket.getStringValue(3);
                return getVosIdProperties(sCrtSessId, sPresType, sVosId);

            } else if (sCmdCode.equalsIgnoreCase("computeVos")) {
                if (cmdPacket.size() < 5) {
                    return failurePacket("Too few arguments!");
                }
                String sCrtSessId = cmdPacket.getStringValue(1);
                String sPresType = cmdPacket.getStringValue(2);
                String sUserId = cmdPacket.getStringValue(3);
                String sSessId = cmdPacket.getStringValue(4);
                return computeVos(sClientId, sPresType, sUserId, sSessId);

            } else if (sCmdCode.equalsIgnoreCase("getVosGraph")) {
                if (cmdPacket.size() < 10) {
                    return failurePacket("Too few arguments!");
                }
                String sCrtSessId = cmdPacket.getStringValue(1);
                String sPresType = cmdPacket.getStringValue(2);
                String sUserName = cmdPacket.getStringValue(3);
                String sUserId = cmdPacket.getStringValue(4);
                String sSessId = cmdPacket.getStringValue(5);
                String sAnchorId = cmdPacket.getStringValue(6);
                String sAnchorLabel = cmdPacket.getStringValue(7);
                String sAnchorType = cmdPacket.getStringValue(8);
                String sLevel = cmdPacket.getStringValue(9);
                return getVosGraph(sClientId, sPresType, sUserName, sUserId,
                        sSessId, sAnchorId, sAnchorLabel, sAnchorType, sLevel);

            } else if (sCmdCode.equalsIgnoreCase("getSimpleVosGraph")) {
                if (cmdPacket.size() < 7) {
                    return failurePacket("Too few arguments!");
                }
                String sCrtSessId = cmdPacket.getStringValue(1);
                String sSessId = cmdPacket.getStringValue(2);
                String sAnchorId = cmdPacket.getStringValue(3);
                String sAnchorLabel = cmdPacket.getStringValue(4);
                String sAnchorType = cmdPacket.getStringValue(5);
                String sLevel = cmdPacket.getStringValue(6);
                return getSimpleVosGraph(sClientId, sSessId, sAnchorId,
                        sAnchorLabel, sAnchorType, sLevel);

            } else if (sCmdCode.equalsIgnoreCase("getSelVosGraph2")) {
                if (cmdPacket.size() < 11) {
                    return failurePacket("Too few arguments!");
                }
                String sCrtSessId = cmdPacket.getStringValue(1);
                String sSessId = cmdPacket.getStringValue(2);
                String sChooserId = cmdPacket.getStringValue(3);
                String sAnchorId = cmdPacket.getStringValue(4);
                String sAnchorLabel = cmdPacket.getStringValue(5);
                String sAnchorType = cmdPacket.getStringValue(6);
                String sLevel = cmdPacket.getStringValue(7);
                String sSelId = cmdPacket.getStringValue(8);
                String sSelLabel = cmdPacket.getStringValue(9);
                String sSelType = cmdPacket.getStringValue(10);
                String sSelMode = cmdPacket.getStringValue(11);
                String sAction = cmdPacket.getStringValue(12);
                return getSelVosGraph2(sClientId, sSessId, sChooserId,
                        sAnchorId, sAnchorLabel, sAnchorType, sLevel, sSelId,
                        sSelLabel, sSelType, sSelMode, sAction);

            } else if (sCmdCode.equalsIgnoreCase("getSelVosGraph")) {
                if (cmdPacket.size() < 11) {
                    return failurePacket("Too few arguments!");
                }
                String sCrtSessId = cmdPacket.getStringValue(1);
                String sSessId = cmdPacket.getStringValue(2);
                String sChooserId = cmdPacket.getStringValue(3);
                String sAnchorId = cmdPacket.getStringValue(4);
                String sAnchorLabel = cmdPacket.getStringValue(5);
                String sAnchorType = cmdPacket.getStringValue(6);
                String sLevel = cmdPacket.getStringValue(7);
                String sSelId = cmdPacket.getStringValue(8);
                String sSelLabel = cmdPacket.getStringValue(9);
                String sSelType = cmdPacket.getStringValue(10);
                String sSelMode = cmdPacket.getStringValue(11);
                String sAction = cmdPacket.getStringValue(12);
                return getSelVosGraph(sClientId, sSessId, sChooserId,
                        sAnchorId, sAnchorLabel, sAnchorType, sLevel, sSelId,
                        sSelLabel, sSelType, sSelMode, sAction);

            } else if (sCmdCode.equalsIgnoreCase("activateAttributes")) {
                if (cmdPacket.size() < 3) {
                    return failurePacket("Too few arguments!");
                }
                String sCrtSessId = cmdPacket.getStringValue(1);
                String sSessId = cmdPacket.getStringValue(2);
                String[] attrs = getItemsFromPacket(cmdPacket, 3);
                return activateAttributes(sClientId, sSessId, attrs);

            } else if (sCmdCode.equalsIgnoreCase("getActiveAttributes")) {
                if (cmdPacket.size() < 3) {
                    return failurePacket("Too few arguments!");
                }
                String sCrtSessId = cmdPacket.getStringValue(1);
                String sSessId = cmdPacket.getStringValue(2);
                return getActiveAttributes(sClientId, sSessId);

            } else if (sCmdCode.equalsIgnoreCase("getSessions")) {
                return getSessions(sClientId);

            } else if (sCmdCode.equalsIgnoreCase("getSessionEvents")) {
                return getSessionEvents(sClientId);

            } else if (sCmdCode.equalsIgnoreCase("getSessionInfo")) {
                if (cmdPacket.size() < 3) {
                    return failurePacket("Too few arguments!");
                }
                String sCrtSessId = cmdPacket.getStringValue(1);
                String sSessId = cmdPacket.getStringValue(2);
                return getSessionInfo(sClientId, sSessId);

            } else if (sCmdCode.equalsIgnoreCase("getSessionUser")) {
                if (cmdPacket.size() < 3) {
                    return failurePacket("Too few arguments!");
                }
                String sCrtSessId = cmdPacket.getStringValue(1);
                String sSessId = cmdPacket.getStringValue(2);
                return getSessionUser(sSessId);

            } else if (sCmdCode.equalsIgnoreCase("getSessionName")) {
                if (cmdPacket.size() < 3) {
                    return failurePacket("Too few arguments!");
                }
                String sCrtSessId = cmdPacket.getStringValue(1);
                String sSessId = cmdPacket.getStringValue(2);
                return getSessionName(sSessId);

            } else if (sCmdCode.equalsIgnoreCase("getProtObjs")) {
                if (cmdPacket.size() < 3) {
                    return failurePacket("Too few arguments!");
                }
                String sCrtSessId = cmdPacket.getStringValue(1);
                String sSessId = cmdPacket.getStringValue(2);
                return getProtObjs(sClientId, sSessId);

            } else if (sCmdCode.equalsIgnoreCase("updateProtObjs")) {
                if (cmdPacket.size() < 4) {
                    return failurePacket("Too few arguments!");
                }
                String sCrtSessId = cmdPacket.getStringValue(1);
                String sSessId = cmdPacket.getStringValue(2);
                String sClientLastTimestamp = cmdPacket.getStringValue(3);
                return updateProtObjs(sClientId, sSessId, sClientLastTimestamp);

            } else if (sCmdCode.equalsIgnoreCase("sessionHasCap")) {
                if (cmdPacket.size() < 5) {
                    return failurePacket("Too few arguments!");
                }
                String sCrtSessId = cmdPacket.getStringValue(1);
                String sOp = cmdPacket.getStringValue(2);
                String sObjId = cmdPacket.getStringValue(3);
                String sSessId = cmdPacket.getStringValue(4);
                return sessionHasCap(sClientId, sOp, sObjId, sSessId);

            } else if (sCmdCode.equalsIgnoreCase("testIsContained")) {
                if (cmdPacket.size() < 6) {
                    return failurePacket("Too few arguments!");
                }
                String sCrtSessId = cmdPacket.getStringValue(1);
                String sId1 = cmdPacket.getStringValue(2);
                String sClass1 = cmdPacket.getStringValue(3);
                String sId2 = cmdPacket.getStringValue(4);
                String sClass2 = cmdPacket.getStringValue(5);
                return testIsContained(sId1, sClass1, sId2, sClass2);

                // Permissions on a PM entity seen as an object.
                // The entity is identified by its id and type.
            } else if (sCmdCode.equalsIgnoreCase("requestPermsOnPmEntity")) {
                if (cmdPacket.size() < 6) {
                    return failurePacket("Too few arguments!");
                }
                String sCrtSessId = cmdPacket.getStringValue(1);
                String sSessId = cmdPacket.getStringValue(2);
                String sTgtId = cmdPacket.getStringValue(3);
                String sTgtClass = cmdPacket.getStringValue(4);
                String sReqPerms = cmdPacket.getStringValue(5);
                return requestPermsOnPmEntity(sSessId, sTgtId, sTgtClass,
                        sReqPerms);

                // Permissions on an object attribute
                // (that may or may not be associated with an object).
                // The oattr is identified by its name and type.
            } else if (sCmdCode.equalsIgnoreCase("requestPerms")) {
                if (cmdPacket.size() < 4) {
                    return failurePacket("Too few arguments!");
                }
                String sSessId = cmdPacket.getStringValue(1);
                String sObjName = cmdPacket.getStringValue(2);
                String sReqPerms = cmdPacket.getStringValue(3);
                return requestPerms(sClientId, sSessId, sObjName, sReqPerms);

            } else if (sCmdCode.equalsIgnoreCase("wouldOpenPreventSave")) {
                if (cmdPacket.size() < 4) {
                    return failurePacket("Too few arguments!");
                }
                String sSessId = cmdPacket.getStringValue(1);
                String sObjName = cmdPacket.getStringValue(2);
                String sReqPerms = cmdPacket.getStringValue(3);
                return wouldOpenPreventSave(sSessId, sObjName, sReqPerms);

            } else if (sCmdCode.equalsIgnoreCase("getPerms")) {
                if (cmdPacket.size() < 4) {
                    return failurePacket("Too few arguments!");
                }
                String sCrtSessId = cmdPacket.getStringValue(1);
                String sSessId = cmdPacket.getStringValue(2);
                String sObjId = cmdPacket.getStringValue(3);
                return getPerms(sCrtSessId, sSessId, sObjId);

            } else if (sCmdCode.equalsIgnoreCase("getUserDescendants")) {
                if (cmdPacket.size() < 3) {
                    return failurePacket("Too few arguments!");
                }
                String sCrtSessId = cmdPacket.getStringValue(1);
                String sUserId = cmdPacket.getStringValue(2);
                return getUserDescendants(sClientId, sUserId);

            } else if (sCmdCode.equalsIgnoreCase("getMaximalSubsets")) {
                if (cmdPacket.size() < 3) {
                    return failurePacket("Too few arguments!");
                }
                String sCrtSessId = cmdPacket.getStringValue(1);
                String sSetId = cmdPacket.getStringValue(2);
                return getMaximalSubsets(sClientId, sSetId);

            } else if (sCmdCode.equalsIgnoreCase("export")) {
                if (cmdPacket.size() < 2) {
                    return failurePacket("Too few arguments!");
                }
                String sCrtSessId = cmdPacket.getStringValue(1);
                return export(sClientId, sCrtSessId);

            } else if (sCmdCode.equalsIgnoreCase("interpretCmd")) {
                if (cmdPacket.size() < 3) {
                    return failurePacket("Too few arguments!");
                }
                String sSessId = cmdPacket.getStringValue(1);
                String sCmd = cmdPacket.getStringValue(2);
                return interpretCmd(sSessId, sCmd);

            } else if (sCmdCode.equalsIgnoreCase("importConfiguration")) {
                if (cmdPacket.size() < 2) {
                    return failurePacket("Too few arguments!");
                }
                String sSessId = cmdPacket.getStringValue(1);
                return importConfiguration(sSessId, cmdPacket);

            } else if (sCmdCode.equalsIgnoreCase("getHostAppPaths")) {
                if (cmdPacket.size() < 4) {
                    return failurePacket("Too few arguments!");
                }
                String sCrtSessId = cmdPacket.getStringValue(1);
                String sHost = cmdPacket.getStringValue(2);
                String appname = cmdPacket.getStringValue(3);
                return getHostAppPaths(sClientId, sCrtSessId, sHost, appname);

            } else if (sCmdCode.equalsIgnoreCase("getInstalledAppNames")) {
                String sSessionId = cmdPacket.getStringValue(1);
                String sHost = cmdPacket.getStringValue(2);
                System.out.println("Calling getInstalledAppNames for " + sHost);
                return getInstalledApps(sHost);
            } else if (sCmdCode.equalsIgnoreCase("getHostRepository")) {
                if (cmdPacket.size() < 2) {
                    return failurePacket("Too few arguments!");
                }
                String sCrtSessId = cmdPacket.getStringValue(1);
                return getHostRepository(sCrtSessId);

            } else if (sCmdCode.equalsIgnoreCase(ADD_HOST_APP.commandCode())) {
                String sSessId = cmdPacket.getStringValue(1);
                String sHost = cmdPacket.getStringValue(2);
                String appName = cmdPacket.getStringValue(3);
                String appPath = cmdPacket.getStringValue(4);
                String mainClassName = cmdPacket.getStringValue(5);
                String appPrefix = cmdPacket.getStringValue(6);
                return addHostApp(sSessId, sHost, appName, appPath, mainClassName, appPrefix);

            } else if (sCmdCode.equalsIgnoreCase("setHostAppPaths")) {
                if (cmdPacket.size() < 11) {
                    return failurePacket("Too few arguments!");
                }
                String sCrtSessId = cmdPacket.getStringValue(1);
                String sHost = cmdPacket.getStringValue(2);
                String sAtoolPath = cmdPacket.getStringValue(3);
                String sRtfedPath = cmdPacket.getStringValue(4);
                String sWkfPath = cmdPacket.getStringValue(5);
                String sEmlPath = cmdPacket.getStringValue(6);
                String sExpPath = cmdPacket.getStringValue(7);
                String sLauncherPath = cmdPacket.getStringValue(8);
                String sMsofficePath = cmdPacket.getStringValue(9);
                String sMedrecPath = cmdPacket.getStringValue(10);
                String sAcctrecPath = cmdPacket.getStringValue(11);
                String soldWkfPath = cmdPacket.getStringValue(12);
                
                return setHostAppPaths(sCrtSessId, sHost, sAtoolPath,
                        sRtfedPath, sWkfPath, sEmlPath, sExpPath,
                        sLauncherPath, sMsofficePath, sMedrecPath, sAcctrecPath, soldWkfPath);

            } else if (sCmdCode.equalsIgnoreCase("getKStorePaths")) {
                if (cmdPacket.size() < 2) {
                    return failurePacket("Too few arguments!");
                }
                String sSessId = cmdPacket.getStringValue(1);
                return getKStorePaths(sClientId, sSessId);

            } else if (sCmdCode.equalsIgnoreCase("setKStorePaths")) {
                if (cmdPacket.size() < 6) {
                    return failurePacket("Too few arguments!");
                }
                String sCrtSessId = cmdPacket.getStringValue(1);
                String sUserId = cmdPacket.getStringValue(2);
                String sHost = cmdPacket.getStringValue(3);
                String sKsPath = cmdPacket.getStringValue(4);
                String sTsPath = cmdPacket.getStringValue(5);
                return setKStorePaths(sCrtSessId, sUserId, sHost, sKsPath,
                        sTsPath);

            } else if (sCmdCode.equalsIgnoreCase("isTimeToRefresh")) {
                if (cmdPacket.size() < 3) {
                    return failurePacket("Too few arguments!");
                }
                String sSessId = cmdPacket.getStringValue(1);
                String sClientTimestamp = cmdPacket.getStringValue(2);
                return isTimeToRefresh(sClientId, sSessId, sClientTimestamp);

            } else if (sCmdCode.equalsIgnoreCase("getDenies")) {
                if (cmdPacket.size() < 2) {
                    return failurePacket("Too few arguments!");
                }
                String sSessId = cmdPacket.getStringValue(1);
                return getDenies(sSessId);

            } else if (sCmdCode.equalsIgnoreCase("getDenyInfo")) {
                if (cmdPacket.size() < 3) {
                    return failurePacket("Too few arguments!");
                }
                String sSessId = cmdPacket.getStringValue(1);
                String sDenyId = cmdPacket.getStringValue(2);
                return getDenyInfo(sSessId, sDenyId);

            } else if (sCmdCode.equalsIgnoreCase("getAllOps")) {
                if (cmdPacket.size() < 2) {
                    return failurePacket("Too few arguments!");
                }
                String sSessId = cmdPacket.getStringValue(1);
                return getAllOps(sSessId);

            } else if (sCmdCode.equalsIgnoreCase("getOattrs")) {
                if (cmdPacket.size() < 2) {
                    return failurePacket("Too few arguments!");
                }
                String sSessId = cmdPacket.getStringValue(1);
                return getOattrs(sSessId);

            } else if (sCmdCode.equalsIgnoreCase("getOconts")) {
                if (cmdPacket.size() < 2) {
                    return failurePacket("Too few arguments!");
                }
                String sSessId = cmdPacket.getStringValue(1);
                return getOattrs(sSessId);

            } else if (sCmdCode.equalsIgnoreCase("getObjAttrsProper")) {
                if (cmdPacket.size() < 2) {
                    return failurePacket("Too few arguments!");
                }
                String sSessId = cmdPacket.getStringValue(1);
                return getObjAttrsProper(sSessId);

            } else if (sCmdCode.equalsIgnoreCase("addDeny")) {
                if (cmdPacket.size() < 10) {
                    return failurePacket("Too few arguments!");
                }
                String sSessId = cmdPacket.getStringValue(1);
                String sDenyName = cmdPacket.getStringValue(2);
                String sDenyType = cmdPacket.getStringValue(3);
                String sUserOrAttrName = cmdPacket.getStringValue(4);
                String sUserOrAttrId = cmdPacket.getStringValue(5);
                String sOp = cmdPacket.getStringValue(6);
                String sOattrName = cmdPacket.getStringValue(7);
                String sOattrId = cmdPacket.getStringValue(8);
                String sIsInters = cmdPacket.getStringValue(9);
                return addDeny(sSessId, sDenyName, sDenyType, sUserOrAttrName,
                        sUserOrAttrId, sOp, sOattrName, sOattrId, sIsInters);

            } else if (sCmdCode.equalsIgnoreCase("deleteDeny")) {
                if (cmdPacket.size() < 6) {
                    return failurePacket("Too few arguments!");
                }
                String sSessId = cmdPacket.getStringValue(1);
                String sDenyName = cmdPacket.getStringValue(2);
                String sOp = cmdPacket.getStringValue(3);
                String sOattrName = cmdPacket.getStringValue(4);
                String sOattrId = cmdPacket.getStringValue(5);
                return deleteDeny(sSessId, sDenyName, sOp, sOattrName, sOattrId);

            } else if (sCmdCode.equalsIgnoreCase("getIdOfEntityWithNameAndType")) {
                if (cmdPacket.size() < 4) {
                    return failurePacket("Too few arguments!");
                }
                String sSessId = cmdPacket.getStringValue(1);
                String sEntityName = cmdPacket.getStringValue(2);
                String sEntityType = cmdPacket.getStringValue(3);
                return getEntityId(sSessId, sEntityName, sEntityType);

            } else if (sCmdCode.equalsIgnoreCase("getNameOfEntityWithIdAndType")) {
                if (cmdPacket.size() < 4) {
                    return failurePacket("Too few arguments!");
                }
                String sSessId = cmdPacket.getStringValue(1);
                String sEntityId = cmdPacket.getStringValue(2);
                String sEntityType = cmdPacket.getStringValue(3);
                return getEntityName(sSessId, sEntityId, sEntityType);

            } else if (sCmdCode.equalsIgnoreCase("getScripts")) {
                return getScripts();

            } else if (sCmdCode.equalsIgnoreCase("enableScript")) {
                if (cmdPacket.size() < 3) {
                    return failurePacket("Too few arguments!");
                }
                String sSessId = cmdPacket.getStringValue(1);
                String sScriptId = cmdPacket.getStringValue(2);
                return enableScript(sSessId, sScriptId);

            } else if (sCmdCode.equalsIgnoreCase("disableEnabledScript")) {
                if (cmdPacket.size() < 2) {
                    return failurePacket("Too few arguments!");
                }
                String sSessId = cmdPacket.getStringValue(1);
                return disableEnabledScript(sSessId);

            } else if (sCmdCode.equalsIgnoreCase("getEnabledScript")) {
                return getEnabledScript();

            } else if (sCmdCode.equalsIgnoreCase("compileScript")) {
                if (cmdPacket.size() < 3) {
                    return failurePacket("Too few arguments!");
                }
                String sSessId = cmdPacket.getStringValue(1);
                String sDeleteOthers = cmdPacket.getStringValue(2);
                return compileScript(sSessId, sDeleteOthers, cmdPacket);

            } else if (sCmdCode.equalsIgnoreCase("compileScriptAndEnable")) {
                if (cmdPacket.size() < 2) {
                    return failurePacket("Too few arguments!");
                }
                String sSessId = cmdPacket.getStringValue(1);
                return compileScriptAndEnable(sSessId, cmdPacket);

            } else if (sCmdCode.equalsIgnoreCase("compileScriptAndAddToEnabled")) {
                if (cmdPacket.size() < 2) {
                    return failurePacket("Too few arguments!");
                }
                String sSessId = cmdPacket.getStringValue(1);
                return compileScriptAndAddToEnabled(sSessId, cmdPacket);

            } else if (sCmdCode.equalsIgnoreCase("addScript")) {
                if (cmdPacket.size() < 4) {
                    return failurePacket("Too few arguments!");
                }
                String sSessId = cmdPacket.getStringValue(1);
                String sScriptId1 = cmdPacket.getStringValue(2);
                String sScriptId2 = cmdPacket.getStringValue(3);
                return addScript(sSessId, sScriptId1, sScriptId2);

            } else if (sCmdCode.equalsIgnoreCase("addScriptToEnabled")) {
                if (cmdPacket.size() < 3) {
                    return failurePacket("Too few arguments!");
                }
                String sSessId = cmdPacket.getStringValue(1);
                String sScriptId = cmdPacket.getStringValue(2);
                return addScriptToEnabled(sSessId, sScriptId);

            } else if (sCmdCode.equalsIgnoreCase("deleteScriptsWithNameExcept")) {
                if (cmdPacket.size() < 4) {
                    return failurePacket("Too few arguments!");
                }
                String sSessId = cmdPacket.getStringValue(1);
                String sScriptName = cmdPacket.getStringValue(2);
                String sScriptId = cmdPacket.getStringValue(3);
                return deleteScriptsWithNameExcept(sSessId, sScriptName,
                        sScriptId);

            } else if (sCmdCode.equalsIgnoreCase("deleteScript")) {
                if (cmdPacket.size() < 3) {
                    return failurePacket("Too few arguments!");
                }
                String sSessId = cmdPacket.getStringValue(1);
                String sScriptId = cmdPacket.getStringValue(2);
                return deleteScript(sSessId, sScriptId);

            } else if (sCmdCode.equalsIgnoreCase("getSourceScript")) {
                if (cmdPacket.size() < 3) {
                    return failurePacket("Too few arguments!");
                }
                String sSessId = cmdPacket.getStringValue(1);
                String sScriptId = cmdPacket.getStringValue(2);
                return getSourceScript(sSessId, sScriptId);

            } else if (sCmdCode.equalsIgnoreCase("deleteScriptRule")) {
                if (cmdPacket.size() < 4) {
                    return failurePacket("Too few arguments!");
                }
                String sSessId = cmdPacket.getStringValue(1);
                String sScriptId = cmdPacket.getStringValue(2);
                String sLabel = cmdPacket.getStringValue(3);
                return deleteScriptRule(sScriptId, sLabel);

            } else if (sCmdCode.equalsIgnoreCase("getAttrInfo")) {
                if (cmdPacket.size() < 5) {
                    return failurePacket("Too few arguments!");
                }
                String sSessId = cmdPacket.getStringValue(1);
                String sAttrId = cmdPacket.getStringValue(2);
                String sAttrType = cmdPacket.getStringValue(3);
                String sIsVos = cmdPacket.getStringValue(4);
                return getAttrInfo(sSessId, sAttrId, sAttrType, sIsVos);

            } else if (sCmdCode.equalsIgnoreCase("addProp")) {
                if (cmdPacket.size() < 6) {
                    return failurePacket("Too few arguments!");
                }
                String sSessId = cmdPacket.getStringValue(1);
                String sId = cmdPacket.getStringValue(2);
                String sType = cmdPacket.getStringValue(3);
                String sIsVos = cmdPacket.getStringValue(4);
                String sProp = cmdPacket.getStringValue(5);
                return addProp(sSessId, sId, sType, sIsVos, sProp);

            } else if (sCmdCode.equalsIgnoreCase("replaceProp")) {
                if (cmdPacket.size() < 6) {
                    return failurePacket("Too few arguments!");
                }
                String sSessId = cmdPacket.getStringValue(1);
                String sId = cmdPacket.getStringValue(2);
                String sType = cmdPacket.getStringValue(3);
                String sIsVos = cmdPacket.getStringValue(4);
                String sOldProp = cmdPacket.getStringValue(5);
                String sNewProp = cmdPacket.getStringValue(6);
                return replaceProp(sSessId, sId, sType, sIsVos, sOldProp,
                        sNewProp);

            } else if (sCmdCode.equalsIgnoreCase("removeProp")) {
                if (cmdPacket.size() < 6) {
                    return failurePacket("Too few arguments!");
                }
                String sSessId = cmdPacket.getStringValue(1);
                String sId = cmdPacket.getStringValue(2);
                String sType = cmdPacket.getStringValue(3);
                String sIsVos = cmdPacket.getStringValue(4);
                String sProp = cmdPacket.getStringValue(5);
                return removeProp(sSessId, sId, sType, sIsVos, sProp);

            } else if (sCmdCode.equalsIgnoreCase("createObject3")) {
                if (cmdPacket.size() < 7) {
                    return failurePacket("Too few arguments!");
                }
                String sSessId = cmdPacket.getStringValue(1);
                String sProcId = cmdPacket.getStringValue(2);
                String sObjName = cmdPacket.getStringValue(3);
                String sObjClass = cmdPacket.getStringValue(4);
                String sObjType = cmdPacket.getStringValue(5);
                String sContainers = cmdPacket.getStringValue(6);
                String sPerms = cmdPacket.getStringValue(7);
                String sSender = cmdPacket.getStringValue(8);
                String sReceiver = cmdPacket.getStringValue(9);
                String sSubject = cmdPacket.getStringValue(10);
                String sAttached = cmdPacket.getStringValue(11);
                return createObject3(sSessId, sProcId, sObjName, sObjClass,
                        sObjType, sContainers, sPerms, sSender, sReceiver,
                        sSubject, sAttached);

            } else if (sCmdCode.equalsIgnoreCase("processEvent")) {
                if (cmdPacket.size() < 7) {
                    return failurePacket("Too few arguments!");
                }
                String sSessId = cmdPacket.getStringValue(1);
                String sProcId = cmdPacket.getStringValue(2);
                String sEventName = cmdPacket.getStringValue(3);
                String sObjName = cmdPacket.getStringValue(4);
                String sObjId = cmdPacket.getStringValue(5);
                String sObjClass = cmdPacket.getStringValue(6);
                String sObjType = cmdPacket.getStringValue(7);
                String sCtx1 = cmdPacket.getStringValue(8);
                String sCtx2 = cmdPacket.getStringValue(9);
                return processEvent(sSessId, sProcId, sEventName, sObjName,
                        sObjId, sObjClass, sObjType, sCtx1, sCtx2);

            } else if (sCmdCode.equalsIgnoreCase("getUserInfo")) {
                if (cmdPacket.size() < 3) {
                    return failurePacket("Too few arguments!");
                }
                String sSessId = cmdPacket.getStringValue(1);
                String sUserId = cmdPacket.getStringValue(2);
                return getUserInfo(sSessId, sUserId);

            } else if (sCmdCode.equalsIgnoreCase("getOpsetsBetween")) {
                if (cmdPacket.size() < 5) {
                    return failurePacket("Too few arguments!");
                }
                String sSessId = cmdPacket.getStringValue(1);
                String sUattrName = cmdPacket.getStringValue(2);
                String sEntityName = cmdPacket.getStringValue(3);
                String sEntityType = cmdPacket.getStringValue(4);
                return getOpsetsBetween(sSessId, sUattrName, sEntityName,
                        sEntityType);

            } else if (sCmdCode.equalsIgnoreCase("deleteOpsetsBetween")) {
                if (cmdPacket.size() < 5) {
                    return failurePacket("Too few arguments!");
                }
                String sSessId = cmdPacket.getStringValue(1);
                String sProcId = cmdPacket.getStringValue(2);
                String sUattrName = cmdPacket.getStringValue(3);
                String sOattrName = cmdPacket.getStringValue(4);
                return deleteOpsetsBetween(sSessId, sProcId, sUattrName,
                        sOattrName);

            } else if (sCmdCode.equalsIgnoreCase("getOpsetOattrs")) {
                if (cmdPacket.size() < 3) {
                    return failurePacket("Too few arguments!");
                }
                String sSessId = cmdPacket.getStringValue(1);
                String sOpsetName = cmdPacket.getStringValue(2);
                return getOpsetOattrs(sSessId, sOpsetName);

            } else if (sCmdCode.equalsIgnoreCase("buildClipboard")) {
                if (cmdPacket.size() < 2) {
                    return failurePacket("Too few arguments!");
                }
                String sSessId = cmdPacket.getStringValue(1);
                String sOattrName = cmdPacket.getStringValue(2);
                return buildClipboard(sSessId, sOattrName);

            } else if (sCmdCode.equalsIgnoreCase("isolateOattr")) {
                if (cmdPacket.size() < 4) {
                    return failurePacket("Too few arguments!");
                }
                String sSessId = cmdPacket.getStringValue(1);
                String sAttrName = cmdPacket.getStringValue(2);
                String sAttrType = cmdPacket.getStringValue(3);
                return isolateOattr(sAttrName, sAttrType);

            } else if (sCmdCode.equalsIgnoreCase("setPerms")) {
                if (cmdPacket.size() < 5) {
                    return failurePacket("Too few arguments!");
                }
                String sSessId = cmdPacket.getStringValue(1);
                String sProcId = cmdPacket.getStringValue(2);
                String sUattrName = cmdPacket.getStringValue(3);
                String sOpset = cmdPacket.getStringValue(4);
                String sSuggOattr = cmdPacket.getStringValue(5);
                String sSuggBase = cmdPacket.getStringValue(6);
                String sSuggBaseType = cmdPacket.getStringValue(7);
                String sPerms = cmdPacket.getStringValue(8);
                String sEntName = cmdPacket.getStringValue(9);
                String sEntType = cmdPacket.getStringValue(10);
                String sInclAscs = cmdPacket.getStringValue(11);
                return setPerms(sSessId, sProcId, sUattrName, sOpset,
                        sSuggOattr, sSuggBase, sSuggBaseType, sPerms, sEntName,
                        sEntType, sInclAscs);

            } else if (sCmdCode.equalsIgnoreCase("testGUWC")) {
                // TestGetUsersWithCapability
                if (cmdPacket.size() < 5) {
                    return failurePacket("Too few arguments!");
                }
                String sSessId = cmdPacket.getStringValue(1);
                String sOp = cmdPacket.getStringValue(2);
                String sContainerName = cmdPacket.getStringValue(3);
                String sPcName = cmdPacket.getStringValue(4);
                return testGUWC(sSessId, sOp, sContainerName, sPcName);

            } else if (sCmdCode.equalsIgnoreCase("addTask")) {
                if (cmdPacket.size() < 3) {
                    return failurePacket("Too few arguments!");
                }
                String sSessId = cmdPacket.getStringValue(1);
                String sTask = cmdPacket.getStringValue(2);
                String sOp = cmdPacket.getStringValue(3);
                String sOcont = cmdPacket.getStringValue(4);
                String sPc = cmdPacket.getStringValue(5);
                return addTask(sSessId, sTask, sOp, sOcont, sPc);

            } else if (sCmdCode.equalsIgnoreCase("getTasks")) {
                if (cmdPacket.size() < 2) {
                    return failurePacket("Too few arguments!");
                }
                String sSessId = cmdPacket.getStringValue(1);
                return getTasks(sSessId);

            } else if (sCmdCode.equalsIgnoreCase("getTaskInfo")) {
                if (cmdPacket.size() < 3) {
                    return failurePacket("Too few arguments!");
                }
                String sSessId = cmdPacket.getStringValue(1);
                String sTaskId = cmdPacket.getStringValue(2);
                return getTaskInfo(sSessId, sTaskId);

            } else if (sCmdCode.equalsIgnoreCase("deleteTask")) {
                if (cmdPacket.size() < 3) {
                    return failurePacket("Too few arguments!");
                }
                String sSessId = cmdPacket.getStringValue(1);
                String sTaskId = cmdPacket.getStringValue(2);
                String sCap = cmdPacket.getStringValue(3);
                return deleteTask(sSessId, sTaskId, sCap);

            } else if (sCmdCode.equalsIgnoreCase("addScon")) {
                if (cmdPacket.size() < 4) {
                    return failurePacket("Too few arguments!");
                }
                String sSessId = cmdPacket.getStringValue(1);
                String sScon = cmdPacket.getStringValue(2);
                String sK = cmdPacket.getStringValue(3);
                String sTask = cmdPacket.getStringValue(4);
                return addScon(sSessId, sScon, sK, sTask);

            } else if (sCmdCode.equalsIgnoreCase("getScons")) {
                if (cmdPacket.size() < 2) {
                    return failurePacket("Too few arguments!");
                }
                String sSessId = cmdPacket.getStringValue(1);
                return getScons(sSessId);

            } else if (sCmdCode.equalsIgnoreCase("getSconInfo")) {
                if (cmdPacket.size() < 3) {
                    return failurePacket("Too few arguments!");
                }
                String sSessId = cmdPacket.getStringValue(1);
                String sSconId = cmdPacket.getStringValue(2);
                return getSconInfo(sSessId, sSconId);

            } else if (sCmdCode.equalsIgnoreCase("deleteScon")) {
                if (cmdPacket.size() < 3) {
                    return failurePacket("Too few arguments!");
                }
                String sSessId = cmdPacket.getStringValue(1);
                String sSconId = cmdPacket.getStringValue(2);
                String sTask = cmdPacket.getStringValue(3);
                return deleteScon(sSessId, sSconId, sTask);

            } else if (sCmdCode.equalsIgnoreCase("checkScon")) {
                if (cmdPacket.size() < 3) {
                    return failurePacket("Too few arguments!");
                }
                String sSessId = cmdPacket.getStringValue(1);
                String sSconId = cmdPacket.getStringValue(2);
                return checkScon(sSconId);

            } else if (sCmdCode.equalsIgnoreCase("addScona")) {
                if (cmdPacket.size() < 4) {
                    return failurePacket("Too few arguments!");
                }
                String sSessId = cmdPacket.getStringValue(1);
                String sScona = cmdPacket.getStringValue(2);
                String sPc = cmdPacket.getStringValue(3);
                String sUattr = cmdPacket.getStringValue(4);
                String sOp = cmdPacket.getStringValue(5);
                String sOattr = cmdPacket.getStringValue(6);
                return addScona(sSessId, sScona, sPc, sUattr, sOp, sOattr);

            } else if (sCmdCode.equalsIgnoreCase("getSconas")) {
                if (cmdPacket.size() < 2) {
                    return failurePacket("Too few arguments!");
                }
                String sSessId = cmdPacket.getStringValue(1);
                return getSconas(sSessId);

            } else if (sCmdCode.equalsIgnoreCase("getSconaInfo")) {
                if (cmdPacket.size() < 3) {
                    return failurePacket("Too few arguments!");
                }
                String sSessId = cmdPacket.getStringValue(1);
                String sSconaId = cmdPacket.getStringValue(2);
                return getSconaInfo(sSessId, sSconaId);

            } else if (sCmdCode.equalsIgnoreCase("deleteScona")) {
                if (cmdPacket.size() < 3) {
                    return failurePacket("Too few arguments!");
                }
                String sSessId = cmdPacket.getStringValue(1);
                String sSconaId = cmdPacket.getStringValue(2);
                String sOp = cmdPacket.getStringValue(3);
                return deleteScona(sSessId, sSconaId, sOp);

            } else if (sCmdCode.equalsIgnoreCase("checkScona")) {
                if (cmdPacket.size() < 3) {
                    return failurePacket("Too few arguments!");
                }
                String sSessId = cmdPacket.getStringValue(1);
                String sSconaId = cmdPacket.getStringValue(2);
                return checkScona(sSconaId);

            } else if (sCmdCode.equalsIgnoreCase("getEntityWithProp")) {
                if (cmdPacket.size() < 4) {
                    return failurePacket("Too few arguments!");
                }
                String sSessId = cmdPacket.getStringValue(1);
                String sEntType = cmdPacket.getStringValue(2);
                String sProp = cmdPacket.getStringValue(3);
                return getEntityWithProp(sSessId, sEntType, sProp);

            } else if (sCmdCode.equalsIgnoreCase("doDacConfinement")) {
                if (cmdPacket.size() < 6) {
                    return failurePacket("Too few arguments!");
                }
                String sSessId = cmdPacket.getStringValue(1);
                String sUser = cmdPacket.getStringValue(2);
                String sPc = cmdPacket.getStringValue(3);
                String sAttr = cmdPacket.getStringValue(4);
                String sCont = cmdPacket.getStringValue(5);
                return doDacConfinement(sSessId, sUser, sPc, sAttr, sCont);

            } else if (sCmdCode.equalsIgnoreCase("testGetMemberObjects")) {
                if (cmdPacket.size() < 6) {
                    return failurePacket("Too few arguments!");
                }
                String sSessId = cmdPacket.getStringValue(1);
                String sContId = cmdPacket.getStringValue(2);
                String sContType = cmdPacket.getStringValue(3);
                return testGetMemberObjects(sSessId, sContId, sContType);

            } else if (sCmdCode.equalsIgnoreCase("testGetPmViews")) {
                if (cmdPacket.size() < 4) {
                    return failurePacket("Too few arguments!");
                }
                String sSessId = cmdPacket.getStringValue(1);
                String sUserId = cmdPacket.getStringValue(2);
                String sType = cmdPacket.getStringValue(3);
                return testGetPmViews(sSessId, sUserId, sType);

            } else if (sCmdCode.equalsIgnoreCase("isAssigned")) {
                if (cmdPacket.size() < 6) {
                    return failurePacket("Too few arguments!");
                }
                String sSessId = cmdPacket.getStringValue(1);
                String sId1 = cmdPacket.getStringValue(2);
                String sType1 = cmdPacket.getStringValue(3);
                String sId2 = cmdPacket.getStringValue(4);
                String sType2 = cmdPacket.getStringValue(5);
                return isAssigned(sId1, sType1, sId2, sType2);

            } else if (sCmdCode.equalsIgnoreCase("getIdOfEntityWithNameAndType")) {
                if (cmdPacket.size() < 4) {
                    return failurePacket("Too few arguments!");
                }
                String sSessId = cmdPacket.getStringValue(1);
                String sName = cmdPacket.getStringValue(2);
                String sType = cmdPacket.getStringValue(3);
                return getEntityId(sSessId, sName, sType);

            } else if (sCmdCode.equalsIgnoreCase("getNameOfEntityWithIdAndType")) {
                if (cmdPacket.size() < 4) {
                    return failurePacket("Too few arguments!");
                }
                String sSessId = cmdPacket.getStringValue(1);
                String sId = cmdPacket.getStringValue(2);
                String sType = cmdPacket.getStringValue(3);
                return getEntityName(sSessId, sId, sType);

            } else if (sCmdCode.equalsIgnoreCase("testGetDeniedPerms")) {
                if (cmdPacket.size() < 4) {
                    return failurePacket("Too few arguments!");
                }
                String sCrtSessId = cmdPacket.getStringValue(1);
                String sSessId = cmdPacket.getStringValue(2);
                String sObjName = cmdPacket.getStringValue(3);
                return testGetDeniedPerms(sSessId, sObjName);

            } else if (sCmdCode.equalsIgnoreCase("genDac")) {
                if (cmdPacket.size() < 4) {
                    return failurePacket("Too few arguments!");
                }
                String sSessId = cmdPacket.getStringValue(1);
                String sPolName = cmdPacket.getStringValue(2);
                String sContName = cmdPacket.getStringValue(3);
                return genDac(sSessId, sPolName, sContName);

            } else if (sCmdCode.equalsIgnoreCase("genMls")) {
                if (cmdPacket.size() < 4) {
                    return failurePacket("Too few arguments!");
                }
                String sSessId = cmdPacket.getStringValue(1);
                String sPolName = cmdPacket.getStringValue(2);
                String sLevels = cmdPacket.getStringValue(3);
                return genMls(sSessId, sPolName, sLevels);

            } else if (sCmdCode.equalsIgnoreCase("genConfForDacUser")) {
                if (cmdPacket.size() < 6) {
                    return failurePacket("Too few arguments!");
                }
                String sSessId = cmdPacket.getStringValue(1);
                String sUser = cmdPacket.getStringValue(2);
                String sPc = cmdPacket.getStringValue(3);
                String sAttr = cmdPacket.getStringValue(4);
                String sCont = cmdPacket.getStringValue(5);
                return genConfForDacUser(sSessId, sUser, sPc, sAttr, sCont);

            } else if (sCmdCode.equalsIgnoreCase("genDacUserWithConf")) {
                if (cmdPacket.size() < 7) {
                    return failurePacket("Too few arguments!");
                }
                String sSessId = cmdPacket.getStringValue(1);
                String sUser = cmdPacket.getStringValue(2);
                String sFullName = cmdPacket.getStringValue(3);
                String sPc = cmdPacket.getStringValue(4);
                String sAttr = cmdPacket.getStringValue(5);
                String sCont = cmdPacket.getStringValue(6);
                return genDacUserWithConf(sSessId, sUser, sFullName, sPc,
                        sAttr, sCont);

            } else if (sCmdCode.equalsIgnoreCase("genIbac")) {
                if (cmdPacket.size() < 3) {
                    return failurePacket("Too few arguments!");
                }
                String sSessId = cmdPacket.getStringValue(1);
                String sPolName = cmdPacket.getStringValue(2);
                return genIbac(sSessId, sPolName);

            } else if (sCmdCode.equalsIgnoreCase("addEmailAcct")) {
                if (cmdPacket.size() < 9) {
                    return failurePacket("Too few arguments!");
                }
                String sSessId = cmdPacket.getStringValue(1);
                String sPmUser = cmdPacket.getStringValue(2);
                String sFullName = cmdPacket.getStringValue(3);
                String sEmailAddr = cmdPacket.getStringValue(4);
                String sPopServer = cmdPacket.getStringValue(5);
                String sSmtpServer = cmdPacket.getStringValue(6);
                String sAcctName = cmdPacket.getStringValue(7);
                String sPassword = cmdPacket.getStringValue(8);
                return addEmailAcct(sSessId, sPmUser, sFullName, sEmailAddr,
                        sPopServer, sSmtpServer, sAcctName, sPassword);

            } else if (sCmdCode.equalsIgnoreCase("getEmailAcct")) {
                if (cmdPacket.size() < 3) {
                    return failurePacket("Too few arguments!");
                }
                String sSessId = cmdPacket.getStringValue(1);
                String sPmUser = cmdPacket.getStringValue(2);
                return getEmailAcct(sSessId, sPmUser);

            } else if (sCmdCode.equalsIgnoreCase("sendSimpleMsg")) {
                if (cmdPacket.size() < 4) {
                    return failurePacket("Too few arguments!");
                }
                String sSessId = cmdPacket.getStringValue(1);
                String sMsgName = cmdPacket.getStringValue(2);
                String sReceiver = cmdPacket.getStringValue(3);
                return sendSimpleMsg(sSessId, sMsgName, sReceiver);

            } else if (sCmdCode.equalsIgnoreCase("copyObject")) {
                if (cmdPacket.size() < 4) {
                    return failurePacket("Too few arguments!");
                }
                String sSessId = cmdPacket.getStringValue(1);
                String sProcId = cmdPacket.getStringValue(2);
                String sObjName = cmdPacket.getStringValue(3);
                return copyObject(sSessId, sProcId, sObjName);

            } else if (sCmdCode.equalsIgnoreCase("sendObject")) {
                if (cmdPacket.size() < 4) {
                    return failurePacket("Too few arguments!");
                }
                String sSessId = cmdPacket.getStringValue(1);
                String sObjName = cmdPacket.getStringValue(2);
                String sReceiver = cmdPacket.getStringValue(3);
                return sendObject(sSessId, sObjName, sReceiver);

            } else if (sCmdCode.equalsIgnoreCase("getEmailRecipients")) {
                if (cmdPacket.size() < 3) {
                    return failurePacket("Too few arguments!");
                }
                String sSessId = cmdPacket.getStringValue(1);
                String sReceiver = cmdPacket.getStringValue(2);
                return getEmailRecipients(sSessId, sReceiver);

            } else if (sCmdCode.equalsIgnoreCase("getUsersAndAttrs")) {
                if (cmdPacket.size() < 2) {
                    return failurePacket("Too few arguments!");
                }
                String sSessId = cmdPacket.getStringValue(1);
                return getUsersAndAttrs(sSessId);

            } else if (sCmdCode.equalsIgnoreCase("addOpenObj")) {
                if (cmdPacket.size() < 3) {
                    return failurePacket("Too few arguments!");
                }
                String sSessId = cmdPacket.getStringValue(1);
                String sObjName = cmdPacket.getStringValue(2);
                return addOpenObj(sSessId, sObjName);

            } else if (sCmdCode.equalsIgnoreCase("deleteOpenObj")) {
                if (cmdPacket.size() < 3) {
                    return failurePacket("Too few arguments!");
                }
                String sSessId = cmdPacket.getStringValue(1);
                String sObjName = cmdPacket.getStringValue(2);
                return deleteOpenObj(sSessId, sObjName);

            } else if (sCmdCode.equalsIgnoreCase("assignObjToOattrWithProp")) {
                if (cmdPacket.size() < 5) {
                    return failurePacket("Too few arguments!");
                }
                String sSessId = cmdPacket.getStringValue(1);
                String sProcId = cmdPacket.getStringValue(2);
                String sObjName = cmdPacket.getStringValue(3);
                String sProp = cmdPacket.getStringValue(4);
                return assignObjToOattrWithProp(sSessId, sProcId, sObjName,
                        sProp);

            } else if (sCmdCode.equalsIgnoreCase("assignObjToOattr")) {
                if (cmdPacket.size() < 5) {
                    return failurePacket("Too few arguments!");
                }
                String sSessId = cmdPacket.getStringValue(1);
                String sProcId = cmdPacket.getStringValue(2);
                String sObjName = cmdPacket.getStringValue(3);
                String sOattrName = cmdPacket.getStringValue(4);
                return assignObjToOattr(sSessId, sProcId, sObjName, sOattrName);

            } else if (sCmdCode.equalsIgnoreCase("deassignObjFromOattrWithProp")) {
                if (cmdPacket.size() < 5) {
                    return failurePacket("Too few arguments!");
                }
                String sSessId = cmdPacket.getStringValue(1);
                String sProcId = cmdPacket.getStringValue(2);
                String sObjName = cmdPacket.getStringValue(3);
                String sProp = cmdPacket.getStringValue(4);
                return deassignObjFromOattrWithProp(sSessId, sProcId, sObjName,
                        sProp);

            } else if (sCmdCode.equalsIgnoreCase("isObjInOattrWithProp")) {
                if (cmdPacket.size() < 4) {
                    return failurePacket("Too few arguments!");
                }
                String sSessId = cmdPacket.getStringValue(1);
                String sObjName = cmdPacket.getStringValue(2);
                String sProp = cmdPacket.getStringValue(3);
                return isObjInOattrWithProp(sSessId, sObjName, sProp);

            } else if (sCmdCode.equalsIgnoreCase("getInboxMessages")) {
                if (cmdPacket.size() < 2) {
                    return failurePacket("Too few arguments!");
                }
                String sSessId = cmdPacket.getStringValue(1);
                return getInboxMessages(sSessId);

            } else if (sCmdCode.equalsIgnoreCase("getOutboxMessages")) {
                if (cmdPacket.size() < 2) {
                    return failurePacket("Too few arguments!");
                }
                String sSessId = cmdPacket.getStringValue(1);
                return getOutboxMessages(sSessId);

            } else if (sCmdCode.equalsIgnoreCase("getFileContent")) {
                if (cmdPacket.size() < 3) {
                    return failurePacket("Too few arguments!");
                }
                String sSessId = cmdPacket.getStringValue(1);
                String sFileProp = cmdPacket.getStringValue(2);
                return getFileContent(sSessId, sFileProp, bisFromClient,
                        bosToClient);

            } else if (sCmdCode.equalsIgnoreCase("createObjForFile")) {
                if (cmdPacket.size() < 4) {
                    return failurePacket("Too few arguments!");
                }
                String sSessId = cmdPacket.getStringValue(1);
                String sFilePath = cmdPacket.getStringValue(2);
                String sContName = cmdPacket.getStringValue(3);
                return createObjForFile(sSessId, sFilePath, sContName);

            } else if (sCmdCode.equalsIgnoreCase("createContForFolder")) {
                if (cmdPacket.size() < 4) {
                    return failurePacket("Too few arguments!");
                }
                String sSessId = cmdPacket.getStringValue(1);
                String sFolderPath = cmdPacket.getStringValue(2);
                String sBaseContName = cmdPacket.getStringValue(3);
                return createContForFolder(sSessId, sFolderPath, sBaseContName);

            } else if (sCmdCode.equalsIgnoreCase("getDascUattrs")) {
                if (cmdPacket.size() < 4) {
                    return failurePacket("Too few arguments!");
                }
                String sSessId = cmdPacket.getStringValue(1);
                String sBaseName = cmdPacket.getStringValue(2);
                String sBaseType = cmdPacket.getStringValue(3);
                return getDascUattrs(sBaseName, sBaseType);

            } else if (sCmdCode.equalsIgnoreCase("getDascUsers")) {
                if (cmdPacket.size() < 4) {
                    return failurePacket("Too few arguments!");
                }
                String sSessId = cmdPacket.getStringValue(1);
                String sBaseName = cmdPacket.getStringValue(2);
                String sBaseType = cmdPacket.getStringValue(3);
                return getDascUsers(sBaseName, sBaseType);

            } else if (sCmdCode.equalsIgnoreCase("getDascOattrs")) {
                if (cmdPacket.size() < 4) {
                    return failurePacket("Too few arguments!");
                }
                String sSessId = cmdPacket.getStringValue(1);
                String sBaseName = cmdPacket.getStringValue(2);
                String sBaseType = cmdPacket.getStringValue(3);
                return getDascOattrs(sBaseName, sBaseType);

            } else if (sCmdCode.equalsIgnoreCase("getDascObjects")) {
                if (cmdPacket.size() < 4) {
                    return failurePacket("Too few arguments!");
                }
                String sSessId = cmdPacket.getStringValue(1);
                String sBaseName = cmdPacket.getStringValue(2);
                String sBaseType = cmdPacket.getStringValue(3);
                return getDascObjects(sBaseName, sBaseType);

            } else if (sCmdCode.equalsIgnoreCase("getDascOpsets")) {
                if (cmdPacket.size() < 4) {
                    return failurePacket("Too few arguments!");
                }
                String sSessId = cmdPacket.getStringValue(1);
                String sBaseName = cmdPacket.getStringValue(2);
                String sBaseType = cmdPacket.getStringValue(3);
                return getDascOpsets(sBaseName, sBaseType);

            } else if (sCmdCode.equalsIgnoreCase("decreaseAscs")) {
                if (cmdPacket.size() < 2) {
                    return failurePacket("Too few arguments!");
                }
                String sSessId = cmdPacket.getStringValue(1);
                return decreaseDisplayedAscs(sSessId);

            } else if (sCmdCode.equalsIgnoreCase("increaseAscs")) {
                if (cmdPacket.size() < 2) {
                    return failurePacket("Too few arguments!");
                }
                String sSessId = cmdPacket.getStringValue(1);
                return increaseDisplayedAscs(sSessId);

            } else if (sCmdCode.equalsIgnoreCase("getContainersOf")) {
                if (cmdPacket.size() < 6) {
                    return failurePacket("Too few arguments!");
                }
                String sSessId = cmdPacket.getStringValue(1);
                String sBaseName = cmdPacket.getStringValue(2);
                String sBaseId = cmdPacket.getStringValue(3);
                String sBaseType = cmdPacket.getStringValue(4);
                String sGraphType = cmdPacket.getStringValue(5);
                return getContainersOf(sBaseName, sBaseId, sBaseType,
                        sGraphType);

            } else if (sCmdCode.equalsIgnoreCase("getMembersOf")) {
                if (cmdPacket.size() < 6) {
                    return failurePacket("Too few arguments!");
                }
                String sSessId = cmdPacket.getStringValue(1);
                String sBaseName = cmdPacket.getStringValue(2);
                String sBaseId = cmdPacket.getStringValue(3);
                String sBaseType = cmdPacket.getStringValue(4);
                String sGraphType = cmdPacket.getStringValue(5);
                return getMembersOf(sBaseName, sBaseId, sBaseType, sGraphType);

            } else if (sCmdCode.equalsIgnoreCase("getConnector")) {
                if (cmdPacket.size() < 2) {
                    return failurePacket("Too few arguments!");
                }
                String sSessId = cmdPacket.getStringValue(1);
                return getConnector();

            } else if (sCmdCode.equalsIgnoreCase("getPosMembersOf")) {
                if (cmdPacket.size() < 6) {
                    return failurePacket("Too few arguments!");
                }
                String sSessId = cmdPacket.getStringValue(1);
                String sBaseName = cmdPacket.getStringValue(2);
                String sBaseId = cmdPacket.getStringValue(3);
                String sBaseType = cmdPacket.getStringValue(4);
                String sGraphType = cmdPacket.getStringValue(5);
                return getPosMembersOf(sSessId, sBaseName, sBaseId, sBaseType,
                        sGraphType);

            } else if (sCmdCode.equalsIgnoreCase("getPosContainersOf")) {
                if (cmdPacket.size() < 6) {
                    return failurePacket("Too few arguments!");
                }
                String sSessId = cmdPacket.getStringValue(1);
                String sBaseName = cmdPacket.getStringValue(2);
                String sBaseId = cmdPacket.getStringValue(3);
                String sBaseType = cmdPacket.getStringValue(4);
                String sGraphType = cmdPacket.getStringValue(5);
                return getPosContainersOf(sSessId, sBaseName, sBaseId,
                        sBaseType, sGraphType);

            } else if (sCmdCode.equalsIgnoreCase("setStartups")) {
                if (cmdPacket.size() < 2) {
                    return failurePacket("Too few arguments!");
                }
                String sSessId = cmdPacket.getStringValue(1);
                return setStartups(sSessId, cmdPacket);

            } else if (sCmdCode.equalsIgnoreCase("addTemplate")) {
                if (cmdPacket.size() < 5) {
                    return failurePacket("Too few arguments!");
                }
                String sSessId = cmdPacket.getStringValue(1);
                String sTplName = cmdPacket.getStringValue(2);
                String sContainers = cmdPacket.getStringValue(3);
                String sKeys = cmdPacket.getStringValue(4);
                return addTemplate(sSessId, sTplName, sContainers, sKeys);

            } else if (sCmdCode.equalsIgnoreCase("getTemplates")) {
                if (cmdPacket.size() < 2) {
                    return failurePacket("Too few arguments!");
                }
                String sSessId = cmdPacket.getStringValue(1);
                return getTemplates(sSessId);

            } else if (sCmdCode.equalsIgnoreCase("getTemplateInfo")) {
                if (cmdPacket.size() < 3) {
                    return failurePacket("Too few arguments!");
                }
                String sSessId = cmdPacket.getStringValue(1);
                String sTplId = cmdPacket.getStringValue(2);
                return getTemplateInfo(sSessId, sTplId);

            } else if (sCmdCode.equalsIgnoreCase("createRecord")) {
                if (cmdPacket.size() < 8) {
                    return failurePacket("Too few arguments!");
                }
                String sSessId = cmdPacket.getStringValue(1);
                String sProcId = cmdPacket.getStringValue(2);
                String sRecordName = cmdPacket.getStringValue(3);
                String sBase = cmdPacket.getStringValue(4);
                String sBaseType = cmdPacket.getStringValue(5);
                String sTplId = cmdPacket.getStringValue(6);
                String sComponents = cmdPacket.getStringValue(7);
                String[] sKeys = getItemsFromPacket(cmdPacket, 8);
                return createRecord(sSessId, sProcId, sRecordName, sBase,
                        sBaseType, sTplId, sComponents, sKeys);

            } else if (sCmdCode.equalsIgnoreCase("createRecordInEntityWithProp")) {
                if (cmdPacket.size() < 8) {
                    return failurePacket("Too few arguments!");
                }
                String sSessId = cmdPacket.getStringValue(1);
                String sProcId = cmdPacket.getStringValue(2);
                String sRecordName = cmdPacket.getStringValue(3);
                String sProp = cmdPacket.getStringValue(4);
                String sBaseType = cmdPacket.getStringValue(5);
                String sTplId = cmdPacket.getStringValue(6);
                String sComponents = cmdPacket.getStringValue(7);
                String[] sKeys = getItemsFromPacket(cmdPacket, 8);
                return createRecordInEntityWithProp(sSessId, sProcId,
                        sRecordName, sProp, sBaseType, sTplId, sComponents,
                        sKeys);

            } else if (sCmdCode.equalsIgnoreCase("getRecords")) {
                if (cmdPacket.size() < 4) {
                    return failurePacket("Too few arguments!");
                }
                String sSessId = cmdPacket.getStringValue(1);
                String sTplId = cmdPacket.getStringValue(2);
                String sKey = cmdPacket.getStringValue(3);
                return getRecords(sSessId, sTplId, sKey);

            } else if (sCmdCode.equalsIgnoreCase("getRecordInfo")) {
                if (cmdPacket.size() < 3) {
                    return failurePacket("Too few arguments!");
                }
                String sSessId = cmdPacket.getStringValue(1);
                String sOattrId = cmdPacket.getStringValue(2);
                return getRecordInfo(sSessId, sOattrId);

            } else if (sCmdCode.equalsIgnoreCase("getObjInfo")) {
                if (cmdPacket.size() < 3) {
                    return failurePacket("Too few arguments!");
                }
                String sSessId = cmdPacket.getStringValue(1);
                String sObjId = cmdPacket.getStringValue(2);
                return getObjInfo(sObjId);

            } else if (sCmdCode.equalsIgnoreCase("getObjProperties")){
                if(cmdPacket.size() < 3){
                    return failurePacket("Too few arguments!");
                }
                String sSessId = cmdPacket.getStringValue(1);
                String sObjId = cmdPacket.getStringValue(2);
                return getObjProperties(sObjId);
            } else if (sCmdCode.equalsIgnoreCase("isInPos")) {
                if (cmdPacket.size() < 3) {
                    return failurePacket("Too few arguments!");
                }
                String sSessId = cmdPacket.getStringValue(1);
                String sObjId = cmdPacket.getStringValue(2);
                return isInPos(sSessId, sObjId);

            } else if (sCmdCode.equalsIgnoreCase("testExportRecords")) {
                if (cmdPacket.size() < 2) {
                    return failurePacket("Too few arguments!");
                }
                String sSessId = cmdPacket.getStringValue(1);
                return testExportRecords();

            } else if (sCmdCode.equalsIgnoreCase("getUsersOf")) {
                if (cmdPacket.size() < 3) {
                    return failurePacket("Too few arguments!");
                }
                String sSessId = cmdPacket.getStringValue(1);
                String sUattrName = cmdPacket.getStringValue(2);
                return getUsersOf(sUattrName);

            } else if (sCmdCode.equalsIgnoreCase("setRecordKeys")) {
                if (cmdPacket.size() < 3) {
                    return failurePacket("Too few arguments!");
                }
                String sSessId = cmdPacket.getStringValue(1);
                String sRecName = cmdPacket.getStringValue(2);
                String[] sKeys = getItemsFromPacket(cmdPacket, 3);
                return setRecordKeys(sSessId, sRecName, sKeys);

            } else if (sCmdCode.equalsIgnoreCase("addRecordKeys")) {
                if (cmdPacket.size() < 3) {
                    return failurePacket("Too few arguments!");
                }
                String sSessId = cmdPacket.getStringValue(1);
                String sRecName = cmdPacket.getStringValue(2);
                String[] sKeys = getItemsFromPacket(cmdPacket, 3);
                return addRecordKeys(sSessId, sRecName, sKeys);

            } else if (sCmdCode.equalsIgnoreCase("getProperties")) {
                if (cmdPacket.size() < 2) {
                    return failurePacket("Too few arguments!");
                }
                String sSessId = cmdPacket.getStringValue(1);
                return getProperties(sSessId);

            } else if (sCmdCode.equalsIgnoreCase("deleteProperty")) {
                if (cmdPacket.size() < 3) {
                    return failurePacket("Too few arguments!");
                }
                String sSessId = cmdPacket.getStringValue(1);
                String sPropName = cmdPacket.getStringValue(2);
                return deleteProperty(sSessId, sPropName);

            } else if (sCmdCode.equalsIgnoreCase("setProperty")) {
                if (cmdPacket.size() < 4) {
                    return failurePacket("Too few arguments!");
                }
                String sSessId = cmdPacket.getStringValue(1);
                String sPropName = cmdPacket.getStringValue(2);
                String sPropValue = cmdPacket.getStringValue(3);
                return setProperty(sSessId, sPropName, sPropValue);

            } else if (sCmdCode.equalsIgnoreCase("getPropertyValue")) {
                if (cmdPacket.size() < 3) {
                    return failurePacket("Too few arguments!");
                }
                String sSessId = cmdPacket.getStringValue(1);
                String sPropName = cmdPacket.getStringValue(2);
                return getPropertyValue(sSessId, sPropName);

            } else if (sCmdCode.equalsIgnoreCase("getProperty")) {
                if (cmdPacket.size() < 3) {
                    return failurePacket("Too few arguments!");
                }
                String sSessId = cmdPacket.getStringValue(1);
                String sPropName = cmdPacket.getStringValue(2);
                return getProperty(sSessId, sPropName);

            } else if (sCmdCode.equalsIgnoreCase("createLinkedObjects")) {
                return createLinkedObjects();

            } else {
                System.out.println(sCmdCode);
                System.in.read();
                return failurePacket("Unknown command");
            }
        } catch (Exception e) {
            return failurePacket(e.getMessage());
        }
    }

    private Packet createLinkedObjects() {
        Attributes attrs = null;
        String sUattrContainerDN = "CN=PmUattrContainer," + sThisDomain;

        try {
            attrs = new BasicAttributes(true);
            attrs.put("objectClass", "pmClassUattr");
            ctx.bind("CN=uattr0," + sUattrContainerDN, null, attrs);

            for (int i = 1; i <= 5000; i++) {
                String sDn = "CN=uattr" + i + "," + sUattrContainerDN;
                attrs = new BasicAttributes(true);
                attrs.put("objectClass", "pmClassUattr");
                ctx.bind(sDn, null, attrs);

                ModificationItem[] mods = new ModificationItem[1];
                mods[0] = new ModificationItem(DirContext.ADD_ATTRIBUTE,
                        new BasicAttribute("pmAssignedTo", sDn));
                ctx.modifyAttributes("CN=uattr0," + sUattrContainerDN, mods);
            }
        } catch (Exception e) {
            if (debugFlag) {
                e.printStackTrace();
            }
            return failurePacket(e.getMessage());
        }
        return successPacket();
    }

    private Packet getPropertyValue(String sSessId, String sPropName) {
        Attributes attrs = null;
        try {
            attrs = ctx.getAttributes("CN=" + sPropName + ","
                    + sPropertyContainerDN);
        } catch (NameNotFoundException nnfe) {
            return failurePacket("No such property " + sPropName);
        } catch (Exception e) {
            e.printStackTrace();
            return failurePacket("Exception in getProperty() (reading)!");
        }
        Attribute attr = attrs.get("pmValue");
        if (attr == null) {
            return failurePacket("Property " + sPropName + " has no value!");
        }
        String sPropValue = null;
        try {
            sPropValue = (String) attr.get();
        } catch (Exception e) {
            e.printStackTrace();
            return failurePacket("Exception in getProperty() (getting the value)!");
        }
        Packet result = new Packet();
        try {
            result.addItem(ItemType.RESPONSE_TEXT, sPropValue);
        } catch (Exception e) {
            e.printStackTrace();
            return failurePacket("Exception when building result packet!");
        }
        return result;
    }

    private Packet getProperty(String sSessId, String sPropName) {
        Attributes attrs = null;
        try {
            attrs = ctx.getAttributes("CN=" + sPropName + ","
                    + sPropertyContainerDN);
        } catch (NameNotFoundException nnfe) {
            return failurePacket("No such property " + sPropName);
        } catch (Exception e) {
            e.printStackTrace();
            return failurePacket("Exception in getProperty() (reading)!");
        }
        Attribute attr = attrs.get("pmValue");
        if (attr == null) {
            return failurePacket("Property " + sPropName + " has no value!");
        }
        String sPropValue = null;
        try {
            sPropValue = (String) attr.get();
        } catch (Exception e) {
            e.printStackTrace();
            return failurePacket("Exception in getProperty() (getting the value)!");
        }
        Packet result = new Packet();
        try {
            result.addItem(ItemType.RESPONSE_TEXT, sPropName + PM_PROP_DELIM
                    + sPropValue);
            return result;
        } catch (Exception e) {
            e.printStackTrace();
            return failurePacket("Exception when building result packet!");
        }
    }

    private Packet setProperty(String sSessId, String sPropName,
                               String sPropValue) {
        // Is there a property with this name?
        boolean bNew = false;
        try {
            ctx.getAttributes("CN=" + sPropName + "," + sPropertyContainerDN);
        } catch (NameNotFoundException nnfe) {
            bNew = true;
        } catch (Exception e) {
            e.printStackTrace();
            return failurePacket("Exception in setProperty() (reading)!");
        }

        if (bNew) {
            // A new property.
            Attributes attrs = new BasicAttributes(true);
            attrs.put("objectClass", sPropertyClass);
            attrs.put("pmValue", sPropValue);
            String sPropDn = "CN=" + sPropName + "," + sPropertyContainerDN;
            try {
                ctx.bind(sPropDn, null, attrs);
            } catch (Exception e) {
                e.printStackTrace();
                return failurePacket("Exception in setProperty() (new)!");
            }
        } else {
            // Property exists, just replace its value.
            ModificationItem[] mods = new ModificationItem[1];
            mods[0] = new ModificationItem(DirContext.REPLACE_ATTRIBUTE,
                    new BasicAttribute("pmValue", sPropValue));
            try {
                ctx.modifyAttributes("CN=" + sPropName + ","
                        + sPropertyContainerDN, mods);
            } catch (Exception e) {
                e.printStackTrace();
                return failurePacket("Exception in setProperty() (replace)!");
            }
        }
        return successPacket();
    }

    private Packet deleteProperty(String sSessId, String sPropName) {
        try {
            ctx.destroySubcontext("CN=" + sPropName + ","
                    + sPropertyContainerDN);
        } catch (Exception e) {
            if (debugFlag) {
                e.printStackTrace();
            }
            return failurePacket("Could not delete property with name "
                    + sPropName);
        }
        return successPacket();
    }

    private Packet getProperties(String sSessId) {
        Packet result = new Packet();
        NamingEnumeration<SearchResult> props;

        try {
            SearchControls constraints = new SearchControls();
            constraints.setSearchScope(SearchControls.ONELEVEL_SCOPE);
            constraints.setReturningAttributes(new String[]{"cn", "pmValue"});
            props = ctx.search(sPropertyContainerDN, "(objectClass=*)",
                    constraints);
            while (props != null && props.hasMore()) {
                SearchResult sr = (SearchResult) props.next();
                String sName = (String) sr.getAttributes().get("cn").get();
                String sValue = (String) sr.getAttributes().get("pmValue").get();
                result.addItem(ItemType.RESPONSE_TEXT, sName + PM_PROP_DELIM
                        + sValue);
            }
            return result;
        } catch (Exception e) {
            if (debugFlag) {
                e.printStackTrace();
            }
            return failurePacket("Exception in getProperties(): "
                    + e.getMessage());
        }
    }

    // Returns sRecId of a record that contains the given object or object
    // attribute as a field. There should be at most one such record.
    // Returns null if there is no such object or object attribute,
    // or if there is no record that contains it.
    private String getRecordOf(String sId, String sType) {
        String sOattrId = null;
        if (sType.equalsIgnoreCase(PM_OBJ)) {
            sOattrId = getAssocOattr(sId);
        } else {
            sOattrId = sId;
        }
        if (sOattrId == null) {
            return null;
        }
        try {
            Attributes attrs = ctx.getAttributes("CN=" + sOattrId + ","
                    + sObjAttrContainerDN);
            Attribute attr = attrs.get("pmToAttr");
            if (attr == null) {
                return null;
            }

            // For each descendant, check whether it is a record:
            for (NamingEnumeration<?> enumer = attr.getAll(); enumer.hasMore(); ) {
                String sRecId = (String) enumer.next();
                if (isRecord(sRecId)) {
                    return sRecId;
                }
            }
            return null;
        } catch (Exception e) {
            e.printStackTrace();
            return null;
        }
    }

    // Check whether the given object attribute is directly assigned to a
    // record,
    // i.e., a container with a template.
    private boolean isInARecord(String sOattrId) {
        try {
            // Get all direct descendant object attributes.
            Attributes attrs = ctx.getAttributes("CN=" + sOattrId + ","
                    + sObjAttrContainerDN);
            Attribute attr = attrs.get("pmToAttr");
            if (attr == null) {
                return false;
            }

            // For each descendant, check whether it is a record:
            NamingEnumeration<?> enumer = attr.getAll();
            while (enumer.hasMore()) {
                String sContId = (String) enumer.next();
                if (isRecord(sContId)) {
                    enumer.close();
                    return true;
                }
            }
            enumer.close();
            return false;
        } catch (Exception e) {
            e.printStackTrace();
            return false;
        }
    }

    // Check whether the given record is indeed a record, and whether the given
    // oa
    // is directly assigned to the given record.
    private boolean isInRecord(String sOattrId, String sRecordId) {
        if (!isRecord(sRecordId)) {
            return false;
        }
        try {
            Attributes attrs = ctx.getAttributes("CN=" + sOattrId + ","
                    + sObjAttrContainerDN);
            Attribute attr = attrs.get("pmToAttr");
            if (attr == null) {
                return false;
            }
            for (NamingEnumeration<?> enumer = attr.getAll(); enumer.hasMore(); ) {
                String sContId = (String) enumer.next();
                if (sContId.equalsIgnoreCase(sRecordId)) {
                    return true;
                }
            }
            return false;
        } catch (Exception e) {
            e.printStackTrace();
            return false;
        }
    }

    private boolean isRecord(String sId) {
        try {
            Attributes attrs = ctx.getAttributes("CN=" + sId + ","
                    + sObjAttrContainerDN);
            if (attrs == null) {
                return false;
            }
            Attribute attr = attrs.get("pmTemplateId");
            if (attr == null) {
                return false;
            }
            return true;
        } catch (Exception e) {
            e.printStackTrace();
            return false;
        }
    }

    private Packet isInPos(String sSessId, String sObjId) {
        String sPosObjId = getVosNodeId(sObjId, sSessId);
        if (sPosObjId == null) {
            return failurePacket();
        }
        return successPacket();
    }

    // Get all info about the composite object associated with the specified
    // object attribute.
    // Item 0: <name>:<id>
    // Item 1: <template name>:<template id>
    // Item 2: <comp count>
    // Items 3 to 3 + <comp count> - 1: <comp name>:<comp id>
    // Item 3 + <comp count>: <key count>
    // Items 3 + <comp count> + 1 to 3 + <comp count> + 1 + <key count> - 1:
    // <key name>=<key value>
    // The <comp id> is the id of the object attribute associated with a
    // component object.
    private Packet getRecordInfo(String sSessId, String sContId) {
        Packet result = new Packet();
        Attributes attrs;
        Attribute attr;

        try {
            // Get container's attributes of interest.
            attrs = ctx.getAttributes("CN=" + sContId + ","
                    + sObjAttrContainerDN);

            String sContName = (String) attrs.get("pmName").get();
            attr = attrs.get("pmTemplateId");
            if (attr == null) {
                return failurePacket("Container " + sContId
                        + " is not a record!");
            }

            String sTplId = (String) attr.get();
            String sTplName = getEntityName(sTplId, PM_TEMPLATE);
            if (sTplName == null) {
                return failurePacket("Inconsistency: no template with such id: "
                        + sTplId);
            }

            result.addItem(ItemType.RESPONSE_TEXT, sContName + PM_FIELD_DELIM
                    + sContId);
            result.addItem(ItemType.RESPONSE_TEXT, sTplName + PM_FIELD_DELIM
                    + sTplId);

            // The component objects: how many, then name:id.
            attr = attrs.get("pmComponents");
            if (attr == null) {
                result.addItem(ItemType.RESPONSE_TEXT, "0");
            } else {
                String sObjCompos = (String) attr.get();
                String[] pieces = sObjCompos.split(PM_FIELD_DELIM);
                result.addItem(ItemType.RESPONSE_TEXT,
                        String.valueOf(pieces.length));
                for (int i = 0; i < pieces.length; i++) {
                    String sName = getEntityName(pieces[i], PM_NODE_OATTR);
                    if (sName == null) {
                        return failurePacket("Inconsistency: no component object (attribute) with id "
                                + pieces[i] + " exists!");
                    }
                    result.addItem(ItemType.RESPONSE_TEXT, sName
                            + PM_FIELD_DELIM + pieces[i]);
                }
            }

            // Now the keys: how many, then name=value.
            attr = attrs.get("pmKey");
            if (attr == null) {
                result.addItem(ItemType.RESPONSE_TEXT, "0");
            } else {
                result.addItem(ItemType.RESPONSE_TEXT,
                        String.valueOf(attr.size()));
            }
            if (attr != null) {
                for (NamingEnumeration<?> attrEnum = attr.getAll(); attrEnum.hasMore(); ) {
                    String sKey = (String) attrEnum.next();
                    result.addItem(ItemType.RESPONSE_TEXT, sKey);
                }
            }
            return result;
        } catch (Exception e) {
            e.printStackTrace();
            return failurePacket("Exception in getRecordInfo(): "
                    + e.getMessage());
        }
    }

    // Returns the <name>:<id> of the oattrs that are records (containers)
    // satisfying some criteria. A record is a container distinguished by
    // the fact that it has an associated template.
    // If the given template is null, return all record containers.
    // Else if the given key is null, return all records that have the given
    // template.
    // Else it returns all records that have the given template and key.
    private Packet getRecords(String sSessId, String sTplId, String sKey) {
        System.out.println("template id = " + sTplId);
        System.out.println("key = " + sKey);

        NamingEnumeration<?> attrs;
        Packet result = new Packet();

        try {
            SearchControls constraints = new SearchControls();
            constraints.setSearchScope(SearchControls.ONELEVEL_SCOPE);
            constraints.setReturningAttributes(new String[]{"pmId", "pmName",
                    "pmTemplateId"});
            String sFilter;
            if (sTplId == null) {
                sFilter = "(objectClass=*)";
            } else if (sKey == null) {
                sFilter = "(&(objectClass=*)(pmTemplateId=" + sTplId + "))";
            } else {
                sFilter = "(&(objectClass=*)(pmTemplateId=" + sTplId
                        + ")(pmKey=" + sKey + "))";
            }
            attrs = ctx.search(sObjAttrContainerDN, sFilter, constraints);
            while (attrs != null && attrs.hasMore()) {
                SearchResult sr = (SearchResult) attrs.next();
                Attribute attr = sr.getAttributes().get("pmTemplateId");
                if (attr == null) {
                    continue;
                }
                String sId = (String) sr.getAttributes().get("pmId").get();
                String sName = (String) sr.getAttributes().get("pmName").get();
                result.addItem(ItemType.RESPONSE_TEXT, sName + PM_FIELD_DELIM
                        + sId);
            }
            return result;
        } catch (Exception e) {
            e.printStackTrace();
            return failurePacket("Exception in getCompositeObjects()");
        }
    }

    // Create a record container (formerly a composite object).
    // sRecName is the name of the new record/container.
    // sBase is the name or id - both should work - of the base node where this
    // record is to be created.
    // sBaseType is the type of the base node where this
    // record is to be created.
    // sTplId is the id of the record's template.
    // sComponents contains the ids OR NAMES of the object attributes associated
    // with the component objects, in the format
    // <id or name 1>:<id or name 2>:...:<id or name n>.
    // sKeys contains the keys of the record, one key per item,
    // in the format <key name>=<key value>.
    private Packet createRecord(String sSessId, String sProcId,
                                String sRecName, String sBase, String sBaseType, String sTplId,
                                String sComponents, String[] sKeys) {

        String sBaseId = null, sBaseName = null;
        sBaseName = getEntityName(sBase, sBaseType);
        if (sBaseName != null) {
            sBaseId = sBase;
        } else {
            sBaseId = getEntityId(sBase, sBaseType);
            if (sBaseId != null) {
                sBaseName = sBase;
            } else {
                return failurePacket("No node of type " + sBaseType
                        + " with name or id " + sBase);
            }
        }

        Packet result = null;
        try {
            result =  addOattr(sSessId, sProcId, sRecName, sRecName,
                    sRecName, sBaseId, sBaseType, "no", null, null);
        } catch (Exception e) {
            if (debugFlag) {
                e.printStackTrace();
            }
            return failurePacket("Exception during record creation: "
                    + e.getMessage());
        }

        // If successful, the result contains the name and id of the new record.
        if (result.hasError()) {
            return result;
        }
        String sLine = result.getStringValue(0);
        String[] pieces = sLine.split(PM_FIELD_DELIM);

        // Add the template id, components, and keys.
        int n = 0;
        if (sTplId != null) {
            n++;
        }
        if (sComponents != null) {
            n++;
        }
        if (sKeys != null) {
            n += sKeys.length;
        }
        if (n == 0) {
            return result;
        }

        ModificationItem[] mods = new ModificationItem[n];
        int i = 0;
        if (sTplId != null) {
            mods[i++] = new ModificationItem(DirContext.ADD_ATTRIBUTE,
                    new BasicAttribute("pmTemplateId", sTplId));
        }
        if (sComponents != null) {
            String sCanonicCompos = getCanonicList(sComponents);
            mods[i++] = new ModificationItem(DirContext.ADD_ATTRIBUTE,
                    new BasicAttribute("pmComponents", sCanonicCompos));
        }
        if (sKeys != null) {
            for (int j = 0; j < sKeys.length; j++) {
                mods[i + j] = new ModificationItem(DirContext.ADD_ATTRIBUTE,
                        new BasicAttribute("pmKey", sKeys[j]));
            }
        }
        try {
            ctx.modifyAttributes("CN=" + pieces[1] + "," + sObjAttrContainerDN,
                    mods);
        } catch (Exception e) {
            if (debugFlag) {
                e.printStackTrace();
            }
            return failurePacket("Unable to set the new record's properties (template, components, or keys)!");
        }
        return result;
    }

    private Packet createRecordInEntityWithProp(String sSessId, String sProcId,
                                                String sRecName, String sProp, String sBaseType, String sTplId,
                                                String sComponents, String[] sKeys) {
        String sBaseId = getEntityWithPropInternal(sBaseType, sProp);
        if (sBaseId == null) {
            return failurePacket("No entity of type " + sBaseType
                    + " with property " + sProp);
        }
        return createRecord(sSessId, sProcId, sRecName, sBaseId, sBaseType,
                sTplId, sComponents, sKeys);
    }

    // A record is an object container associated with:
    // - a template that tells the number, order, and names of the columns.
    // - pointers to the fields, which are the objects within the container
    // and must be contained in the appropriate columns.
    // - keys that allow relatively fast retrieval of the record.
    // This method sets the keys of a record.
    private Packet setRecordKeys(String sSessId, String sRecName, String[] sKeys) {

        // The record is an object container. Must exist and must be a record:
        String sId = getEntityId(sRecName, PM_NODE_OATTR);
        if (sId == null) {
            return failurePacket("No such record " + sRecName);
        }
        if (!isRecord(sId)) {
            return failurePacket(sRecName + " is not a record!");
        }

        if (sKeys == null || sKeys.length == 0) {
            return successPacket();
        }

        int n = sKeys.length;
        ModificationItem[] mods = new ModificationItem[1];
        mods[0] = new ModificationItem(DirContext.REMOVE_ATTRIBUTE,
                new BasicAttribute("pmKey"));
        try {
            ctx.modifyAttributes("CN=" + sId + "," + sObjAttrContainerDN, mods);
        } catch (Exception e) {
            System.out.println("Probably no pmKey attribute found; exception follows!");
            e.printStackTrace();
        }

        mods = new ModificationItem[n];
        for (int i = 0; i < n; i++) {
            mods[i] = new ModificationItem(DirContext.ADD_ATTRIBUTE,
                    new BasicAttribute("pmKey", sKeys[i]));
        }
        try {
            ctx.modifyAttributes("CN=" + sId + "," + sObjAttrContainerDN, mods);
        } catch (Exception e) {
            if (debugFlag) {
                e.printStackTrace();
            }
            return failurePacket("Unable to set the record's keys!");
        }
        return successPacket();
    }

    private Packet addRecordKeys(String sSessId, String sRecName, String[] sKeys) {

        // The record is an object container. Must exist and must be a record:
        String sId = getEntityId(sRecName, PM_NODE_OATTR);
        if (sId == null) {
            return failurePacket("No such record " + sRecName);
        }
        if (!isRecord(sId)) {
            return failurePacket(sRecName + " is not a record!");
        }

        if (sKeys == null || sKeys.length == 0) {
            return successPacket();
        }

        int n = sKeys.length;
        ModificationItem[] mods = new ModificationItem[n];
        for (int i = 0; i < n; i++) {
            mods[i] = new ModificationItem(DirContext.ADD_ATTRIBUTE,
                    new BasicAttribute("pmKey", sKeys[i]));
        }
        try {
            ctx.modifyAttributes("CN=" + sId + "," + sObjAttrContainerDN, mods);
        } catch (Exception e) {
            if (debugFlag) {
                e.printStackTrace();
            }
            return failurePacket("Unable to add the key t " + sRecName + "!");
        }
        return successPacket();
    }

    // Each item returned is a string <tpl name>:<tpl id>.
    private Packet getTemplates(String sClientId) {
        Packet result = new Packet();
        NamingEnumeration<?> tpls;

        try {
            SearchControls constraints = new SearchControls();
            constraints.setSearchScope(SearchControls.ONELEVEL_SCOPE);
            constraints.setReturningAttributes(new String[]{"pmId", "pmName"});
            tpls = ctx.search(sTemplateContainerDN, "(objectClass=*)",
                    constraints);

            while (tpls != null && tpls.hasMore()) {
                SearchResult sr = (SearchResult) tpls.next();
                String sName = (String) sr.getAttributes().get("pmName").get();
                String sId = (String) sr.getAttributes().get("pmId").get();
                result.addItem(ItemType.RESPONSE_TEXT, sName + PM_FIELD_DELIM
                        + sId);
            }
            return result;
        } catch (CommunicationException e) {
            if (debugFlag) {
                e.printStackTrace();
            }
            return failurePacket("AD connection error");
        } catch (Exception e) {
            if (debugFlag) {
                e.printStackTrace();
            }
            return failurePacket("Exception: " + e.getMessage());
        }
    }

    private Packet addRecordKey(String sSessId, String sRecId, String sKey) {
        if (sKey == null || sKey.length() <= 0) {
            return successPacket();
        }
        ModificationItem[] adds = new ModificationItem[1];

        try {
            adds[0] = new ModificationItem(DirContext.ADD_ATTRIBUTE,
                    new BasicAttribute("pmKey", sKey));
            ctx.modifyAttributes("CN=" + sRecId + "," + sObjAttrContainerDN,
                    adds);
            return successPacket();
        } catch (Exception e) {
            if (debugFlag) {
                e.printStackTrace();
            }
            return failurePacket("Exception when adding key to record "
                    + sRecId);
        }
    }

    private Packet addTemplateKey(String sSessId, String sTplId, String sKey) {
        if (sKey == null || sKey.length() <= 0) {
            return successPacket();
        }
        ModificationItem[] adds = new ModificationItem[1];

        try {
            adds[0] = new ModificationItem(DirContext.ADD_ATTRIBUTE,
                    new BasicAttribute("pmKey", sKey));
            ctx.modifyAttributes("CN=" + sTplId + "," + sTemplateContainerDN,
                    adds);
            return successPacket();
        } catch (Exception e) {
            if (debugFlag) {
                e.printStackTrace();
            }
            return failurePacket("Exception when adding key to the template");
        }
    }

    // Add a record's template. sTplName is the template name, sContainers
    // contains the container ids separated by ":", and sKeys contains the
    // keys separated by ":".
    private Packet addTemplate(String sSessId, String sTplName,
                               String sContainers, String sKeys) {
        String sId = getEntityId(sTplName, PM_TEMPLATE);
        if (sId != null) {
            return failurePacket("Duplicate template name!");
        }

        RandomGUID myGUID = new RandomGUID();
        sId = myGUID.toStringNoDashes();

        Attributes attrs = new BasicAttributes(true);
        attrs.put("objectClass", sTemplateClass);
        attrs.put("pmId", sId);
        attrs.put("pmName", sTplName);

        if (sContainers == null || sContainers.length() == 0) {
            return failurePacket("The containers argument cannot be empty or null!");
        }
        attrs.put("pmComponents", sContainers);

        // Prepare the path and create.
        String sDn = "CN=" + sId + "," + sTemplateContainerDN;
        try {
            ctx.bind(sDn, null, attrs);
        } catch (Exception e) {
            e.printStackTrace();
            return failurePacket("Exception when creating the template object!");
        }

        if (sKeys == null || sKeys.length() == 0) {
            return successPacket();
        }

        String[] pieces = sKeys.split(PM_FIELD_DELIM);
        ModificationItem[] adds = new ModificationItem[pieces.length];

        try {
            for (int i = 0; i < pieces.length; i++) {
                adds[i] = new ModificationItem(DirContext.ADD_ATTRIBUTE,
                        new BasicAttribute("pmKey", pieces[i]));
            }
            ctx.modifyAttributes("CN=" + sId + "," + sTemplateContainerDN, adds);
            return successPacket();
        } catch (Exception e) {
            if (debugFlag) {
                e.printStackTrace();
            }
            return failurePacket("Exception when adding keys to the template");
        }
    }

    private Packet isObjInOattrWithProp(String sSessId, String sObjName,
                                        String sProp) {
        String sOattrId = getEntityWithPropInternal(PM_NODE_OATTR, sProp);
        if (sOattrId == null) {
            return failurePacket("No object attribute with property \"" + sProp
                    + "\"!");
        }
        String sOaId = getEntityId(sObjName, PM_NODE_OATTR);
        if (sOaId == null) {
            return failurePacket("No object attribute or no object of name \""
                    + sObjName + "\"!");
        }

        Packet res = new Packet();
        try {
            if (attrIsAscendant(sOaId, sOattrId, PM_NODE_OATTR)) {
                res.addItem(ItemType.RESPONSE_TEXT, "yes");
            } else {
                res.addItem(ItemType.RESPONSE_TEXT, "no");
            }
        } catch (Exception e) {
            e.printStackTrace();
            return failurePacket("Exception when building the result packet in isObjInattrWithProp()!");
        }
        return res;
    }

    // Store the new startups for the user of the session.
    // Argument sSessId identifies the session. From it, we can find the user
    // id.
    // The startups start at item 4 in cmd. They are POS ids, so we need to
    // translate them to original ids before storing them.
    private Packet setStartups(String sSessId, Packet cmd) {
        // The startups (POS ids) start at item 2 (0 = cmd code, 1 = sess id).
        for (int i = 2; i < cmd.size(); i++) {
            String sLine = cmd.getStringValue(i);
            System.out.println("pos id=" + sLine);
        }

        // Get the user startups, if any.
        String sUserId = getSessionUserId(sSessId);

        Attributes attrs = null;
        try {
            attrs = ctx.getAttributes("CN=" + sUserId + ","
                    + sStartupContainerDN);
        } catch (NameNotFoundException e) {
            attrs = null;
            e.printStackTrace();
        } catch (Exception e) {
            e.printStackTrace();
            return failurePacket("Exception in setStartups!");
        }
        try {
            // If the startups exist, delete them.
            if (attrs != null) {
                ctx.destroySubcontext("CN=" + sUserId + ","
                        + sStartupContainerDN);
            }

            // Are there any startup points in the command?
            int n = cmd.size() - 2;
            if (n <= 0) {
                return successPacket();
            }

            // Create a new pmClassStartup instance for the current user.
            attrs = new BasicAttributes(true);
            attrs.put("objectClass", sStartupClass);
            attrs.put("pmId", sUserId);
            String sDn = "CN=" + sUserId + "," + sStartupContainerDN;
            ctx.bind(sDn, null, attrs);

            // Translate each startup from POS id to original id and add it to
            // the
            // instance.
            ModificationItem[] adds = new ModificationItem[n];
            for (int i = 0; i < n; i++) {
                String sPosId = cmd.getStringValue(i + 2);
                String sOrigId = getPosOrigId(sPosId);
                adds[i] = new ModificationItem(DirContext.ADD_ATTRIBUTE,
                        new BasicAttribute("pmStartup", sOrigId));
            }
            ctx.modifyAttributes("CN=" + sUserId + "," + sStartupContainerDN,
                    adds);
            return successPacket();
        } catch (Exception e) {
            if (debugFlag) {
                e.printStackTrace();
            }
            return failurePacket("Exception in setStartups: " + e.getMessage());
        }
    }

    private String getPosOrigId(String sPosId) {
        try {
            Attributes attrs = ctx.getAttributes("CN=" + sPosId + ","
                    + sVosNodeContainerDN);
            String sOrigId = (String) attrs.get("pmOriginalId").get();
            return sOrigId;
        } catch (Exception e) {
            e.printStackTrace();
            return null;
        }
    }

    private Packet getConnector() {
        Packet result = new Packet();
        try {
            result.addItem(ItemType.RESPONSE_TEXT, PM_NODE_CONN
                    + PM_FIELD_DELIM + PM_CONNECTOR_ID + PM_FIELD_DELIM
                    + PM_CONNECTOR_NAME);
        } catch (Exception e) {
            e.printStackTrace();
            return failurePacket("Exception when building the result packet in getConnector()");
        }
        return result;
    }

    // Find the containers of an entity. We'll call the entity "base node".
    // "Container" can be any node of the PM graph to which the base node is
    // assigned.
    // If the base node is the connector, there are no containers.
    // If the base node is a policy class, the only container is the connector.
    // If the base node is a user attribute, its containers can be other
    // user attributes, a policy class, the connector, or an operation set.
    // If the base node is a user, its containers can be user attributes or the
    // connector.
    // If the base node is an object attribute or associate to an object,
    // its containers can be other object attributes, a policy, or the
    // connector.
    // If the base node is an operation set, its containers can be an object
    // attribute ot the connector.
    // Parameters:
    // sBaseName, sBaseId, sBaseType: the label/name, id, and type of the base
    // node. One
    // but not both of the name and id may be null. The type must be non-null.
    // sGraphType: the type of graph we display.
    private Packet getContainersOf(String sBaseName, String sBaseId,
                                   String sBaseType, String sGraphType) {
        if (sBaseType == null) {
            return failurePacket("Null base node type in getContainersOf()");
        }
        if (sBaseName == null) {
            if (sBaseId == null) {
                return failurePacket("Null base node name and id in getContainersOf()");
            }
            sBaseName = getEntityName(sBaseId, sBaseType);
            if (sBaseName == null) {
                return failurePacket("No base node of type " + sBaseType
                        + " and id " + sBaseId);
            }
        } else if (sBaseId == null) {
            sBaseId = getEntityId(sBaseName, sBaseType);
            if (sBaseId == null) {
                return failurePacket("No base node of type " + sBaseType
                        + " and name " + sBaseName);
            }
        } else {
            String sBaseName2 = getEntityName(sBaseId, sBaseType);
            if (sBaseName2 == null) {
                return failurePacket("No base node of type " + sBaseType
                        + " and id " + sBaseId);
            }
            if (!sBaseName2.equalsIgnoreCase(sBaseName)) {
                return failurePacket("Inconsistency between base node name "
                        + sBaseName + " and id " + sBaseId);
            }
        }

        Packet result = new Packet();

        try {
            // POLICY.
            if (sBaseType.equalsIgnoreCase(PM_NODE_POL)) {
                Attributes attrs = ctx.getAttributes("CN=" + sBaseId + ","
                        + sPolicyContainerDN);

                // Add the connector.
                Attribute attr = attrs.get("pmToConnector");
                if (attr != null) {
                    for (NamingEnumeration<?> attrEnum = attr.getAll(); attrEnum.hasMore(); ) {
                        String sId = (String) attrEnum.next();
                        result.addItem(ItemType.RESPONSE_TEXT, PM_NODE_CONN
                                + PM_FIELD_DELIM + sId + PM_FIELD_DELIM
                                + getEntityName(sId, PM_NODE_CONN));
                    }
                }

                // USER ATTRIBUTE.
            } else if (sBaseType.equalsIgnoreCase(PM_NODE_UATTR)) {
                Attributes attrs = ctx.getAttributes("CN=" + sBaseId + ","
                        + sUserAttrContainerDN);

                // Add the user attributes.
                Attribute attr = attrs.get("pmToAttr");
                if (attr != null) {
                    for (NamingEnumeration<?> attrEnum = attr.getAll(); attrEnum.hasMore(); ) {
                        String sId = (String) attrEnum.next();
                        result.addItem(ItemType.RESPONSE_TEXT, PM_NODE_UATTR
                                + PM_FIELD_DELIM + sId + PM_FIELD_DELIM
                                + getEntityName(sId, PM_NODE_UATTR));
                    }
                }

                // Add the policies.
                attr = attrs.get("pmToPolicy");
                if (attr != null) {
                    for (NamingEnumeration<?> attrEnum = attr.getAll(); attrEnum.hasMore(); ) {
                        String sId = (String) attrEnum.next();
                        result.addItem(ItemType.RESPONSE_TEXT, PM_NODE_POL
                                + PM_FIELD_DELIM + sId + PM_FIELD_DELIM
                                + getEntityName(sId, PM_NODE_POL));
                    }
                }

                // Add the connector.
                attr = attrs.get("pmToConnector");
                if (attr != null) {
                    for (NamingEnumeration<?> attrEnum = attr.getAll(); attrEnum.hasMore(); ) {
                        String sId = (String) attrEnum.next();
                        result.addItem(ItemType.RESPONSE_TEXT, PM_NODE_CONN
                                + PM_FIELD_DELIM + sId + PM_FIELD_DELIM
                                + getEntityName(sId, PM_NODE_CONN));
                    }
                }

                // Add the operation sets if graph type is correct.
                if (sGraphType.equalsIgnoreCase(PM_GRAPH_CAPS)) {
                    attr = attrs.get("pmToOpSet");
                    if (attr != null) {
                        for (NamingEnumeration<?> attrEnum = attr.getAll(); attrEnum.hasMore(); ) {
                            String sId = (String) attrEnum.next();
                            result.addItem(
                                    ItemType.RESPONSE_TEXT,
                                    PM_NODE_OPSET + PM_FIELD_DELIM + sId
                                            + PM_FIELD_DELIM
                                            + getEntityName(sId, PM_NODE_OPSET));
                        }
                    }
                }

                // USER.
            } else if (sBaseType.equalsIgnoreCase(PM_NODE_USER)) {
                Attributes attrs = ctx.getAttributes("CN=" + sBaseId + ","
                        + sUserContainerDN);

                // Add the user attributes.
                Attribute attr = attrs.get("pmToAttr");
                if (attr != null) {
                    for (NamingEnumeration<?> attrEnum = attr.getAll(); attrEnum.hasMore(); ) {
                        String sId = (String) attrEnum.next();
                        result.addItem(ItemType.RESPONSE_TEXT, PM_NODE_UATTR
                                + PM_FIELD_DELIM + sId + PM_FIELD_DELIM
                                + getEntityName(sId, PM_NODE_UATTR));
                    }
                }

                // Add the connector.
                attr = attrs.get("pmToConnector");
                if (attr != null) {
                    for (NamingEnumeration<?> attrEnum = attr.getAll(); attrEnum.hasMore(); ) {
                        String sId = (String) attrEnum.next();
                        result.addItem(ItemType.RESPONSE_TEXT, PM_NODE_CONN
                                + PM_FIELD_DELIM + sId + PM_FIELD_DELIM
                                + getEntityName(sId, PM_NODE_CONN));
                    }
                }

                // OBJECT ATTRIBUTE OR ASSOCIATE.
            } else if (sBaseType.equalsIgnoreCase(PM_NODE_OATTR)
                    || sBaseType.equalsIgnoreCase(PM_NODE_ASSOC)) {
                Attributes attrs = ctx.getAttributes("CN=" + sBaseId + ","
                        + sObjAttrContainerDN);

                // Add the object attributes.
                Attribute attr = attrs.get("pmToAttr");
                if (attr != null) {
                    for (NamingEnumeration<?> attrEnum = attr.getAll(); attrEnum.hasMore(); ) {
                        String sId = (String) attrEnum.next();
                        result.addItem(ItemType.RESPONSE_TEXT, PM_NODE_OATTR
                                + PM_FIELD_DELIM + sId + PM_FIELD_DELIM
                                + getEntityName(sId, PM_NODE_OATTR));
                    }
                }

                // Add the connector.
                attr = attrs.get("pmToConnector");
                if (attr != null) {
                    for (NamingEnumeration<?> attrEnum = attr.getAll(); attrEnum.hasMore(); ) {
                        String sId = (String) attrEnum.next();
                        result.addItem(ItemType.RESPONSE_TEXT, PM_NODE_CONN
                                + PM_FIELD_DELIM + sId + PM_FIELD_DELIM
                                + getEntityName(sId, PM_NODE_CONN));
                    }
                }

                // Add the policy classes.
                attr = attrs.get("pmToPolicy");
                if (attr != null) {
                    for (NamingEnumeration<?> attrEnum = attr.getAll(); attrEnum.hasMore(); ) {
                        String sId = (String) attrEnum.next();
                        result.addItem(ItemType.RESPONSE_TEXT, PM_NODE_POL
                                + PM_FIELD_DELIM + sId + PM_FIELD_DELIM
                                + getEntityName(sId, PM_NODE_POL));
                    }
                }

                // OPERATION SET.
            } else if (sBaseType.equalsIgnoreCase(PM_NODE_OPSET)) {
                Attributes attrs = ctx.getAttributes("CN=" + sBaseId + ","
                        + sOpsetContainerDN);

                // Add the object attributes.
                Attribute attr = attrs.get("pmToAttr");
                if (attr != null) {
                    for (NamingEnumeration<?> attrEnum = attr.getAll(); attrEnum.hasMore(); ) {
                        String sId = (String) attrEnum.next();
                        result.addItem(ItemType.RESPONSE_TEXT, PM_NODE_OATTR
                                + PM_FIELD_DELIM + sId + PM_FIELD_DELIM
                                + getEntityName(sId, PM_NODE_OATTR));
                    }
                }

                // Add the connector.
                attr = attrs.get("pmToConnector");
                if (attr != null) {
                    for (NamingEnumeration<?> attrEnum = attr.getAll(); attrEnum.hasMore(); ) {
                        String sId = (String) attrEnum.next();
                        result.addItem(ItemType.RESPONSE_TEXT, PM_NODE_CONN
                                + PM_FIELD_DELIM + sId + PM_FIELD_DELIM
                                + getEntityName(sId, PM_NODE_CONN));
                    }
                }

            }
            return result;
        } catch (Exception e) {
            e.printStackTrace();
            return failurePacket("Exception in getContainersOf()!");
        }
    }

    // Get the members of a POS container. Membership is defined in terms of the
    // assignment relation. x is a member of y iff x ---> y.
    // After the POS graph is computed following a computeVos() command, the
    // client
    // does not know the POS id or original id of any POS node, except the
    // original id
    // of the connector node, which is 1. Consequently, right after a
    // computeVos()
    // command, the client has to send getPosMembersOf() with the sBaseId == 1.
    // We translate 1 (the original id of the connector) into the POS id of the
    // connector. Subsequent commands getPosMembersOf() will use the POS ids
    // received by the client in returns from previous getPosMembersOf().
    private Packet getPosMembersOf(String sSessId, String sBaseName,
                                   String sBaseId, String sBaseType, String sGraphType) {

        System.out.println("GetPosMembersOf(name=" + sBaseName + ", id="
                + sBaseId + ", type=" + sBaseType + ", graph=" + sGraphType);
        String sUserId = getSessionUserId(sSessId);
        String sUserName = getEntityName(sUserId, PM_NODE_USER);
        System.out.println("    called for user id=" + sUserId + " and name="
                + sUserName);

        boolean bConnector = false;

        // The objects are also object attributes:
        if (sBaseType.equalsIgnoreCase(PM_NODE_ASSOC)) {
            sBaseType = PM_NODE_OATTR;
        }

        // If the base node is the connector, replace its original id by its POS
        // id.
        if (sBaseId.equals(PM_CONNECTOR_ID)) {
            bConnector = true;
            if (sGraphType.equalsIgnoreCase(PM_VOS_PRES_USER)) {
                sBaseId = getVosNodeId(PM_CONNECTOR_ID, sSessId);
            } else {
                sBaseId = getAdminVosNodeId(PM_CONNECTOR_ID, sSessId);
            }
            if (sBaseId == null) {
                return failurePacket("Couldn't get the connector's new id");
            }
        }

        // Collect the members of the base node.
        Packet result = new Packet();

        try {
            Attribute attr = null;
            if (sGraphType.equalsIgnoreCase(PM_VOS_PRES_USER)) {
                if (bConnector) {
                    // We display the connector for the "user" type of graph.
                    attr = getPosStartups(sSessId);
                    if (attr == null) {
                        attr = getVosNodeAscs(sBaseId);
                    }
                } else {
                    attr = getVosNodeAscs(sBaseId);
                }
            } else {
                attr = getAdminVosNodeAscs(sBaseId);
            }
            if (attr != null) {
                for (NamingEnumeration<?> attrEnum = attr.getAll(); attrEnum.hasMore(); ) {
                    String sId = (String) attrEnum.next();
                    String sType = null;
                    String sName = null;
                    if (sGraphType.equalsIgnoreCase(PM_VOS_PRES_USER)) {
                        sType = getVosNodeType(sId);
                        sName = getVosNodeName(sId);
                    } else {
                        sType = getAdminVosNodeType(sId);
                        sName = getAdminVosNodeName(sId);
                    }
                    if (sType == null || sName == null) {
                        return failurePacket("Inconsistency in POS: null type or name for POS node "
                                + sId);
                    }
                    result.addItem(ItemType.RESPONSE_TEXT, sType
                            + PM_FIELD_DELIM + sId + PM_FIELD_DELIM + sName);
                }
            }
            return result;
        } catch (Exception e) {
            e.printStackTrace();
            return failurePacket("Exception in getPosMembersOf() for "
                    + sBaseId);
        }
    }

    // Get the containers of a POS node. Containment is defined in terms of the
    // assignment relation. x contains y iff y ---> x.
    // After the POS graph is computed following a computeVos() command, the
    // client
    // does not know the POS id or original id of any POS node, except the
    // original id
    // of the connector node, which is 1. Consequently, rigt after a
    // computeVos()
    // command, the client has to send getPosMembersOf() with the sBaseId == 1.
    // We translate 1 (the original id of the connector) into the POS id of the
    // connector. Subsequent commands getPosMembersOf() will use the POS ids
    // received by the client in returns from previous getPosMembersOf().
    private Packet getPosContainersOf(String sSessId, String sBaseName,
                                      String sBaseId, String sBaseType, String sGraphType) {
        // The objects are object attributes:
        if (sBaseType.equalsIgnoreCase(PM_NODE_ASSOC)) {
            sBaseType = PM_NODE_OATTR;
        }

        // If the base node is the connector, replace its original id by its POS
        // id.
        if (sBaseId.equals(PM_CONNECTOR_ID)) {
            if (sGraphType.equalsIgnoreCase(PM_VOS_PRES_USER)) {
                sBaseId = getVosNodeId(PM_CONNECTOR_ID, sSessId);
            } else {
                sBaseId = getAdminVosNodeId(PM_CONNECTOR_ID, sSessId);
            }
            if (sBaseId == null) {
                return failurePacket("Couldn't get the connector's new id");
            }
        }

        // Collect the containers of the base node.
        Packet result = new Packet();

        try {
            Attribute attr = null;
            if (sGraphType.equalsIgnoreCase(PM_VOS_PRES_USER)) {
                attr = getVosNodeDescs(sBaseId);
            } else {
                attr = getAdminVosNodeDescs(sBaseId);
            }
            if (attr != null) {
                for (NamingEnumeration<?> attrEnum = attr.getAll(); attrEnum.hasMore(); ) {
                    String sId = (String) attrEnum.next();
                    String sType = null;
                    String sName = null;
                    if (sGraphType.equalsIgnoreCase(PM_VOS_PRES_USER)) {
                        sType = getVosNodeType(sId);
                        sName = getVosNodeName(sId);
                    } else {
                        sType = getAdminVosNodeType(sId);
                        sName = getAdminVosNodeName(sId);
                    }
                    if (sType == null || sName == null) {
                        return failurePacket("Inconsistency in POS: null type or name for POS node "
                                + sId);
                    }
                    result.addItem(ItemType.RESPONSE_TEXT, sType
                            + PM_FIELD_DELIM + sId + PM_FIELD_DELIM + sName);
                }
            }
            return result;
        } catch (Exception e) {
            e.printStackTrace();
            return failurePacket("Exception in getPosContainersOf() for "
                    + sBaseId);
        }
    }

    // Find the members of a container. "Container" can be any node of the PM
    // graph, and we'll also call it "base" node. The membership is defined
    // by the direct
    // assignment relation of another entity to the base node.
    // According to this def, an operation set can be considered a container
    // for the user attributes that are assigned to it.
    // The container is given as a "base" node of the PM graph.
    // If the base node is the connector, the nodes assigned to it can be users,
    // user attributes, policies, object attributes, object attributes
    // associated
    // to objects, and operation sets.
    // If the base node is a policy class, the nodes assigned to it can be user
    // attributes, object attributes, object attributes associated to objects.
    // If the base node is a user attribute, the nodes assigned to it can be
    // users,
    // user attributes.
    // If the base node is a user, there are no nodes assigned to it.
    // If the base node is an object attribute, the nodes assigned to it can be
    // object attributes, object attributes associated to objects, operation
    // sets.
    // If the base node is an object attribute associated to an object, the
    // nodes
    // assigned to it are operation sets.
    // If the base node is an operation set, the nodes assigned to it can be
    // user attributes.
    // Parameters:
    // sBaseName, sBaseId, sBaseType: the label/name, id, and type of the base
    // node. One
    // but not both of the name and id may be null. The type must be non-null.
    // sGraphType: the type of graph we display.
    private Packet getMembersOf(String sBaseName, String sBaseId,
                                String sBaseType, String sGraphType) {
        if (sBaseType == null) {
            return failurePacket("Null (unknown) base node type in getMembersOf()");
        }
        if (sBaseName == null) {
            if (sBaseId == null) {
                return failurePacket("Name and id of the base node are both null in getMembersOf()");
            }
            sBaseName = getEntityName(sBaseId, sBaseType);
            if (sBaseName == null) {
                return failurePacket("No base node of type " + sBaseType
                        + " and id " + sBaseId);
            }
        } else if (sBaseId == null) {
            sBaseId = getEntityId(sBaseName, sBaseType);
            if (sBaseId == null) {
                return failurePacket("No base node of type " + sBaseType
                        + " and name " + sBaseName);
            }
        } else {
            String sBaseName2 = getEntityName(sBaseId, sBaseType);
            if (sBaseName2 == null) {
                return failurePacket("No base node of type " + sBaseType
                        + " and id " + sBaseId);
            }
            if (!sBaseName2.equalsIgnoreCase(sBaseName)) {
                return failurePacket("Inconsistency between base node name "
                        + sBaseName + " and id " + sBaseId);
            }
        }

        Packet result = new Packet();

        try {
            // For the CONNECTOR.
            if (sBaseType.equalsIgnoreCase(PM_NODE_CONN)) {
                Attributes attrs = ctx.getAttributes("CN=" + sBaseId + ","
                        + sConnectorContainerDN);

                // Add the users and user attributes if correct graph type.
                if (sGraphType.equalsIgnoreCase(PM_GRAPH_CAPS)
                        || sGraphType.equalsIgnoreCase(PM_GRAPH_UATTR)) {
                    Attribute attr = attrs.get("pmFromUser");
                    if (attr != null) {
                        for (NamingEnumeration<?> attrEnum = attr.getAll(); attrEnum.hasMore(); ) {
                            String sId = (String) attrEnum.next();
                            result.addItem(ItemType.RESPONSE_TEXT, PM_NODE_USER
                                    + PM_FIELD_DELIM + sId + PM_FIELD_DELIM
                                    + getEntityName(sId, PM_NODE_USER));
                        }
                    }

                    attr = attrs.get("pmFromUserAttr");
                    if (attr != null) {
                        for (NamingEnumeration<?> attrEnum = attr.getAll(); attrEnum.hasMore(); ) {
                            String sId = (String) attrEnum.next();
                            result.addItem(
                                    ItemType.RESPONSE_TEXT,
                                    PM_NODE_UATTR + PM_FIELD_DELIM + sId
                                            + PM_FIELD_DELIM
                                            + getEntityName(sId, PM_NODE_UATTR));
                        }
                    }
                }

                // Always add the policies.
                Attribute attr = attrs.get("pmFromPolicyClass");
                if (attr != null) {
                    for (NamingEnumeration<?> attrEnum = attr.getAll(); attrEnum.hasMore(); ) {
                        String sId = (String) attrEnum.next();
                        result.addItem(ItemType.RESPONSE_TEXT, PM_NODE_POL
                                + PM_FIELD_DELIM + sId + PM_FIELD_DELIM
                                + getEntityName(sId, PM_NODE_POL));
                    }
                }

                // Add the object attributes and associates if correct graph
                // type.
                if (sGraphType.equalsIgnoreCase(PM_GRAPH_ACES)
                        || sGraphType.equalsIgnoreCase(PM_GRAPH_OATTR)) {
                    attr = attrs.get("pmFromObjAttr");
                    if (attr != null) {
                        for (NamingEnumeration<?> attrEnum = attr.getAll(); attrEnum.hasMore(); ) {
                            String sId = (String) attrEnum.next();
                            if (hasAssocObj(sId)) {
                                result.addItem(
                                        ItemType.RESPONSE_TEXT,
                                        PM_NODE_ASSOC
                                                + PM_FIELD_DELIM
                                                + sId
                                                + PM_FIELD_DELIM
                                                + getEntityName(sId,
                                                PM_NODE_OATTR));
                            } else {
                                result.addItem(
                                        ItemType.RESPONSE_TEXT,
                                        PM_NODE_OATTR
                                                + PM_FIELD_DELIM
                                                + sId
                                                + PM_FIELD_DELIM
                                                + getEntityName(sId,
                                                PM_NODE_OATTR));
                            }
                        }
                    }
                }

                // Always add the operation sets.
                attr = attrs.get("pmFromOpSet");
                if (attr != null) {
                    for (NamingEnumeration<?> attrEnum = attr.getAll(); attrEnum.hasMore(); ) {
                        String sId = (String) attrEnum.next();
                        result.addItem(ItemType.RESPONSE_TEXT, PM_NODE_OPSET
                                + PM_FIELD_DELIM + sId + PM_FIELD_DELIM
                                + getEntityName(sId, PM_NODE_OPSET));
                    }
                }

                // POLICY
            } else if (sBaseType.equalsIgnoreCase(PM_NODE_POL)) {
                Attributes attrs = ctx.getAttributes("CN=" + sBaseId + ","
                        + sPolicyContainerDN);

                // Add the user attributes if correct graph type.
                if (sGraphType.equalsIgnoreCase(PM_GRAPH_CAPS)
                        || sGraphType.equalsIgnoreCase(PM_GRAPH_UATTR)) {
                    Attribute attr = attrs.get("pmFromUserAttr");
                    if (attr != null) {
                        for (NamingEnumeration<?> attrEnum = attr.getAll(); attrEnum.hasMore(); ) {
                            String sId = (String) attrEnum.next();
                            result.addItem(
                                    ItemType.RESPONSE_TEXT,
                                    PM_NODE_UATTR + PM_FIELD_DELIM + sId
                                            + PM_FIELD_DELIM
                                            + getEntityName(sId, PM_NODE_UATTR));
                        }
                    }
                }

                // Add the object attributes and associates if correct graph
                // type.
                if (sGraphType.equalsIgnoreCase(PM_GRAPH_ACES)
                        || sGraphType.equalsIgnoreCase(PM_GRAPH_OATTR)) {
                    Attribute attr = attrs.get("pmFromObjAttr");
                    if (attr != null) {
                        for (NamingEnumeration<?> attrEnum = attr.getAll(); attrEnum.hasMore(); ) {
                            String sId = (String) attrEnum.next();
                            if (hasAssocObj(sId)) {
                                result.addItem(
                                        ItemType.RESPONSE_TEXT,
                                        PM_NODE_ASSOC
                                                + PM_FIELD_DELIM
                                                + sId
                                                + PM_FIELD_DELIM
                                                + getEntityName(sId,
                                                PM_NODE_OATTR));
                            } else {
                                result.addItem(
                                        ItemType.RESPONSE_TEXT,
                                        PM_NODE_OATTR
                                                + PM_FIELD_DELIM
                                                + sId
                                                + PM_FIELD_DELIM
                                                + getEntityName(sId,
                                                PM_NODE_OATTR));
                            }
                        }
                    }
                }

                // USER ATTRIBUTE
            } else if (sBaseType.equalsIgnoreCase(PM_NODE_UATTR)) {
                Attributes attrs = ctx.getAttributes("CN=" + sBaseId + ","
                        + sUserAttrContainerDN);

                // Add the user attributes.
                Attribute attr = attrs.get("pmFromAttr");
                if (attr != null) {
                    for (NamingEnumeration<?> attrEnum = attr.getAll(); attrEnum.hasMore(); ) {
                        String sId = (String) attrEnum.next();
                        result.addItem(ItemType.RESPONSE_TEXT, PM_NODE_UATTR
                                + PM_FIELD_DELIM + sId + PM_FIELD_DELIM
                                + getEntityName(sId, PM_NODE_UATTR));
                    }
                }

                // Add the users.
                attr = attrs.get("pmFromUser");
                if (attr != null) {
                    for (NamingEnumeration<?> attrEnum = attr.getAll(); attrEnum.hasMore(); ) {
                        String sId = (String) attrEnum.next();
                        result.addItem(ItemType.RESPONSE_TEXT, PM_NODE_USER
                                + PM_FIELD_DELIM + sId + PM_FIELD_DELIM
                                + getEntityName(sId, PM_NODE_USER));
                    }
                }

                // OBJECT ATTRIBUTE
            } else if (sBaseType.equalsIgnoreCase(PM_NODE_OATTR)) {
                Attributes attrs = ctx.getAttributes("CN=" + sBaseId + ","
                        + sObjAttrContainerDN);

                // Add the object attributes and associates.
                Attribute attr = attrs.get("pmFromAttr");
                if (attr != null) {
                    for (NamingEnumeration<?> attrEnum = attr.getAll(); attrEnum.hasMore(); ) {
                        String sId = (String) attrEnum.next();
                        if (hasAssocObj(sId)) {
                            result.addItem(
                                    ItemType.RESPONSE_TEXT,
                                    PM_NODE_ASSOC + PM_FIELD_DELIM + sId
                                            + PM_FIELD_DELIM
                                            + getEntityName(sId, PM_NODE_OATTR));
                        } else {
                            result.addItem(
                                    ItemType.RESPONSE_TEXT,
                                    PM_NODE_OATTR + PM_FIELD_DELIM + sId
                                            + PM_FIELD_DELIM
                                            + getEntityName(sId, PM_NODE_OATTR));
                        }
                    }
                }

                // Add the operation sets if correct graph type.
                if (sGraphType.equalsIgnoreCase(PM_GRAPH_ACES)) {
                    attr = attrs.get("pmFromOpSet");
                    if (attr != null) {
                        for (NamingEnumeration<?> attrEnum = attr.getAll(); attrEnum.hasMore(); ) {
                            String sId = (String) attrEnum.next();
                            result.addItem(
                                    ItemType.RESPONSE_TEXT,
                                    PM_NODE_OPSET + PM_FIELD_DELIM + sId
                                            + PM_FIELD_DELIM
                                            + getEntityName(sId, PM_NODE_OPSET));
                        }
                    }
                }

                // OBJECT ATTRIBUTE ASSOCIATED TO AN OBJECT
            } else if (sBaseType.equalsIgnoreCase(PM_NODE_ASSOC)) {
                Attributes attrs = ctx.getAttributes("CN=" + sBaseId + ","
                        + sObjAttrContainerDN);

                // Add the operation sets if correct graph type.
                if (sGraphType.equalsIgnoreCase(PM_GRAPH_ACES)) {
                    Attribute attr = attrs.get("pmFromOpSet");
                    if (attr != null) {
                        for (NamingEnumeration<?> attrEnum = attr.getAll(); attrEnum.hasMore(); ) {
                            String sId = (String) attrEnum.next();
                            result.addItem(
                                    ItemType.RESPONSE_TEXT,
                                    PM_NODE_OPSET + PM_FIELD_DELIM + sId
                                            + PM_FIELD_DELIM
                                            + getEntityName(sId, PM_NODE_OPSET));
                        }
                    }
                }

                // OPERATION SET.
            } else if (sBaseType.equalsIgnoreCase(PM_NODE_OPSET)) {
                Attributes attrs = ctx.getAttributes("CN=" + sBaseId + ","
                        + sOpsetContainerDN);

                // Add the user attributes.
                Attribute attr = attrs.get("pmFromAttr");
                if (attr != null) {
                    for (NamingEnumeration<?> attrEnum = attr.getAll(); attrEnum.hasMore(); ) {
                        String sId = (String) attrEnum.next();
                        result.addItem(ItemType.RESPONSE_TEXT, PM_NODE_UATTR
                                + PM_FIELD_DELIM + sId + PM_FIELD_DELIM
                                + getEntityName(sId, PM_NODE_UATTR));
                    }
                }
            }
            return result;
        } catch (Exception e) {
            e.printStackTrace();
            return failurePacket("Exception in getMembersOf()");
        }
    }

    private Packet decreaseDisplayedAscs(String sSessId) {
        if (nMaxDspAscs <= PM_MAX_DISPLAYED_ASCS) {
            return successPacket();
        }
        nMaxDspAscs--;
        return successPacket();
    }

    private Packet increaseDisplayedAscs(String sSessId) {
        nMaxDspAscs++;
        return successPacket();
    }

    // Create a PM object container for a given folder within a given container.
    private Packet createContForFolder(String sSessId, String sFolderPath,
                                       String sBaseContName) {
        System.out.println("Entering createContForFolder");
        System.out.println("    sFolderPath = " + sFolderPath);
        System.out.println("    sContName = " + sBaseContName);

        // First get the folder's name.
        File f = new File(sFolderPath);
        String sFolderName = f.getName();
        System.out.println("    sFolderName = " + sFolderName);

        // Now get a name for the container. We can use the same
        // getUniqueObjName.
        String sContName = getUniqueObjName(sFolderName);
        System.out.println("    sContName = " + sContName);

        // We need the id of the base container.
        String sBaseContId = getEntityId(sBaseContName, PM_NODE_OATTR);
        if (sBaseContId == null) {
            return failurePacket("No container " + sBaseContName);
        }

        // Now create the new container.
        Packet result =  addOattrInternal(sContName, null, sContName,
                sContName, sBaseContId, PM_NODE_OATTR, null, null);

        return result;
    }

    // Create a PM (logical) object for a given file within a given container.
    private Packet createObjForFile(String sSessId, String sFilePath,
                                    String sContName) {
        System.out.println("Entering createObjForFile");
        System.out.println("    sFilePath = " + sFilePath);
        System.out.println("    sContName = " + sContName);

        // First get the file's name.
        File f = new File(sFilePath);
        String sFileName = f.getName();
        System.out.println("    sFileName = " + sFileName);

        // Now get a name for the object.
        String sObjName = getUniqueObjName(sFileName);
        System.out.println("    sObjName = " + sObjName);

        // Get the file host.
        String sHostName = getSessionHostName(sSessId);

        String sContId = getEntityId(sContName, PM_NODE_OATTR);
        if (sContId == null) {
            return failurePacket("No container " + sContName);
        }

        // Now create the object.
        Packet result =  addObjectInternal(sObjName, null, null,
                sObjName, sObjName, sContId, PM_NODE_OATTR, PM_CLASS_FILE_NAME,
                null, sHostName, sFilePath, null, null, false, null, null,
                null, null, null, null, null);

        return result;
    }

    // Given a proper file name (not the entire path), this function returns
    // a suitable object name.
    // Strating with the file name (excluding the file type), check
    // to see whether an object attribute with that name exists.
    // If yes, try that name with a '1' appended, then a '2', etc.,
    // until the object attribute with that name does not exist.
    private String getUniqueObjName(String sFileName) {
        System.out.println("Entering getUniqueObjName with argument "
                + sFileName);
        int ix = sFileName.lastIndexOf(".");
        String sBaseName = null;
        String sFileType = null;
        if (ix >= 0) {
            sBaseName = sFileName.substring(0, ix);
            sFileType = sFileName.substring(ix);
        } else {
            sBaseName = sFileName;
            sFileType = "";
        }

        System.out.println("    Found ix = " + ix + ", sBaseName = "
                + sBaseName + ", sFileType = " + sFileType);

        String sObjName = sBaseName;
        int n = 0;
        System.out.println("    Entering the loop of getUniqueObjName");
        while (true) {
            System.out.println("    Trying the name " + sObjName);
            if (getEntityId(sObjName, PM_NODE_OATTR) == null) {
                return sObjName;
            }
            n++;
            sObjName = sObjName + n;
        }
    }

    // sFileProp is the name of a property. This method first finds the value
    // of that property, which is used as the absolute path of the file.
    private Packet getFileContent(String sSessId, String sFileProp,
                                  InputStream bisFromClient, OutputStream bosToClient) {
        // First get the file location on the server.
        String sPath = getFilePath(sSessId, sFileProp);
        if (sPath == null) {
            return failurePacket("No file with property: " + sFileProp + "!");
        }

        File f = new File(sPath);
        if (!f.exists() || !f.isFile() || !f.canRead()) {
            return failurePacket("Something wrong with file " + sPath + "!");
        }
        try {
            FileInputStream fis = new FileInputStream(f);
            BufferedInputStream bis = new BufferedInputStream(fis);
            PacketManager.sendPacket(bis, (int) f.length(), bosToClient);
        } catch (Exception e) {
            e.printStackTrace();
            return failurePacket("Exception when creating streams for the requested file!");
        }
        return dnrPacket();
    }

    // sProp is a property name. The corresponding property value
    // is the file absolute path on the engine host.
    private String getFilePath(String sSessId, String sProp) {
        Packet res =  getPropertyValue(sSessId, sProp);
        if (res.hasError()) {
            return null;
        }
        return res.getStringValue(0);
    }

    private Packet getOutboxMessages(String sSessId) {
        return getMailboxMessages(sSessId, "outboxof=");
    }

    private Packet getInboxMessages(String sSessId) {
        return getMailboxMessages(sSessId, "inboxof=");
    }

    private Packet getMailboxMessages(String sSessId, String sPropPrefix) {
        String sUserId = getSessionUserId(sSessId);
        if (sUserId == null) {
            return failurePacket("Couldn't find the session or the user id!");
        }
        String sUserName = getEntityName(sUserId, PM_NODE_USER);
        if (sUserName == null) {
            return failurePacket("Couldn't find the session user!");
        }
        String sProp = sPropPrefix + sUserName;
        String sMailboxId = getEntityWithPropInternal(PM_NODE_OATTR, sProp);
        if (sMailboxId == null) {
            return failurePacket("No object attribute with property \"" + sProp
                    + "\"!");
        }

        // We found the session's user's mailbox. Get all objects that are
        // messages,
        // i.e., have pmEmlRecip.
        Packet result = new Packet();
        try {
            Attributes mailboxAttrs = ctx.getAttributes("CN=" + sMailboxId
                    + "," + sObjAttrContainerDN);
            Attribute mailboxAttr = mailboxAttrs.get("pmFromAttr");
            if (mailboxAttr != null) {
                for (NamingEnumeration<?> attrEnum = mailboxAttr.getAll(); attrEnum.hasMore(); ) {
                    String sOattrId = (String) attrEnum.next();
                    String sObjId = getAssocObj(sOattrId);

                    // Note that the INBOX could contain oattrs, for example
                    // wINBOX,
                    // which do not have associated objects. Skip them.
                    if (sObjId == null) {
                        continue;
                    }

                    Attributes objAttrs = ctx.getAttributes("CN=" + sObjId
                            + "," + sVirtualObjContainerDN);
                    Attribute attr = objAttrs.get("pmEmlRecip");
                    if (attr == null) {
                        continue;
                    }
                    String sRecip = (String) attr.get();
                    // For the messages in the inbox, the recipient is the user.
                    // For the messages in the outbox, the recipient may be
                    // another user.
                    String sSender = (String) objAttrs.get("pmEmlSender").get();
                    String sDate = (String) objAttrs.get("pmTimestamp").get();
                    String sSubject = (String) objAttrs.get("pmEmlSubject").get();
                    String sLabel = getEntityName(sObjId, PM_OBJ);
                    attr = objAttrs.get("pmEmlAttached");
                    if (attr == null) {
                        result.addItem(ItemType.RESPONSE_TEXT, sLabel
                                + PM_ALT_FIELD_DELIM + PM_ALT_FIELD_DELIM
                                + sSender + PM_ALT_FIELD_DELIM + sRecip
                                + PM_ALT_FIELD_DELIM + sDate
                                + PM_ALT_FIELD_DELIM + sSubject);
                    } else {
                        result.addItem(ItemType.RESPONSE_TEXT, sLabel
                                + PM_ALT_FIELD_DELIM + attr.get()
                                + PM_ALT_FIELD_DELIM + sSender
                                + PM_ALT_FIELD_DELIM + sRecip
                                + PM_ALT_FIELD_DELIM + sDate
                                + PM_ALT_FIELD_DELIM + sSubject);
                    }
                }
            }
            return result;
        } catch (Exception e) {
            e.printStackTrace();
            return failurePacket("Exception in getMailboxMessages: "
                    + e.getMessage());
        }
    }

    private Packet deassignObjFromOattrWithProp(String sSessId, String sProcId,
                                                String sObjName, String sProp) {
        String sOattrId = getEntityWithPropInternal(PM_NODE_OATTR, sProp);
        if (sOattrId == null) {
            return failurePacket("No object attribute with property \"" + sProp
                    + "\"!");
        }
        String sOaId = getEntityId(sObjName, PM_NODE_OATTR);
        if (sOaId == null) {
            return failurePacket("No object attribute or no object of name \""
                    + sObjName + "\"!");
        }
        return deleteAssignment(sSessId, sProcId, sOaId, PM_NODE_OATTR,
                sOattrId, PM_NODE_OATTR, "no");
    }

    private Packet assignObjToOattrWithProp(String sSessId, String sProcId,
                                            String sObjName, String sProp) {
        String sOattrId = getEntityWithPropInternal(PM_NODE_OATTR, sProp);
        if (sOattrId == null) {
            return failurePacket("No object attribute with property \"" + sProp
                    + "\"!");
        }
        String sOaId = getEntityId(sObjName, PM_NODE_OATTR);
        if (sOaId == null) {
            return failurePacket("No object attribute or no object of name \""
                    + sObjName + "\"!");
        }
        return assign(sSessId, sProcId, sOaId, PM_NODE_OATTR, sOattrId,
                PM_NODE_OATTR, "no");
    }

    private Packet assignObjToOattr(String sSessId, String sProcId,
                                    String sObjName, String sOattrName) {
        String sOattrId = getEntityId(sOattrName, PM_NODE_OATTR);
        if (sOattrId == null) {
            return failurePacket("No object attribute with the name \""
                    + sOattrName + "\"!");
        }
        String sOaId = getEntityId(sObjName, PM_NODE_OATTR);
        if (sOaId == null) {
            return failurePacket("No object attribute or no object of name \""
                    + sObjName + "\"!");
        }
        return assign(sSessId, sProcId, sOaId, PM_NODE_OATTR, sOattrId,
                PM_NODE_OATTR, "no");
    }

    // An object can be opened multiple times in a session before being closed.
    // pmOpenObj stores the name of the object and a count:
    // <obj name>|<link count>.
    private Packet addOpenObj(String sSessId, String sObjName) {
        try {
            Attributes ooattrs = ctx.getAttributes("CN=" + sSessId + ","
                    + sSessionContainerDN);
            Attribute ooattr = ooattrs.get("pmOpenObj");
            if (ooattr == null) {
                // There are no open objects in this session. Add the open
                // object with a count of 1.
                ModificationItem[] mods = new ModificationItem[1];
                mods[0] = new ModificationItem(DirContext.ADD_ATTRIBUTE,
                        new BasicAttribute("pmOpenObj", sObjName
                                + PM_ALT_FIELD_DELIM + 1));
                ctx.modifyAttributes("CN=" + sSessId + ","
                        + sSessionContainerDN, mods);
                return successPacket();
            } else {
                // There are some open objects. Find the specified one.
                for (NamingEnumeration<?> enumer = ooattr.getAll(); enumer.hasMore(); ) {
                    String sOO = (String) enumer.next();
                    String[] pieces = sOO.split(PM_ALT_DELIM_PATTERN);
                    if (sObjName.equalsIgnoreCase(pieces[0])) {
                        // Object found. Increase its count.
                        int count = Integer.valueOf(pieces[1]).intValue() + 1;
                        String sNewOO = sObjName + PM_ALT_FIELD_DELIM + count;
                        ModificationItem[] mods = new ModificationItem[1];
                        mods[0] = new ModificationItem(
                                DirContext.REMOVE_ATTRIBUTE,
                                new BasicAttribute("pmOpenObj", sOO));
                        ctx.modifyAttributes("CN=" + sSessId + ","
                                + sSessionContainerDN, mods);
                        mods[0] = new ModificationItem(
                                DirContext.ADD_ATTRIBUTE, new BasicAttribute(
                                "pmOpenObj", sNewOO));
                        ctx.modifyAttributes("CN=" + sSessId + ","
                                + sSessionContainerDN, mods);
                        return successPacket();
                    }
                }
                // Object not found. Add it with a count of 1.
                ModificationItem[] mods = new ModificationItem[1];
                mods[0] = new ModificationItem(DirContext.ADD_ATTRIBUTE,
                        new BasicAttribute("pmOpenObj", sObjName
                                + PM_ALT_FIELD_DELIM + 1));
                ctx.modifyAttributes("CN=" + sSessId + ","
                        + sSessionContainerDN, mods);
                return successPacket();
            }
        } catch (Exception e) {
            e.printStackTrace();
            return failurePacket("Exception while adding open object: "
                    + e.getMessage());
        }
    }

    private Packet deleteOpenObj(String sSessId, String sObjName) {
        try {
            Attributes ooattrs = ctx.getAttributes("CN=" + sSessId + ","
                    + sSessionContainerDN);
            Attribute ooattr = ooattrs.get("pmOpenObj");
            if (ooattr == null) {
                // There are no open objects in this session. Signal error.
                return failurePacket("There are no open objects in this session!");
            }

            // There are some open objects. Find the specified one.
            for (NamingEnumeration<?> enumer = ooattr.getAll(); enumer.hasMore(); ) {
                String sOO = (String) enumer.next();
                String[] pieces = sOO.split(PM_ALT_DELIM_PATTERN);
                if (sObjName.equalsIgnoreCase(pieces[0])) {
                    // Object found. Decrease its count.
                    int count = Integer.valueOf(pieces[1]).intValue() - 1;
                    if (count <= 0) {
                        // Delete object completely.
                        ModificationItem[] mods = new ModificationItem[1];
                        mods[0] = new ModificationItem(
                                DirContext.REMOVE_ATTRIBUTE,
                                new BasicAttribute("pmOpenObj", sOO));
                        ctx.modifyAttributes("CN=" + sSessId + ","
                                + sSessionContainerDN, mods);
                        return successPacket();
                    }
                    // Count still positive. Replace the attribute.
                    String sNewOO = sObjName + PM_ALT_FIELD_DELIM + count;
                    ModificationItem[] mods = new ModificationItem[1];
                    mods[0] = new ModificationItem(DirContext.REMOVE_ATTRIBUTE,
                            new BasicAttribute("pmOpenObj", sOO));
                    ctx.modifyAttributes("CN=" + sSessId + ","
                            + sSessionContainerDN, mods);
                    mods[0] = new ModificationItem(DirContext.ADD_ATTRIBUTE,
                            new BasicAttribute("pmOpenObj", sNewOO));
                    ctx.modifyAttributes("CN=" + sSessId + ","
                            + sSessionContainerDN, mods);
                    return successPacket();
                }
            }
            // Object not found. Signal error.
            return failurePacket("There is no such object open in this session!");
        } catch (Exception e) {
            e.printStackTrace();
            return failurePacket("Exception while deleting open object "
                    + sObjName);
        }
    }

    // Check the conditions:
    // sReceiver must be a user with an inbox container or
    // a user attribute.
    // If sReceiver is a user with an inbox container, the method returns that
    // user.
    // If sReceiver is a user attribute, the method returns all users members
    // of that attribute, which have an inbox container.
    private Packet getEmailRecipients(String sSessId, String sReceiver) {
        String sUserId = null;
        String sUattrId = null;
        String sInboxId = null;
        Packet result = new Packet();

        // Is this a user?
        sUserId = getEntityId(sReceiver, PM_NODE_USER);
        if (sUserId != null) {
            // Does the user have an inbox container?
            sInboxId = getEntityWithPropInternal(PM_NODE_OATTR, "inboxof="
                    + sReceiver);
            if (sInboxId == null) {
                return failurePacket("User " + sReceiver + " has no INBOX!");
            }
            try {
                result.addItem(ItemType.RESPONSE_TEXT, sReceiver);
            } catch (Exception e) {
                e.printStackTrace();
                return failurePacket("Exception when building the result packet");
            }
            return result;
        }

        // Not a user. Is this a user attribute?
        sUattrId = getEntityId(sReceiver, PM_NODE_UATTR);
        if (sUattrId == null) {
            return failurePacket(sReceiver
                    + " is not a user or user attribute!");
        }

        // A user attribute. Get all its users and keep only those with an
        // INBOX.
        HashSet<String> users = new HashSet<String>();
        getMemberUsers(sUattrId, users);
        Iterator<String> iter = users.iterator();
        try {
            while (iter.hasNext()) {
                sUserId = iter.next();
                String sUserName = getEntityName(sUserId, PM_NODE_USER);
                // Should not happen:
                if (sUserName == null) {
                    continue;
                }
                sInboxId = getEntityWithPropInternal(PM_NODE_OATTR, "inboxof="
                        + sUserName);
                if (sInboxId != null) {
                    result.addItem(ItemType.RESPONSE_TEXT, sUserName);
                }
            }
        } catch (Exception e) {
            e.printStackTrace();
            return failurePacket("Exception when building the result packet");
        }
        return result;
    }

    /*
     * // If the object contains the message, then the object should already be
     * // in the sender's OUTBOX. If the object is an attachment, it should not
     * // be in the sender's OUTBOX. This function simply inserts the object //
     * in the receiver's INBOX, if not already there. private Packet
     * sendObject(String sSessId, String sObjName, String sReceiver) { // Find
     * the id of the associated oattr. String sOattrId = getIdOfEntityWithNameAndType(sObjName,
     * PM_NODE_OATTR); if (sOattrId == null) return
     * failurePacket("No object or associated attribute " + sObjName +
     * " exists!");
     *
     * // Find the receiver's INBOX container. String sInboxId =
     * getEntityWithPropInternal(PM_NODE_OATTR, "inboxof=" + sReceiver); if
     * (sInboxId == null) return
     * failurePacket("Receiver has no INBOX container!");
     *
     * // Insert the object in the receiver's INBOX, if not already there. if
     * (!attrIsAssignedToAttr(sOattrId, sInboxId, PM_NODE_OATTR)) { Packet res =
     * addDoubleLink(sOattrId, PM_NODE_OATTR, sInboxId, PM_NODE_OATTR);
     * if (res.hasError()) return res; } return successPacket(); }
     */
    // Generate an event.
    private Packet sendObject(String sSessId, String sObjName, String sReceiver) {
        String sObjId = getEntityId(sObjName, PM_OBJ);
        return  processEvent(sSessId, null, PM_EVENT_OBJECT_SEND,
                sObjName, sObjId, null, null, sReceiver, null);
    }

    // The message is already in an object with the name sMsgName, probably
    // located
    // in the OUTBOX container of the sender. Just include the message in the
    // receiver's INBOX container.
    private Packet sendSimpleMsg(String sSessId, String sMsgName,
                                 String sReceiver) {
        // Find the msg id (as an object attribute).
        String sMsgId = getEntityId(sMsgName, PM_NODE_OATTR);
        if (sMsgId == null) {
            return failurePacket("No message " + sMsgName + " exists!");
        }

        // Find the sender and the sender's OUTBOX container.
        String sSenderId = getSessionUserId(sSessId);
        if (sSenderId == null) {
            return failurePacket("Couldn't find sender!");
        }
        String sSender = getEntityName(sSenderId, PM_NODE_USER);
        if (sSender == null) {
            return failurePacket("Couldn't find sender!");
        }

        String sOutboxId = getEntityWithPropInternal(PM_NODE_OATTR, "outboxof="
                + sSender);
        if (sOutboxId == null) {
            return failurePacket("Sender has no OUTBOX container!");
        }

        // Find the receiver's INBOX container.
        String sInboxId = getEntityWithPropInternal(PM_NODE_OATTR, "inboxof="
                + sReceiver);
        if (sInboxId == null) {
            return failurePacket("Receiver has no INBOX container!");
        }

        Packet res =  addDoubleLink(sMsgId, PM_NODE_OATTR, sInboxId,
                PM_NODE_OATTR);
        if (res.hasError()) {
            return res;
        }
        res =  deleteDoubleLink(sMsgId, PM_NODE_OATTR, sOutboxId,
                PM_NODE_OATTR);
        if (res.hasError()) {
            return res;
        }
        return successPacket();
    }

    // Returns:
    // item 0: <user name>:<user id>
    // item 1: <'coming from' name>
    // item 2: <email address>
    // item 3: <incoming server>
    // item 4: <outgoing server>
    // item 5: <account name>.
    // If the user has no email account, the result contains only item 0.
    private Packet getEmailAcct(String sSessId, String sPmUser) {
        String sPmUserId = getEntityId(sPmUser, PM_NODE_USER);
        if (sPmUserId == null) {
            return failurePacket("No such PM user!");
        }
        if (!entityExists(sPmUserId, PM_EMAIL_ACCT)) {
            Packet result = new Packet();
            try {
                result.addItem(ItemType.RESPONSE_TEXT, sPmUser + PM_FIELD_DELIM
                        + sPmUserId);
            } catch (Exception e) {
                e.printStackTrace();
                return failurePacket("Exception when building the result packet");
            }
            return result;
        }

        try {
            Attributes attrs = ctx.getAttributes("CN=" + sPmUserId + ","
                    + sEmailAcctContainerDN);
            Packet result = new Packet();
            result.addItem(ItemType.RESPONSE_TEXT, sPmUser + PM_FIELD_DELIM
                    + sPmUserId);
            result.addItem(ItemType.RESPONSE_TEXT,
                    (String) attrs.get("pmUserName").get());
            result.addItem(ItemType.RESPONSE_TEXT,
                    (String) attrs.get("pmEmailAddr").get());
            result.addItem(ItemType.RESPONSE_TEXT,
                    (String) attrs.get("pmPopServer").get());
            result.addItem(ItemType.RESPONSE_TEXT,
                    (String) attrs.get("pmSmtpServer").get());
            result.addItem(ItemType.RESPONSE_TEXT,
                    (String) attrs.get("pmAcctName").get());
            return result;
        } catch (Exception e) {
            if (debugFlag) {
                e.printStackTrace();
            }
            return failurePacket("Exception while retrieveing the email account attributes!");
        }
    }

    private Packet addEmailAcct(String sSessId, String sPmUser,
                                String sFullName, String sEmailAddr, String sPopServer,
                                String sSmtpServer, String sAcctName, String sPassword) {
        // Checks...
        return addEmailAcctInternal(sPmUser, sFullName, sEmailAddr, sPopServer,
                sSmtpServer, sAcctName, sPassword);
    }

    private Packet addEmailAcctInternal(String sPmUser, String sFullName,
                                        String sEmailAddr, String sPopServer, String sSmtpServer,
                                        String sAcctName, String sPassword) {
        // Test if account already exists.
        String sPmUserId = getEntityId(sPmUser, PM_NODE_USER);
        if (sPmUserId == null) {
            return failurePacket("No such PM user!");
        }
        if (entityExists(sPmUserId, PM_EMAIL_ACCT)) {
            System.out.println("Email account already exists. Modifying...");
            ModificationItem[] mods = new ModificationItem[6];
            mods[0] = new ModificationItem(DirContext.REPLACE_ATTRIBUTE,
                    new BasicAttribute("pmUserName", sFullName));
            mods[1] = new ModificationItem(DirContext.REPLACE_ATTRIBUTE,
                    new BasicAttribute("pmEmailAddr", sEmailAddr));
            mods[2] = new ModificationItem(DirContext.REPLACE_ATTRIBUTE,
                    new BasicAttribute("pmPopServer", sPopServer));
            mods[3] = new ModificationItem(DirContext.REPLACE_ATTRIBUTE,
                    new BasicAttribute("pmSmtpServer", sSmtpServer));
            mods[4] = new ModificationItem(DirContext.REPLACE_ATTRIBUTE,
                    new BasicAttribute("pmAcctName", sAcctName));
            mods[5] = new ModificationItem(DirContext.REPLACE_ATTRIBUTE,
                    new BasicAttribute("pmPassword", sPassword));
            try {
                ctx.modifyAttributes("CN=" + sPmUserId + ","
                        + sEmailAcctContainerDN, mods);
            } catch (Exception e) {
                if (debugFlag) {
                    e.printStackTrace();
                }
                return failurePacket(e.getMessage());
            }
        } else {
            System.out.println("Email account new. Setting it up...");
            // Prepare the attributes of the new user object.
            Attributes attrs = new BasicAttributes(true);
            attrs.put("objectClass", sEmailAcctClass);
            attrs.put("pmId", sPmUserId);
            attrs.put("pmUserName", sFullName);
            attrs.put("pmEmailAddr", sEmailAddr);
            attrs.put("pmPopServer", sPopServer);
            attrs.put("pmSmtpServer", sSmtpServer);
            attrs.put("pmAcctName", sAcctName);
            attrs.put("pmPassword", sPassword);
            // Prepare the path and create the new user object.
            String sDn = "CN=" + sPmUserId + "," + sEmailAcctContainerDN;
            try {
                ctx.bind(sDn, null, attrs);
            } catch (Exception e) {
                if (debugFlag) {
                    e.printStackTrace();
                }
                return failurePacket("Failed to create the e-mail account for user "
                        + sPmUser);
            }
        }
        return successPacket();
    }

    private Packet genIbac(String sSessId, String sPolName) {
        // Check permissions...

        // If a policy with the property "type=identity" already exists, return.
        if (getEntityWithPropInternal(PM_NODE_POL, "type=identity") != null) {
            return failurePacket("An identity-based policy already exists!");
        }

        if (getEntityId(sPolName, PM_NODE_POL) != null) {
            return failurePacket("A policy with the same name already exists!");
        }

        String sCmd;
        Packet res;

        // Create the policy class.
        sCmd = "add|p|" + sPolName + "|c|PM";
        res =  interpretCmd(sSessId, sCmd);
        if (res.hasError()) {
            return res;
        }
        sCmd = "add|prop|type=identity|p|" + sPolName;
        res =  interpretCmd(sSessId, sCmd);
        if (res.hasError()) {
            return res;
        }

        // Generate the EVER script for "User create".
        Packet script = new Packet();
        // The function that processes the script expects it to start at item 3.
        try {
            script.addItem(ItemType.RESPONSE_TEXT, "Filler");
            script.addItem(ItemType.RESPONSE_TEXT, "Filler");
            script.addItem(ItemType.RESPONSE_TEXT, "Filler");
            script.addItem(ItemType.RESPONSE_TEXT, "script ibac");
            script.addItem(ItemType.RESPONSE_TEXT, "");
            script.addItem(ItemType.RESPONSE_TEXT, "when any user performs \""
                    + PM_EVENT_USER_CREATE + "\"");
            script.addItem(ItemType.RESPONSE_TEXT, "do");
            script.addItem(ItemType.RESPONSE_TEXT,
                    "  create user attribute uattr_name_of_user(user_new())");
            script.addItem(ItemType.RESPONSE_TEXT,
                    "    with property prop_name_of_user(user_new())");
            script.addItem(ItemType.RESPONSE_TEXT,
                    "    in policy pol_with_prop(\"type=identity\")");
            script.addItem(ItemType.RESPONSE_TEXT,
                    "  assign user user_new() to user attribute uattr_name_of_new_user()");
        } catch (Exception e) {
            e.printStackTrace();
            return failurePacket("Exception when building the script packet!");
        }

        // Compile and submit the script.
        // boolean bScriptCompiled = sysCaller.addScript(script);
        // System.out.println("Result from compile script: " + bScriptCompiled);

        res =  compileScriptAndAddToEnabled(sSessId, script);
        if (res == null) {
            return failurePacket("Null result from addScript call");
        }
        if (res.hasError()) {
            return res;
        }
        return successPacket();
    }

    // We create a DAC user with specified name and a sensitive container in
    // his/her home, a confinement policy if it does not exist, a
    // confinement attribute for the sensitive container.
    // The DAC policy must exist. The user (as well as his home) must not exist.
    // The confinement policy class may or may not exist; if it doesn't
    // exist, it will be created. The confinement attribute must not exist;
    // it will be created.
    private Packet genDacUserWithConf(String sSessId, String sUser,
                                      String sFullName, String sConfPol, String sConfAttr,
                                      String sSensCont) {

        String sCmd;
        Packet res;

        // Do permission checks...

        // Return failure if a DAC policy does not exist.
        String sDacPolId = getEntityWithPropInternal(PM_NODE_POL,
                "type=discretionary");
        if (sDacPolId == null) {
            return failurePacket("No DAC policy exists!");
        }

        // The user must not exist.
        String sUserId = getEntityId(sUser, PM_NODE_USER);
        if (sUserId != null) {
            return failurePacket("User \"" + sUser + "\" already exists!");
        }

        // The user name attribute must not exist.
        String sUserNameAttrId = getEntityId(sFullName, PM_NODE_UATTR);
        if (sUserNameAttrId != null) {
            return failurePacket("A user attribute \"" + sFullName
                    + "\" already exists!");
        }

        // Return failure if the confinement policy exists but does not have
        // the property "type=confinement".
        String sConfPolId = getEntityId(sConfPol, PM_NODE_POL);
        if (sConfPolId != null) {
            HashSet<String> props = getProps(sConfPolId, PM_NODE_POL);
            if (!props.contains("type=confinement")) {
                return failurePacket("Policy \"" + sConfPol
                        + "\" exists, but is not a confinement policy!");
            }
        }

        // Create the DAC user and process the event.
        Packet result =  addUserInternal(sUser, null, sFullName,
                sFullName, null, PM_CONNECTOR_ID, PM_NODE_CONN);
        if (result.hasError()) {
            return result;
        }
        String sLine = result.getStringValue(0);
        String[] pieces = sLine.split(PM_FIELD_DELIM);
        result =  processEvent(sSessId, null, PM_EVENT_USER_CREATE,
                sUser, pieces[1], PM_CLASS_USER_NAME, null, null, null);
        if (result.hasError()) {
            return result;
        }

        // Create the sensitive container in the user's home.
        String sHomeId = getEntityWithPropInternal(PM_NODE_OATTR, "homeof="
                + sUser);
        if (sHomeId == null) {
            return failurePacket("User \"" + sUser
                    + "\" has no home container!");
        }
        String sHome = getEntityName(sHomeId, PM_NODE_OATTR);
        sCmd = "add|b|" + sSensCont + "|b|" + sHome;
        res =  interpretCmd(sSessId, sCmd);
        if (res.hasError()) {
            return res;
        }

        return genConfForDacUser(sSessId, sUser, sConfPol, sConfAttr, sSensCont);
    }

    // We create the confinement attribute for a specified sensitive container
    // of a
    // specified user. The policy may or may not exist; if it doesn't
    // exist, it will be created. The user, home, and his/her container must
    // exist.
    // The confinement attribute must not exist; it will be created.
    private Packet genConfForDacUser(String sSessId, String sUser,
                                     String sConfPol, String sConfAttr, String sSensCont) {
        String sCmd;
        Packet res;

        // Return failure if a DAC policy does not exist.
        String sDacPolId = getEntityWithPropInternal(PM_NODE_POL,
                "type=discretionary");
        if (sDacPolId == null) {
            return failurePacket("No DAC policy exists!");
        }

        // Return failure if the confinement policy exists but does not have the
        // property
        // "type=confinement".
        String sConfPolId = getEntityId(sConfPol, PM_NODE_POL);
        if (sConfPolId != null) {
            HashSet<String> props = getProps(sConfPolId, PM_NODE_POL);
            if (!props.contains("type=confinement")) {
                return failurePacket("Policy \"" + sConfPol
                        + "\" exists, but is not a confinement policy!");
            }
        }

        // The user must exist.
        String sUserId = getEntityId(sUser, PM_NODE_USER);
        if (sUserId == null) {
            return failurePacket("User \"" + sUser + "\" must already exist!");
        }

        // The user name attribute must exist.
        String sUserNameAttrId = getEntityWithPropInternal(PM_NODE_UATTR,
                "nameof=" + sUser);
        if (sUserNameAttrId == null) {
            return failurePacket("User \"" + sUser
                    + "\" does not have a name attribute!");
        }

        // The user's home must exist.
        String sHomeId = getEntityWithPropInternal(PM_NODE_OATTR, "homeof="
                + sUser);
        if (sHomeId == null) {
            return failurePacket("User \"" + sUser
                    + "\" has no home container!");
        }

        // The sensitive container must exist somewhere in the user's home.
        String sSensContId = getEntityId(sSensCont, PM_NODE_OATTR);
        if (sSensContId == null) {
            return failurePacket("Container \"" + sSensCont
                    + "\" does not exist!");
        }
        if (!attrIsAscendant(sSensContId, sHomeId, PM_NODE_OATTR)) {
            return failurePacket("Container \"" + sSensCont
                    + "\" is not contained in user \"" + sUser + "\" home!");
        }

        // The confine attribute must not exist.
        String sConfAttrId = getEntityId(sConfAttr, PM_NODE_UATTR);
        if (sConfAttrId != null) {
            return failurePacket("The confinement attribute \"" + sConfAttr
                    + "\" already exists!");
        }

        // Create the confinement policy if necessary.
        if (sConfPolId == null) {
            sCmd = "add|p|" + sConfPol + "|c|PM";
            res =  interpretCmd(sSessId, sCmd);
            if (res.hasError()) {
                return res;
            }
            sCmd = "add|prop|type=confinement|p|" + sConfPol;
            res =  interpretCmd(sSessId, sCmd);
            if (res.hasError()) {
                return res;
            }
            sConfPolId = getEntityId(sConfPol, PM_NODE_POL);
        }

        // Create the new confine attribute and assign the user to it.
        sCmd = "add|a|" + sConfAttr + "|p|" + sConfPol;
        res =  interpretCmd(sSessId, sCmd);
        if (res.hasError()) {
            return res;
        }
        sCmd = "asg|u|" + sUser + "|a|" + sConfAttr;
        res =  interpretCmd(sSessId, sCmd);
        if (res.hasError()) {
            return res;
        }

        // Assign the sensitive container to the confinement policy.
        sCmd = "asg|o|" + sSensCont + "|p|" + sConfPol;
        res =  interpretCmd(sSessId, sCmd);
        if (res.hasError()) {
            return res;
        }

        // Create an object that represents the confinement attribute.
        // Insert this object in the DAC policy class - the same policy
        // class where the user name attribute is located.
        String sDacPol = getEntityName(sDacPolId, PM_NODE_POL);
        sCmd = "add|ob|" + sConfAttr + " rep|User attribute|no|" + sConfAttr
                + "|ignored|p|" + sDacPol;
        res =  interpretCmd(sSessId, sCmd);
        if (res.hasError()) {
            return res;
        }

        // Create an object that represents the sensitive container - in the
        // confinement policy.
        sCmd = "add|ob|" + sSensCont + " rep|Object attribute|no|" + sSensCont
                + "|ignored|p|" + sConfPol;
        res =  interpretCmd(sSessId, sCmd);
        if (res.hasError()) {
            return res;
        }

        // Set permissions:
        // <confine attribute> -> read/write -> <sensitive container>.
        String sName = generateRandomName();
        sCmd = "add|s|" + sName + "|oc|ignored|a|" + sConfAttr;
        res =  interpretCmd(sSessId, sCmd);
        if (res.hasError()) {
            return res;
        }
        sCmd = "asg|s|" + sName + "|b|" + sSensCont;
        res =  interpretCmd(sSessId, sCmd);
        if (res.hasError()) {
            return res;
        }
        sCmd = "add|op|File read|s|" + sName;
        res =  interpretCmd(sSessId, sCmd);
        if (res.hasError()) {
            return res;
        }
        sCmd = "add|op|File write|s|" + sName;
        res =  interpretCmd(sSessId, sCmd);
        if (res.hasError()) {
            return res;
        }

        // Set permissions:
        // <confine attribute> -> create objects/assign object attributes ->
        // <sensitive container>.
        sName = generateRandomName();
        sCmd = "add|s|" + sName + "|oc|ignored|a|" + sConfAttr;
        res =  interpretCmd(sSessId, sCmd);
        if (res.hasError()) {
            return res;
        }
        sCmd = "asg|s|" + sName + "|b|" + sSensCont + " rep";
        res =  interpretCmd(sSessId, sCmd);
        if (res.hasError()) {
            return res;
        }
        sCmd = "add|op|Object attribute assign to|s|" + sName;
        res =  interpretCmd(sSessId, sCmd);
        if (res.hasError()) {
            return res;
        }
        sCmd = "add|op|Object attribute create object|s|" + sName;
        res =  interpretCmd(sSessId, sCmd);
        if (res.hasError()) {
            return res;
        }

        // Set permissions:
        // <user name attribute> -> assign user attrs -> <confine attribute>.
        sName = generateRandomName();
        String sUserNameAttr = getEntityName(sUserNameAttrId, PM_NODE_UATTR);
        sCmd = "add|s|" + sName + "|oc|ignored|a|" + sUserNameAttr;
        res =  interpretCmd(sSessId, sCmd);
        if (res.hasError()) {
            return res;
        }
        sCmd = "asg|s|" + sName + "|b|" + sConfAttr + " rep";
        res =  interpretCmd(sSessId, sCmd);
        if (res.hasError()) {
            return res;
        }
        sCmd = "add|op|User attribute assign to|s|" + sName;
        res =  interpretCmd(sSessId, sCmd);
        if (res.hasError()) {
            return res;
        }

        // Deny conf attribute File write on the complement of the sensitive
        // container.
        sName = generateRandomName();
        sCmd = "add|deny|" + sName + "|" + PM_DENY_ACROSS_SESSIONS + "|a|"
                + sConfAttr + "|no";
        res =  interpretCmd(sSessId, sCmd);
        if (res.hasError()) {
            return res;
        }
        sCmd = "add|op|File write|deny|" + sName;
        res =  interpretCmd(sSessId, sCmd);
        if (res.hasError()) {
            return res;
        }
        sCmd = "add|cb|" + sSensCont + "|deny|" + sName;
        res =  interpretCmd(sSessId, sCmd);
        if (res.hasError()) {
            return res;
        }

        // Deny conf attribute Create object on the complement of the sensitive
        // container.
        sName = generateRandomName();
        sCmd = "add|deny|" + sName + "|" + PM_DENY_ACROSS_SESSIONS + "|a|"
                + sConfAttr + "|no";
        res =  interpretCmd(sSessId, sCmd);
        if (res.hasError()) {
            return res;
        }
        sCmd = "add|op|Object attribute create object|deny|" + sName;
        res =  interpretCmd(sSessId, sCmd);
        if (res.hasError()) {
            return res;
        }
        sCmd = "add|cb|" + sSensCont + "|deny|" + sName;
        res =  interpretCmd(sSessId, sCmd);
        if (res.hasError()) {
            return res;
        }

        return successPacket();
    }

    private Packet genMls(String sSessId, String sPolName, String sLevels) {
        // Check permissions...

        // If a policy with the property "type=mls" already exists, return.
        if (getEntityWithPropInternal(PM_NODE_POL, "type=mls") != null) {
            return failurePacket("A multi-level security policy already exists!");
        }

        // Generate commands for creating the policy class.
        String sCmd;
        Packet res;

        sCmd = "add|p|" + sPolName + "|c|PM";
        res =  interpretCmd(sSessId, sCmd);
        if (res.hasError()) {
            return res;
        }
        sCmd = "add|prop|type=mls|p|" + sPolName;
        res =  interpretCmd(sSessId, sCmd);
        if (res.hasError()) {
            return res;
        }
        sCmd = "add|prop|levels=" + sLevels + "|p|" + sPolName;
        res =  interpretCmd(sSessId, sCmd);
        if (res.hasError()) {
            return res;
        }

        // Get the levels in an array.
        String[] levels = sLevels.split(PM_LIST_MEMBER_SEP);
        int n = levels.length;
        if (n < 2) {
            return failurePacket("Too few security levels!");
        }

        // Generate the user attributes.
        for (int i = 1; i <= n; i++) {
            if (i == 1) {
                sCmd = "add|a|" + levels[i - 1] + "|p|" + sPolName;
            } else {
                sCmd = "add|a|" + levels[i - 1] + "|a|" + levels[i - 2];
            }
            res =  interpretCmd(sSessId, sCmd);
            if (res.hasError()) {
                return res;
            }
        }

        // Generate the object attribute x1...xn.
        StringBuffer sb = new StringBuffer();
        for (int i = 1; i <= n; i++) {
            sb.append(levels[i - 1]);
        }
        String sAll = sb.toString();
        sCmd = "add|b|" + sAll + "|p|" + sPolName;
        res =  interpretCmd(sSessId, sCmd);
        if (res.hasError()) {
            return res;
        }

        // Prepare the array sRight used to store the object attributes
        // x1...xn, x2...xn, x3...xn, ..., xn, and the array sLeft used to store
        // the object attributes x1...xn, x1...xn-1, ..., x1.
        String[] sRight = new String[n];
        sRight[0] = sAll;
        String[] sLeft = new String[n];
        sLeft[0] = sAll;
        // Generate the other names in the arrays.
        for (int i = 2; i <= n; i++) {
            sb = new StringBuffer();
            for (int j = i; j <= n; j++) {
                sb.append(levels[j - 1]);
            }
            sRight[i - 1] = sb.toString();
            System.out.println("Generated right name " + sRight[i - 1]);
        }

        for (int i = 2; i <= n; i++) {
            sb = new StringBuffer();
            for (int j = 1; j <= n - i + 1; j++) {
                sb.append(levels[j - 1]);
            }
            sLeft[i - 1] = sb.toString();
            System.out.println("Generated left name " + sLeft[i - 1]);
        }

        // Generate the object attributes.
        for (int i = 2; i <= n; i++) {
            sCmd = "add|b|" + sRight[i - 1] + "|b|" + sRight[i - 2];
            System.out.println("Trying to generate container " + sRight[i - 1]
                    + " in " + sRight[i - 2]);
            res =  interpretCmd(sSessId, sCmd);
            if (res.hasError()) {
                return res;
            }
        }

        for (int i = 2; i <= n; i++) {
            sCmd = "add|b|" + sLeft[i - 1] + "|b|" + sLeft[i - 2];
            System.out.println("Trying to generate container " + sLeft[i - 1]
                    + " in " + sLeft[i - 2]);
            res =  interpretCmd(sSessId, sCmd);
            if (res.hasError()) {
                return res;
            }
        }

        // Generate the object attributes x2,...,xn-1 and assign them as
        // follows (the indexes start with 1; in the code they start with 0):
        // x2 -> leftn-1, x2 -> right2
        // x3 -> leftn-2, x3 -> right3
        // ...
        // xn-1 -> left2, xn-1 -> rightn-1
        for (int i = 2; i <= n - 1; i++) {
            sCmd = "add|b|" + levels[i - 1] + "|b|" + sLeft[n - i];
            System.out.println("Trying to generate container " + levels[i - 1]
                    + " in " + sLeft[n - i]);
            res =  interpretCmd(sSessId, sCmd);
            if (res.hasError()) {
                return res;
            }

            sCmd = "asg|b|" + levels[i - 1] + "|b|" + sRight[i - 1];
            System.out.println("Trying to assign container " + levels[i - 1]
                    + " in " + sRight[i - 1]);
            res =  interpretCmd(sSessId, sCmd);
            if (res.hasError()) {
                return res;
            }
        }

        // Generate and assign the operation sets:
        // xi -> {read} -> x1...xi (i.e., left[n-i+1]),
        // xi -> {write} -> xi...xn (i.e., right[i]).
        for (int i = 1; i <= n; i++) {
            String sOpsName = generateRandomName();
            sCmd = "add|s|" + sOpsName + "|oc|ignored|a|" + levels[i - 1];
            res =  interpretCmd(sSessId, sCmd);
            if (res.hasError()) {
                return res;
            }
            sCmd = "asg|s|" + sOpsName + "|b|" + sLeft[n - i];
            res =  interpretCmd(sSessId, sCmd);
            if (res.hasError()) {
                return res;
            }
            sCmd = "add|op|File read|s|" + sOpsName;
            res =  interpretCmd(sSessId, sCmd);
            if (res.hasError()) {
                return res;
            }

            sOpsName = generateRandomName();
            sCmd = "add|s|" + sOpsName + "|oc|ignored|a|" + levels[i - 1];
            res =  interpretCmd(sSessId, sCmd);
            if (res.hasError()) {
                return res;
            }
            sCmd = "asg|s|" + sOpsName + "|b|" + sRight[i - 1];
            res =  interpretCmd(sSessId, sCmd);
            if (res.hasError()) {
                return res;
            }
            sCmd = "add|op|File write|s|" + sOpsName;
            res =  interpretCmd(sSessId, sCmd);
            if (res.hasError()) {
                return res;
            }
        }

        // Generate the objects that represent containers x1,...,xn:
        for (int i = 1; i <= n; i++) {
            sCmd = "add|ob|" + levels[i - 1] + " rep|Object attribute|no|"
                    + levels[i - 1] + "|ignored|p|" + sPolName;
            res =  interpretCmd(sSessId, sCmd);
            if (res.hasError()) {
                return res;
            }

            String sOpsName = generateRandomName();
            sCmd = "add|s|" + sOpsName + "|oc|ignored|a|" + levels[i - 1];
            res =  interpretCmd(sSessId, sCmd);
            if (res.hasError()) {
                return res;
            }
            sCmd = "asg|s|" + sOpsName + "|b|" + levels[i - 1] + " rep";
            res =  interpretCmd(sSessId, sCmd);
            if (res.hasError()) {
                return res;
            }
            sCmd = "add|op|Object attribute assign to|s|" + sOpsName;
            res =  interpretCmd(sSessId, sCmd);
            if (res.hasError()) {
                return res;
            }
            sCmd = "add|op|Object attribute create object|s|" + sOpsName;
            res =  interpretCmd(sSessId, sCmd);
            if (res.hasError()) {
                return res;
            }
        }

        // Add the subject attribute constraints.
        // first the attribute sets.
        sCmd = "add|sac|mls|intra session";
        res =  interpretCmd(sSessId, sCmd);
        if (res.hasError()) {
            return res;
        }

        for (int i = 1; i <= n; i++) {
            sCmd = "add|as|" + levels[i - 1];
            res =  interpretCmd(sSessId, sCmd);
            if (res.hasError()) {
                return res;
            }

            sCmd = "add|a|" + levels[i - 1] + "|as|" + levels[i - 1];
            res =  interpretCmd(sSessId, sCmd);
            if (res.hasError()) {
                return res;
            }

            sCmd = "add|as|" + levels[i - 1] + "|sa|mls";
            res =  interpretCmd(sSessId, sCmd);
            if (res.hasError()) {
                return res;
            }
        }

        // Generate the EVER script for MLS.
        Packet script = new Packet();
        // The function that processes the script expects it to start at item 3.
        try {
            script.addItem(ItemType.RESPONSE_TEXT, "Filler");
            script.addItem(ItemType.RESPONSE_TEXT, "Filler");
            script.addItem(ItemType.RESPONSE_TEXT, "Filler");
            script.addItem(ItemType.RESPONSE_TEXT, "script mls");
            script.addItem(ItemType.RESPONSE_TEXT, "");
            script.addItem(ItemType.RESPONSE_TEXT, "when any user performs \""
                    + PM_EVENT_USER_CREATE + "\"");
            script.addItem(ItemType.RESPONSE_TEXT, "do");
            script.addItem(ItemType.RESPONSE_TEXT,
                    "  assign user user_new() to");
            script.addItem(ItemType.RESPONSE_TEXT,
                    "    user attribute uattr_lowest_level()");

            script.addItem(ItemType.RESPONSE_TEXT, "when any user performs \""
                    + PM_EVENT_OBJECT_CREATE + "\"");
            script.addItem(ItemType.RESPONSE_TEXT, "do");
            script.addItem(ItemType.RESPONSE_TEXT,
                    "  assign object object_new() to");
            script.addItem(
                    ItemType.RESPONSE_TEXT,
                    "    object attribute oattr_with_name_of_active_attr(pol_with_prop(\"type=mls\"))");
        } catch (Exception e) {
            e.printStackTrace();
            return failurePacket("Exception when building the script packet!");
        }

        // Compile and submit the script.
        res =  compileScriptAndAddToEnabled(sSessId, script);
        if (res == null) {
            return failurePacket("Null result from addScript call");
        }
        return res;
    }

    // Configure a DAC policy. Parameters:
    // sPolName: the DAC policy name.
    // sContName: the name of a user attribute that will contain all users'
    // name attributes.
    private Packet genDac(String sSessId, String sPolName, String sContName) {
        // Check permissions...

        // If a policy with the property "type=discretionary" already exists,
        // return.
        if (getEntityWithPropInternal(PM_NODE_POL, "type=discretionary") != null) {
            return failurePacket("A discretionary policy already exists!");
        }

        String sCmd;
        Packet res;

        // Create the policy class.
        sCmd = "add|p|" + sPolName + "|c|PM";
        res =  interpretCmd(sSessId, sCmd);
        if (res.hasError()) {
            return res;
        }
        sCmd = "add|prop|type=discretionary|p|" + sPolName;
        res =  interpretCmd(sSessId, sCmd);
        if (res.hasError()) {
            return res;
        }

        // Create the attribute container and its representative object.
        sCmd = "add|a|" + sContName + "|p|" + sPolName;
        res =  interpretCmd(sSessId, sCmd);
        if (res.hasError()) {
            return res;
        }
        sCmd = "add|prop|usersof=discretionary|a|" + sContName;
        res =  interpretCmd(sSessId, sCmd);
        if (res.hasError()) {
            return res;
        }
        sCmd = "add|ob|" + sContName + " rep|User attribute|yes|" + sContName
                + "|ignored|p|" + sPolName;
        res =  interpretCmd(sSessId, sCmd);
        if (res.hasError()) {
            return res;
        }

        // Generate the EVER script for "User create".
        Packet script = new Packet();
        // The function that processes the script expects it to start at item 3.
        try {
            script.addItem(ItemType.RESPONSE_TEXT, "Filler");
            script.addItem(ItemType.RESPONSE_TEXT, "Filler");
            script.addItem(ItemType.RESPONSE_TEXT, "Filler");
            script.addItem(ItemType.RESPONSE_TEXT, "script dac");
            script.addItem(ItemType.RESPONSE_TEXT, "");
            script.addItem(ItemType.RESPONSE_TEXT, "when any user performs \""
                    + PM_EVENT_USER_CREATE + "\"");
            script.addItem(ItemType.RESPONSE_TEXT, "do");
            script.addItem(ItemType.RESPONSE_TEXT,
                    "  create user attribute uattr_name_of_user(user_new())");
            script.addItem(ItemType.RESPONSE_TEXT,
                    "    with property prop_name_of_user(user_new())");
            script.addItem(ItemType.RESPONSE_TEXT, "    in policy pol_discr()");

            script.addItem(ItemType.RESPONSE_TEXT,
                    "  assign user user_new() to user attribute uattr_name_of_new_user()");

            script.addItem(ItemType.RESPONSE_TEXT,
                    "  assign user attribute uattr_name_of_new_user() to");
            script.addItem(ItemType.RESPONSE_TEXT,
                    "    user attribute uattr_discr_users()");

            script.addItem(ItemType.RESPONSE_TEXT,
                    "  create object attribute oattr_home_of_new_user()");
            script.addItem(ItemType.RESPONSE_TEXT,
                    "    with property prop_home_of_new_user()");
            script.addItem(ItemType.RESPONSE_TEXT, "    in policy pol_discr()");

            script.addItem(ItemType.RESPONSE_TEXT,
                    "  create object obj_rep_of_home_of_new_user()");
            script.addItem(ItemType.RESPONSE_TEXT,
                    "    representing object attribute oattr_home_of_new_user() and ascendants");
            script.addItem(ItemType.RESPONSE_TEXT, "    in policy pol_discr()");

            script.addItem(ItemType.RESPONSE_TEXT,
                    "  grant uattr_name_of_new_user() operations");
            script.addItem(ItemType.RESPONSE_TEXT,
                    "    \"File read\", \"File write\"");
            script.addItem(ItemType.RESPONSE_TEXT,
                    "    on object attribute oattr_home_of_new_user()");

            script.addItem(ItemType.RESPONSE_TEXT,
                    "  grant uattr_name_of_new_user() operations");
            script.addItem(ItemType.RESPONSE_TEXT,
                    "    \"Object attribute create object\",");
            script.addItem(ItemType.RESPONSE_TEXT,
                    "    \"Object attribute create object attribute\",");
            script.addItem(ItemType.RESPONSE_TEXT,
                    "    \"Object attribute create operation set\",");
            script.addItem(ItemType.RESPONSE_TEXT,
                    "    \"Object attribute assign\",");
            script.addItem(ItemType.RESPONSE_TEXT,
                    "    \"Object attribute assign to\",");
            script.addItem(ItemType.RESPONSE_TEXT,
                    "    \"Operation set assign to\",");
            script.addItem(ItemType.RESPONSE_TEXT,
                    "    \"Operation set assign\",");
            script.addItem(ItemType.RESPONSE_TEXT, "    \"Entity represent\"");
            script.addItem(ItemType.RESPONSE_TEXT,
                    "    on object attribute oattr_rep_of_home_of_new_user()");

            script.addItem(ItemType.RESPONSE_TEXT,
                    "  grant uattr_name_of_new_user() operations");
            script.addItem(ItemType.RESPONSE_TEXT, "    \"User assign\",");
            script.addItem(ItemType.RESPONSE_TEXT,
                    "    \"User attribute assign to operation set\"");
            script.addItem(ItemType.RESPONSE_TEXT,
                    "    on object attribute oattr_rep_of_discr_users()");
        } catch (Exception e) {
            e.printStackTrace();
            return failurePacket("Exception when building the result packet");
        }

        // Compile and submit the script.
        // boolean bScriptCompiled = sysCaller.addScript(script);
        // System.out.println("Result from compile script: " + bScriptCompiled);

        res =  compileScriptAndAddToEnabled(sSessId, script);
        if (res == null) {
            return failurePacket("Null result from addScript call");
        }
        if (res.hasError()) {
            return res;
        }
        return successPacket();
    }

    private Packet doDacConfinement(String sSessId, String sUser, String sPc,
                                    String sAttr, String sContainer) {
        // Check permissions...
        // Not yet.

        // Generate commands for creating needed entities and relations,
        // and call interpretCmd(sSessId, sSessId, command) repeatedly
        // to process them.
        String sCmd;
        Packet res;

        // If the confinement policy class does not exist, create it.
        if (getEntityId(sPc, PM_NODE_POL) == null) {
            sCmd = "add|p|" + sPc + "|c|PM";
            res =  interpretCmd(sSessId, sCmd);
            if (res.hasError()) {
                return res;
            }
            sCmd = "add|prop|type=confinement|p|" + sPc;
            res =  interpretCmd(sSessId, sCmd);
            if (res.hasError()) {
                return res;
            }
        }

        // Create the new confine attribute and assign the user to it.
        // Create an object that represents the confine attribute in
        sCmd = "add|a|" + sAttr + "|p|" + sPc;
        res =  interpretCmd(sSessId, sCmd);
        if (res.hasError()) {
            return res;
        }
        sCmd = "add|ob|" + sAttr + " rep|User attribute|no|" + sAttr
                + "|ignored|p|" + sPc;
        res =  interpretCmd(sSessId, sCmd);
        if (res.hasError()) {
            return res;
        }
        sCmd = "asg|u|" + sUser + "|a|" + sAttr;
        res =  interpretCmd(sSessId, sCmd);
        if (res.hasError()) {
            return res;
        }

        // Create the sensitive container and its representative object.
        sCmd = "add|b|" + sContainer + "|p|" + sPc;
        res =  interpretCmd(sSessId, sCmd);
        if (res.hasError()) {
            return res;
        }
        sCmd = "add|ob|" + sContainer + " rep|Object attribute|no|"
                + sContainer + "|ignored|p|" + sPc;
        res =  interpretCmd(sSessId, sCmd);
        if (res.hasError()) {
            return res;
        }

        // Create and assign an opset that allows users with the confine
        // attribute
        // to assign other users to the confine attribute.
        String sName = generateRandomName();
        sCmd = "add|s|" + sName + "|oc|ignored|a|" + sAttr;
        res =  interpretCmd(sSessId, sCmd);
        if (res.hasError()) {
            return res;
        }
        sCmd = "asg|s|" + sName + "|b|" + sAttr + " rep";
        res =  interpretCmd(sSessId, sCmd);
        if (res.hasError()) {
            return res;
        }
        sCmd = "add|op|User attribute assign to|s|" + sName;
        res =  interpretCmd(sSessId, sCmd);
        if (res.hasError()) {
            return res;
        }

        // Create and assign an opset that allows users with the confine
        // attribute
        // to create objects in the sensitive container and to assign object
        // attributes (including objects) to the sensitive container.
        sName = generateRandomName();
        sCmd = "add|s|" + sName + "|oc|ignored|a|" + sAttr;
        res =  interpretCmd(sSessId, sCmd);
        if (res.hasError()) {
            return res;
        }
        sCmd = "asg|s|" + sName + "|b|" + sContainer + " rep";
        res =  interpretCmd(sSessId, sCmd);
        if (res.hasError()) {
            return res;
        }
        sCmd = "add|op|Object attribute assign to|s|" + sName;
        res =  interpretCmd(sSessId, sCmd);
        if (res.hasError()) {
            return res;
        }
        sCmd = "add|op|Object attribute create object|s|" + sName;
        res =  interpretCmd(sSessId, sCmd);
        if (res.hasError()) {
            return res;
        }

        // Create and assign an opset that allows users with the confine
        // attribute
        // to read/write objects of the sensitive container.
        sName = generateRandomName();
        sCmd = "add|s|" + sName + "|oc|ignored|a|" + sAttr;
        res =  interpretCmd(sSessId, sCmd);
        if (res.hasError()) {
            return res;
        }
        sCmd = "asg|s|" + sName + "|b|" + sContainer;
        res =  interpretCmd(sSessId, sCmd);
        if (res.hasError()) {
            return res;
        }
        sCmd = "add|op|File read|s|" + sName;
        res =  interpretCmd(sSessId, sCmd);
        if (res.hasError()) {
            return res;
        }
        sCmd = "add|op|File write|s|" + sName;
        res =  interpretCmd(sSessId, sCmd);
        if (res.hasError()) {
            return res;
        }

        // Create a deny, attribute-based, across sessions, denying File write
        // on the complement of the sensitive container.
        sName = generateRandomName();
        sCmd = "add|deny|" + sName + "|" + PM_DENY_ACROSS_SESSIONS + "|a|"
                + sAttr + "|no";
        res =  interpretCmd(sSessId, sCmd);
        if (res.hasError()) {
            return res;
        }
        sCmd = "add|op|File write|deny|" + sName;
        res =  interpretCmd(sSessId, sCmd);
        if (res.hasError()) {
            return res;
        }
        sCmd = "add|cb|" + sContainer + "|deny|" + sName;
        res =  interpretCmd(sSessId, sCmd);
        if (res.hasError()) {
            return res;
        }

        // Create a deny, attribute-based, across sessions, denying Create
        // object
        // on the complement of the sensitive container.
        sName = generateRandomName();
        sCmd = "add|deny|" + sName + "|" + PM_DENY_ACROSS_SESSIONS + "|a|"
                + sAttr + "|no";
        res =  interpretCmd(sSessId, sCmd);
        if (res.hasError()) {
            return res;
        }
        sCmd = "add|op|Object attribute create object|deny|" + sName;
        res =  interpretCmd(sSessId, sCmd);
        if (res.hasError()) {
            return res;
        }
        sCmd = "add|cb|" + sContainer + "|deny|" + sName;
        res =  interpretCmd(sSessId, sCmd);
        if (res.hasError()) {
            return res;
        }
        return successPacket();
    }

    /**
	 * @uml.property  name="myRandom"
	 */
    Random myRandom = new Random();

    private String generateRandomName() {
        byte[] bytes = new byte[4];
        myRandom.nextBytes(bytes);
        return byteArray2HexString(bytes);
    }

    // New definition for Static constraint for attributes:
    // A Static constraint for attributes (scona for short)
    // has the format:
    //
    // <pc, uattr, opset, oattr>.
    //
    // Semantics: Within the policy class pc, the user attribute uattr
    // cannot be directly authorized to any operation in opset on any
    // object contained in the object attribute oattr, i.e., we cannot
    // have something like this:
    // uattr ->+ pc, oattr ->+ pc, uattr -> ops -> oa ->+ pc,
    // where (ops int opset) != empty, and there is an object o such that
    // o ->* oa, o ->* oattr.
    private Packet checkScona(String sSconaId) {
        Attributes attrs;
        Attribute attr;

        try {

            attrs = ctx.getAttributes("CN=" + sSconaId + ","
                    + sSconaContainerDN);
            String sPcId = (String) attrs.get("pmPc").get();
            String sUattrId = (String) attrs.get("pmUserAttr").get();
            String sOattrId = (String) attrs.get("pmObjAttr").get();
            System.out.println("Checking scona "
                    + getEntityName(sSconaId, PM_SCONA));
            System.out.println("  with uattr "
                    + getEntityName(sUattrId, PM_NODE_UATTR));
            System.out.println("  with oattr "
                    + getEntityName(sOattrId, PM_NODE_OATTR));
            System.out.println("  in pc " + getEntityName(sPcId, PM_NODE_POL));

            attr = attrs.get("pmOp");
            if (attr == null) {
                return successPacket();
            }

            if (!attrIsAscendantToPolicy(sUattrId, PM_NODE_UATTR, sPcId)) {
                System.out.println("  Uattr "
                        + getEntityName(sUattrId, PM_NODE_UATTR)
                        + " is not in policy "
                        + getEntityName(sPcId, PM_NODE_POL));
                return successPacket();
            }

            if (!attrIsAscendantToPolicy(sOattrId, PM_NODE_OATTR, sPcId)) {
                System.out.println("  Oattr "
                        + getEntityName(sOattrId, PM_NODE_OATTR)
                        + " is not in policy "
                        + getEntityName(sPcId, PM_NODE_POL));
                return successPacket();
            }

            // Create the set of scona operations.
            HashSet<String> sconaOpers = new HashSet<String>();
            for (NamingEnumeration<?> attrEnum = attr.getAll(); attrEnum.hasMore(); ) {
                sconaOpers.add((String) attrEnum.next());
            }

            // Prepare the set of opset operations.
            HashSet<String> opsetOpers = new HashSet<String>();

            // For each opset ops such that ua -> ops
            Vector<String> opsets = getToOpsets(sUattrId);
            for (int ops = 0; ops < opsets.size(); ops++) {
                String sOpsId = opsets.elementAt(ops);
                System.out.println("  Found opset "
                        + getEntityName(sOpsId, PM_NODE_OPSET)
                        + " assigned to uattr "
                        + getEntityName(sUattrId, PM_NODE_UATTR));

                // If (opsOpers int sconaOpers) = empty, continue with next
                // opset.
                // First get the ops' operations as a set.
                opsetOpers.clear();
                addOpsetToSet(sOpsId, opsetOpers);
                opsetOpers.retainAll(sconaOpers);
                if (opsetOpers.isEmpty()) {
                    System.out.println("    The opset has no operation common with the scona");
                    continue;
                }

                // For each oa the opset is assigned to.
                Vector<String> oattrs = getToAttrs(sOpsId);
                for (int oa = 0; oa < oattrs.size(); oa++) {
                    String sOaId = oattrs.elementAt(oa);
                    System.out.println("    Found oattr "
                            + getEntityName(sOaId, PM_NODE_OATTR)
                            + " assigned to the opset");
                    // If !(oa ->+ pc) continue.
                    if (!attrIsAscendantToPolicy(sOaId, PM_NODE_OATTR, sPcId)) {
                        System.out.println("      It's not in the scona's policy class");
                        continue;
                    }
                    // If oattr and oa have common objects, return false.
                    if (containersIntersect(sOattrId, sOaId)) {
                        System.out.println("      Containers "
                                + getEntityName(sOattrId, PM_NODE_OATTR)
                                + " and " + getEntityName(sOaId, PM_NODE_OATTR)
                                + " have common objects");
                        return failurePacket();
                    }
                    System.out.println("      Containers "
                            + getEntityName(sOattrId, PM_NODE_OATTR) + " and "
                            + getEntityName(sOaId, PM_NODE_OATTR)
                            + " are disjoint");
                }
            }
            return successPacket();
        } catch (Exception e) {
            e.printStackTrace();
            return failurePacket("Exception while checking a static constraint: "
                    + e.getClass().getName());
        }
    }

    private boolean containersIntersect(String sContId1, String sContId2) {
        HashSet<String> members = new HashSet<String>();
        getMemberObjects(sContId1, members);
        Iterator<String> membersIter = members.iterator();
        while (membersIter.hasNext()) {
            String sAssocId = membersIter.next();
            if (attrIsAscendant(sAssocId, sContId2, PM_NODE_OATTR)) {
                return true;
            }
        }
        return false;
    }

    // Delete static constraint for attributes.
    // Second parameter is the constraint id.
    // Third parameter is the name of the operation to be deleted.
    // The op name can be null, and that means to delete the entire constraint.
    private Packet deleteScona(String sSessId, String sSconaId, String sOp) {
        if (sSconaId == null || sSconaId.length() == 0) {
            return failurePacket("The static constraint id cannot be null or empty!");
        }

        String sSconaName = getEntityName(sSconaId, PM_SCONA);
        if (sSconaName == null) {
            return failurePacket("Unknown constraint id " + sSconaId + "!");
        }

        if (sOp == null || sOp.length() == 0) {
            // No op was selected, try to delete the entire constraint.
            try {
                ctx.destroySubcontext("CN=" + sSconaId + ","
                        + sSconaContainerDN);
            } catch (Exception e) {
                if (debugFlag) {
                    e.printStackTrace();
                }
                return failurePacket("Error while deleting constraint "
                        + sSconaName + ": " + e.getMessage());
            }
        } else {
            // An op of the constraint is also selected. Delete the op only.
            if (!isOperation(sOp)) {
                return failurePacket("Unkown operation " + sOp
                        + " in constraint!");
            }
            ModificationItem[] mods = new ModificationItem[1];
            mods[0] = new ModificationItem(DirContext.REMOVE_ATTRIBUTE,
                    new BasicAttribute("pmOp", sOp));
            try {
                ctx.modifyAttributes(
                        "CN=" + sSconaId + "," + sSconaContainerDN, mods);
            } catch (Exception e) {
                if (debugFlag) {
                    e.printStackTrace();
                }
                return failurePacket("Error while deleting operation " + sOp
                        + ": " + e.getMessage());
            }
        }
        return successPacket();
    }

    // Returns:
    // item 0: <scona name>:<scona id>
    // item 1: <pc name>:<pc id>
    // item 2: <ua name>:<ua id>
    // item 3: <oa name>:<oa id>
    // item 4,...: <op name>
    private Packet getSconaInfo(String sSessId, String sSconaId) {
        Packet result = new Packet();
        Attributes attrs;
        Attribute attr;

        try {
            attrs = ctx.getAttributes("CN=" + sSconaId + ","
                    + sSconaContainerDN);

            // First insert the scona name and id.
            String sSconaName = (String) attrs.get("pmName").get();
            result.addItem(ItemType.RESPONSE_TEXT, sSconaName + PM_FIELD_DELIM
                    + sSconaId);

            // Now the policy class.
            String sPcId = (String) attrs.get("pmPc").get();
            String sPcName = getEntityName(sPcId, PM_NODE_POL);
            if (sPcName == null) {
                return failurePacket("Invalid policy class in static constraint for attributes!");
            }
            result.addItem(ItemType.RESPONSE_TEXT, sPcName + PM_FIELD_DELIM
                    + sPcId);

            // Now the user attribute.
            String sUattrId = (String) attrs.get("pmUserAttr").get();
            String sUattrName = getEntityName(sUattrId, PM_NODE_UATTR);
            if (sUattrName == null) {
                return failurePacket("Invalid user attribute in static constraint for attributes!");
            }
            result.addItem(ItemType.RESPONSE_TEXT, sUattrName + PM_FIELD_DELIM
                    + sUattrId);

            // Now the object attribute.
            String sOattrId = (String) attrs.get("pmObjAttr").get();
            String sOattrName = getEntityName(sOattrId, PM_NODE_OATTR);
            if (sOattrName == null) {
                return failurePacket("Invalid object attribute in static constraint for attributes!");
            }
            result.addItem(ItemType.RESPONSE_TEXT, sOattrName + PM_FIELD_DELIM
                    + sOattrId);

            // Get the constraint's operations.
            attr = attrs.get("pmOp");
            if (attr != null) {
                for (NamingEnumeration<?> attrEnum = attr.getAll(); attrEnum.hasMore(); ) {
                    String sOp = (String) attrEnum.next();
                    result.addItem(ItemType.RESPONSE_TEXT, sOp);
                }
            }

            return result;

        } catch (Exception e) {
            e.printStackTrace();
            return failurePacket("Exception in getSconaInfo(): "
                    + e.getMessage());
        }
    }

    // Get all static constraints on attributes. Each item returned
    // contains <scona name>:<scona id>.
    private Packet getSconas(String sSessId) {
        Packet result = new Packet();
        NamingEnumeration<?> sconas;

        try {
            SearchControls constraints = new SearchControls();
            constraints.setSearchScope(SearchControls.ONELEVEL_SCOPE);
            constraints.setReturningAttributes(new String[]{"pmId", "pmName"});
            sconas = ctx.search(sSconaContainerDN, "(objectClass=*)",
                    constraints);

            while (sconas != null && sconas.hasMore()) {
                SearchResult sr = (SearchResult) sconas.next();
                String sName = (String) sr.getAttributes().get("pmName").get();
                String sId = (String) sr.getAttributes().get("pmId").get();
                result.addItem(ItemType.RESPONSE_TEXT, sName + PM_FIELD_DELIM
                        + sId);
            }
            return result;

        } catch (CommunicationException e) {
            if (debugFlag) {
                e.printStackTrace();
            }
            return failurePacket("AD connection error");
        } catch (Exception e) {
            if (debugFlag) {
                e.printStackTrace();
            }
            return failurePacket("Exception: " + e.getMessage());
        }
    }

    // Add a new static constraint for attributes, or a new op to en existing
    // constraint.
    private Packet addScona(String sSessId, String sSconaName, String sPcName,
                            String sUattrName, String sOp, String sOattrName) {
        boolean newScona = false;
        String sSconaId = getEntityId(sSconaName, PM_SCONA);
        if (sSconaId == null) {
            // This is a new static constraint for attributes, so
            // sPcName, sUattrName and sOattrName cannot be null and they must
            // exist.
            if (sPcName == null || sPcName.length() == 0) {
                return failurePacket("The policy class cannot be null!");
            }
            String sPcId = getEntityId(sPcName, PM_NODE_POL);
            if (sPcId == null) {
                return failurePacket("No such policy class " + sPcName + "!");
            }
            if (sUattrName == null || sUattrName.length() == 0) {
                return failurePacket("User attribute cannot be null!");
            }
            String sUattrId = getEntityId(sUattrName, PM_NODE_UATTR);
            if (sUattrId == null) {
                return failurePacket("No such user attribute " + sUattrName
                        + "!");
            }
            if (sOattrName == null || sOattrName.length() == 0) {
                return failurePacket("Object attribute cannot be null!");
            }
            String sOattrId = getEntityId(sOattrName, PM_NODE_OATTR);
            if (sOattrId == null) {
                return failurePacket("No such object attribute " + sOattrName
                        + "!");
            }

            newScona = true;
            Attributes attrs = new BasicAttributes(true);
            RandomGUID myGUID = new RandomGUID();
            sSconaId = myGUID.toStringNoDashes();
            attrs.put("objectClass", sSconaClass);
            attrs.put("pmId", sSconaId);
            attrs.put("pmName", sSconaName);
            attrs.put("pmPc", sPcId);
            attrs.put("pmUserAttr", sUattrId);
            attrs.put("pmObjAttr", sOattrId);
            try {
                ctx.bind("CN=" + sSconaId + "," + sSconaContainerDN, null,
                        attrs);
            } catch (Exception e) {
                e.printStackTrace();
                return failurePacket("Unable to create static constraint \""
                        + sSconaName + "\"");
            }
        }

        // The static constraint already exists.
        // Prepare the return, <scona name>:<scona id>.
        Packet okResult = new Packet();
        try {
            okResult.addItem(ItemType.RESPONSE_TEXT, sSconaName
                    + PM_FIELD_DELIM + sSconaId);
        } catch (Exception e) {
            e.printStackTrace();
            return failurePacket("Exception when building the result packet");
        }

        // The operation cannot be null if the constraint already existed.
        if (sOp == null) {
            if (newScona) {
                return okResult;
            } else {
                return failurePacket("The operation cannot be null!");
            }
        }

        // The operation must be valid.
        if (!isOperation(sOp)) {
            return failurePacket(sOp + " is not an operation!");
        }

        // Add the operation to the constraint.
        ModificationItem[] mods = new ModificationItem[1];
        mods[0] = new ModificationItem(DirContext.ADD_ATTRIBUTE,
                new BasicAttribute("pmOp", sOp));
        try {
            ctx.modifyAttributes("CN=" + sSconaId + "," + sSconaContainerDN,
                    mods);
        } catch (Exception e) {
            e.printStackTrace();
            return failurePacket("Unable to add the operation \"" + sOp
                    + "\": " + e.getClass().getName());
        }

        // Now check the constraint.
        Packet res =  checkScona(sSconaId);
        if (res.hasError()) {
            String sErr = res.getErrorMessage();
            if (newScona) {
                // Roll back the scona addition.
                try {
                    ctx.destroySubcontext("CN=" + sSconaId + ","
                            + sSconaContainerDN);
                } catch (Exception e) {
                    if (debugFlag) {
                        e.printStackTrace();
                    }
                    return failurePacket(sErr
                            + " Unable to roll back constraint addition!");
                }
                return failurePacket(sErr
                        + " Constraint addition has been rolled back!");
            } else {
                // Roll back the operation addition.
                mods[0] = new ModificationItem(DirContext.REMOVE_ATTRIBUTE,
                        new BasicAttribute("pmOp", sOp));
                try {
                    ctx.modifyAttributes("CN=" + sSconaId + ","
                            + sSconaContainerDN, mods);
                } catch (Exception e) {
                    e.printStackTrace();
                    return failurePacket(sErr
                            + " Unable to roll back operation addition!");
                }
                return failurePacket(sErr
                        + " Operation addition has been rolled back!");
            }
        }

        return okResult;
    }

    // Check all static constraints on users.
    @SuppressWarnings("unused")
    private Packet checkScons() {
        Packet res;
        NamingEnumeration<?> scons;

        try {
            SearchControls constraints = new SearchControls();
            constraints.setSearchScope(SearchControls.ONELEVEL_SCOPE);
            constraints.setReturningAttributes(new String[]{"pmId", "pmName"});
            scons = ctx.search(sSconContainerDN, "(objectClass=*)", constraints);

            while (scons != null && scons.hasMore()) {
                SearchResult sr = (SearchResult) scons.next();
                String sName = (String) sr.getAttributes().get("pmName").get();
                String sId = (String) sr.getAttributes().get("pmId").get();
                res =  checkScon(sId);
                if (res.hasError()) {
                    return res;
                }
            }
            return successPacket();
        } catch (CommunicationException e) {
            if (debugFlag) {
                e.printStackTrace();
            }
            return failurePacket("AD connection error");
        } catch (Exception e) {
            if (debugFlag) {
                e.printStackTrace();
            }
            return failurePacket("Exception: " + e.getMessage());
        }
    }

    // Check the specified static constraint on users.
    private Packet checkScon(String sSconId) {
        Attributes attrs;
        Attribute attr;

        try {
            attrs = ctx.getAttributes("CN=" + sSconId + "," + sSconContainerDN);
            String sK = (String) attrs.get("pmThreshold").get();
            int k = Integer.valueOf(sK).intValue();
            attr = attrs.get("pmTask");
            if (attr == null) {
                return successPacket();
            }
            int n = attr.size();
            if (n <= k) {
                return successPacket();
            }

            // Check whether any user is authorized to more than k tasks out of
            // the n
            // this constraint has.
            // Create a hash map where the key is the user id, initially empty.
            // The value of an entry is the number of tasks in the constraint
            // the key user is authorized for.
            HashMap<String, String> hmSconUsers = new HashMap<String, String>();

            // We need to maintain the set of users authorized for a task.
            HashSet<String> hsTaskUsers = new HashSet<String>();

            // For each task in the constraint
            for (NamingEnumeration<?> attrEnum = attr.getAll(); attrEnum.hasMore(); ) {
                String sTaskId = (String) attrEnum.next();

                System.out.println("For task " + sTaskId + "="
                        + getEntityName(sTaskId, PM_TASK));

                // Empty the set of users authorized for the task.
                hsTaskUsers.clear();

                // A user is authorized for this task if he's autorized for at
                // least
                // one of the task's capabilities.
                // Get the task's capabilities.
                Attributes taskAttrs = ctx.getAttributes("CN=" + sTaskId + ","
                        + sTaskContainerDN);
                Attribute taskAttr = taskAttrs.get("pmCap");
                if (taskAttr != null) {
                    for (NamingEnumeration<?> capEnum = taskAttr.getAll(); capEnum.hasMore(); ) {
                        String sCap = (String) capEnum.next();
                        System.out.println("  For capability " + sCap);
                        // Split the cap on commas.
                        String[] pieces = sCap.split(PM_LIST_MEMBER_SEP);
                        // pieces[0] is the op name.
                        // pieces[1] is the obj id.
                        // pieces[2] is the pc id.
                        // Get the users with this capability, but first get the
                        // oattr
                        // associated to the object.
                        String sAssocId = getAssocOattr(pieces[1]);
                        HashSet<String> hsCapUsers = getUsersWithObjCap(
                                pieces[0], sAssocId, pieces[2]);
                        System.out.println("    Found users:");

                        // For each user in hsCapUsers
                        // if the user is not already in hsTaskUsers then
                        // update its number of authorized tasks in hmSconUsers
                        // if its number is greater than k exit with false;
                        // insert the user into hsTaskUsers.
                        Iterator<String> iter = hsCapUsers.iterator();
                        while (iter.hasNext()) {
                            String sUserId = iter.next();
                            System.out.println("      " + sUserId + "="
                                    + getEntityName(sUserId, PM_NODE_USER));

                            if (hsTaskUsers.contains(sUserId)) {
                                System.out.println("        already in the task users.");
                                continue;
                            }

                            // The user is new within the users authorized for
                            // the task.
                            // Get his/her number of tasks from hmSconUsers. If
                            // he's not
                            // in hmSconUsers, consider his number of authorized
                            // tasks as 0.
                            String sNumber = hmSconUsers.get(sUserId);
                            if (sNumber == null) {
                                sNumber = "0";
                            }
                            int number = Integer.valueOf(sNumber).intValue();
                            System.out.println("        not in the task users. His number of tasks is "
                                    + number);

                            // If he's already authorized to k tasks, with the
                            // current task that'll
                            // make k+1, so return false.
                            if (number >= k) {
                                return failurePacket("User "
                                        + getEntityName(sUserId, PM_NODE_USER)
                                        + " is authorized to more than " + k
                                        + " tasks in constraint "
                                        + getEntityName(sSconId, PM_SCON) + ".");
                            }

                            // Update his number of authorized tasks.
                            sNumber = String.valueOf(++number);
                            hmSconUsers.put(sUserId, sNumber);

                            // Add him to the task users too.
                            hsTaskUsers.add(sUserId);
                            System.out.println("          been updated to "
                                    + number
                                    + " in hmSconUsers and the user added to hsTaskUsers");
                        }
                    }
                }
            }
        } catch (Exception e) {
            e.printStackTrace();
            return failurePacket("Exception: " + e.getMessage());
        }
        return successPacket();
    }

    // Delete static constraint. Second parameter is the constraint id.
    // Third parameter is the name of the task to be deleted.
    // The task name can be null, and that means to delete the entire
    // constraint.
    private Packet deleteScon(String sSessId, String sSconId, String sTask) {
        if (sSconId == null || sSconId.length() == 0) {
            return failurePacket("The static constraint id cannot be null or empty!");
        }

        String sSconName = getEntityName(sSconId, PM_SCON);
        if (sSconName == null) {
            return failurePacket("Unknown constraint id " + sSconId + "!");
        }

        if (sTask == null || sTask.length() == 0) {
            // No task was selected, try to delete the entire constraint.
            try {
                ctx.destroySubcontext("CN=" + sSconId + "," + sSconContainerDN);
            } catch (Exception e) {
                if (debugFlag) {
                    e.printStackTrace();
                }
                return failurePacket("Error while deleting constraint "
                        + sSconName + ": " + e.getMessage());
            }
        } else {
            // A task of the constraint is also selected. Delete the task only.
            String sTaskId = getEntityId(sTask, PM_TASK);
            if (sTaskId == null) {
                return failurePacket("Unkown task " + sTask + " in constraint!");
            }
            ModificationItem[] mods = new ModificationItem[1];
            mods[0] = new ModificationItem(DirContext.REMOVE_ATTRIBUTE,
                    new BasicAttribute("pmTask", sTaskId));
            try {
                ctx.modifyAttributes("CN=" + sSconId + "," + sSconContainerDN,
                        mods);
            } catch (Exception e) {
                if (debugFlag) {
                    e.printStackTrace();
                }
                return failurePacket("Error while deleting task " + sTask
                        + ": " + e.getMessage());
            }
        }
        return successPacket();
    }

    // Returns:
    // item 0: <scon name>:<scon id>
    // item 1: <scon threshold> (that integer k).
    // item 2: <task name>:<task id>
    // item 3: <task name>:<task id>
    // ...
    private Packet getSconInfo(String sSessId, String sSconId) {
        Packet result = new Packet();
        Attributes attrs;
        Attribute attr;

        try {
            attrs = ctx.getAttributes("CN=" + sSconId + "," + sSconContainerDN);

            // First insert the scon name and id.
            String sSconName = (String) attrs.get("pmName").get();
            result.addItem(ItemType.RESPONSE_TEXT, sSconName + PM_FIELD_DELIM
                    + sSconId);

            // Now the threshold k.
            String sK = (String) attrs.get("pmThreshold").get();
            result.addItem(ItemType.RESPONSE_TEXT, sK);

            // Get the constraint's tasks.
            attr = attrs.get("pmTask");
            if (attr != null) {
                for (NamingEnumeration<?> attrEnum = attr.getAll(); attrEnum.hasMore(); ) {
                    String sTaskId = (String) attrEnum.next();
                    // FInd task's name.
                    String sTaskName = getEntityName(sTaskId, PM_TASK);
                    // Prepare the string to return.
                    result.addItem(ItemType.RESPONSE_TEXT, sTaskName
                            + PM_FIELD_DELIM + sTaskId);
                }
            }
            return result;
        } catch (Exception e) {
            e.printStackTrace();
            return failurePacket("Exception in getSconInfo(): "
                    + e.getMessage());
        }
    }

    // Get all constraints. Each item returned contains
    // <constraint name>:<constraint id>.
    private Packet getScons(String sSessId) {
        Packet result = new Packet();
        NamingEnumeration<?> scons;

        try {
            SearchControls constraints = new SearchControls();
            constraints.setSearchScope(SearchControls.ONELEVEL_SCOPE);
            constraints.setReturningAttributes(new String[]{"pmId", "pmName"});
            scons = ctx.search(sSconContainerDN, "(objectClass=*)", constraints);

            while (scons != null && scons.hasMore()) {
                SearchResult sr = (SearchResult) scons.next();
                String sName = (String) sr.getAttributes().get("pmName").get();
                String sId = (String) sr.getAttributes().get("pmId").get();
                result.addItem(ItemType.RESPONSE_TEXT, sName + PM_FIELD_DELIM
                        + sId);
            }
            return result;

        } catch (CommunicationException e) {
            if (debugFlag) {
                e.printStackTrace();
            }
            return failurePacket("AD connection error");
        } catch (Exception e) {
            if (debugFlag) {
                e.printStackTrace();
            }
            return failurePacket("Exception: " + e.getMessage());
        }
    }

    // Add a new static constraint or a new task to en existing constraint.
    // For constraints, see the documentation.
    private Packet addScon(String sSessId, String sSconName, String sK,
                           String sTaskName) {
        boolean newscon = false;
        String sSconId = getEntityId(sSconName, PM_SCON);
        if (sSconId == null) {
            // NEW STATIC CONSTRAINT.
            // K cannot be null.
            if (sK == null || sK.length() == 0) {
                return failurePacket("Threshold k cannot be null!");
            }
            // Convert k from string to integer.
            int k = Integer.valueOf(sK).intValue();
            if (k < 0) {
                return failurePacket("Invalid value for threshold k!");
            }

            newscon = true;
            Attributes attrs = new BasicAttributes(true);
            RandomGUID myGUID = new RandomGUID();
            sSconId = myGUID.toStringNoDashes();
            attrs.put("objectClass", sSconClass);
            attrs.put("pmId", sSconId);
            attrs.put("pmName", sSconName);
            attrs.put("pmThreshold", sK);
            try {
                ctx.bind("CN=" + sSconId + "," + sSconContainerDN, null, attrs);
            } catch (Exception e) {
                e.printStackTrace();
                return failurePacket("Unable to create static constraint \""
                        + sSconName + "\"");
            }
        }

        // SCON EXISTS.
        // Prepare the return, <scon name>:<scon id>.
        Packet okResult = new Packet();
        try {
            okResult.addItem(ItemType.RESPONSE_TEXT, sSconName + PM_FIELD_DELIM
                    + sSconId);
        } catch (Exception e) {
            e.printStackTrace();
            return failurePacket("Exception when building the result packet");
        }

        // Task cannot be null if the constraint already existed.
        if (sTaskName == null) {
            if (newscon) {
                return okResult;
            } else {
                return failurePacket("Task cannot be null!");
            }
        }

        // Task must exist.
        String sTaskId = getEntityId(sTaskName, PM_TASK);
        if (sTaskId == null) {
            return failurePacket(sTaskName + " is not a task!");
        }

        // Add the task to the constraint.
        ModificationItem[] mods = new ModificationItem[1];
        mods[0] = new ModificationItem(DirContext.ADD_ATTRIBUTE,
                new BasicAttribute("pmTask", sTaskId));
        try {
            ctx.modifyAttributes("CN=" + sSconId + "," + sSconContainerDN, mods);
        } catch (Exception e) {
            e.printStackTrace();
            return failurePacket("Unable to add task \"" + sTaskName + "\": "
                    + e.getMessage());
        }

        // Now check the constraint.
        Packet res =  checkScon(sSconId);
        if (res.hasError()) {
            // Roll back the task addition.
            mods[0] = new ModificationItem(DirContext.REMOVE_ATTRIBUTE,
                    new BasicAttribute("pmTask", sTaskId));
            String sErr = res.getErrorMessage();
            try {
                ctx.modifyAttributes("CN=" + sSconId + "," + sSconContainerDN,
                        mods);
            } catch (Exception e) {
                e.printStackTrace();
                return failurePacket(sErr
                        + " Unable to roll back task addition!");
            }
            return failurePacket(sErr + " Task addition has been rolled back!");
        }
        return okResult;
    }

    // DeleteTask(). Second parameter is the task id. Third parameter is
    // the capability to be deleted in the format: <op name>,<obj name>,<pc
    // name>.
    // The capability can be null, and that means to delete the entire task.
    private Packet deleteTask(String sSessId, String sTaskId, String sCap) {
        if (sTaskId == null || sTaskId.length() == 0) {
            return failurePacket("The task id cannot be null or empty!");
        }

        String sTaskName = getEntityName(sTaskId, PM_TASK);
        if (sTaskName == null) {
            return failurePacket("Unknown task id " + sTaskId + "!");
        }

        if (sCap == null || sCap.length() == 0) {
            // No capability was selected, try to delete the entire task.
            try {
                ctx.destroySubcontext("CN=" + sTaskId + "," + sTaskContainerDN);
            } catch (Exception e) {
                if (debugFlag) {
                    e.printStackTrace();
                }
                return failurePacket("Error while deleting task " + sTaskName
                        + ": " + e.getMessage());
            }
        } else {
            // A capability of the task is also selected. Delete the capability
            // only,
            // but first build the capability <op name>,<ocont name>:<ocont
            // id>,<pc name>:<pc id>.
            String[] pieces = sCap.split(PM_LIST_MEMBER_SEP);
            // pieces[0] is the op name.
            // pieces[1] is the ocont name.
            String sOcontId = getEntityId(pieces[1], PM_NODE_OATTR);
            if (sOcontId == null) {
                return failurePacket("Unkown container " + pieces[1]
                        + " in capability!");
            }
            // pieces[2] is the pc name.
            String sPcId = getEntityId(pieces[2], PM_NODE_POL);
            if (sPcId == null) {
                return failurePacket("Unkown policy " + pieces[2]
                        + " in capability!");
            }

            String sTrueCap = pieces[0] + PM_LIST_MEMBER_SEP + sOcontId
                    + PM_LIST_MEMBER_SEP + sPcId;
            ModificationItem[] mods = new ModificationItem[1];
            mods[0] = new ModificationItem(DirContext.REMOVE_ATTRIBUTE,
                    new BasicAttribute("pmCap", sTrueCap));
            try {
                ctx.modifyAttributes("CN=" + sTaskId + "," + sTaskContainerDN,
                        mods);
            } catch (Exception e) {
                if (debugFlag) {
                    e.printStackTrace();
                }
                return failurePacket("Error while deleting capability "
                        + sTrueCap + ": " + e.getMessage());
            }
        }
        return successPacket();
    }

    // Returns:
    // item 0: <task name>:<task id>
    // item 1,...: the capabilities in the format:
    // <op name>,<ocont name>:<ocont id>,<pc name>:<pc id>
    private Packet getTaskInfo(String sSessId, String sTaskId) {
        Packet result = new Packet();
        Attributes attrs;
        Attribute attr;

        try {
            attrs = ctx.getAttributes("CN=" + sTaskId + "," + sTaskContainerDN);

            // First insert the task name and id.
            String sTaskName = (String) attrs.get("pmName").get();
            result.addItem(ItemType.RESPONSE_TEXT, sTaskName + PM_FIELD_DELIM
                    + sTaskId);

            // Get the task's caps.
            attr = attrs.get("pmCap");
            if (attr != null) {
                for (NamingEnumeration<?> attrEnum = attr.getAll(); attrEnum.hasMore(); ) {
                    String sCap = (String) attrEnum.next();
                    System.out.println(sCap);
                    // Split the cap on commas.
                    String[] pieces = sCap.split(PM_LIST_MEMBER_SEP);
                    // pieces[0] is the op name.
                    // pieces[1] is the ocont id. Find its name.
                    String sOcontName = getEntityName(pieces[1], PM_NODE_OATTR);
                    // pieces[2] is the pc id. Find its name.
                    String sPcName = getEntityName(pieces[2], PM_NODE_POL);
                    // Prepare the string to return.
                    result.addItem(ItemType.RESPONSE_TEXT, pieces[0]
                            + PM_LIST_MEMBER_SEP + sOcontName + PM_FIELD_DELIM
                            + pieces[1] + PM_LIST_MEMBER_SEP + sPcName
                            + PM_FIELD_DELIM + pieces[2]);
                }
            }
            return result;
        } catch (Exception e) {
            e.printStackTrace();
            return failurePacket("Exception in getTaskInfo(): "
                    + e.getMessage());
        }
    }

    // Get all tasks. Each item returned contains <task name>:<task id>.
    private Packet getTasks(String sSessId) {
        Packet result = new Packet();
        NamingEnumeration<?> tasks;

        try {
            SearchControls constraints = new SearchControls();
            constraints.setSearchScope(SearchControls.ONELEVEL_SCOPE);
            constraints.setReturningAttributes(new String[]{"pmId", "pmName"});
            tasks = ctx.search(sTaskContainerDN, "(objectClass=*)", constraints);

            while (tasks != null && tasks.hasMore()) {
                SearchResult sr = (SearchResult) tasks.next();
                String sName = (String) sr.getAttributes().get("pmName").get();
                String sId = (String) sr.getAttributes().get("pmId").get();
                result.addItem(ItemType.RESPONSE_TEXT, sName + PM_FIELD_DELIM
                        + sId);
            }
            return result;

        } catch (CommunicationException e) {
            if (debugFlag) {
                e.printStackTrace();
            }
            return failurePacket("AD connection error");
        } catch (Exception e) {
            if (debugFlag) {
                e.printStackTrace();
            }
            return failurePacket("Exception: " + e.getMessage());
        }
    }

    // Add a new task or add a new capability to en existing task.
    private Packet addTask(String sSessId, String sTaskName, String sOpName,
                           String sOcontName, String sPcName) {
        boolean newtask = false;
        String sTaskId = getEntityId(sTaskName, PM_TASK);
        if (sTaskId == null) {
            // No such task, must be created.
            newtask = true;
            Attributes attrs = new BasicAttributes(true);
            RandomGUID myGUID = new RandomGUID();
            sTaskId = myGUID.toStringNoDashes();
            attrs.put("objectClass", sTaskClass);
            attrs.put("pmId", sTaskId);
            attrs.put("pmName", sTaskName);
            try {
                ctx.bind("CN=" + sTaskId + "," + sTaskContainerDN, null, attrs);
            } catch (Exception e) {
                e.printStackTrace();
                return failurePacket("Unable to create task \"" + sTaskName
                        + "\"");
            }
        }

        // Task now exists. Add (op, ocont, pc) - if not null - to the task.
        Packet result = new Packet();
        try {
            result.addItem(ItemType.RESPONSE_TEXT, sTaskName + PM_FIELD_DELIM
                    + sTaskId);
        } catch (Exception e) {
            e.printStackTrace();
            return failurePacket("Exception when building the result packet");
        }
        if (sOpName == null) {
            if (newtask) {
                return result;
            } else {
                return failurePacket("Operation cannot be null!");
            }
        }

        // Operation must exist.
        if (!isOperation(sOpName)) {
            return failurePacket(sOpName + " is not an operation!");
        }

        // The object container must exist.
        String sOcontId = getEntityId(sOcontName, PM_NODE_OATTR);
        if (sOcontId == null) {
            return failurePacket("Container name is either null or is unknown!");
        }

        // The pc must exist.
        String sPcId = getEntityId(sPcName, PM_NODE_POL);
        if (sPcId == null) {
            return failurePacket("Policy name is either null or is unknown!");
        }

        ModificationItem[] mods = new ModificationItem[1];
        mods[0] = new ModificationItem(DirContext.ADD_ATTRIBUTE,
                new BasicAttribute("pmCap", sOpName + "," + sOcontId + ","
                        + sPcId));
        try {
            ctx.modifyAttributes("CN=" + sTaskId + "," + sTaskContainerDN, mods);
        } catch (Exception e) {
            e.printStackTrace();
            return failurePacket("Unable to add capability \"" + sOpName + ","
                    + sOcontName + "," + sPcName + "\"!");
        }
        return result;
    }

    // The function setPerms() tries to create or update a set of operations and
    // establish a double assignment ua -> opset -> oa.
    //
    // Algorithm for setting permissions
    // Input:
    // Ua: the uattr we grant permissions.
    // TheOpset: the operation set we want to update.
    // SuggOa: the suggested object attribute to assign the opset to. May be
    // null.
    // SuggBase: the suggested container (object attribute or policy) to contain
    // the object attribute to assign the opset to. May be null.
    // Ent: the entity on which we grant permissions.
    // Opers: the operations for the permissions we grant.
    // IncludesAscs: true when the admin permissions need to be set on a
    // sub-graph
    // Including the entities ascendants.
    // Return value:
    // true (success) or false (failure).
    // Pseudo-code:
    // Boolean SetPerms(Ua, TheOpset, SuggOa, SuggBase, Ent, Opers, IncludeAscs)
    // {
    // If (Ua == null || Ua does not exist) return false;
    // If (TheOpset != null && TheOpset does not exist) return false;
    // If (Ent == null || Ent does not exist) return false;
    // If (SuggBase != null && SuggBase does not exist) return false;
    // If (SuggBase != null && SuggBase.type != oattr && SuggBase.type !=
    // policy)
    // return false;
    // If (SuggOa != null && SuggOa does not exist) return false;
    // // If we have an opset to upate, then update it with the operations.
    // // We ignore all other params, although we should check some conditions
    // If (TheOpset != null) {
    // TheOpset.operations = Opers;
    // Return true;
    // }
    // // We need to separate the admin operations from the i/o operations.
    // Set AdminOpers = Opers - FilePerms 4 DirPerms;
    // Set IoOpers = Opers - adminOpers;
    // // First, the case when the entity is an object that represents a PM
    // // sub-graph.
    // If (Ent.type == PM_NODE_ASSOC && Ent is a rep object) {
    // // Ignore the i/o operations and create an opset with the admin
    // operations
    // // between Ua and Ent.
    // If (AdminOpers g ) {
    // Create opset TheOpset with TheOpset.operations = AdminOpers;
    // Assign Ua t TheOpset t Ent;
    // }
    // Return true;
    // }
    //
    // // Now the entity can be a File object, an object attribute, a policy,
    // // a user, a user attribute, the connector, or an operation set.
    //
    // // The i/o operations are allowed only on an object attribute or File
    // object.
    // If (Ent.type == PM_NODE_ASSOC || Ent.type == PM_NODE_OATTR) {
    // If (IoOpers g ) {
    // Create opset TheOpset with TheOpset.operations = IoOpers;
    // Assign Ua t TheOpset t Ent;
    // }
    // }
    //
    // // Let's process the admin operations.
    // If (AdminOpers == ?) return true;
    //
    // // First get an existing object or create one that represents the entity.
    // Oattr RepOa = getOrCreateOaRepresentingEntity(Ent, SuggOa, SuggBase,
    // IncludesAscs);
    // If (RepOa == null) return false;
    // CreateOpseBetween(AdminOpers, Ua, RepOa);
    // Return true;
    // }
    //
    // Oattr getOrCreateOaRepresentingEntity(Ent, SuggOa, SuggBase,
    // IncludesAscs) {
    // // If the suggested oattr is null
    // If (SuggOa == null) {
    // // If suggested base is null, find an oattr that represents the subgraph
    // // specified by the entity and IncludesAscs.
    // // Otherwise, create an oattr within the suggested base that represents
    // // the subgraph specified by the entity and IncludesAscs.
    // If (SuggBase == null) {
    // Return getOaRepresentingEntity(Ent, IncludesAscs);
    // } else {
    // Return createOaRepresentingEntity(Ent, SuggBase, IncludesAscs);
    // }
    // }
    // The suggested oattr is not null. Use it if it represents
    // the entity and ignore the suggested base. Otherwise, return null.
    // If (oaRepresentsEntity(SuggOa, Ent, IncludesAscs)) return SuggOa;
    // Return null;
    // }
    private Packet setPerms(String sSessId, String sProcId, String sUattrName,
                            String sOpsetName, String sSuggOattr, String sSuggBase,
                            String sSuggBaseType, String sOpers, String sEntName,
                            String sEntType, String sIncludesAscs) {
        System.out.println("Uattr: " + sUattrName);
        System.out.println("Opset: " + sOpsetName);
        System.out.println("Suggested oattr: " + sSuggOattr);
        System.out.println("Suggested base: " + sSuggBase);
        System.out.println("Perms: " + sOpers);
        System.out.println("Entity: " + sEntName + "(" + sEntType + ")");
        System.out.println("Ascendants: " + sIncludesAscs);

        boolean isSubgraph = sIncludesAscs.equalsIgnoreCase("yes");

        String sUattrId = getEntityId(sUattrName, PM_NODE_UATTR);
        if (sUattrId == null) {
            return failurePacket("No user attribute " + sUattrName);
        }

        String sEntId = getEntityId(sEntName, sEntType);
        if (sEntId == null) {
            return failurePacket("No entity " + sEntName + " of type "
                    + sEntType);
        }

        String sSuggBaseId = null;
        if (sSuggBase != null) {
            sSuggBaseId = getEntityId(sSuggBase, sSuggBaseType);
            if (sSuggBaseId == null) {
                return failurePacket("No such suggested base " + sSuggBase);
            }
        }

        String sSuggOattrId = null;
        if (sSuggOattr != null) {
            sSuggOattrId = getEntityId(sSuggOattr, PM_NODE_OATTR);
            if (sSuggOattrId == null) {
                return failurePacket("No such suggested object attribute "
                        + sSuggOattr);
            }
        }

        /*
         * HashSet hs = getEntityDirectRepOattrs(sEntId, sEntType,
         * sIncludesAscs.equalsIgnoreCase("yes")); printSet(hs, PM_PERM,
         * "Direct representatives of entity " + sEntName);
         */

        // If the opset name is specified, simply set its permissions equal to
        // sPerms.
        if (sOpsetName != null) {
            System.out.println("Opset name specified, set its operations to "
                    + sOpers);
            String sOpsetId = getEntityId(sOpsetName, PM_NODE_OPSET);
            if (sOpsetId == null) {
                return failurePacket("No operation set " + sOpsetName);
            }

            // Set the opset permissions as specified by sPerms.
            setOpsetOps(sOpsetId, sOpers);
            return successPacket();
        }

        // No opset name specified. We treat I/O and admin operations
        // differently,
        // so get the set of all I/O operations if you didn't already do so.
        if (allIoOpers == null) {
            allIoOpers = new HashSet<String>();
            for (int i = 0; i < sDirOps.length; i++) {
                allIoOpers.add(sDirOps[i]);
            }
            for (int i = 0; i < sFileOps.length; i++) {
                allIoOpers.add(sFileOps[i]);
            }
        }

        // Split the set of operations into I/O and administrative operations.
        HashSet<String> adminOpers = stringToSet(sOpers);
        adminOpers.removeAll(allIoOpers);
        printSet(adminOpers, PM_PERM,
                "Trying to set administrative operations on " + sEntName
                        + " for " + sUattrName);

        HashSet<String> ioOpers = stringToSet(sOpers);
        ioOpers.retainAll(allIoOpers);
        printSet(ioOpers, PM_PERM, "Trying to set I/O operations on "
                + sEntName + " for " + sUattrName);

        Packet res;
        if (sEntType.equalsIgnoreCase(PM_NODE_ASSOC)) {
            if (oattrRepresentsAnEntity(sEntId)) {
                // The entity is an object attribute associated to an object
                // that represents some entity or subgraph.
                // We ignore the I/O operations and set only the admin
                // operations
                // in a new opset.
                if (adminOpers.isEmpty()) {
                    return successPacket();
                }
                res =  createOpsetBetween(sSessId, sProcId, adminOpers,
                        sUattrId, sEntId);
                if (res.hasError()) {
                    return res;
                }
                return successPacket();
            }
        }

        // Now the entity is an object attribute associated to a File/Dir
        // object,
        // or an object attribute not associated, or the connector node, or a
        // policy
        // class, or a user attribute, or a user. The I/O operations are allowed
        // only on an object attribute.
        if (sEntType.equalsIgnoreCase(PM_NODE_ASSOC)
                || sEntType.equalsIgnoreCase(PM_NODE_OATTR)) {
            if (!ioOpers.isEmpty()) {
                res =  createOpsetBetween(sSessId, sProcId, ioOpers,
                        sUattrId, sEntId);
                if (res.hasError()) {
                    return res;
                }
            }
        }

        // Now process the administrative operations.
        if (adminOpers.isEmpty()) {
            return successPacket();
        }

        // First get an existing or create a representative object attribute
        // for the entity, according to isSubgraph.
        String sRepOaId = getOrCreateOattrRepresentingEntity(sEntId, sEntType,
                sSuggOattrId, sSuggBaseId, sSuggBaseType, isSubgraph);

        if (sRepOaId == null) {
            return failurePacket("Could not find or create a suitable representative object for entity "
                    + sEntName);
        }

        res =  createOpsetBetween(sSessId, sProcId, adminOpers,
                sUattrId, sRepOaId);
        if (res.hasError()) {
            return res;
        }
        return successPacket();
    }

    /**
	 * @uml.property  name="allIoOpers"
	 */
    HashSet<String> allIoOpers = null;

    // This function finds or creates an object attribute associated to an
    // object that represents a given entity/subgraph.
    //
    // if (suggested oattr and base are both null) {
    // if (an object attribute oa that represents the entity or its subgraph
    // exists) return oa;
    // else return null.
    // } else if (suggested oattr is not null and the suggested base is null) {
    // if (suggested oattr represents the entity or its subgraph) return
    // suggested oattr;
    // else return null.
    // } else if (suggested oattr is null and the suggested base is not null) {
    // create an object representing the entity or its subgraph within the
    // suggested base;
    // return the associated oattr;
    // } else {
    // return null;
    // }
    private String getOrCreateOattrRepresentingEntity(String sEntId,
                                                      String sEntType, String sSuggOattrId, String sSuggBaseId,
                                                      String sSuggBaseType, boolean isSubgraph) {
        String sRepOaId;

        if (sSuggOattrId == null) {
            if (sSuggBaseId == null) {
                System.out.println("Suggested oattr = null, suggested base = null");
                // Try to find an oattr that represents the entity or subgraph.
                sRepOaId = getOattrRepresentingEntity(sEntId, sEntType,
                        isSubgraph);
                System.out.println("Got oattr "
                        + getEntityName(sRepOaId, PM_NODE_OATTR)
                        + " representing entity "
                        + getEntityName(sEntId, sEntType));
                return sRepOaId;
            } else {
                // We have a suggested base. Create an oattr that represents the
                // entity
                // according to isSubgraph in the suggested base.

                sRepOaId = createOattrRepresentingEntity(sSuggBaseId,
                        sSuggBaseType, sEntId, sEntType, isSubgraph);
                return sRepOaId;
            }
        } else {
            // We have a suggested object attribute. We'll use it only if it
            // represents
            // our entity. We don't care about the suggested base.
            // When invoked from the admin tool, this case doesn't take place,
            // because the opset is also selected, so the opset will get
            // updated.
            if (oattrRepresentsThisEntity(sSuggOattrId, sEntId, sEntType,
                    isSubgraph)) {
                System.out.println("Oattr " + sSuggOattrId
                        + " represents the entity or subgraph!");
                return sSuggOattrId;
            } else {
                System.out.println("Oattr " + sSuggOattrId
                        + " does not represent the entity or subgraph!");
            }
        }
        return null;
    }

    // Return first oattr (if any) you find associated to an object that
    // represents
    // the entity according to isSubgraph.
    private String getOattrRepresentingEntity(String sEntId, String sEntType,
                                              boolean isSubgraph) {
        // Search PmVirtualObjContainer for objects x such that:
        // x represents a PM entity and
        // x.origid = entity.id and
        // x.includesAscs = isSubgraph
        String sObjId;
        NamingEnumeration<?> objects;
        try {
            SearchControls constraints = new SearchControls();
            constraints.setSearchScope(SearchControls.ONELEVEL_SCOPE);
            constraints.setReturningAttributes(new String[]{"pmId",
                    "pmOriginalId", "pmIncludesAscendants"});
            objects = ctx.search(sVirtualObjContainerDN, "(objectClass=*)",
                    constraints);
            while (objects != null && objects.hasMore()) {
                SearchResult sr = (SearchResult) objects.next();
                Attributes attrs = sr.getAttributes();
                sObjId = (String) attrs.get("pmId").get();
                Attribute attr = attrs.get("pmOriginalId");
                if (attr == null) {
                    continue;
                }
                String sOrigId = (String) attr.get();
                if (!sOrigId.equalsIgnoreCase(sEntId)) {
                    continue;
                }
                attr = attrs.get("pmIncludesAscendants");
                if (((String) attr.get()).equalsIgnoreCase("TRUE") == isSubgraph) {
                    String sOattrId = getAssocOattr(sObjId);
                    if (sOattrId == null) {
                        continue;
                    }
                    return sOattrId;
                }
            }
        } catch (Exception e) {
            if (debugFlag) {
                e.printStackTrace();
            }
        }
        return null;
    }

    // Returns true iff the oattr is associated to an object that represents
    // the PM entity or subgraph, according to the param isSubgraph.
    private boolean oattrRepresentsThisEntity(String sOattrId, String sEntId,
                                              String sEntType, boolean isSubgraph) {
        // Get the assoc object, if any.
        String sObjId = getAssocObj(sOattrId);
        if (sObjId == null) {
            return false;
        }
        // Test whether pmOriginalId == sEntId.
        try {
            Attributes attrs = ctx.getAttributes("CN=" + sObjId + ","
                    + sVirtualObjContainerDN);
            Attribute attr = attrs.get("pmOriginalId");
            if (attr == null) {
                return false;
            }
            String sOrigId = (String) attr.get();
            if (!sOrigId.equalsIgnoreCase(sEntId)) {
                return false;
            }
            // Even when the object represents the entity, the
            // pmIncludesAscendants
            // must have the same value as isSubgraph.
            String sInclAscs = (String) attrs.get("pmIncludesAscendants").get();
            if (isSubgraph) {
                return sInclAscs.equalsIgnoreCase("true");
            } else {
                return sInclAscs.equalsIgnoreCase("false");
            }
        } catch (Exception e) {
            if (debugFlag) {
                e.printStackTrace();
            }
            return false;
        }
    }

    // Returns true iff the oattr is associated to an object that represents
    // a PM entity according to isSubgraph.
    /*
   private boolean oattrRepresentsAnEntity(String sOattrId, boolean isSubgraph) {
   // Get the assoc object, if any.
   String sObjId = getAssocObj(sOattrId);
   if (sObjId == null) {
   return false;
   }
   try {
   Attributes attrs = ctx.getAttributes("CN=" + sObjId + ","
   + sVirtualObjContainerDN);
   // pmOriginalName must be set for representative objects.
   Attribute attr = attrs.get("pmOriginalName");
   if (attr == null) {
   return false;
   }
   // Check pmIncludesAscendants must have the same value as
   // isSubgraph.
   String sInclAscs = (String) attrs.get("pmIncludesAscendants").get();
   if (isSubgraph) {
   return sInclAscs.equalsIgnoreCase("true");
   } else {
   return sInclAscs.equalsIgnoreCase("false");
   }
   } catch (Exception e) {
   if (debugFlag) {
   e.printStackTrace();
   }
   return false;
   }
   }
    */
    // Returns true if the argument is an object that represents a PM entity
    // as needed by AdminVos (i.e., one in {pm} U PC U UA U U U OA).
    private boolean objRepresentsAGraphEntity(String sObjId) {
        try {
            Attributes attrs = ctx.getAttributes("CN=" + sObjId + ","
                    + sVirtualObjContainerDN);
            Attribute attr = attrs.get("pmObjClass");
            if (attr == null || attr.size() <= 0) {
                System.out.println("objReprAnEntity: pmObjClass is null or empty");
                return false;
            }
            String sClass = (String) attr.get();
            System.out.println("objReprAnEntity: sClass is " + sClass);
            if (sClass.equalsIgnoreCase(PM_CLASS_USER_NAME)) {
                return true;
            }
            if (sClass.equalsIgnoreCase(PM_CLASS_UATTR_NAME)) {
                return true;
            }
            if (sClass.equalsIgnoreCase(PM_CLASS_OATTR_NAME)) {
                return true;
            }
            if (sClass.equalsIgnoreCase(PM_CLASS_CONN_NAME)) {
                return true;
            }
            if (sClass.equalsIgnoreCase(PM_CLASS_POL_NAME)) {
                return true;
            }
            return false;
        } catch (Exception e) {
            if (debugFlag) {
                e.printStackTrace();
            }
            return false;
        }
    }

    // Returns true iff the oattr is associated to an object that represents
    // a PM entity.
    private boolean oattrRepresentsAnEntity(String sOattrId) {
        // Get the assoc object, if any.
        String sObjId = getAssocObj(sOattrId);
        if (sObjId == null) {
            return false;
        }
        try {
            Attributes attrs = ctx.getAttributes("CN=" + sObjId + ","
                    + sVirtualObjContainerDN);
            // pmOriginalName must be set for representative objects.
            Attribute attr = attrs.get("pmOriginalName");
            return (attr != null);
        } catch (Exception e) {
            if (debugFlag) {
                e.printStackTrace();
            }
            return false;
        }
    }

    // Create an opset with the operations specified in opSet and insert it
    // between
    // the user attribute and the object attribute. Return the id of the new
    // opset
    // or null in case of error.
    private Packet createOpsetBetween(String sSessId, String sProcId,
                                      HashSet<String> opSet, String sUattrId, String sOattrId) {
        Packet res = null;

        // Check some permissions.
        if (!requestAddOpsetPerms(sSessId, sProcId, sOattrId, PM_NODE_OATTR)) {
            return failurePacket(reqPermsMsg);
        }

        // Generate a name for the operation set.
        Random random = new Random();
        byte[] bytes = new byte[4];
        random.nextBytes(bytes);
        String sOpsetName = byteArray2HexString(bytes);

        // Create an empty opset object between the uattr and oattr.
        Attributes attrs = new BasicAttributes(true);
        RandomGUID myGUID = new RandomGUID();
        String sOpsetId = myGUID.toStringNoDashes();
        attrs.put("objectClass", sOpsetClass);
        attrs.put("pmId", sOpsetId);
        attrs.put("pmName", sOpsetName);
        attrs.put("pmDescription", "Auto opset.");
        attrs.put("pmOtherInfo", "No info.");
        attrs.put("pmObjClass", "Ignored");
        try {
            ctx.bind("CN=" + sOpsetId + "," + sOpsetContainerDN, null, attrs);
        } catch (Exception e) {
            e.printStackTrace();
            return failurePacket("Could not create the opset object: "
                    + e.getMessage());
        }
        res =  addDoubleLink(sOpsetId, PM_NODE_OPSET, sOattrId,
                PM_NODE_OATTR);
        if (res.hasError()) {
            return res;
        }

        // Insert here the permission check.
        if (!requestAssignPerms(sSessId, sProcId, sUattrId, PM_NODE_UATTR,
                sOpsetId, PM_NODE_OPSET)) {
            return failurePacket(reqPermsMsg);
        }

        res =  addDoubleLink(sUattrId, PM_NODE_UATTR, sOpsetId,
                PM_NODE_OPSET);
        if (res.hasError()) {
            return res;
        }

        // Add the operations.
        if (!opSet.isEmpty()) {
            int n = opSet.size();
            ModificationItem[] adds = new ModificationItem[n];
            Iterator<String> iter = opSet.iterator();
            int i = 0;
            while (iter.hasNext()) {
                adds[i++] = new ModificationItem(DirContext.ADD_ATTRIBUTE,
                        new BasicAttribute("pmOp", iter.next()));
            }
            try {
                ctx.modifyAttributes(
                        "CN=" + sOpsetId + "," + sOpsetContainerDN, adds);
            } catch (Exception e) {
                e.printStackTrace();
                return failurePacket("Could not add operations to the opset: "
                        + e.getMessage());
            }
        }
        res = new Packet();
        try {
            res.addItem(ItemType.RESPONSE_TEXT, sOpsetName + PM_FIELD_DELIM
                    + sOpsetId);
        } catch (Exception e) {
            e.printStackTrace();
            return failurePacket("Exception when building the result packet");
        }
        return res;
    }

    // Create a representative object for the specified entity. Assign the
    // associated object attribute to the base node, which can be a policy class
    // or an object attribute.
    // It returns the id of the associated object attribute or null.
    private String createOattrRepresentingEntity(String sBaseId,
                                                 String sBaseType, String sEntId, String sEntType, boolean bInh) {
        // Find a name for the representative object.
        String sEntName = getEntityName(sEntId, sEntType);
        if (sEntName == null) {
            System.out.println("CreateOattrReprresentingEntity: no such entity "
                    + sEntId);
            return null;
        }
        String sPrefix = sEntName + " rep";
        String sObjName = sPrefix;
        int i = 1;
        while (true) {
            String sId = getEntityId(sObjName, PM_NODE_OATTR);
            if (sId == null) {
                break;
            }
            sObjName = sPrefix + " " + i;
            i++;
        }
        String sObjClass = typeToClass(sEntType);
        Packet res =  addObjectInternal(sObjName, null, null,
                "Representative", "No info.", sBaseId, sBaseType, sObjClass,
                null, null, null, sEntName, sEntId, bInh, null, null, null,
                null, null, null, null);
        if (res.hasError()) {
            System.out.println("CreateOattrReprresentingEntity: could not create rep object. "
                    + res.getErrorMessage());
            return null;
        }
        String sLine = res.getStringValue(0);
        String[] pieces = sLine.split(PM_FIELD_DELIM);
        String sAssocId = getAssocOattr(pieces[1]);
        return sAssocId;
    }

    // Set the opset's operations as specified by the list sOps, where the ops
    // are separated by commas.
    private void setOpsetOps(String sOpsetId, String sOps) {
        try {
            // Get the opset's operations and delete them.
            Attributes attrs = ctx.getAttributes("CN=" + sOpsetId + ","
                    + sOpsetContainerDN);
            Attribute attr = attrs.get("pmOp");
            if (attr != null) {
                int n = attr.size();
                ModificationItem[] mods = new ModificationItem[n];
                int i = 0;
                for (NamingEnumeration<?> enumer = attr.getAll(); enumer.hasMore(); ) {
                    mods[i++] = new ModificationItem(
                            DirContext.REMOVE_ATTRIBUTE, new BasicAttribute(
                            "pmOp", (String) enumer.next()));
                }
                ctx.modifyAttributes(
                        "CN=" + sOpsetId + "," + sOpsetContainerDN, mods);
            }

            // Add the new operations.
            if (sOps != null) {
                String[] pieces = sOps.split(",");
                int n = pieces.length;
                ModificationItem[] adds = new ModificationItem[n];
                for (int i = 0; i < n; i++) {
                    adds[i] = new ModificationItem(DirContext.ADD_ATTRIBUTE,
                            new BasicAttribute("pmOp", pieces[i]));
                }
                ctx.modifyAttributes(
                        "CN=" + sOpsetId + "," + sOpsetContainerDN, adds);
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    // Build an object for the clipboard of the session's host.
    // If the clipboard object exists, first delete it.
    //
    // The object attribute passed as argument actually is associated to the
    // object from which we copy a part to the clipboard. It can be null, which
    // means we copy from something that's not (yet) an object.
    //
    // The idea is to create a clipboard object for the session's host, which
    // has exactly the same attributes as the source object (with some
    // exceptions, like when the source object is labeled low (MLS) and the
    // user's level is high; in this case, the clipboard object should be high,
    // because it is created by a high session).
    //
    // If the object attribute passed as argument is null, just create the
    // clipboard object with the connector node as base.
    // If the object attribute passed as argument is not null, copy its
    // assignments to the new clipboard object (include containers, policies,
    // and opsets).
    // Finally, assign the clipboard to the MLS container corresponding to
    // the session's level. This also means that any possible assignment of the
    // clipboard object to another level (assignment that could have been
    // inherited from the object attribute passed as argument) must be deleted.
    // The clipboard object has the name "<host> clipboard".
    // Note. The final step
    // (assignment to MLS container) could be made in an event/response rule
    // for a "create clipboard" event.
    private Packet buildClipboard(String sSessId, String sOattrName) {
        System.out.println("Build clipboard for oattr " + sOattrName);

        // Get the session's host and the clipboard object name.
        String sHost = getSessionHostName(sSessId);
        if (sHost == null) {
            return failurePacket("Couldn't get the session's host name!");
        }
        String sClipName = sHost + " clipboard";

        // If the clipboard object already exists, delete it.
        String sClipObjId = getEntityId(sClipName, PM_OBJ);
        if (sClipObjId != null) {
            deleteObjectStrong(sSessId, sClipObjId);
        }

        // Build the clipboard object on the connector.
        Packet res =  addObjectInternal(sClipName, null, null,
                "Clipboard object for host " + sHost, "None.", PM_CONNECTOR_ID,
                PM_NODE_CONN, PM_CLASS_CLIPBOARD_NAME, null, sHost, null, null,
                null, false, null, null, null, null, null, null, null);
        if (res.hasError()) {
            return res;
        }

        // Get the id of the associated object attribute.
        String sClipId = getEntityId(sClipName, PM_NODE_OATTR);

        // If the source object is specified (its associated oattr - the second
        // argument of this method), we need to copy its assignments to the
        // clipboard object.
        if (sOattrName != null) {
            String sOattrId = getEntityId(sOattrName, PM_NODE_OATTR);
            if (sOattrId == null) {
                return failurePacket("No source object (attribute) for the clipboard!");
            }
            String sObjId = getAssocObj(sOattrId);
            if (sObjId == null) {
                return failurePacket("No source object for the clipboard!");
            }

            // Delete the link clipboard <-> connector.
            res =  deleteDoubleLink(sClipId, PM_NODE_OATTR,
                    PM_CONNECTOR_ID, PM_NODE_CONN);
            if (res.hasError()) {
                return res;
            }

            // Now copy the assignments of sOattrId to the clipboard object.
            copyOattrAssignments(sOattrId, sClipId);
        }

        // Now label the clipboard with the session's level, if the clipboard
        // is in MLS.
        labelClipboard(sSessId, sClipId);

        return successPacket();
    }

    // Labeling the clipboard. In the case of an mls policy, the session
    // could have more than one active attributes in that policy. We must
    // select the "highest" attribute among the actives, and we define
    // "higher" as "being contained in": a > b iff a ->+ b.
    private Packet labelClipboard(String sSessId, String sClipId) {
        System.out.println("Labeling the Clipboard object.");

        // Find whether there is a MLS policy.
        String sMlsPolId = getEntityWithPropInternal(PM_NODE_POL, "type=mls");
        System.out.println("Found policy mls " + sMlsPolId);

        // Find the MLS user attributes that are active in the current session.
        HashSet<String> hs = getPolicyActiveAttributes(sSessId, sMlsPolId);
        // If no such attributes, there is nothing to do.
        if (hs.isEmpty()) {
            return successPacket();
        }

        // Find the highest active attribute in this policy.
        Iterator<String> hsiter = hs.iterator();
        String sHighestId = null;
        String sCrtId;
        while (hsiter.hasNext()) {
            sCrtId = hsiter.next();
            // If this is the first in loop, remember it and continue.
            if (sHighestId == null) {
                sHighestId = sCrtId;
                continue;
            }
            // There is a highest until now, compare crt to highest.
            if (attrIsAscendant(sCrtId, sHighestId, PM_NODE_UATTR)) {
                sHighestId = sCrtId;
            }
        }
        System.out.println("We found the highest active attribute to be "
                + getEntityName(sHighestId, PM_NODE_UATTR));

        // Get the corresponding object attribute, if one exists.
        String sPrefix = "correspondsto=";
        String sProp = getPropertyWithPrefix(sPrefix, sHighestId, PM_NODE_UATTR);
        if (sProp == null) {
            return successPacket();
        }
        String sCorrOattr = sProp.substring(sProp.indexOf(sPrefix)
                + sPrefix.length());
        String sCorrOattrId = getEntityId(sCorrOattr, PM_NODE_OATTR);
        if (sCorrOattrId == null) {
            return failurePacket("No object attribute " + sCorrOattr);
        }
        System.out.println("We found the corresponding oattr to be "
                + sCorrOattr);

        // Need to delete all other clipboard assignments to object attributes
        // of that policy.
        hs = getPolicyAttributesAssigned(sMlsPolId, sClipId);
        if (!hs.isEmpty()) {
            hsiter = hs.iterator();
            while (hsiter.hasNext()) {
                sCrtId = hsiter.next();
                // Delete sClipId ---> sCrtId.
                System.out.println("Trying to delete clipboard assignment to "
                        + getEntityName(sCrtId, PM_NODE_OATTR));
                Packet res =  deleteDoubleLink(sClipId, PM_NODE_OATTR,
                        sCrtId, PM_NODE_OATTR);
                if (res.hasError()) {
                    return res;
                }
            }
        }

        // Add sClipId ---> sCorrOattrId.
        System.out.println("Trying to add clipboard assignment to "
                + sCorrOattr);
        Packet res =  addDoubleLink(sClipId, PM_NODE_OATTR,
                sCorrOattrId, PM_NODE_OATTR);
        if (res.hasError()) {
            return res;
        }
        return successPacket();
    }

    // Get a string with the type and names of the containers of an object
    // attribute identified by its id. The containers include other object
    // attributes, policy classes, and the connector node.
    // An example of the result: "b|Med Records,p|DAC,c|PM".
    private String getOattrContainers(String sOattrId) {
        StringBuffer sb = new StringBuffer();
        try {
            boolean first = true;
            String sId;
            String sName;

            // Get the policy classes.
            Attribute attr = getToPolicies(sOattrId, PM_NODE_OATTR);
            if (attr != null) {
                for (NamingEnumeration<?> enumer = attr.getAll(); enumer.hasMore(); ) {
                    sId = (String) enumer.next();
                    sName = getEntityName(sId, PM_NODE_POL);
                    if (first) {
                        sb.append(PM_NODE_POL + "|" + sName);
                        first = false;
                    } else {
                        sb.append("," + PM_NODE_POL + "|" + sName);
                    }
                }
            }

            // Get other object attributes.
            attr = getToAttrs(sOattrId, PM_NODE_OATTR);
            if (attr != null) {
                for (NamingEnumeration<?> enumer = attr.getAll(); enumer.hasMore(); ) {
                    sId = (String) enumer.next();
                    sName = getEntityName(sId, PM_NODE_OATTR);
                    if (first) {
                        sb.append(PM_NODE_OATTR + "|" + sName);
                        first = false;
                    } else {
                        sb.append("," + PM_NODE_OATTR + "|" + sName);
                    }
                }
            }

            // Get the connector.
            attr = getToConnector(sOattrId, PM_NODE_OATTR);
            if (attr != null) {
                for (NamingEnumeration<?> enumer = attr.getAll(); enumer.hasMore(); ) {
                    sId = (String) enumer.next();
                    sName = getEntityName(sId, PM_NODE_CONN);
                    if (first) {
                        sb.append(PM_NODE_CONN + "|" + sName);
                        first = false;
                    } else {
                        sb.append("," + PM_NODE_CONN + "|" + sName);
                    }
                }
            }
        } catch (Exception e) {
            if (debugFlag) {
                e.printStackTrace();
            }
            return null;
        }
        return sb.toString();
    }

    // Copy assignments (to policies, to other attributes, or from opsets)
    // from object attribute 1 to object attribute 2.
    private Packet copyOattrAssignments(String sOattrId1, String sOattrId2) {
        Packet res;
        try {
            // Copy links to policy classes.
            Attribute attr = getToPolicies(sOattrId1, PM_NODE_OATTR);
            if (attr != null) {
                for (NamingEnumeration<?> enumer = attr.getAll(); enumer.hasMore(); ) {
                    String sId = (String) enumer.next();

                    System.out.println("Copy assignment "
                            + getEntityName(sOattrId2, PM_NODE_OATTR) + " --> "
                            + getEntityName(sId, PM_NODE_POL));
                    res =  addDoubleLink(sOattrId2, PM_NODE_OATTR, sId,
                            PM_NODE_POL);
                    if (res.hasError()) {
                        return res;
                    }
                }
            }

            // Copy links to other object attributes.
            attr = getToAttrs(sOattrId1, PM_NODE_OATTR);
            if (attr != null) {
                for (NamingEnumeration<?> enumer = attr.getAll(); enumer.hasMore(); ) {
                    String sId = (String) enumer.next();
                    System.out.println("Copy assignment "
                            + getEntityName(sOattrId2, PM_NODE_OATTR) + " --> "
                            + getEntityName(sId, PM_NODE_OATTR));
                    res =  addDoubleLink(sOattrId2, PM_NODE_OATTR, sId,
                            PM_NODE_OATTR);
                    if (res.hasError()) {
                        return res;
                    }
                }
            }

            // Copy links from opsets.
            attr = getFromOpsets(sOattrId1, PM_NODE_OATTR);
            if (attr != null) {
                for (NamingEnumeration<?> enumer = attr.getAll(); enumer.hasMore(); ) {
                    String sId = (String) enumer.next();
                    System.out.println("Copy assignment "
                            + getEntityName(sId, PM_NODE_OPSET) + " --> "
                            + getEntityName(sOattrId2, PM_NODE_OATTR));
                    res =  addDoubleLink(sId, PM_NODE_OPSET, sOattrId2,
                            PM_NODE_OATTR);
                    if (res.hasError()) {
                        return res;
                    }
                }
            }
        } catch (Exception e) {
            if (debugFlag) {
                e.printStackTrace();
            }
            return failurePacket("Exception in copyAssignments: "
                    + e.getMessage());
        }
        return successPacket();
    }

    // Cut all links to/from this attribute. To be called as a command.
    private Packet isolateOattr(String sName, String sType) {
        String sAttrId = getEntityId(sName, sType);
        if (sAttrId == null) {
            return failurePacket("No attribute " + sName + " of type " + sType);
        }
        return isolateOattr(sAttrId);
    }

    private Packet isolateOattr(String sAttrId) {
        Packet res;
        try {
            // Cut link to connector node, if it exists.
            Attribute attr = getToConnector(sAttrId, PM_NODE_OATTR);
            if (attr != null) {
                res =  deleteDoubleLink(sAttrId, PM_NODE_OATTR,
                        PM_CONNECTOR_ID, PM_NODE_CONN);
            }
        } catch (Exception e) {
        }

        try {
            // Cut links to policy classes.
            Attribute attr = getToPolicies(sAttrId, PM_NODE_OATTR);
            if (attr != null) {
                for (NamingEnumeration<?> enumer = attr.getAll(); enumer.hasMore(); ) {
                    String sId = (String) enumer.next();
                    res =  deleteDoubleLink(sAttrId, PM_NODE_OATTR,
                            sId, PM_NODE_POL);
                    if (res.hasError()) {
                        return res;
                    }
                }
            }

            // Cut links to other object attributes.
            attr = getToAttrs(sAttrId, PM_NODE_OATTR);
            if (attr != null) {
                for (NamingEnumeration<?> enumer = attr.getAll(); enumer.hasMore(); ) {
                    String sId = (String) enumer.next();
                    res =  deleteDoubleLink(sAttrId, PM_NODE_OATTR,
                            sId, PM_NODE_OATTR);
                    if (res.hasError()) {
                        return res;
                    }
                }
            }

            // Cut links from opsets.
            attr = getFromOpsets(sAttrId, PM_NODE_OATTR);
            if (attr != null) {
                for (NamingEnumeration<?> enumer = attr.getAll(); enumer.hasMore(); ) {
                    String sId = (String) enumer.next();
                    res =  deleteDoubleLink(sId, PM_NODE_OPSET,
                            sAttrId, PM_NODE_OATTR);
                    if (res.hasError()) {
                        return res;
                    }
                }
            }
        } catch (Exception e) {
            if (debugFlag) {
                e.printStackTrace();
            }
            return failurePacket("Exception in isolateOattr: " + e.getMessage());
        }
        return successPacket();
    }

    // Event Obj id Obj class Ctx1 Ctx2
    // ---------------------------------------------------------------------------
    // Object create obj id File Containers Permissions
    // Object read ? File - -
    // Object write - File Containers -
    // Object delete obj id - Containers assoc id
    // User create user id User - -
    // Object send obj id File Recipient -
    // Session delete sess id Session - -
    //
    // / For "Object delete", Ctx1 contains the containers the deleted object is
    // directly assigned to. Ctx2 contains the id of the associated object
    // attribute.
    // For Object write/read, first get the obj id, Ctx1 and Ctx2.
    private Packet processEvent(String sSessId, String sProcId,
                                String sEventName, String sObjName, String sObjId,
                                String sObjClass, String sObjType, String sCtx1, String sCtx2) {

        System.out.println("processEvent with initial arguments");
        System.out.println("    sessId          = " + sSessId);
        System.out.println("    procId          = " + sProcId);
        System.out.println("    eventName       = " + sEventName);
        System.out.println("    objName         = " + sObjName);
        System.out.println("    objId           = " + sObjId);
        System.out.println("    objClass        = " + sObjClass);
        System.out.println("    objType         = " + sObjType);
        System.out.println("    ctx1            = " + sCtx1);
        System.out.println("    ctx2            = " + sCtx2);

        if (sEventName.equalsIgnoreCase(PM_EVENT_OBJECT_WRITE)
                || sEventName.equalsIgnoreCase(PM_EVENT_OBJECT_READ)) {
            sObjId = getEntityId(sObjName, PM_OBJ);
        } else if (sEventName.equalsIgnoreCase(PM_EVENT_USER_CREATE)) {
            sObjId = getEntityId(sObjName, PM_NODE_USER);
        }

        try {
            if (sEventName.equalsIgnoreCase(PM_EVENT_OBJECT_WRITE)
                    || sEventName.equalsIgnoreCase(PM_EVENT_OBJECT_READ)) {
                String sAssocId = getAssocOattr(sObjId);
                // Get the first level containers where this object is in this
                // moment.
                Attribute attr = getToAttrs(sAssocId, PM_NODE_OATTR);
                StringBuffer sb = new StringBuffer();
                boolean firstTime = true;
                if (attr != null) {
                    for (NamingEnumeration<?> enumer = attr.getAll(); enumer.hasMore(); ) {
                        String sId = (String) enumer.next();
                        if (firstTime) {
                            firstTime = false;
                        } else {
                            sb.append(PM_LIST_MEMBER_SEP);
                        }
                        sb.append(PM_NODE_OATTR + PM_ALT_FIELD_DELIM
                                + getEntityName(sId, PM_NODE_OATTR));
                    }
                }
                if (sb.length() > 0) {
                    sCtx1 = sb.toString();
                }
                sCtx2 = sAssocId;
            }
        } catch (Exception e) {
            if (debugFlag) {
                e.printStackTrace();
            }
            return failurePacket("Exception processing event arguments");
        }

        System.out.println("processEvent with processed arguments");
        System.out.println("    sessId          = " + sSessId);
        System.out.println("    procId          = " + sProcId);
        System.out.println("    eventName       = " + sEventName);
        System.out.println("    objName         = " + sObjName);
        System.out.println("    objId           = " + sObjId);
        System.out.println("    objClass        = " + sObjClass);
        System.out.println("    objType         = " + sObjType);
        System.out.println("    ctx1            = " + sCtx1);
        System.out.println("    ctx2            = " + sCtx2);

        // Get the enabled script. Set the global var sEnabledScriptId
        // because applyActionDeleteRule will us it.
        // The call chain is:
        // processEvent->applyRule->applyAction->applyActionDeleteRule.
        sEnabledScriptId = getEnabledScriptId();
        if (sEnabledScriptId == null) {
            return successPacket();
        }

        Packet res = null;
        try {
            Attributes scriptAttrs = ctx.getAttributes("CN=" + sEnabledScriptId
                    + "," + sRuleContainerDN);
            Attribute attr = scriptAttrs.get("pmFirst");

            EventContext eventCtx = new EventContext(sSessId, sProcId,
                    sEventName, sObjName, sObjClass, sObjType, sObjId, sCtx1,
                    sCtx2);
            while (attr != null) {
                String sRuleId = (String) attr.get();
                res =  matchEvent(eventCtx, sRuleId);
                if (res.hasError()) {
                    System.out.println(res.getErrorMessage());
                } else {
                    System.out.println("...Applying rule " + sRuleId + "!");
                    res =  applyRule(eventCtx, sRuleId);
                    if (res.hasError()) {
                        System.out.println("Error in rule " + sRuleId + ": "
                                + res.getErrorMessage());
                    }
                }
                Attributes ruleAttrs = ctx.getAttributes("CN=" + sRuleId + ","
                        + sRuleContainerDN);
                attr = ruleAttrs.get("pmNext");
            }
        } catch (NameNotFoundException e) {
            // If the rule was deleted by an action???
            if (debugFlag) {
                e.printStackTrace();
            }
        } catch (Exception e) {
            if (debugFlag) {
                e.printStackTrace();
            }
            return failurePacket("Exception looping through rules during event match: "
                    + e.getMessage());
        }
        return successPacket();
    }

    private Packet applyRule(EventContext eventCtx, String sRuleId) {
        try {
            Attributes ruleAttrs = ctx.getAttributes("CN=" + sRuleId + ","
                    + sRuleContainerDN);
            Attribute attr = ruleAttrs.get("pmFirst");
            while (attr != null) {
                String sActionId = (String) attr.get();
                System.out.println("......Applying action " + sActionId + "!");
                Packet res =  applyAction(eventCtx, sActionId);

                // Even when applying the action results in a failure, we may
                // want
                // to continue.
                if (res.hasError()) {
                    System.out.println("ERROR: " + res.getErrorMessage());
                }
                // if (res.hasError()) return result;

                // If this action deleted the rule, extracting the action
                // attributes
                // will result in an exception we can ignore.
                Attributes actAttrs = ctx.getAttributes("CN=" + sActionId + ","
                        + sRuleContainerDN);
                attr = actAttrs.get("pmNext");
            }
        } catch (NameNotFoundException e) {
            e.printStackTrace();
            // return failurePacket("Exception while getting rule actions: " +
            // e.getMessage());
        } catch (Exception e) {
            e.printStackTrace();
            return failurePacket("Exception while getting rule actions: "
                    + e.getMessage());
        }
        return successPacket();
    }

    private Packet applyAction(EventContext eventCtx, String sActionId) {
        try {
            Attributes actAttrs = ctx.getAttributes("CN=" + sActionId + ","
                    + sRuleContainerDN);
            Attribute attr = actAttrs.get("pmCondition");
            if (attr != null) {
                for (NamingEnumeration<?> enumer = attr.getAll(); enumer.hasMore(); ) {
                    String sCondId = (String) enumer.next();
                    Packet res =  checkCondition(eventCtx, sCondId);
                    if (res.hasError()) {
                        return res;
                    }
                }
            }

            String sAct = (String) actAttrs.get("pmType").get();
            if (sAct.equals("assign")) {
                return applyActionAssign(eventCtx, sActionId);
            } else if (sAct.equals("assign like")) {
                return applyActionAssignLike(eventCtx, sActionId);
            } else if (sAct.equals("grant")) {
                return applyActionGrant(eventCtx, sActionId);
            } else if (sAct.equals("create")) {
                return applyActionCreate(eventCtx, sActionId);
            } else if (sAct.equals("deny")) {
                return applyActionDeny(eventCtx, sActionId);
            } else if (sAct.equals("delete assignment")) {
                return applyActionDeassign(eventCtx, sActionId);
            } else if (sAct.equals("delete deny")) {
                return applyActionDeleteDeny(eventCtx, sActionId);
            } else if (sAct.equals("delete rule")) {
                return applyActionDeleteRule(eventCtx, sActionId);
            } else {
                return failurePacket("Unknown action type " + sAct);
            }
        } catch (Exception e) {
            e.printStackTrace();
            return failurePacket("Exception while dispatching event action");
        }
    }

    // When checking conditions, retain all operands, even those that have
    // null name and/or id - this means that the operand looked for does not
    // exist.
    private Packet checkCondition(EventContext eventCtx, String sCondId) {
        try {
            Attributes condAttrs = ctx.getAttributes("CN=" + sCondId + ","
                    + sRuleContainerDN);
            Attribute attr = condAttrs.get("pmOpnd1");
            if (attr == null) {
                return failurePacket("No operand in condition " + sCondId);
            }
            HashSet<ActOpnd> hsOpnd1 = new HashSet<ActOpnd>();
            for (NamingEnumeration<?> enumer = attr.getAll(); enumer.hasMore(); ) {
                String sOpndId = (String) enumer.next();
                // Get the runtime action operand and insert it into the HashSet
                // of
                // first operands. Most often, the run-time operand is the same
                // as the
                // compile-time operand. A function operand at run-time is
                // different.
                ActOpnd[] actOpnds = evalOpnd(eventCtx, sOpndId);
                for (int i = 0; i < actOpnds.length; i++) {
                    hsOpnd1.add(actOpnds[i]);
                }
            }
            printOpndSet(hsOpnd1, "Set of first operands in condition");
            if (hsOpnd1.isEmpty()) {
                return failurePacket("No first operands in condition!?");
            }

            // To date, the only check implemented is whether the operand exists
            // (or
            // does not exist if the condition is negated).
            Iterator<ActOpnd> iter1 = hsOpnd1.iterator();
            attr = condAttrs.get("pmIsNegated");
            boolean isNegated = ((String) attr.get()).equalsIgnoreCase("TRUE");
            while (iter1.hasNext()) {
                if (!isNegated && !condOpndExists(iter1.next())) {
                    return failurePacket("Operand does not exist");
                } else if (isNegated && condOpndExists(iter1.next())) {
                    return failurePacket("Operand exists");
                }
            }
        } catch (Exception e) {
            e.printStackTrace();
            return failurePacket("Exception while dispatching event action");
        }
        return successPacket();
    }

    private boolean condOpndExists(ActOpnd opnd) {
        String sName = opnd.getName();
        String sId = opnd.getId();
        String sType = opnd.getType();
        System.out.println("(((((((((((((Operand " + sName + ", " + sId + ", "
                + sType);
        if (sName == null) {
            return false;
        }
        if (sType == null) {
            return false;
        }
        if (getEntityId(sName, sType) == null) {
            return false;
        }
        return true;
    }

    private Packet applyActionDeleteRule(EventContext eventCtx, String sActionId) {
        try {
            Attributes actAttrs = ctx.getAttributes("CN=" + sActionId + ","
                    + sRuleContainerDN);
            Attribute attr = actAttrs.get("pmOpnd1");

            String sLastError = null;
            ActOpnd[] actOpnds = null;
            String sOpndId = null;

            attr = actAttrs.get("pmOpnd1");
            if (attr == null) {
                return failurePacket("No labels in \"Delete rule(s)\" action "
                        + sActionId);
            }
            HashSet<ActOpnd> hsOpnd1 = new HashSet<ActOpnd>();
            for (NamingEnumeration<?> enumer = attr.getAll(); enumer.hasMore(); ) {
                sOpndId = (String) enumer.next();
                actOpnds = evalOpnd(eventCtx, sOpndId);
                sLastError = actOpnds[0].getError();
                if (sLastError != null) {
                    System.out.println("Last error when evaluating operand 1: "
                            + sLastError);
                    continue;
                }
                for (int i = 0; i < actOpnds.length; i++) {
                    hsOpnd1.add(actOpnds[i]);
                }
            }
            printOpndSet(hsOpnd1, "Set of first operands in \"Delete rule(s)\"");
            if (hsOpnd1.isEmpty()) {
                return failurePacket("No first operands in \"Delete rule(s)\". Last error was: "
                        + sLastError);
            }

            // Delete the rules with the labels specified in hsOpnd1.
            Iterator<ActOpnd> iter1 = hsOpnd1.iterator();

            while (iter1.hasNext()) {
                ActOpnd opnd1 = iter1.next();
                Packet res =  deleteScriptRule(sEnabledScriptId,
                        opnd1.getName());
                if (res.hasError()) {
                    sLastError = res.getErrorMessage();
                }
            }
            if (sLastError != null) {
                return failurePacket(sLastError);
            }

            return successPacket();
        } catch (Exception e) {
            e.printStackTrace();
            return failurePacket("Exception while dispatching event action");
        }
    }

    private Packet applyActionDeassign(EventContext eventCtx, String sActionId) {
        try {
            Attributes actAttrs = ctx.getAttributes("CN=" + sActionId + ","
                    + sRuleContainerDN);
            Attribute attr = actAttrs.get("pmOpnd1");
            if (attr == null) {
                return failurePacket("No operand 1 in \"Delete assignment\" action");
            }
            HashSet<ActOpnd> hsOpnd1 = new HashSet<ActOpnd>();
            String sLastError = null;
            for (NamingEnumeration<?> enumer = attr.getAll(); enumer.hasMore(); ) {
                String sOpndId = (String) enumer.next();
                // Get the runtime action operand and insert it into the HashSet
                // of
                // first operands. Most often, the run-time operand is the same
                // as the
                // compile-time operand. A function operand at run-time is
                // different.
                ActOpnd[] actOpnds = evalOpnd(eventCtx, sOpndId);
                sLastError = actOpnds[0].getError();
                if (sLastError != null) {
                    System.out.println("Last error in evalOpnd was: "
                            + sLastError);
                    continue;
                }
                for (int i = 0; i < actOpnds.length; i++) {
                    hsOpnd1.add(actOpnds[i]);
                }
            }
            printOpndSet(hsOpnd1,
                    "Set of first operands in \"Delete assignment\"");
            if (hsOpnd1.isEmpty()) {
                System.out.println("No first operands in deassign. Last error was: "
                        + sLastError);
                return failurePacket("No first operands in deassign. Last error was: "
                        + sLastError);
            }

            attr = actAttrs.get("pmOpnd2");
            if (attr == null) {
                return failurePacket("No operand 2 in \"Delete assignment\" action");
            }
            HashSet<ActOpnd> hsOpnd2 = new HashSet<ActOpnd>();
            for (NamingEnumeration<?> enumer = attr.getAll(); enumer.hasMore(); ) {
                String sOpndId = (String) enumer.next();
                ActOpnd[] actOpnds = evalOpnd(eventCtx, sOpndId);
                sLastError = actOpnds[0].getError();
                if (sLastError != null) {
                    System.out.println("Last error in evalOpnd was: "
                            + sLastError);
                    continue;
                }
                for (int i = 0; i < actOpnds.length; i++) {
                    hsOpnd2.add(actOpnds[i]);
                }
            }
            printOpndSet(hsOpnd2,
                    "Set of second operands in \"Delete assignment\"");
            if (hsOpnd2.isEmpty()) {
                System.out.println("No second operands in \"Delete assignment\". Last error was: "
                        + sLastError);
                return failurePacket("No second operands in \"Delete assignment\". Last error was: "
                        + sLastError);
            }

            // Deassign each operand1 from each operand2. Even if there is an
            // error,
            // try to perform as much as possible and then report.
            Iterator<ActOpnd> iter1 = hsOpnd1.iterator();
            Iterator<ActOpnd> iter2 = hsOpnd2.iterator();

            while (iter1.hasNext()) {
                ActOpnd opnd1 = iter1.next();
                while (iter2.hasNext()) {
                    ActOpnd opnd2 = iter2.next();
                    Packet result =  deleteAssignmentInternal(
                            opnd1.getId(), opnd1.getType(), opnd2.getId(),
                            opnd2.getType());
                    if (result.hasError()) {
                        sLastError = result.getErrorMessage();
                    }
                }
            }
            if (sLastError != null) {
                return failurePacket(sLastError);
            }
        } catch (Exception e) {
            e.printStackTrace();
            return failurePacket("Exception while dispatching event action");
        }
        return successPacket();
    }

    private Packet applyActionDeleteDeny(EventContext eventCtx, String sActionId) {
        try {
            Attributes actAttrs = ctx.getAttributes("CN=" + sActionId + ","
                    + sRuleContainerDN);
            Attribute attr = actAttrs.get("pmIsIntrasession");
            if (attr == null) {
                return failurePacket("No intrasession attribute in \"Delete deny\" action "
                        + sActionId);
            }
            boolean bIntrasession = ((String) attr.get()).equals("TRUE");
            attr = actAttrs.get("pmIsIntersection");
            if (attr == null) {
                return failurePacket("No intersection attribute in \"Delete deny\" action "
                        + sActionId);
            }
            boolean bIntersection = ((String) attr.get()).equals("TRUE");

            attr = actAttrs.get("pmOpnd1");

            String sLastError = null;
            ActOpnd actOpnd1 = null;
            ActOpnd[] actOpnds = null;
            String sOpndId = null;

            // "Delete deny" could have an empty set of first operands,
            // meaning any user.
            if (attr == null) {
                actOpnd1 = new ActOpnd("*", PM_NODE_USER, "*", false, false,
                        null);
            } else {
                // There should be only one first operand - a user or a user
                // attribute.
                sOpndId = (String) attr.get();
                // Get the runtime action operand
                actOpnds = evalOpnd(eventCtx, sOpndId);
                sLastError = actOpnds[0].getError();
                if (sLastError != null) {
                    System.out.println("Last error when evaluating operand 1: "
                            + sLastError);
                    return failurePacket("No first operands in \"Delete deny\". Last error was: "
                            + sLastError);
                }
                actOpnd1 = actOpnds[0];
            }
            printOpnd(actOpnd1, "First operand in \"Delete deny\"");

            attr = actAttrs.get("pmOpnd2");
            if (attr == null) {
                return failurePacket("No operand 2 in \"Delete deny\" action "
                        + sActionId);
            }
            HashSet<ActOpnd> hsOpnd2 = new HashSet<ActOpnd>();
            for (NamingEnumeration<?> enumer = attr.getAll(); enumer.hasMore(); ) {
                sOpndId = (String) enumer.next();
                actOpnds = evalOpnd(eventCtx, sOpndId);
                sLastError = actOpnds[0].getError();
                if (sLastError != null) {
                    System.out.println("Last error when evaluating operand 2: "
                            + sLastError);
                    continue;
                }
                for (int i = 0; i < actOpnds.length; i++) {
                    hsOpnd2.add(actOpnds[i]);
                }
            }
            printOpndSet(hsOpnd2, "Set of second operands in \"Delete deny\"");
            if (hsOpnd2.isEmpty()) {
                return failurePacket("No second operands in \"Deny\". Last error was: "
                        + sLastError);
            }

            attr = actAttrs.get("pmOpnd3");
            if (attr == null) {
                return failurePacket("No operand 3 in \"Delete deny\" action "
                        + sActionId);
            }
            HashSet<ActOpnd> hsOpnd3 = new HashSet<ActOpnd>();
            for (NamingEnumeration<?> enumer = attr.getAll(); enumer.hasMore(); ) {
                sOpndId = (String) enumer.next();
                actOpnds = evalOpnd(eventCtx, sOpndId);
                sLastError = actOpnds[0].getError();
                if (sLastError != null) {
                    System.out.println("Last error when evaluating operand 3: "
                            + sLastError);
                    continue;
                }
                for (int i = 0; i < actOpnds.length; i++) {
                    hsOpnd3.add(actOpnds[i]);
                }
            }
            printOpndSet(hsOpnd3, "Set of third operands in \"Delete deny\"");
            if (hsOpnd3.isEmpty()) {
                return failurePacket("No third operands in \"Delete deny\". Last error was: "
                        + sLastError);
            }

            // Generate a name for the deny constraint.
            Random random = new Random();
            byte[] bytes = new byte[4];
            random.nextBytes(bytes);
            String sDenyName = byteArray2HexString(bytes);
            System.out.println("============deny name is " + sDenyName);
            String sType = actOpnd1.getType();
            String sDenyType = null;
            if (sType.equalsIgnoreCase(PM_NODE_USER)) {
                sDenyType = PM_DENY_USER_ID;
            } else if (sType.equalsIgnoreCase(PM_NODE_UATTR)) {
                sDenyType = PM_DENY_ACROSS_SESSIONS;
                if (bIntrasession) {
                    sDenyType = PM_DENY_INTRA_SESSION;
                }
            } else {
                return failurePacket("Incorrect type for first \"Delete deny\" operand");
            }

            String sExistingDeny = getSimilarDeny(sDenyType,
                    actOpnd1.getName(), actOpnd1.getId(), bIntersection,
                    hsOpnd2, hsOpnd3);
            if (sExistingDeny == null) {
                return failurePacket("No such deny exists");
            }
            return deleteDenyInternal(sExistingDeny, null, null, null);
        } catch (Exception e) {
            e.printStackTrace();
            return failurePacket("Exception while dispatching event action");
        }
    }

    private Packet applyActionAssign(EventContext eventCtx, String sActionId) {
        try {
            Attributes actAttrs = ctx.getAttributes("CN=" + sActionId + ","
                    + sRuleContainerDN);
            Attribute attr = actAttrs.get("pmOpnd1");
            if (attr == null) {
                return failurePacket("No operand 1 in \"Assign\" action");
            }
            HashSet<ActOpnd> hsOpnd1 = new HashSet<ActOpnd>();
            String sLastError = null;
            for (NamingEnumeration<?> enumer = attr.getAll(); enumer.hasMore(); ) {
                String sOpndId = (String) enumer.next();
                // Get the runtime action operand and insert it into the HashSet
                // of
                // first operands. Most often, the run-time operand is the same
                // as the
                // compile-time operand. A function operand at run-time is
                // different.
                ActOpnd[] actOpnds = evalOpnd(eventCtx, sOpndId);
                sLastError = actOpnds[0].getError();
                if (sLastError != null) {
                    System.out.println("Last error in evalOpnd was: "
                            + sLastError);
                    continue;
                }
                for (int i = 0; i < actOpnds.length; i++) {
                    hsOpnd1.add(actOpnds[i]);
                }
            }
            printOpndSet(hsOpnd1, "Set of first operands in \"Assign\"");
            if (hsOpnd1.isEmpty()) {
                System.out.println("No first operands in assign. Last error was: "
                        + sLastError);
                return failurePacket("No first operands in assign. Last error was: "
                        + sLastError);
            }

            attr = actAttrs.get("pmOpnd2");
            if (attr == null) {
                return failurePacket("No operand 2 in \"Assign\" action");
            }
            HashSet<ActOpnd> hsOpnd2 = new HashSet<ActOpnd>();
            for (NamingEnumeration<?> enumer = attr.getAll(); enumer.hasMore(); ) {
                String sOpndId = (String) enumer.next();
                ActOpnd[] actOpnds = evalOpnd(eventCtx, sOpndId);
                sLastError = actOpnds[0].getError();
                if (sLastError != null) {
                    System.out.println("Last error in evalOpnd was: "
                            + sLastError);
                    continue;
                }
                for (int i = 0; i < actOpnds.length; i++) {
                    hsOpnd2.add(actOpnds[i]);
                }
            }
            printOpndSet(hsOpnd2, "Set of second operands in \"Assign\"");
            if (hsOpnd2.isEmpty()) {
                System.out.println("No second operands in \"Assign\". Last error was: "
                        + sLastError);
                return failurePacket("No second operands in \"Assign\". Last error was: "
                        + sLastError);
            }

            // Assign each operand1 to each operand2. Even if there is an error,
            // try to perform as much as possible and then report.
            Iterator<ActOpnd> iter1 = hsOpnd1.iterator();
            Iterator<ActOpnd> iter2 = hsOpnd2.iterator();

            while (iter1.hasNext()) {
                ActOpnd opnd1 = iter1.next();
                while (iter2.hasNext()) {
                    ActOpnd opnd2 = iter2.next();
                    Packet res =  assignInternal(opnd1.getId(),
                            opnd1.getType(), opnd2.getId(), opnd2.getType());
                    if (res.hasError()) {
                        sLastError = res.getErrorMessage();
                    }
                }
            }
            if (sLastError != null) {
                return failurePacket(sLastError);
            }
        } catch (Exception e) {
            e.printStackTrace();
            return failurePacket("Exception while dispatching event action");
        }
        return successPacket();
    }

    private void printOpndSet(HashSet<ActOpnd> opndSet, String caption) {
        Iterator<ActOpnd> iter = opndSet.iterator();

        System.out.println(caption);
        while (iter.hasNext()) {
            System.out.print("  Operand (");
            ActOpnd actOpnd = iter.next();
            System.out.print("name=" + actOpnd.getName());
            System.out.print(", type=" + actOpnd.getType());
            System.out.print(", id=" + actOpnd.getId());
            System.out.print(", err=" + actOpnd.getError());
            System.out.println(")");
        }
    }

    private void printOpnd(ActOpnd actOpnd, String caption) {
        System.out.println(caption);
        System.out.print("  Operand (");
        System.out.print("name=" + actOpnd.getName());
        System.out.print(", type=" + actOpnd.getType());
        System.out.print(", id=" + actOpnd.getId());
        System.out.print(", err=" + actOpnd.getError());
        System.out.println(")");
    }

    // Evaluate an action operand (an object of AD class pmClassOperand),
    // pointed to by sOpndId. It has the following attributes:
    // pmId, pmType, pmIsFunction, pmIsSubgraph, pmIsComplement,
    // pmOriginalName, pmOriginalId, pmArgs.
    // If the operand is function, pmArgs is a list of pointers to its arguments
    // (which are operands); pmOriginalName and pmOriginalId are the function's
    // name and id.
    // If it's not a function, the operand could be a PM entity, and then
    // the pmOriginalName and pmOriginalId are the name and id of that entity.
    // If it's not a PM entity, the operand could be a word, and then the
    // pmOriginalName is that word, and pmOriginalId should be ignored.
    // For example, the operand could be the name of an operation,
    // like "File write", or a property like "homeof=gigi".
    // The return value is an object of Java class ActOpnd, which contains
    // the name, type, and id of a PM entity, whether it represents a subgraph,
    // or if it's to be interpreted as the complement of a container.
    // It also contains an error message, which, if null, indicates successful
    // evaluation.
    // NOTE THAT THE RESULT OF AN EVALUATION IS ALWAYS AN ARRAY OF ActOpnd
    // objects.
    // From an operand which is argument of a function, we retain only the
    // first array component.
    private ActOpnd[] evalOpnd(EventContext eventCtx, String sOpndId) {
        System.out.println("EvalOpnd " + sOpndId);
        ActOpnd[] res = new ActOpnd[1];
        try {
            Attributes opndAttrs = ctx.getAttributes("CN=" + sOpndId + ","
                    + sRuleContainerDN);
            String sIsFun = (String) opndAttrs.get("pmIsFunction").get();
            boolean isFun = sIsFun.equals("TRUE");
            String sType = (String) opndAttrs.get("pmType").get();
            Attribute attr = opndAttrs.get("pmOriginalId");
            if (attr == null && !sType.equalsIgnoreCase(PM_OP)
                    && !sType.equalsIgnoreCase(PM_LABEL)) {
                res[0] = new ActOpnd(null, null, null, false, false,
                        "Missing id of operand " + sOpndId);
                return res;
            }
            String sOrigId = null;
            if (attr != null) {
                sOrigId = (String) attr.get();
            }

            attr = opndAttrs.get("pmOriginalName");
            if (attr == null) {
                res[0] = new ActOpnd(null, null, null, false, false,
                        "Missing name of operand " + sOpndId);
                return res;
            }
            String sOrigName = (String) attr.get();

            attr = opndAttrs.get("pmIsSubgraph");
            if (attr == null) {
                res[0] = new ActOpnd(null, null, null, false, false,
                        "Missing subgraph specification in operand " + sOpndId);
                return res;
            }
            boolean isSubgraph = ((String) attr.get()).equals("TRUE");

            attr = opndAttrs.get("pmIsComplement");
            if (attr == null) {
                res[0] = new ActOpnd(null, null, null, false, false,
                        "Missing complement specification in operand "
                                + sOpndId);
                return res;
            }
            boolean isComplement = ((String) attr.get()).equals("TRUE");

            // If the operand is not a function, return a record containing its
            // name,
            // type, id, isSubgraph, and a null error string.
            if (!isFun) {
                res[0] = new ActOpnd(sOrigName, sType, sOrigId, isSubgraph,
                        isComplement, null);
                return res;
            }

            // If the operand is a function, first evaluate its arguments, put
            // them
            // into a vector to preserve the order, then evaluate the function.
            // Be careful to put in the vector only the first component of the
            // array resulted from the evaluation of an argument.
            Vector<ActOpnd> funArgs = new Vector<ActOpnd>();
            attr = opndAttrs.get("pmArgs");

            // Function without parameters.
            if (attr == null) {
                res = evalFun(eventCtx, sOrigName, sOrigId, sType, funArgs);
                for (int i = 0; i < res.length; i++) {
                    res[i].setSubgraph(isSubgraph);
                    res[i].setComplement(isComplement);
                }
                return res;
            }

            // Function with parameters. Its parameters' ids are
            // separated by "|".
            String sArgIds = (String) attr.get();
            if (sArgIds == null || sArgIds.length() == 0) {
                res[0] = new ActOpnd(null, null, null, false, false,
                        "Null or empty function arguments in operand "
                                + sOpndId);
                return res;
            }
            String[] pieces = sArgIds.split(PM_ALT_DELIM_PATTERN);

            // Prepare the vector containing the arguments evaluated.
            // Be careful to insert into the vector only the first component of
            // the
            // array resulted from the evaluation of an argument.
            for (int i = 0; i < pieces.length; i++) {
                String sArgId = pieces[i];
                res = evalOpnd(eventCtx, sArgId);
                if (res[0].getError() != null) {
                    return res;
                }
                funArgs.addElement(res[0]);// !!!!!!!!!!!!!!!!!!!!!!!!??????????
            }

            res = evalFun(eventCtx, sOrigName, sOrigId, sType, funArgs);
            for (int i = 0; i < res.length; i++) {
                res[i].setSubgraph(isSubgraph);
                res[i].setComplement(isComplement);
            }
            return res;
        } catch (Exception e) {
            e.printStackTrace();
            res[0] = new ActOpnd(null, null, null, false, false,
                    "Exception during evaluation of operand " + sOpndId);
            return res;
        }
    }

    // Evaluate a function. funArgs is a vector containing the runtime function
    // arguments.
    private ActOpnd[] evalFun(EventContext eventCtx, String sFunName,
                              String sFunId, String sFunType, Vector<ActOpnd> funArgs) {
        System.out.println("Evaluating function " + sFunName);
        for (int i = 0; i < funArgs.size(); i++) {
            System.out.println("Argument id = " + funArgs.get(i).getId());
        }

        // Dispatch the function evaluation to the correct method.
        if (sFunName.equalsIgnoreCase("object_new")) {
            return evalFun_object_new(eventCtx, sFunType, funArgs);// 1116
        } else if (sFunName.equalsIgnoreCase("oattr_corresponding_to_active_attr")) {
            return evalFun_oattr_corresponding_to_active_attr(eventCtx,
                    sFunType, funArgs);// 1117
        } else if (sFunName.equalsIgnoreCase("oattr_with_name_of_active_attr")) {
            return evalFun_oattr_with_name_of_active_attr(eventCtx, sFunType,
                    funArgs);// 1117
        } else if (sFunName.equalsIgnoreCase("oattr_of_user_choice")) {
            return evalFun_oattr_of_user_choice(eventCtx, sFunType, funArgs);// 1119
        } else if (sFunName.equalsIgnoreCase("oattr_of_default_user")) {
            return evalFun_oattr_of_default_user(eventCtx, sFunType, funArgs);// 1120
        } else if (sFunName.equalsIgnoreCase("oattr_home_of_default_user")) {
            return evalFun_oattr_home_of_default_user(eventCtx, sFunType,
                    funArgs);// 1121
        } else if (sFunName.equalsIgnoreCase("user_default")) {
            return evalFun_user_default(eventCtx, sFunType, funArgs);// 1122
        } else if (sFunName.equalsIgnoreCase("prop_home_of_new_user")) {
            return evalFun_prop_home_of_new_user(eventCtx, sFunType, funArgs);// 1123
        } else if (sFunName.equalsIgnoreCase("uattr_name_of_new_user")) {
            return evalFun_uattr_name_of_new_user(eventCtx, sFunType, funArgs);// 1124
        } else if (sFunName.equalsIgnoreCase("prop_name_of_new_user")) {
            return evalFun_prop_name_of_new_user(eventCtx, sFunType, funArgs);// 1125
        } else if (sFunName.equalsIgnoreCase("user_new")) {
            return evalFun_user_new(eventCtx, sFunType, funArgs);// 1126
        } else if (sFunName.equalsIgnoreCase("uattr_name_of_user")) {
            return evalFun_uattr_name_of_user(eventCtx, sFunType, funArgs);// 1127
        } else if (sFunName.equalsIgnoreCase("prop_name_of_user")) {
            return evalFun_prop_name_of_user(eventCtx, sFunType, funArgs);// 1128
        } else if (sFunName.equalsIgnoreCase("pol_discr")) {
            return evalFun_pol_discr(eventCtx, sFunType, funArgs);// 1129
        } else if (sFunName.equalsIgnoreCase("pol_id")) {
            return evalFun_pol_id(eventCtx, sFunType, funArgs);// 1130
        } else if (sFunName.equalsIgnoreCase("pol_with_prop")) {
            return evalFun_pol_with_prop(eventCtx, sFunType, funArgs);// 1131
        } else if (sFunName.equalsIgnoreCase("oattr_home_of_new_user")) {
            return evalFun_oattr_home_of_new_user(eventCtx, sFunType, funArgs);// 1132
        } else if (sFunName.equalsIgnoreCase("oattr_home_of_user")) {
            return evalFun_oattr_home_of_user(eventCtx, sFunType, funArgs);// 1133
        } else if (sFunName.equalsIgnoreCase("obj_rep_of_home_of_new_user")) {
            return evalFun_obj_rep_of_home_of_new_user(eventCtx, sFunType,
                    funArgs);// 1134
        } else if (sFunName.equalsIgnoreCase("obj_rep_of_home_of_user")) {
            return evalFun_obj_rep_of_home_of_user(eventCtx, sFunType, funArgs);// 1135
        } else if (sFunName.equalsIgnoreCase("oattr_rep_of_home_of_new_user")) {
            return evalFun_oattr_rep_of_home_of_new_user(eventCtx, sFunType,
                    funArgs);// 1136
        } else if (sFunName.equalsIgnoreCase("oattr_rep_of_home_of_user")) {
            return evalFun_oattr_rep_of_home_of_user(eventCtx, sFunType,
                    funArgs);// 1137
        } else if (sFunName.equalsIgnoreCase("oattr_rep_of_discr_users")) {
            return evalFun_oattr_rep_of_discr_users(eventCtx, sFunType, funArgs);// 1138
        } else if (sFunName.equalsIgnoreCase("uattr_discr_users")) {
            return evalFun_uattr_discr_users(eventCtx, sFunType, funArgs);// 1139
        } else if (sFunName.equalsIgnoreCase("oattr_of_default_obj")) {
            return evalFun_oattr_of_default_obj(eventCtx, sFunType, funArgs);// 1140
        } else if (sFunName.equalsIgnoreCase("uattr_lowest_level")) {
            return evalFun_uattr_lowest_level(eventCtx, sFunType, funArgs);// 1141
        } else if (sFunName.equalsIgnoreCase("oattr_direct_asc_of_and_containing")) {
            return evalFun_oattr_direct_asc_of_and_containing(eventCtx,
                    sFunType, funArgs);// 1142
        } else if (sFunName.equalsIgnoreCase("uattr_direct_ascs_of_uattr")) {
            return evalFun_uattr_direct_ascs_of_uattr(eventCtx, sFunType,
                    funArgs);// 1143
        } else if (sFunName.equalsIgnoreCase("uattr_direct_ascs_of_uattr_except")) {
            return evalFun_uattr_direct_ascs_of_uattr_except(eventCtx,
                    sFunType, funArgs);// 1144
        } else if (sFunName.equalsIgnoreCase("uattr_active_in_default_session_and_in_uattr")) {
            return evalFun_uattr_active_in_default_session_and_in_uattr(
                    eventCtx, sFunType, funArgs);// 1145
        } else if (sFunName.equalsIgnoreCase("prop_discr_users")) {
            return evalFun_prop_discr_users(eventCtx, sFunType, funArgs);// 1146
        } else if (sFunName.equalsIgnoreCase("obj_rep_of_discr_users")) {
            return evalFun_obj_rep_of_discr_users(eventCtx, sFunType, funArgs);// 1147
        } else if (sFunName.equalsIgnoreCase("oattr_witems_of_new_user")) {
            return evalFun_oattr_witems_of_new_user(eventCtx, sFunType, funArgs);// 1148
        } else if (sFunName.equalsIgnoreCase("oattr_inbox_of_new_user")) {
            return evalFun_oattr_inbox_of_new_user(eventCtx, sFunType, funArgs);// 1148
        } else if (sFunName.equalsIgnoreCase("oattr_winbox_of_new_user")) {
            return evalFun_oattr_winbox_of_new_user(eventCtx, sFunType, funArgs);// 1148
        } else if (sFunName.equalsIgnoreCase("oattr_inbox_of_user")) {
            return evalFun_oattr_inbox_of_user(eventCtx, sFunType, funArgs);// 1149
        } else if (sFunName.equalsIgnoreCase("oattr_winbox_of_user")) {
            return evalFun_oattr_winbox_of_user(eventCtx, sFunType, funArgs);// 1149
        } else if (sFunName.equalsIgnoreCase("oattr_outbox_of_new_user")) {
            return evalFun_oattr_outbox_of_new_user(eventCtx, sFunType, funArgs);// 1150
        } else if (sFunName.equalsIgnoreCase("oattr_outbox_of_user")) {
            return evalFun_oattr_outbox_of_user(eventCtx, sFunType, funArgs);// 1151
        } else if (sFunName.equalsIgnoreCase("prop_witems_of_new_user")) {
            return evalFun_prop_witems_of_new_user(eventCtx, sFunType, funArgs);
        } else if (sFunName.equalsIgnoreCase("prop_inbox_of_new_user")) {
            return evalFun_prop_inbox_of_new_user(eventCtx, sFunType, funArgs);
        } else if (sFunName.equalsIgnoreCase("prop_inbox_of_user")) {
            return evalFun_prop_inbox_of_user(eventCtx, sFunType, funArgs);
        } else if (sFunName.equalsIgnoreCase("prop_outbox_of_new_user")) {
            return evalFun_prop_outbox_of_new_user(eventCtx, sFunType, funArgs);
        } else if (sFunName.equalsIgnoreCase("prop_outbox_of_user")) {
            return evalFun_prop_outbox_of_user(eventCtx, sFunType, funArgs);
        } else if (sFunName.equalsIgnoreCase("obj_rep_of_inbox_of_new_user")) {
            return evalFun_obj_rep_of_inbox_of_new_user(eventCtx, sFunType,
                    funArgs);
        } else if (sFunName.equalsIgnoreCase("obj_rep_of_inbox_of_user")) {
            return evalFun_obj_rep_of_inbox_of_user(eventCtx, sFunType, funArgs);
        } else if (sFunName.equalsIgnoreCase("oattr_rep_of_inbox_of_new_user")) {
            return evalFun_oattr_rep_of_inbox_of_new_user(eventCtx, sFunType,
                    funArgs);
        } else if (sFunName.equalsIgnoreCase("oattr_rep_of_inbox_of_user")) {
            return evalFun_oattr_rep_of_inbox_of_user(eventCtx, sFunType,
                    funArgs);
        } else if (sFunName.equalsIgnoreCase("obj_rep_of_outbox_of_new_user")) {
            return evalFun_obj_rep_of_outbox_of_new_user(eventCtx, sFunType,
                    funArgs);
        } else if (sFunName.equalsIgnoreCase("obj_rep_of_outbox_of_user")) {
            return evalFun_obj_rep_of_outbox_of_user(eventCtx, sFunType,
                    funArgs);
        } else if (sFunName.equalsIgnoreCase("oattr_rep_of_outbox_of_new_user")) {
            return evalFun_oattr_rep_of_outbox_of_new_user(eventCtx, sFunType,
                    funArgs);
        } else if (sFunName.equalsIgnoreCase("oattr_rep_of_outbox_of_user")) {
            return evalFun_oattr_rep_of_outbox_of_user(eventCtx, sFunType,
                    funArgs);
        } else if (sFunName.equalsIgnoreCase("user_recipient")) {
            return evalFun_user_recipient(eventCtx, sFunType, funArgs);
        } else if (sFunName.equalsIgnoreCase("oattr_witems")) {
            return evalFun_oattr_witems(eventCtx, sFunType, funArgs);
        } else if (sFunName.equalsIgnoreCase("oattr_inboxes")) {
            return evalFun_oattr_inboxes(eventCtx, sFunType, funArgs);
        } else if (sFunName.equalsIgnoreCase("oattr_outboxes")) {
            return evalFun_oattr_outboxes(eventCtx, sFunType, funArgs);
        } else if (sFunName.equalsIgnoreCase("session_default")) {
            return evalFun_session_default(eventCtx, sFunType, funArgs);
        } else if (sFunName.equalsIgnoreCase("rule_composed_of")) {
            return evalFun_rule_composed_of(eventCtx, sFunType, funArgs);
        } else if (sFunName.equalsIgnoreCase("id_or_name_as_string")) {
            return evalFun_id_or_name_as_string(eventCtx, sFunType, funArgs);
        } else if (sFunName.equalsIgnoreCase("name_of_rep_of_oattr")) {
            return evalFun_name_of_rep_of_oattr(eventCtx, sFunType, funArgs);
        } else if (sFunName.equalsIgnoreCase("oattr_rep_of_oattr")) {
            return evalFun_oattr_rep_of_oattr(eventCtx, sFunType, funArgs);
        } else if (sFunName.equalsIgnoreCase("obj_rep_of_oattr")) {
            return evalFun_obj_rep_of_oattr(eventCtx, sFunType, funArgs);
        } else if (sFunName.equalsIgnoreCase("oattr_record_of_default_obj")) {
            return evalFun_oattr_record_of_default_obj(eventCtx, sFunType,
                    funArgs);
        } else if (sFunName.equalsIgnoreCase("oattr_record_of_oattr")) {
            return evalFun_oattr_record_of_oattr(eventCtx, sFunType, funArgs);
        } else if (sFunName.equalsIgnoreCase("process_default")) {
            return evalFun_process_default(eventCtx, sFunType, funArgs);
        } else {
            ActOpnd[] err = new ActOpnd[1];
            err[0] = new ActOpnd(null, null, null, false, false, "Function "
                    + sFunName + " not implemented!");
            return err;
        }
    }

    // Returns the object attribute associated to an object that represents
    // another object attribute.
    private ActOpnd[] evalFun_oattr_rep_of_oattr(EventContext eventCtx,
                                                 String sFunType, Vector<ActOpnd> funArgs) {
        ActOpnd[] res = new ActOpnd[1];

        if (funArgs.isEmpty() || funArgs.size() != 1) {
            res[0] = new ActOpnd(null, null, null, false, false,
                    "Incorrect number of arguments for function oattr_rep_of_oattr");
            return res;
        }
        ActOpnd arg = funArgs.get(0);
        if (!arg.getType().equalsIgnoreCase(PM_NODE_OATTR)) {
            res[0] = new ActOpnd(null, null, null, false, false,
                    "Argument of function oattr_rep_of_oattr is not an object attribute");
            return res;
        }
        String sOattrName = arg.getName();
        String sRepName = sOattrName + " rep";
        String sRepId = getEntityId(sRepName, PM_NODE_OATTR);
        if (sRepId == null) {
            res[0] = new ActOpnd(null, null, null, false, false,
                    "Argument of function oattr_rep_of_oattr has no representative");
            return res;
        }
        res[0] = new ActOpnd(sRepName, PM_NODE_OATTR, sRepId, false, false,
                null);
        return res;
    }

    // Returns the object attribute associated to an object that represents
    // another object attribute.
    private ActOpnd[] evalFun_obj_rep_of_oattr(EventContext eventCtx,
                                               String sFunType, Vector<ActOpnd> funArgs) {
        ActOpnd[] res = new ActOpnd[1];

        if (funArgs.isEmpty() || funArgs.size() != 1) {
            res[0] = new ActOpnd(null, null, null, false, false,
                    "Incorrect number of arguments for function oattr_rep_of_oattr");
            return res;
        }
        ActOpnd arg = funArgs.get(0);
        if (!arg.getType().equalsIgnoreCase(PM_NODE_OATTR)) {
            res[0] = new ActOpnd(null, null, null, false, false,
                    "Argument of function oattr_rep_of_oattr is not an object attribute");
            return res;
        }
        String sOattrName = arg.getName();
        String sRepName = sOattrName + " rep";
        String sRepId = getEntityId(sRepName, PM_NODE_OATTR);
        // No check
        res[0] = new ActOpnd(sRepName, PM_OBJ, sRepId, false, false, null);
        return res;
    }

    // Returns the name of the object attribute associated to the object
    // that represents a specified object attribute.
    // Parameters: an object attribute.
    private ActOpnd[] evalFun_name_of_rep_of_oattr(EventContext eventCtx,
                                                   String sFunType, Vector<ActOpnd> funArgs) {
        ActOpnd[] res = new ActOpnd[1];

        if (funArgs.isEmpty() || funArgs.size() != 1) {
            res[0] = new ActOpnd(null, null, null, false, false,
                    "Incorrect number of arguments for function name_of_rep_of_oattr");
            return res;
        }
        ActOpnd arg = funArgs.get(0);
        if (!arg.getType().equalsIgnoreCase(PM_NODE_OATTR)) {
            res[0] = new ActOpnd(null, null, null, false, false,
                    "Argument of function name_of_rep_of_oattr is not an object attribute");
            return res;
        }
        String sOattrName = arg.getName();
        String sRepName = sOattrName + " rep";
        String sRepId = getEntityId(sRepName, PM_OBJ);
        // I didn't check existence because it ccould just being created.
        res[0] = new ActOpnd(sRepName, PM_UNKNOWN, sRepId, false, false, null);
        return res;
    }

    // If the argument is of any of the types a, u, p, c, b, ob, ses,
    // then return its id as string (i.e., return it in the name field and
    // with type k.
    // If the argument is of type k or rule, then return its name in the
    // name field and with type k.
    private ActOpnd[] evalFun_id_or_name_as_string(EventContext eventCtx,
                                                   String sFunType, Vector<ActOpnd> funArgs) {
        ActOpnd[] res = new ActOpnd[1];

        if (funArgs.isEmpty() || funArgs.size() != 1) {
            res[0] = new ActOpnd(null, null, null, false, false,
                    "Wrong argument count in id_or_name_as_string()");
            return res;
        }

        ActOpnd arg0 = funArgs.get(0);
        String sT = arg0.getType();

        RandomGUID myGUID = new RandomGUID();
        String sId = myGUID.toStringNoDashes();

        if (sT.equals(PM_UNKNOWN) || sT.equals(PM_RULE)) {
            res[0] = new ActOpnd(arg0.getName(), PM_UNKNOWN, sId, false, false,
                    null);
        } else {
            res[0] = new ActOpnd(arg0.getId(), PM_UNKNOWN, sId, false, false,
                    null);
        }
        return res;
    }

    // This function has a variable number of arguments, but at least one.
    // This first argument (argument number 0) is the string representation
    // of an EVER rule, that could contain up to 9 macros #1,...,#n (n <= 9),
    // which will be replaced by the values of its subsequent arguments:
    // #1 by argument number 1, #2 by argument number 2, etc. If naa is the
    // number of actual arguments including the first (argument number 0),
    // then naa must be > n. After substitution, the first argument must be
    // compiled and added to the currently enabled script.
    private ActOpnd[] evalFun_rule_composed_of(EventContext eventCtx,
                                               String sFunType, Vector<ActOpnd> funArgs) {
        ActOpnd[] res = new ActOpnd[1];

        if (funArgs.isEmpty()) {
            res[0] = new ActOpnd(null, null, null, false, false,
                    "No arguments in rule_composed_of()");
            return res;
        }

        int nActualArgs = funArgs.size();
        ActOpnd arg0 = funArgs.get(0);
        System.out.println("rule_composed_of's arg 0 type is " + arg0.getType());
        System.out.println("rule_composed_of's arg 0 id is " + arg0.getId());
        System.out.println("rule_composed_of's arg 0 name is " + arg0.getName());

        String sOrigString = arg0.getName();
        StringBuffer sb = new StringBuffer();

        for (int i = 0; i < sOrigString.length(); ) {
            char c = sOrigString.charAt(i++);
            if (c == '#') {
                if (i >= sOrigString.length()) {
                    res[0] = new ActOpnd(null, null, null, false, false,
                            "Incorrect argument reference in rule_composed_of()");
                    return res;
                }
                c = sOrigString.charAt(i++);
                if (c < '1' || c > '9') {
                    res[0] = new ActOpnd(null, null, null, false, false,
                            "Argument reference not in range 1..9 in rule_composed_of()");
                    return res;
                }
                int iArg = c - '0';
                if (iArg >= nActualArgs) {
                    res[0] = new ActOpnd(null, null, null, false, false,
                            "Argument reference out of the arguments range in rule_composed_of()");
                    return res;
                }

                String sRepl = funArgs.get(iArg).getName();
                sb.append(sRepl);
            } else {
                sb.append(c);
            }
        }

        RandomGUID myGUID = new RandomGUID();
        String sId = myGUID.toStringNoDashes();
        res[0] = new ActOpnd(sb.toString(), PM_RULE, sId, false, false, null);
        System.out.println("result type is " + res[0].getType());
        System.out.println("result id is " + res[0].getId());
        System.out.println("result name is " + res[0].getName());
        return res;
    }

    // The object_new() function returns an ActOpnd containing the object
    // attribute associated with the newly created object, if the event
    // who triggered its evaluation was "Object create". Otherwise, it
    // returns an error ActOpnd.
    // Parameters: none. It uses the event context to extract info.
    private ActOpnd[] evalFun_object_new(EventContext eventCtx,
                                         String sFunType, Vector<ActOpnd> funArgs) {
        ActOpnd[] res = new ActOpnd[1];

        // The event context should contain the virtual object name and id,
        // and the function type is PM_OBJ. This function needs to return the
        // object attribute associated to the virtual object.
        if (!eventCtx.getEventName().equalsIgnoreCase(PM_EVENT_OBJECT_CREATE)) {
            res[0] = new ActOpnd(null, null, null, false, false,
                    "Event is not \"" + PM_EVENT_OBJECT_CREATE + "\"!");
            return res;
        }
        String sObjId = eventCtx.getObjId();
        if (sObjId == null) {
            res[0] = new ActOpnd(null, null, null, false, false,
                    "Null object id in the context");
            return res;
        }
        String sId = getAssocOattr(sObjId);
        if (sId == null) {
            res[0] = new ActOpnd(null, null, null, false, false,
                    "No object attribute associated to object "
                            + eventCtx.getObjId());
            return res;
        }
        res[0] = new ActOpnd(eventCtx.getObjName(), PM_NODE_OATTR, sId, false,
                false, null);
        return res;
    }

    // Returns the user attribute uaa, which is active in the default session
    // and
    // uaa ->+ uaarg, where uaarg is the first argument (a user attribute).
    private ActOpnd[] evalFun_uattr_active_in_default_session_and_in_uattr(
            EventContext eventCtx, String sFunType, Vector<ActOpnd> funArgs) {
        ActOpnd[] res = new ActOpnd[1];

        if (funArgs.isEmpty() || funArgs.size() != 1) {
            res[0] = new ActOpnd(
                    null,
                    null,
                    null,
                    false,
                    false,
                    "Incorrect number of arguments for function uattr_active_in_default_session_and_in_uattr");
            return res;
        }

        ActOpnd arg = funArgs.get(0);
        if (!arg.getType().equalsIgnoreCase(PM_NODE_UATTR)) {
            res[0] = new ActOpnd(
                    null,
                    null,
                    null,
                    false,
                    false,
                    "First argument of uattr_active_in_default_session_and_in_uattr is not a user attribute");
            return res;
        }
        String sUattrId1 = arg.getId();

        HashSet<String> actives = getSessionActiveAttrSet(eventCtx.getSessId());
        if (actives.isEmpty()) {
            res[0] = new ActOpnd(null, null, null, false, false,
                    "No user attributes active in the event context");
            return res;
        }
        Iterator<String> iter = actives.iterator();
        while (iter.hasNext()) {
            String sUattrId = iter.next();
            if (attrIsAscendant(sUattrId, sUattrId1, PM_NODE_UATTR)) {
                String sUattrName = getEntityName(sUattrId, PM_NODE_UATTR);
                res[0] = new ActOpnd(sUattrName, PM_NODE_UATTR, sUattrId,
                        false, false, null);
                return res;
            }
        }
        res[0] = new ActOpnd(null, null, null, false, false,
                "No active attribute contained in "
                        + getEntityName(sUattrId1, PM_NODE_UATTR));
        return res;
    }

    // The oattr_that_corresponds_to_active_attr() function returns an ActOpnd
    // containing the object attribute that corresponds to the subject's
    // active attribute in a specified policy class.
    // Parameters: the policy class.
    /*
   private ActOpnd[] evalFun_oattr_that_corresponds_to_active_attr(
   EventContext eventCtx, String sFunType, List<ActOpnd> funArgs) {
   ActOpnd[] res = new ActOpnd[1];

   if (funArgs.isEmpty() || funArgs.size() != 1) {
   res[0] = new ActOpnd(
   null,
   null,
   null,
   false,
   false,
   "Incorrect number of arguments for function oattr_that_corresponds_to_active_attr");
   return res;
   }

   ActOpnd arg = funArgs.get(0);
   if (!arg.getType().equalsIgnoreCase(PM_NODE_POL)) {
   res[0] = new ActOpnd(
   null,
   null,
   null,
   false,
   false,
   "Argument of function oattr_that_corresponds_to_active_attr is not a policy class");
   return res;
   }
   String sPolId = arg.getId();
   HashSet<String> hs = getPolicyActiveAttributes(eventCtx.getSessId(),
   sPolId);
   if (hs.isEmpty()) {
   res[0] = new ActOpnd(null, null, null, false, false,
   "No user attributes active in the event context and policy "
   + arg.getName());
   return res;
   }
   // Now go through all active user attributes and find the (first) one
   // that has
   // a corresponding object attribute (the user attribute has a property
   // "correspondsto=<oattr name>").
   Iterator<String> iter = hs.iterator();
   while (iter.hasNext()) {
   // The id of the active user attribute...
   String sUattrId = iter.next();
   // Get its property that starts with "correspondsto=", if any...
   String sCorrTo = "correspondsto=";
   String sProp = getPropertyWithPrefix(sCorrTo, sUattrId,
   PM_NODE_UATTR);
   // If none, continue with next active...
   if (sProp == null) {
   continue;
   }
   // If property found, get the corresponding oattr...
   String sOattrName = sProp.substring(sCorrTo.length());
   String sOattrId = getIdOfEntityWithNameAndType(sOattrName, PM_NODE_OATTR);
   if (sOattrId != null) {
   res[0] = new ActOpnd(sOattrName, PM_NODE_OATTR, sOattrId,
   false, false, null);
   return res;
   }
   }
   res[0] = new ActOpnd(null, null, null, false, false,
   "No object attribute corresponds to an active attribute!");
   return res;
   }
    */
    // The oattr_corresponding_to_active_attr() function returns an ActOpnd
    // containing the object attribute that corresponds to one of the subject's
    // active attributes in a specified policy class. The active attribute
    // indicates the corresponding object attribute in a property
    // "correspondsto=<oattr name>".
    // Parameters: the policy class.
    private ActOpnd[] evalFun_oattr_corresponding_to_active_attr(
            EventContext eventCtx, String sFunType, Vector<ActOpnd> funArgs) {
        ActOpnd[] res = new ActOpnd[1];

        if (funArgs.isEmpty() || funArgs.size() != 1) {
            res[0] = new ActOpnd(
                    null,
                    null,
                    null,
                    false,
                    false,
                    "Incorrect number of arguments for function evalFun_oattr_corresponding_to_active_attr");
            return res;
        }

        ActOpnd arg = funArgs.get(0);
        if (!arg.getType().equalsIgnoreCase(PM_NODE_POL)) {
            res[0] = new ActOpnd(
                    null,
                    null,
                    null,
                    false,
                    false,
                    "Argument of function evalFun_oattr_corresponding_to_active_attr is not a policy class");
            return res;
        }
        String sPolId = arg.getId();
        HashSet<String> hs = getPolicyActiveAttributes(eventCtx.getSessId(),
                sPolId);
        if (hs.isEmpty()) {
            res[0] = new ActOpnd(null, null, null, false, false,
                    "No user attributes active in the event context and policy "
                            + arg.getName());
            return res;
        }
        Iterator<String> iter = hs.iterator();
        while (iter.hasNext()) {
            String sUattrId = iter.next();
            String sPrefix = "correspondsto=";
            String sProp = getPropertyWithPrefix(sPrefix, sUattrId,
                    PM_NODE_UATTR);
            if (sProp == null) {
                continue;
            }
            String sOattrName = sProp.substring(sProp.indexOf(sPrefix)
                    + sPrefix.length());
            String sOattrId = getEntityId(sOattrName, PM_NODE_OATTR);
            if (sOattrId != null) {
                res[0] = new ActOpnd(sOattrName, PM_NODE_OATTR, sOattrId,
                        false, false, null);
                return res;
            }
        }
        res[0] = new ActOpnd(null, null, null, false, false,
                "No object attribute corresponding to an active attribute!");
        return res;
    }

    // The oattr_with_name_of_active_attr() function returns an ActOpnd
    // containing the object attribute with the same name as the subject's
    // active attribute in a specified policy class.
    // Parameters: the policy class.
    private ActOpnd[] evalFun_oattr_with_name_of_active_attr(
            EventContext eventCtx, String sFunType, Vector<ActOpnd> funArgs) {
        ActOpnd[] res = new ActOpnd[1];

        if (funArgs.isEmpty() || funArgs.size() != 1) {
            res[0] = new ActOpnd(null, null, null, false, false,
                    "Incorrect number of arguments for function oattr_with_name_of_active_attr");
            return res;
        }

        ActOpnd arg = funArgs.get(0);
        if (!arg.getType().equalsIgnoreCase(PM_NODE_POL)) {
            res[0] = new ActOpnd(null, null, null, false, false,
                    "Argument of function oattr_with_name_of_active_attr is not a policy class");
            return res;
        }
        String sPolId = arg.getId();
        HashSet<String> hs = getPolicyActiveAttributes(eventCtx.getSessId(),
                sPolId);
        if (hs.isEmpty()) {
            res[0] = new ActOpnd(null, null, null, false, false,
                    "No user attributes active in the event context and policy "
                            + arg.getName());
            return res;
        }
        Iterator<String> iter = hs.iterator();
        while (iter.hasNext()) {
            String sUattrId = iter.next();
            String sUattrName = getEntityName(sUattrId, PM_NODE_UATTR);
            if (sUattrName == null) {
                res[0] = new ActOpnd(null, null, null, false, false,
                        "No user attribute of id " + sUattrId);
                return res;
            }
            String sOattrId = getEntityId(sUattrName, PM_NODE_OATTR);
            if (sOattrId != null) {
                res[0] = new ActOpnd(sUattrName, PM_NODE_OATTR, sOattrId,
                        false, false, null);
                return res;
            }
        }
        res[0] = new ActOpnd(null, null, null, false, false,
                "No object attribute with name of an active attribute!");
        return res;
    }

    // The user_recipient() function returns an ActOpnd
    // containing the user to be recipient of an email message.
    // It is extracted from ctx1.
    // Parameters: None.
    private ActOpnd[] evalFun_user_recipient(EventContext eventCtx,
                                             String sFunType, Vector<ActOpnd> funArgs) {
        ActOpnd[] res = new ActOpnd[1];
        String sUserName = eventCtx.getCtx1();
        String sUserId = getEntityId(sUserName, PM_NODE_USER);
        if (sUserId == null) {
            res[0] = new ActOpnd(null, null, null, false, false,
                    "No user of name " + sUserName);
            return res;
        }

        res[0] = new ActOpnd(sUserName, PM_NODE_USER, sUserId, false, false,
                null);
        return res;
    }

    // The oattr_of_user_choice() function returns an ActOpnd
    // containing an object attribute selected by the user app, which is
    // contained in a given policy class.
    // Parameters: the policy class.
    private ActOpnd[] evalFun_oattr_of_user_choice(EventContext eventCtx,
                                                   String sFunType, Vector<ActOpnd> funArgs) {
        ActOpnd[] res = new ActOpnd[1];

        if (funArgs.isEmpty() || funArgs.size() != 1) {
            res[0] = new ActOpnd(null, null, null, false, false,
                    "Incorrect number of arguments for function oattr_of_user_choice");
            return res;
        }
        ActOpnd arg = funArgs.get(0);
        if (!arg.getType().equalsIgnoreCase(PM_NODE_POL)) {
            res[0] = new ActOpnd(null, null, null, false, false,
                    "Argument of function oattr_of_user_choice is not a policy class");
            return res;
        }
        HashSet<String> selConts = stringToSet(eventCtx.getCtx1());
        if (selConts.isEmpty()) {
            res[0] = new ActOpnd(null, null, null, false, false,
                    "No user-selected (oattr) containers!");
            return res;
        }
        Iterator<String> iter = selConts.iterator();
        while (iter.hasNext()) {
            String sOattrName = iter.next();
            String sOattrId = getEntityId(sOattrName, PM_NODE_OATTR);
            if (sOattrId == null) {
                res[0] = new ActOpnd(null, null, null, false, false,
                        "No object attribute of name " + sOattrName);
                return res;
            }
            if (attrIsAscendantToPolicy(sOattrId, PM_NODE_OATTR, arg.getId())) {
                res[0] = new ActOpnd(sOattrName, PM_NODE_OATTR, sOattrId,
                        false, false, null);
                return res;
            }
        }
        res[0] = new ActOpnd(null, null, null, false, false,
                "No user-selected container in policy class " + arg.getName());
        return res;
    }

    // Returns the object attribute with the property:
    // owner=<user>
    // where <user> is the user of the process that triggered the event.
    // Parameters: None.
    private ActOpnd[] evalFun_oattr_of_default_user(EventContext eventCtx,
                                                    String sFunType, Vector<ActOpnd> funArgs) {
        ActOpnd[] res = new ActOpnd[1];

        String sSessId = eventCtx.getSessId();
        String sUserId = getSessionUserId(sSessId);
        if (sUserId == null) {
            res[0] = new ActOpnd(null, null, null, false, false,
                    "No user for session " + sSessId);
            return res;
        }
        String sUser = getEntityName(sUserId, PM_NODE_USER);
        if (sUser == null) {
            res[0] = new ActOpnd(null, null, null, false, false,
                    "No user with id " + sUserId);
            return res;
        }

        // Let's find the oattr with the property:
        String sProp = "owner=" + sUser;
        String sOattrId = getEntityWithPropInternal(PM_NODE_OATTR, sProp);
        System.out.println("=============oattr with property " + sProp
                + " found " + sOattrId);

        if (sOattrId == null) {
            res[0] = new ActOpnd(null, null, null, false, false,
                    "No object attribute with property " + sProp);
            return res;
        }
        String sOattr = getEntityName(sOattrId, PM_NODE_OATTR);
        if (sOattr == null) {
            res[0] = new ActOpnd(null, null, null, false, false,
                    "No object attribute with id " + sOattrId);
            return res;
        }
        res[0] = new ActOpnd(sOattr, PM_NODE_OATTR, sOattrId, false, false,
                null);
        return res;
    }

    // Returns all direct ascendants of first argument excepting the second
    // argument. Both arguments are user attributes.
    private ActOpnd[] evalFun_uattr_direct_ascs_of_uattr_except(
            EventContext eventCtx, String sFunType, Vector<ActOpnd> funArgs) {
        ActOpnd[] err = new ActOpnd[1];
        if (funArgs.isEmpty() || funArgs.size() != 2) {
            err[0] = new ActOpnd(null, null, null, false, false,
                    "Incorrect number of arguments for function uattr_direct_ascs_of_uattr_except");
            return err;
        }
        ActOpnd arg = funArgs.get(0);
        if (!arg.getType().equalsIgnoreCase(PM_NODE_UATTR)) {
            err[0] = new ActOpnd(
                    null,
                    null,
                    null,
                    false,
                    false,
                    "Argument 1 of function uattr_direct_ascs_of_uattr_except is not a user attribute");
            return err;
        }
        String sUattrId1 = arg.getId();
        arg = funArgs.get(1);
        if (!arg.getType().equalsIgnoreCase(PM_NODE_UATTR)) {
            err[0] = new ActOpnd(
                    null,
                    null,
                    null,
                    false,
                    false,
                    "Argument 2 of function uattr_direct_ascs_of_uattr_except is not a user attribute");
            return err;
        }
        String sUattrId2 = arg.getId();

        // Get all direct ascendants of the first argument.
        try {
            Attributes attrs = ctx.getAttributes("CN=" + sUattrId1 + ","
                    + sUserAttrContainerDN);
            Attribute attr = attrs.get("pmFromAttr");
            if (attr == null) {
                err[0] = new ActOpnd(null, null, null, false, false,
                        "No direct ascendants found");
                return err;
            }
            // Let's see if the second argument is one of these ascendants.
            boolean isOne = false;
            for (NamingEnumeration<?> attrEnum = attr.getAll(); attrEnum.hasMore(); ) {
                String sId = (String) attrEnum.next();
                if (sId.equalsIgnoreCase(sUattrId2)) {
                    isOne = true;
                    break;
                }
            }
            int n = attr.size();
            if (isOne) {
                n--;
            }
            if (n == 0) {
                err[0] = new ActOpnd(null, null, null, false, false,
                        "No ascendants as requested found");
                return err;
            }
            ActOpnd[] result = new ActOpnd[n];
            int i = 0;
            for (NamingEnumeration<?> attrEnum = attr.getAll(); attrEnum.hasMore(); ) {
                String sId = (String) attrEnum.next();
                if (sId.equalsIgnoreCase(sUattrId2)) {
                    continue;
                }
                result[i++] = new ActOpnd(getEntityName(sId, PM_NODE_UATTR),
                        PM_NODE_UATTR, sId, false, false, null);
            }
            return result;
        } catch (Exception e) {
            if (debugFlag) {
                e.printStackTrace();
            }
            err[0] = new ActOpnd(null, null, null, false, false, "Exception: "
                    + e.getMessage());
            return err;
        }
    }

    private ActOpnd[] evalFun_uattr_direct_ascs_of_uattr(EventContext eventCtx,
                                                         String sFunType, Vector<ActOpnd> funArgs) {
        ActOpnd[] err = new ActOpnd[1];
        if (funArgs.isEmpty() || funArgs.size() != 1) {
            err[0] = new ActOpnd(null, null, null, false, false,
                    "Incorrect number of arguments for function uattr_direct_ascs_of_uattr");
            return err;
        }
        ActOpnd arg = funArgs.get(0);
        if (!arg.getType().equalsIgnoreCase(PM_NODE_UATTR)) {
            err[0] = new ActOpnd(null, null, null, false, false,
                    "Argument of function uattr_direct_ascs_of_uattr is not a user attribute");
            return err;
        }
        String sUattrId = arg.getId();
        // Get all direct ascendants of the first argument.
        try {
            Attributes attrs = ctx.getAttributes("CN=" + sUattrId + ","
                    + sUserAttrContainerDN);
            Attribute attr = attrs.get("pmFromAttr");
            if (attr == null) {
                err[0] = new ActOpnd(null, null, null, false, false,
                        "No direct ascendants found");
                return err;
            }
            int n = attr.size();
            ActOpnd[] result = new ActOpnd[n];
            int i = 0;
            for (NamingEnumeration<?> attrEnum = attr.getAll(); attrEnum.hasMore(); ) {
                String sId = (String) attrEnum.next();
                result[i++] = new ActOpnd(getEntityName(sId, PM_NODE_UATTR),
                        PM_NODE_UATTR, sId, false, false, null);
            }
            return result;
        } catch (Exception e) {
            if (debugFlag) {
                e.printStackTrace();
            }
            err[0] = new ActOpnd(null, null, null, false, false, "Exception: "
                    + e.getMessage());
            return err;
        }
    }

    // Returns an object attribute oa with the property:
    // oa -> oattr1 and oattr2 ->* oa, where oattr1 and oattr2 are its two
    // parameters. It assumes that oa is unique.
    // Parameters: two object attributes oattr1 and oattr2 such that
    // there is a unique oa such that oattr2 ->* oa -> oattr1.
    private ActOpnd[] evalFun_oattr_direct_asc_of_and_containing(
            EventContext eventCtx, String sFunType, Vector<ActOpnd> funArgs) {
        ActOpnd[] res = new ActOpnd[1];

        if (funArgs.isEmpty() || funArgs.size() != 2) {
            res[0] = new ActOpnd(null, null, null, false, false,
                    "Incorrect number of arguments for function oattr_direct_asc_of_and_containing");
            return res;
        }
        ActOpnd arg1 = funArgs.get(0);
        if (!arg1.getType().equalsIgnoreCase(PM_NODE_OATTR)) {
            res[0] = new ActOpnd(
                    null,
                    null,
                    null,
                    false,
                    false,
                    "First argument of function oattr_direct_asc_of_and_containing is not an object attribute");
            return res;
        }
        String sOattrId1 = arg1.getId();
        System.out.println("First operand is " + arg1.getName());

        ActOpnd arg2 = funArgs.get(1);
        if (!arg2.getType().equalsIgnoreCase(PM_NODE_OATTR)) {
            res[0] = new ActOpnd(
                    null,
                    null,
                    null,
                    false,
                    false,
                    "Second argument of function oattr_direct_asc_containing is not an object attribute");
            return res;
        }
        String sOattrId2 = arg2.getId();
        System.out.println("Second operand is " + arg2.getName());

        // Get all direct ascendants of the first argument.
        System.out.println("Walking thru all ascendants of the first argument");
        try {
            Attributes attrs = ctx.getAttributes("CN=" + sOattrId1 + ","
                    + sObjAttrContainerDN);
            Attribute attr = attrs.get("pmFromAttr");
            if (attr != null) {
                for (NamingEnumeration<?> attrEnum = attr.getAll(); attrEnum.hasMore(); ) {
                    String sId = (String) attrEnum.next();
                    System.out.println("For direct ascendant " + sId);
                    if (attrIsAscendant(sOattrId2, sId, PM_NODE_OATTR)) {
                        res[0] = new ActOpnd(getEntityName(sId, PM_NODE_OATTR),
                                PM_NODE_OATTR, sId, false, false, null);
                        return res;
                    }
                }
            }
        } catch (Exception e) {
            if (debugFlag) {
                e.printStackTrace();
            }
            res[0] = new ActOpnd(null, null, null, false, false, "Exception: "
                    + e.getMessage());
            return res;
        }
        res[0] = new ActOpnd(null, null, null, false, false,
                "No container satisfying the requirement was found");
        return res;
    }

    // Returns the object attribute associated with the event's object,
    // if the event is Object create, Object write, etc., but not User create,
    // etc.
    //
    // Note that when the event is "Object delete", the id of the associated
    // object attribute cannot be obtained using getAssocId(), because the
    // object no longer exists. Instead, the assoc id is passed to
    // processEvent() and all subsequent functions in Ctx2. All containers
    // the deleted object is assigned to are passed in Ctx1.
    // Parameters: None.
    private ActOpnd[] evalFun_oattr_of_default_obj(EventContext eventCtx,
                                                   String sFunType, Vector<ActOpnd> funArgs) {
        ActOpnd[] res = new ActOpnd[1];

        String sEventName = eventCtx.getEventName();
        if (!sEventName.startsWith("Object ")) {
            res[0] = new ActOpnd(null, null, null, false, false,
                    "The event is not \"Object ...\"!");
            return res;
        }
        String sObjName = eventCtx.getObjName();
        String sObjId = eventCtx.getObjId();

        // If the event is "Object delete", the assoc id is in Ctx2.
        if (sEventName.equalsIgnoreCase("Object delete")) {
            res[0] = new ActOpnd(sObjName, PM_NODE_OATTR, eventCtx.getCtx2(),
                    false, false, null);
            return res;
        }
        String sActObjId = getEntityId(sObjName, PM_OBJ);
        if (sActObjId == null) {
            res[0] = new ActOpnd(null, null, null, false, false,
                    "No such object \"" + sObjName + "\"!");
            return res;
        }
        if (!sActObjId.equalsIgnoreCase(sObjId)) {
            res[0] = new ActOpnd(null, null, null, false, false,
                    "Context's object id is not the actual id!");
            return res;
        }
        String sAssocId = getAssocOattr(sObjId);
        if (sAssocId == null) {
            res[0] = new ActOpnd(null, null, null, false, false,
                    "Context's object has no associated object attribute!");
            return res;
        }
        res[0] = new ActOpnd(sObjName, PM_NODE_OATTR, sAssocId, false, false,
                null);
        return res;
    }

    // Returns the record (an object container) the default object is a member
    // of.
    // The event must be Object create, Object write, etc., but not User create,
    // etc.
    //
    // Note that when the event is "Object delete", the id of the associated
    // object attribute cannot be obtained using getAssocId(), because the
    // object no longer exists. Instead, the assoc id is passed to
    // processEvent() and all subsequent functions in Ctx2. All containers
    // the deleted object is assigned to are passed in Ctx1.
    // Parameters: None.
    private ActOpnd[] evalFun_oattr_record_of_default_obj(
            EventContext eventCtx, String sFunType, Vector<ActOpnd> funArgs) {
        ActOpnd[] res = new ActOpnd[1];

        String sEventName = eventCtx.getEventName();
        if (!sEventName.startsWith("Object ")) {
            res[0] = new ActOpnd(null, null, null, false, false,
                    "The event is not \"Object ...\"!");
            return res;
        }
        String sObjName = eventCtx.getObjName();

        String sAssocId = null;

        // If the event is "Object delete", the assoc id is in Ctx2.
        if (sEventName.equalsIgnoreCase("Object delete")) {
            sAssocId = eventCtx.getCtx2();
        } else {
            sAssocId = getEntityId(sObjName, PM_NODE_OATTR);
        }
        if (sAssocId == null) {
            res[0] = new ActOpnd(null, null, null, false, false,
                    "Could not find an object attribute associated to object \""
                            + sObjName + "\"!");
            return res;
        }
        String sRecId = getRecordOf(sAssocId, PM_NODE_OATTR);
        if (sRecId == null) {
            res[0] = new ActOpnd(null, null, null, false, false, "Object "
                    + sObjName + " is not a field of a record!");
            return res;
        }

        String sRecName = getEntityName(sRecId, PM_NODE_OATTR);
        res[0] = new ActOpnd(sRecName, PM_NODE_OATTR, sRecId, false, false,
                null);
        return res;
    }

    private ActOpnd[] evalFun_oattr_record_of_oattr(EventContext eventCtx,
                                                    String sFunType, Vector<ActOpnd> funArgs) {
        ActOpnd[] res = new ActOpnd[1];
        if (funArgs.isEmpty() || funArgs.size() != 1) {
            res[0] = new ActOpnd(null, null, null, false, false,
                    "Incorrect number of arguments for function oattr_record_of_oattr");
            return res;
        }
        ActOpnd arg = funArgs.get(0);
        if (!arg.getType().equalsIgnoreCase(PM_NODE_OATTR)) {
            res[0] = new ActOpnd(null, null, null, false, false,
                    "Argument of function oattr_record_of_oattr is not an object attribute");
            return res;
        }
        String sOattrId = arg.getId();
        if (sOattrId == null) {
            res[0] = new ActOpnd(null, null, null, false, false,
                    "Argument of function oattr_record_of_oattr has null id!");
            return res;
        }

        String sRecId = getRecordOf(sOattrId, PM_NODE_OATTR);
        if (sRecId == null) {
            res[0] = new ActOpnd(null, null, null, false, false,
                    "No record containing the argument " + sOattrId);
            return res;
        }

        String sRecName = getEntityName(sRecId, PM_NODE_OATTR);
        res[0] = new ActOpnd(sRecName, PM_NODE_OATTR, sRecId, false, false,
                null);
        return res;
    }

    // This function returns the property "homeof=<user>", where <user>
    // is the name of the user just created. The event
    // must be "Create user", the context object must be a user, and the
    // event object class must be "User".
    // Parameters: None.
    private ActOpnd[] evalFun_prop_home_of_new_user(EventContext eventCtx,
                                                    String sFunType, Vector<ActOpnd> funArgs) {
        ActOpnd[] res = new ActOpnd[1];

        String sEventName = eventCtx.getEventName();
        if (!sEventName.equalsIgnoreCase(PM_EVENT_USER_CREATE)) {
            res[0] = new ActOpnd(null, null, null, false, false,
                    "Event is not \"" + PM_EVENT_USER_CREATE + "\"");
            return res;
        }
        String sUserName = eventCtx.getObjName();
        String sClass = eventCtx.getObjClass();
        if (!sClass.equalsIgnoreCase(PM_CLASS_USER_NAME)) {
            res[0] = new ActOpnd(null, null, null, false, false,
                    "Object class is not \"User\"");
            return res;
        }
        String sUserId = getEntityId(sUserName, PM_NODE_USER);
        if (sUserId == null) {
            res[0] = new ActOpnd(null, null, null, false, false, "No user \""
                    + sUserName + "\"");
            return res;
        }
        res[0] = new ActOpnd("homeof=" + sUserName, PM_UNKNOWN, null, false,
                false, null);
        return res;
    }

    private ActOpnd[] evalFun_prop_witems_of_new_user(EventContext eventCtx,
                                                      String sFunType, Vector<ActOpnd> funArgs) {
        ActOpnd[] res = new ActOpnd[1];

        String sEventName = eventCtx.getEventName();
        if (!sEventName.equalsIgnoreCase(PM_EVENT_USER_CREATE)) {
            res[0] = new ActOpnd(null, null, null, false, false,
                    "Event is not \"" + PM_EVENT_USER_CREATE + "\"");
            return res;
        }
        String sUserName = eventCtx.getObjName();
        String sClass = eventCtx.getObjClass();
        if (!sClass.equalsIgnoreCase(PM_CLASS_USER_NAME)) {
            res[0] = new ActOpnd(null, null, null, false, false,
                    "Object class is not \"User\"");
            return res;
        }
        String sUserId = getEntityId(sUserName, PM_NODE_USER);
        if (sUserId == null) {
            res[0] = new ActOpnd(null, null, null, false, false, "No user \""
                    + sUserName + "\"");
            return res;
        }
        res[0] = new ActOpnd("witemsof=" + sUserName, PM_UNKNOWN, null, false,
                false, null);
        return res;
    }

    private ActOpnd[] evalFun_prop_inbox_of_new_user(EventContext eventCtx,
                                                     String sFunType, Vector<ActOpnd> funArgs) {
        ActOpnd[] res = new ActOpnd[1];

        String sEventName = eventCtx.getEventName();
        if (!sEventName.equalsIgnoreCase(PM_EVENT_USER_CREATE)) {
            res[0] = new ActOpnd(null, null, null, false, false,
                    "Event is not \"" + PM_EVENT_USER_CREATE + "\"");
            return res;
        }
        String sUserName = eventCtx.getObjName();
        String sClass = eventCtx.getObjClass();
        if (!sClass.equalsIgnoreCase(PM_CLASS_USER_NAME)) {
            res[0] = new ActOpnd(null, null, null, false, false,
                    "Object class is not \"User\"");
            return res;
        }
        String sUserId = getEntityId(sUserName, PM_NODE_USER);
        if (sUserId == null) {
            res[0] = new ActOpnd(null, null, null, false, false, "No user \""
                    + sUserName + "\"");
            return res;
        }
        res[0] = new ActOpnd("inboxof=" + sUserName, PM_UNKNOWN, null, false,
                false, null);
        return res;
    }

    private ActOpnd[] evalFun_prop_inbox_of_user(EventContext eventCtx,
                                                 String sFunType, Vector<ActOpnd> funArgs) {
        ActOpnd[] res = new ActOpnd[1];

        if (funArgs.isEmpty() || funArgs.size() != 1) {
            res[0] = new ActOpnd(null, null, null, false, false,
                    "Incorrect number of arguments for function prop_inbox_of_user");
            return res;
        }
        ActOpnd arg = funArgs.get(0);
        if (!arg.getType().equalsIgnoreCase(PM_NODE_USER)) {
            res[0] = new ActOpnd(null, null, null, false, false,
                    "Argument of function prop_inbox_of_user is not a user");
            return res;
        }
        String sProp = "inboxof=" + arg.getName();
        res[0] = new ActOpnd(sProp, PM_UNKNOWN, null, false, false, null);
        return res;
    }

    private ActOpnd[] evalFun_prop_outbox_of_new_user(EventContext eventCtx,
                                                      String sFunType, Vector<ActOpnd> funArgs) {
        ActOpnd[] res = new ActOpnd[1];

        String sEventName = eventCtx.getEventName();
        if (!sEventName.equalsIgnoreCase(PM_EVENT_USER_CREATE)) {
            res[0] = new ActOpnd(null, null, null, false, false,
                    "Event is not \"" + PM_EVENT_USER_CREATE + "\"");
            return res;
        }
        String sUserName = eventCtx.getObjName();
        String sClass = eventCtx.getObjClass();
        if (!sClass.equalsIgnoreCase(PM_CLASS_USER_NAME)) {
            res[0] = new ActOpnd(null, null, null, false, false,
                    "Object class is not \"User\"");
            return res;
        }
        String sUserId = getEntityId(sUserName, PM_NODE_USER);
        if (sUserId == null) {
            res[0] = new ActOpnd(null, null, null, false, false, "No user \""
                    + sUserName + "\"");
            return res;
        }
        res[0] = new ActOpnd("outboxof=" + sUserName, PM_UNKNOWN, null, false,
                false, null);
        return res;
    }

    private ActOpnd[] evalFun_prop_outbox_of_user(EventContext eventCtx,
                                                  String sFunType, Vector<ActOpnd> funArgs) {
        ActOpnd[] res = new ActOpnd[1];

        if (funArgs.isEmpty() || funArgs.size() != 1) {
            res[0] = new ActOpnd(null, null, null, false, false,
                    "Incorrect number of arguments for function prop_outbox_of_user");
            return res;
        }
        ActOpnd arg = funArgs.get(0);
        if (!arg.getType().equalsIgnoreCase(PM_NODE_USER)) {
            res[0] = new ActOpnd(null, null, null, false, false,
                    "Argument of function prop_outbox_of_user is not a user");
            return res;
        }
        String sProp = "outboxof=" + arg.getName();
        res[0] = new ActOpnd(sProp, PM_UNKNOWN, null, false, false, null);
        return res;
    }

    // This function returns the property "nameof=<user>", where <user>
    // is the name of the user just created. The event
    // must be "Create user", the context object must be a user, and the
    // event object class must be "User".
    // Parameters: None.
    private ActOpnd[] evalFun_prop_name_of_new_user(EventContext eventCtx,
                                                    String sFunType, Vector<ActOpnd> funArgs) {
        ActOpnd[] res = new ActOpnd[1];

        String sEventName = eventCtx.getEventName();
        if (!sEventName.equalsIgnoreCase(PM_EVENT_USER_CREATE)) {
            res[0] = new ActOpnd(null, null, null, false, false,
                    "Event is not \"" + PM_EVENT_USER_CREATE + "\"");
            return res;
        }
        String sUserName = eventCtx.getObjName();
        String sClass = eventCtx.getObjClass();
        if (!sClass.equalsIgnoreCase(PM_CLASS_USER_NAME)) {
            res[0] = new ActOpnd(null, null, null, false, false,
                    "Object class is not \"User\"");
            return res;
        }
        String sUserId = getEntityId(sUserName, PM_NODE_USER);
        if (sUserId == null) {
            res[0] = new ActOpnd(null, null, null, false, false, "No user \""
                    + sUserName + "\"");
            return res;
        }
        res[0] = new ActOpnd("nameof=" + sUserName, PM_UNKNOWN, null, false,
                false, null);
        return res;
    }

    // Return the new user when the event is "User create".
    // Parameters: None.
    private ActOpnd[] evalFun_user_new(EventContext eventCtx, String sFunType,
                                       Vector<ActOpnd> funArgs) {
        ActOpnd[] res = new ActOpnd[1];

        String sEventName = eventCtx.getEventName();
        if (!sEventName.equalsIgnoreCase(PM_EVENT_USER_CREATE)) {
            res[0] = new ActOpnd(null, null, null, false, false,
                    "Event is not \"" + PM_EVENT_USER_CREATE + "\"");
            return res;
        }
        String sUserName = eventCtx.getObjName();
        String sClass = eventCtx.getObjClass();
        if (!sClass.equalsIgnoreCase(PM_CLASS_USER_NAME)) {
            res[0] = new ActOpnd(null, null, null, false, false,
                    "Object class is not \"User\"");
            return res;
        }
        String sUserId = getEntityId(sUserName, PM_NODE_USER);
        if (sUserId == null) {
            res[0] = new ActOpnd(null, null, null, false, false, "No user \""
                    + sUserName + "\"");
            return res;
        }
        res[0] = new ActOpnd(sUserName, PM_NODE_USER, sUserId, false, false,
                null);
        return res;
    }

    // Returns the object attribute with the property homeof=<user>,
    // where <user> is the user of the current session.
    // Parameters: None.
    private ActOpnd[] evalFun_oattr_home_of_default_user(EventContext eventCtx,
                                                         String sFunType, Vector<ActOpnd> funArgs) {
        ActOpnd[] res = new ActOpnd[1];

        String sSessId = eventCtx.getSessId();
        String sUserId = getSessionUserId(sSessId);
        if (sUserId == null) {
            res[0] = new ActOpnd(null, null, null, false, false,
                    "No user for session " + sSessId);
            return res;
        }
        String sUser = getEntityName(sUserId, PM_NODE_USER);
        if (sUser == null) {
            res[0] = new ActOpnd(null, null, null, false, false,
                    "No user with id " + sUserId);
            return res;
        }
        // Let's find the oattr with the property:
        String sProp = "homeof=" + sUser;
        String sOattrId = getEntityWithPropInternal(PM_NODE_OATTR, sProp);
        System.out.println("=============oattr with property " + sProp
                + " found " + sOattrId);

        if (sOattrId == null) {
            res[0] = new ActOpnd(null, null, null, false, false,
                    "No object attribute with property " + sProp);
            return res;
        }
        String sOattr = getEntityName(sOattrId, PM_NODE_OATTR);
        if (sOattr == null) {
            res[0] = new ActOpnd(null, null, null, false, false,
                    "No object attribute with id " + sOattrId);
            return res;
        }
        res[0] = new ActOpnd(sOattr, PM_NODE_OATTR, sOattrId, false, false,
                null);
        return res;
    }

    private ActOpnd[] evalFun_oattr_outboxes(EventContext eventCtx,
                                             String sFunType, Vector<ActOpnd> funArgs) {
        ActOpnd[] res = new ActOpnd[1];

        // Let's find the oattr with the property:
        String sProp = "containerof=outboxes";
        String sOattrId = getEntityWithPropInternal(PM_NODE_OATTR, sProp);
        if (sOattrId == null) {
            res[0] = new ActOpnd(null, null, null, false, false,
                    "No object attribute with property " + sProp);
            return res;
        }
        String sOattr = getEntityName(sOattrId, PM_NODE_OATTR);
        if (sOattr == null) {
            res[0] = new ActOpnd(null, null, null, false, false,
                    "No object attribute with id " + sOattrId);
            return res;
        }
        res[0] = new ActOpnd(sOattr, PM_NODE_OATTR, sOattrId, false, false,
                null);
        return res;
    }

    private ActOpnd[] evalFun_oattr_inboxes(EventContext eventCtx,
                                            String sFunType, Vector<ActOpnd> funArgs) {
        ActOpnd[] res = new ActOpnd[1];

        // Let's find the oattr with the property:
        String sProp = "containerof=inboxes";
        String sOattrId = getEntityWithPropInternal(PM_NODE_OATTR, sProp);
        if (sOattrId == null) {
            res[0] = new ActOpnd(null, null, null, false, false,
                    "No object attribute with property " + sProp);
            return res;
        }
        String sOattr = getEntityName(sOattrId, PM_NODE_OATTR);
        if (sOattr == null) {
            res[0] = new ActOpnd(null, null, null, false, false,
                    "No object attribute with id " + sOattrId);
            return res;
        }
        res[0] = new ActOpnd(sOattr, PM_NODE_OATTR, sOattrId, false, false,
                null);
        return res;
    }

    private ActOpnd[] evalFun_oattr_witems(EventContext eventCtx,
                                           String sFunType, Vector<ActOpnd> funArgs) {
        ActOpnd[] res = new ActOpnd[1];

        // Let's find the oattr with the property:
        String sProp = "containerof=witems";
        String sOattrId = getEntityWithPropInternal(PM_NODE_OATTR, sProp);
        if (sOattrId == null) {
            res[0] = new ActOpnd(null, null, null, false, false,
                    "No object attribute with property " + sProp);
            return res;
        }
        String sOattr = getEntityName(sOattrId, PM_NODE_OATTR);
        if (sOattr == null) {
            res[0] = new ActOpnd(null, null, null, false, false,
                    "No object attribute with id " + sOattrId);
            return res;
        }
        res[0] = new ActOpnd(sOattr, PM_NODE_OATTR, sOattrId, false, false,
                null);
        return res;
    }

    private ActOpnd[] evalFun_oattr_inbox_of_user(EventContext eventCtx,
                                                  String sFunType, Vector<ActOpnd> funArgs) {
        ActOpnd[] res = new ActOpnd[1];

        if (funArgs.isEmpty() || funArgs.size() != 1) {
            res[0] = new ActOpnd(null, null, null, false, false,
                    "Incorrect number of arguments for function oattr_inbox_of_user");
            return res;
        }
        ActOpnd arg = funArgs.get(0);
        if (!arg.getType().equalsIgnoreCase(PM_NODE_USER)) {
            res[0] = new ActOpnd(null, null, null, false, false,
                    "Argument of function oattr_inbox_of_user is not a user");
            return res;
        }
        String sUserName = arg.getName();
        String sInboxName = sUserName + " INBOX";
        String sInboxId = getEntityId(sInboxName, PM_NODE_OATTR);
        res[0] = new ActOpnd(sInboxName, PM_NODE_OATTR, sInboxId, false, false,
                null);
        return res;
    }

    private ActOpnd[] evalFun_oattr_winbox_of_user(EventContext eventCtx,
                                                   String sFunType, Vector<ActOpnd> funArgs) {
        ActOpnd[] res = new ActOpnd[1];

        if (funArgs.isEmpty() || funArgs.size() != 1) {
            res[0] = new ActOpnd(null, null, null, false, false,
                    "Incorrect number of arguments for function oattr_winbox_of_user");
            return res;
        }
        ActOpnd arg = funArgs.get(0);
        if (!arg.getType().equalsIgnoreCase(PM_NODE_USER)) {
            res[0] = new ActOpnd(null, null, null, false, false,
                    "Argument of function oattr_winbox_of_user is not a user");
            return res;
        }
        String sUserName = arg.getName();
        String sInboxName = sUserName + " wINBOX";
        String sInboxId = getEntityId(sInboxName, PM_NODE_OATTR);
        res[0] = new ActOpnd(sInboxName, PM_NODE_OATTR, sInboxId, false, false,
                null);
        return res;
    }

    private ActOpnd[] evalFun_oattr_outbox_of_new_user(EventContext eventCtx,
                                                       String sFunType, Vector<ActOpnd> funArgs) {
        ActOpnd[] res = new ActOpnd[1];

        String sEventName = eventCtx.getEventName();
        if (!sEventName.equalsIgnoreCase(PM_EVENT_USER_CREATE)) {
            res[0] = new ActOpnd(null, null, null, false, false,
                    "Event is not \"" + PM_EVENT_USER_CREATE + "\"");
            return res;
        }
        String sUserName = eventCtx.getObjName();
        String sClass = eventCtx.getObjClass();
        if (!sClass.equalsIgnoreCase(PM_CLASS_USER_NAME)) {
            res[0] = new ActOpnd(null, null, null, false, false,
                    "Object class is not \"User\"");
            return res;
        }
        String sUserId = getEntityId(sUserName, PM_NODE_USER);
        if (sUserId == null) {
            res[0] = new ActOpnd(null, null, null, false, false, "No user \""
                    + sUserName + "\"");
            return res;
        }
        String sOutboxName = sUserName + " OUTBOX";
        String sOutboxId = getEntityId(sOutboxName, PM_NODE_OATTR);
        res[0] = new ActOpnd(sOutboxName, PM_NODE_OATTR, sOutboxId, false,
                false, null);
        return res;
    }

    private ActOpnd[] evalFun_oattr_outbox_of_user(EventContext eventCtx,
                                                   String sFunType, Vector<ActOpnd> funArgs) {
        ActOpnd[] res = new ActOpnd[1];

        if (funArgs.isEmpty() || funArgs.size() != 1) {
            res[0] = new ActOpnd(null, null, null, false, false,
                    "Incorrect number of arguments for function oattr_outbox_of_user");
            return res;
        }
        ActOpnd arg = funArgs.get(0);
        if (!arg.getType().equalsIgnoreCase(PM_NODE_USER)) {
            res[0] = new ActOpnd(null, null, null, false, false,
                    "Argument of function oattr_outbox_of_user is not a user");
            return res;
        }
        String sUserName = arg.getName();
        String sOutboxName = sUserName + " OUTBOX";
        String sOutboxId = getEntityId(sOutboxName, PM_NODE_OATTR);
        res[0] = new ActOpnd(sOutboxName, PM_NODE_OATTR, sOutboxId, false,
                false, null);
        return res;
    }

    private ActOpnd[] evalFun_oattr_witems_of_new_user(EventContext eventCtx,
                                                       String sFunType, Vector<ActOpnd> funArgs) {
        ActOpnd[] res = new ActOpnd[1];

        String sEventName = eventCtx.getEventName();
        if (!sEventName.equalsIgnoreCase(PM_EVENT_USER_CREATE)) {
            res[0] = new ActOpnd(null, null, null, false, false,
                    "Event is not \"" + PM_EVENT_USER_CREATE + "\"");
            return res;
        }
        String sUserName = eventCtx.getObjName();
        String sClass = eventCtx.getObjClass();
        if (!sClass.equalsIgnoreCase(PM_CLASS_USER_NAME)) {
            res[0] = new ActOpnd(null, null, null, false, false,
                    "Object class is not \"User\"");
            return res;
        }
        String sUserId = getEntityId(sUserName, PM_NODE_USER);
        if (sUserId == null) {
            res[0] = new ActOpnd(null, null, null, false, false, "No user \""
                    + sUserName + "\"");
            return res;
        }
        String sInboxName = sUserName + " witems";
        String sInboxId = getEntityId(sInboxName, PM_NODE_OATTR);
        res[0] = new ActOpnd(sInboxName, PM_NODE_OATTR, sInboxId, false, false,
                null);
        return res;
    }

    // Returns the object attribute which will be the INBOX container of the
    // new user. Its name is "<user> INBOX",
    // where <user> is the new user. The event name must be "User create",
    // the object name must be the new user name, and the object class
    // must be "User".
    private ActOpnd[] evalFun_oattr_inbox_of_new_user(EventContext eventCtx,
                                                      String sFunType, Vector<ActOpnd> funArgs) {
        ActOpnd[] res = new ActOpnd[1];

        String sEventName = eventCtx.getEventName();
        if (!sEventName.equalsIgnoreCase(PM_EVENT_USER_CREATE)) {
            res[0] = new ActOpnd(null, null, null, false, false,
                    "Event is not \"" + PM_EVENT_USER_CREATE + "\"");
            return res;
        }
        String sUserName = eventCtx.getObjName();
        String sClass = eventCtx.getObjClass();
        if (!sClass.equalsIgnoreCase(PM_CLASS_USER_NAME)) {
            res[0] = new ActOpnd(null, null, null, false, false,
                    "Object class is not \"User\"");
            return res;
        }
        String sUserId = getEntityId(sUserName, PM_NODE_USER);
        if (sUserId == null) {
            res[0] = new ActOpnd(null, null, null, false, false, "No user \""
                    + sUserName + "\"");
            return res;
        }
        String sInboxName = sUserName + " INBOX";
        String sInboxId = getEntityId(sInboxName, PM_NODE_OATTR);
        res[0] = new ActOpnd(sInboxName, PM_NODE_OATTR, sInboxId, false, false,
                null);
        return res;
    }

    // Returns the object attribute which will be the wINBOX container of the
    // new user. Its name is "<user> wINBOX",
    // where <user> is the new user. The event name must be "User create",
    // the object name must be the new user name, and the object class
    // must be "User".
    private ActOpnd[] evalFun_oattr_winbox_of_new_user(EventContext eventCtx,
                                                       String sFunType, Vector<ActOpnd> funArgs) {
        ActOpnd[] res = new ActOpnd[1];

        String sEventName = eventCtx.getEventName();
        if (!sEventName.equalsIgnoreCase(PM_EVENT_USER_CREATE)) {
            res[0] = new ActOpnd(null, null, null, false, false,
                    "Event is not \"" + PM_EVENT_USER_CREATE + "\"");
            return res;
        }
        String sUserName = eventCtx.getObjName();
        String sClass = eventCtx.getObjClass();
        if (!sClass.equalsIgnoreCase(PM_CLASS_USER_NAME)) {
            res[0] = new ActOpnd(null, null, null, false, false,
                    "Object class is not \"User\"");
            return res;
        }
        String sUserId = getEntityId(sUserName, PM_NODE_USER);
        if (sUserId == null) {
            res[0] = new ActOpnd(null, null, null, false, false, "No user \""
                    + sUserName + "\"");
            return res;
        }
        String sInboxName = sUserName + " wINBOX";
        String sInboxId = getEntityId(sInboxName, PM_NODE_OATTR);
        res[0] = new ActOpnd(sInboxName, PM_NODE_OATTR, sInboxId, false, false,
                null);
        return res;
    }

    // Returns the object attribute which will be the home container of the
    // new user. Its name is "<user> home",
    // where <user> is the new user. The event name must be "User create",
    // the object name must be the new user name, and the object class
    // must be "User".
    // Parameters: None.
    private ActOpnd[] evalFun_oattr_home_of_new_user(EventContext eventCtx,
                                                     String sFunType, Vector<ActOpnd> funArgs) {
        ActOpnd[] res = new ActOpnd[1];

        String sEventName = eventCtx.getEventName();
        if (!sEventName.equalsIgnoreCase(PM_EVENT_USER_CREATE)) {
            res[0] = new ActOpnd(null, null, null, false, false,
                    "Event is not \"" + PM_EVENT_USER_CREATE + "\"");
            return res;
        }
        String sUserName = eventCtx.getObjName();
        String sClass = eventCtx.getObjClass();
        if (!sClass.equalsIgnoreCase(PM_CLASS_USER_NAME)) {
            res[0] = new ActOpnd(null, null, null, false, false,
                    "Object class is not \"User\"");
            return res;
        }
        String sUserId = getEntityId(sUserName, PM_NODE_USER);
        if (sUserId == null) {
            res[0] = new ActOpnd(null, null, null, false, false, "No user \""
                    + sUserName + "\"");
            return res;
        }
        String sHomeName = sUserName + " home";
        String sHomeId = getEntityId(sHomeName, PM_NODE_OATTR);
        res[0] = new ActOpnd(sHomeName, PM_NODE_OATTR, sHomeId, false, false,
                null);
        return res;
    }

    // Returns the object attribute which is the home container of the
    // user passed as argument. Its name is "<user> home".
    // Parameters: A user.
    private ActOpnd[] evalFun_oattr_home_of_user(EventContext eventCtx,
                                                 String sFunType, Vector<ActOpnd> funArgs) {
        ActOpnd[] res = new ActOpnd[1];

        if (funArgs.isEmpty() || funArgs.size() != 1) {
            res[0] = new ActOpnd(null, null, null, false, false,
                    "Incorrect number of arguments for function oattr_home_of_user");
            return res;
        }
        ActOpnd arg = funArgs.get(0);
        if (!arg.getType().equalsIgnoreCase(PM_NODE_USER)) {
            res[0] = new ActOpnd(null, null, null, false, false,
                    "Argument of function oattr_home_of_user is not a user");
            return res;
        }
        String sUserName = arg.getName();
        String sHomeName = sUserName + " home";
        String sHomeId = getEntityId(sHomeName, PM_NODE_OATTR);
        res[0] = new ActOpnd(sHomeName, PM_NODE_OATTR, sHomeId, false, false,
                null);
        return res;
    }

    // Returns the object that represents the outbox container of the
    // new user. Its name is "<user> outbox rep",
    // where <user> is the new user. The event name must be "User create",
    // the object name must be the new user name, and the object class
    // must be "User".
    // Parameters: None.
    private ActOpnd[] evalFun_obj_rep_of_outbox_of_new_user(
            EventContext eventCtx, String sFunType, Vector<ActOpnd> funArgs) {
        ActOpnd[] res = new ActOpnd[1];

        String sEventName = eventCtx.getEventName();
        if (!sEventName.equalsIgnoreCase(PM_EVENT_USER_CREATE)) {
            res[0] = new ActOpnd(null, null, null, false, false,
                    "Event is not \"" + PM_EVENT_USER_CREATE + "\"");
            return res;
        }
        String sUserName = eventCtx.getObjName();
        String sClass = eventCtx.getObjClass();
        if (!sClass.equalsIgnoreCase(PM_CLASS_USER_NAME)) {
            res[0] = new ActOpnd(null, null, null, false, false,
                    "Object class is not \"User\"");
            return res;
        }
        String sUserId = getEntityId(sUserName, PM_NODE_USER);
        if (sUserId == null) {
            res[0] = new ActOpnd(null, null, null, false, false, "No user \""
                    + sUserName + "\"");
            return res;
        }
        String sRepName = sUserName + " outbox rep";
        String sRepId = getEntityId(sRepName, PM_OBJ);
        res[0] = new ActOpnd(sRepName, PM_OBJ, sRepId, false, false, null);
        return res;
    }

    // Returns the object that represents the inbox container of the
    // new user. Its name is "<user> inbox rep",
    // where <user> is the new user. The event name must be "User create",
    // the object name must be the new user name, and the object class
    // must be "User".
    // Parameters: None.
    private ActOpnd[] evalFun_obj_rep_of_inbox_of_new_user(
            EventContext eventCtx, String sFunType, Vector<ActOpnd> funArgs) {
        ActOpnd[] res = new ActOpnd[1];

        String sEventName = eventCtx.getEventName();
        if (!sEventName.equalsIgnoreCase(PM_EVENT_USER_CREATE)) {
            res[0] = new ActOpnd(null, null, null, false, false,
                    "Event is not \"" + PM_EVENT_USER_CREATE + "\"");
            return res;
        }
        String sUserName = eventCtx.getObjName();
        String sClass = eventCtx.getObjClass();
        if (!sClass.equalsIgnoreCase(PM_CLASS_USER_NAME)) {
            res[0] = new ActOpnd(null, null, null, false, false,
                    "Object class is not \"User\"");
            return res;
        }
        String sUserId = getEntityId(sUserName, PM_NODE_USER);
        if (sUserId == null) {
            res[0] = new ActOpnd(null, null, null, false, false, "No user \""
                    + sUserName + "\"");
            return res;
        }
        String sRepName = sUserName + " inbox rep";
        String sRepId = getEntityId(sRepName, PM_OBJ);
        res[0] = new ActOpnd(sRepName, PM_OBJ, sRepId, false, false, null);
        return res;
    }

    // Returns the object that represents the home container of the
    // new user. Its name is "<user> home rep",
    // where <user> is the new user. The event name must be "User create",
    // the object name must be the new user name, and the object class
    // must be "User".
    // Parameters: None.
    private ActOpnd[] evalFun_obj_rep_of_home_of_new_user(
            EventContext eventCtx, String sFunType, Vector<ActOpnd> funArgs) {
        ActOpnd[] res = new ActOpnd[1];

        String sEventName = eventCtx.getEventName();
        if (!sEventName.equalsIgnoreCase(PM_EVENT_USER_CREATE)) {
            res[0] = new ActOpnd(null, null, null, false, false,
                    "Event is not \"" + PM_EVENT_USER_CREATE + "\"");
            return res;
        }
        String sUserName = eventCtx.getObjName();
        String sClass = eventCtx.getObjClass();
        if (!sClass.equalsIgnoreCase(PM_CLASS_USER_NAME)) {
            res[0] = new ActOpnd(null, null, null, false, false,
                    "Object class is not \"User\"");
            return res;
        }
        String sUserId = getEntityId(sUserName, PM_NODE_USER);
        if (sUserId == null) {
            res[0] = new ActOpnd(null, null, null, false, false, "No user \""
                    + sUserName + "\"");
            return res;
        }
        String sRepName = sUserName + " home rep";
        String sRepId = getEntityId(sRepName, PM_OBJ);
        res[0] = new ActOpnd(sRepName, PM_OBJ, sRepId, false, false, null);
        return res;
    }

    // Returns the object which represents the user attribute container
    // of the discretionary users, i.e., the user attribute with the
    // property "usersof=dicretionary". The name of this object is
    // <name of user attr container> + "rep".
    // Parameters: None.
    private ActOpnd[] evalFun_obj_rep_of_discr_users(EventContext eventCtx,
                                                     String sFunType, Vector<ActOpnd> funArgs) {
        ActOpnd[] res = new ActOpnd[1];

        // Let's find the uattr with the property:
        String sProp = "usersof=discretionary";
        String sUattrId = getEntityWithPropInternal(PM_NODE_UATTR, sProp);
        System.out.println("=============uattr with property " + sProp
                + " found " + sUattrId);

        if (sUattrId == null) {
            res[0] = new ActOpnd(null, null, null, false, false,
                    "No user attribute with property " + sProp);
            return res;
        }
        String sUattrName = getEntityName(sUattrId, PM_NODE_UATTR);
        if (sUattrName == null) {
            res[0] = new ActOpnd(null, null, null, false, false,
                    "No user attribute with id " + sUattrId);
            return res;
        }
        String sRepName = sUattrName + " rep";
        String sRepId = getEntityId(sRepName, PM_NODE_OATTR);
        // We don't test sRepId, because it may not exist when we call this
        // function just to get the object created.
        res[0] = new ActOpnd(sRepName, PM_OBJ, sRepId, false, false, null);
        return res;
    }

    // Returns the object which represents the outbox container of the
    // user passed as argument. Its name is "<user> outbox rep".
    // Parameters: a user.
    private ActOpnd[] evalFun_obj_rep_of_outbox_of_user(EventContext eventCtx,
                                                        String sFunType, Vector<ActOpnd> funArgs) {
        ActOpnd[] res = new ActOpnd[1];

        if (funArgs.isEmpty() || funArgs.size() != 1) {
            res[0] = new ActOpnd(null, null, null, false, false,
                    "Incorrect number of arguments for function obj_rep_of_outbox_of_user");
            return res;
        }
        ActOpnd arg = funArgs.get(0);
        if (!arg.getType().equalsIgnoreCase(PM_NODE_USER)) {
            res[0] = new ActOpnd(null, null, null, false, false,
                    "Argument of function obj_rep_of_outbox_of_user is not a user");
            return res;
        }
        String sUserName = arg.getName();
        String sRepName = sUserName + " outbox rep";
        String sRepId = getEntityId(sRepName, PM_OBJ);
        res[0] = new ActOpnd(sRepName, PM_OBJ, sRepId, false, false, null);
        return res;
    }

    // Returns the object which represents the inbox container of the
    // user passed as argument. Its name is "<user> inbox rep".
    // Parameters: a user.
    private ActOpnd[] evalFun_obj_rep_of_inbox_of_user(EventContext eventCtx,
                                                       String sFunType, Vector<ActOpnd> funArgs) {
        ActOpnd[] res = new ActOpnd[1];

        if (funArgs.isEmpty() || funArgs.size() != 1) {
            res[0] = new ActOpnd(null, null, null, false, false,
                    "Incorrect number of arguments for function obj_rep_of_inbox_of_user");
            return res;
        }
        ActOpnd arg = funArgs.get(0);
        if (!arg.getType().equalsIgnoreCase(PM_NODE_USER)) {
            res[0] = new ActOpnd(null, null, null, false, false,
                    "Argument of function obj_rep_of_inbox_of_user is not a user");
            return res;
        }
        String sUserName = arg.getName();
        String sRepName = sUserName + " inbox rep";
        String sRepId = getEntityId(sRepName, PM_OBJ);
        res[0] = new ActOpnd(sRepName, PM_OBJ, sRepId, false, false, null);
        return res;
    }

    // Returns the object which represents the home container of the
    // user passed as argument. Its name is "<user> home rep".
    // Parameters: a user.
    private ActOpnd[] evalFun_obj_rep_of_home_of_user(EventContext eventCtx,
                                                      String sFunType, Vector<ActOpnd> funArgs) {
        ActOpnd[] res = new ActOpnd[1];

        if (funArgs.isEmpty() || funArgs.size() != 1) {
            res[0] = new ActOpnd(null, null, null, false, false,
                    "Incorrect number of arguments for function obj_rep_of_home_of_user");
            return res;
        }
        ActOpnd arg = funArgs.get(0);
        if (!arg.getType().equalsIgnoreCase(PM_NODE_USER)) {
            res[0] = new ActOpnd(null, null, null, false, false,
                    "Argument of function obj_rep_of_home_of_user is not a user");
            return res;
        }
        String sUserName = arg.getName();
        String sRepName = sUserName + " home rep";
        String sRepId = getEntityId(sRepName, PM_OBJ);
        res[0] = new ActOpnd(sRepName, PM_OBJ, sRepId, false, false, null);
        return res;
    }

    // Like evalFun_obj_rep_of_outbox_of_new_user, but returns an object
    // attribute.
    // Parameters: None.
    private ActOpnd[] evalFun_oattr_rep_of_outbox_of_new_user(
            EventContext eventCtx, String sFunType, Vector<ActOpnd> funArgs) {
        ActOpnd[] res = new ActOpnd[1];

        String sEventName = eventCtx.getEventName();
        if (!sEventName.equalsIgnoreCase(PM_EVENT_USER_CREATE)) {
            res[0] = new ActOpnd(null, null, null, false, false,
                    "Event is not \"" + PM_EVENT_USER_CREATE + "\"");
            return res;
        }
        String sUserName = eventCtx.getObjName();
        String sClass = eventCtx.getObjClass();
        if (!sClass.equalsIgnoreCase(PM_CLASS_USER_NAME)) {
            res[0] = new ActOpnd(null, null, null, false, false,
                    "Object class is not \"User\"");
            return res;
        }
        String sUserId = getEntityId(sUserName, PM_NODE_USER);
        if (sUserId == null) {
            res[0] = new ActOpnd(null, null, null, false, false, "No user \""
                    + sUserName + "\"");
            return res;
        }
        String sRepName = sUserName + " outbox rep";
        String sRepId = getEntityId(sRepName, PM_NODE_OATTR);
        res[0] = new ActOpnd(sRepName, PM_NODE_OATTR, sRepId, false, false,
                null);
        return res;
    }

    // Like evalFun_obj_rep_of_inbox_of_new_user, but returns an object
    // attribute.
    // Parameters: None.
    private ActOpnd[] evalFun_oattr_rep_of_inbox_of_new_user(
            EventContext eventCtx, String sFunType, Vector<ActOpnd> funArgs) {
        ActOpnd[] res = new ActOpnd[1];

        String sEventName = eventCtx.getEventName();
        if (!sEventName.equalsIgnoreCase(PM_EVENT_USER_CREATE)) {
            res[0] = new ActOpnd(null, null, null, false, false,
                    "Event is not \"" + PM_EVENT_USER_CREATE + "\"");
            return res;
        }
        String sUserName = eventCtx.getObjName();
        String sClass = eventCtx.getObjClass();
        if (!sClass.equalsIgnoreCase(PM_CLASS_USER_NAME)) {
            res[0] = new ActOpnd(null, null, null, false, false,
                    "Object class is not \"User\"");
            return res;
        }
        String sUserId = getEntityId(sUserName, PM_NODE_USER);
        if (sUserId == null) {
            res[0] = new ActOpnd(null, null, null, false, false, "No user \""
                    + sUserName + "\"");
            return res;
        }
        String sRepName = sUserName + " inbox rep";
        String sRepId = getEntityId(sRepName, PM_NODE_OATTR);
        res[0] = new ActOpnd(sRepName, PM_NODE_OATTR, sRepId, false, false,
                null);
        return res;
    }

    // Like evalFun_obj_rep_of_home_of_new_user, but returns an object
    // attribute.
    // Parameters: None.
    private ActOpnd[] evalFun_oattr_rep_of_home_of_new_user(
            EventContext eventCtx, String sFunType, Vector<ActOpnd> funArgs) {
        ActOpnd[] res = new ActOpnd[1];

        String sEventName = eventCtx.getEventName();
        if (!sEventName.equalsIgnoreCase(PM_EVENT_USER_CREATE)) {
            res[0] = new ActOpnd(null, null, null, false, false,
                    "Event is not \"" + PM_EVENT_USER_CREATE + "\"");
            return res;
        }
        String sUserName = eventCtx.getObjName();
        String sClass = eventCtx.getObjClass();
        if (!sClass.equalsIgnoreCase(PM_CLASS_USER_NAME)) {
            res[0] = new ActOpnd(null, null, null, false, false,
                    "Object class is not \"User\"");
            return res;
        }
        String sUserId = getEntityId(sUserName, PM_NODE_USER);
        if (sUserId == null) {
            res[0] = new ActOpnd(null, null, null, false, false, "No user \""
                    + sUserName + "\"");
            return res;
        }
        String sRepName = sUserName + " home rep";
        String sRepId = getEntityId(sRepName, PM_NODE_OATTR);
        res[0] = new ActOpnd(sRepName, PM_NODE_OATTR, sRepId, false, false,
                null);
        return res;
    }

    // Like evalFun_obj_rep_of_outbox_of_user, but returns an object attribute.
    // Parameters: a user.
    private ActOpnd[] evalFun_oattr_rep_of_outbox_of_user(
            EventContext eventCtx, String sFunType, Vector<ActOpnd> funArgs) {
        ActOpnd[] res = new ActOpnd[1];

        if (funArgs.isEmpty() || funArgs.size() != 1) {
            res[0] = new ActOpnd(null, null, null, false, false,
                    "Incorrect number of arguments for function oattr_rep_of_outbox_of_user");
            return res;
        }
        ActOpnd arg = funArgs.get(0);
        if (!arg.getType().equalsIgnoreCase(PM_NODE_USER)) {
            res[0] = new ActOpnd(null, null, null, false, false,
                    "Argument of function oattr_rep_of_outbox_of_user is not a user");
            return res;
        }
        String sUserName = arg.getName();
        String sRepName = sUserName + " outbox rep";
        String sRepId = getEntityId(sRepName, PM_NODE_OATTR);
        res[0] = new ActOpnd(sRepName, PM_NODE_OATTR, sRepId, false, false,
                null);
        return res;
    }

    // Like evalFun_obj_rep_of_inbox_of_user, but returns an object attribute.
    // Parameters: a user.
    private ActOpnd[] evalFun_oattr_rep_of_inbox_of_user(EventContext eventCtx,
                                                         String sFunType, Vector<ActOpnd> funArgs) {
        ActOpnd[] res = new ActOpnd[1];

        if (funArgs.isEmpty() || funArgs.size() != 1) {
            res[0] = new ActOpnd(null, null, null, false, false,
                    "Incorrect number of arguments for function oattr_rep_of_inbox_of_user");
            return res;
        }
        ActOpnd arg = funArgs.get(0);
        if (!arg.getType().equalsIgnoreCase(PM_NODE_USER)) {
            res[0] = new ActOpnd(null, null, null, false, false,
                    "Argument of function oattr_rep_of_inbox_of_user is not a user");
            return res;
        }
        String sUserName = arg.getName();
        String sRepName = sUserName + " inbox rep";
        String sRepId = getEntityId(sRepName, PM_NODE_OATTR);
        res[0] = new ActOpnd(sRepName, PM_NODE_OATTR, sRepId, false, false,
                null);
        return res;
    }

    // Like evalFun_obj_rep_of_home_of_user, but returns an object attribute.
    // Parameters: a user.
    private ActOpnd[] evalFun_oattr_rep_of_home_of_user(EventContext eventCtx,
                                                        String sFunType, Vector<ActOpnd> funArgs) {
        ActOpnd[] res = new ActOpnd[1];

        if (funArgs.isEmpty() || funArgs.size() != 1) {
            res[0] = new ActOpnd(null, null, null, false, false,
                    "Incorrect number of arguments for function oattr_rep_of_home_of_user");
            return res;
        }
        ActOpnd arg = funArgs.get(0);
        if (!arg.getType().equalsIgnoreCase(PM_NODE_USER)) {
            res[0] = new ActOpnd(null, null, null, false, false,
                    "Argument of function oattr_rep_of_home_of_user is not a user");
            return res;
        }
        String sUserName = arg.getName();
        String sRepName = sUserName + " home rep";
        String sRepId = getEntityId(sRepName, PM_NODE_OATTR);
        res[0] = new ActOpnd(sRepName, PM_NODE_OATTR, sRepId, false, false,
                null);
        return res;
    }

    // Returns the object that represents all discretionary users and
    // attributes.
    // First find the uattr with the property
    // "usersof=discretionary", then add " rep" to its name, and look for an
    // object attribute with this name associated to an object.
    // Parameters: None.
    private ActOpnd[] evalFun_oattr_rep_of_discr_users(EventContext eventCtx,
                                                       String sFunType, Vector<ActOpnd> funArgs) {
        ActOpnd[] res = new ActOpnd[1];

        // Let's find the uattr with the property:
        String sProp = "usersof=discretionary";
        String sUattrId = getEntityWithPropInternal(PM_NODE_UATTR, sProp);
        System.out.println("=============uattr with property " + sProp
                + " found " + sUattrId);

        if (sUattrId == null) {
            res[0] = new ActOpnd(null, null, null, false, false,
                    "No user attribute with property " + sProp);
            return res;
        }
        String sUattrName = getEntityName(sUattrId, PM_NODE_UATTR);
        if (sUattrName == null) {
            res[0] = new ActOpnd(null, null, null, false, false,
                    "No user attribute with id " + sUattrId);
            return res;
        }
        String sRepName = sUattrName + " rep";
        String sRepId = getEntityId(sRepName, PM_NODE_OATTR);
        if (sRepId == null) {
            res[0] = new ActOpnd(null, null, null, false, false,
                    "No object attribute " + sRepName);
            return res;
        }
        res[0] = new ActOpnd(sRepName, PM_NODE_OATTR, sRepId, false, false,
                null);
        return res;
    }

    // Returns the user attribute "DAC users".
    // Parameters: None.
    private ActOpnd[] evalFun_uattr_discr_users(EventContext eventCtx,
                                                String sFunType, Vector<ActOpnd> funArgs) {
        ActOpnd[] res = new ActOpnd[1];

        // Let's find the uattr with the property:
        String sProp = "usersof=discretionary";
        String sUattrId = getEntityWithPropInternal(PM_NODE_UATTR, sProp);
        System.out.println("=============uattr with property " + sProp
                + " found " + sUattrId);
        if (sUattrId == null) {
            res[0] = new ActOpnd(null, null, null, false, false,
                    "No user attribute with property " + sProp);
            return res;
        }
        String sUattrName = getEntityName(sUattrId, PM_NODE_UATTR);
        if (sUattrName == null) {
            res[0] = new ActOpnd(null, null, null, false, false,
                    "No user attribute with id " + sUattrId);
            return res;
        }
        res[0] = new ActOpnd(sUattrName, PM_NODE_UATTR, sUattrId, false, false,
                null);
        return res;
    }

    // Returns the default process, i.e., the one that triggered the event.
    // Parameters: None.
    private ActOpnd[] evalFun_process_default(EventContext eventCtx,
                                              String sFunType, Vector<ActOpnd> funArgs) {
        ActOpnd[] res = new ActOpnd[1];

        String sProcId = eventCtx.getProcId();
        if (sProcId == null) {
            res[0] = new ActOpnd(null, null, null, false, false,
                    "No process in the event context");
            return res;
        }
        // The process name (first arg in ActOpnd) is the same as the process
        // id.
        res[0] = new ActOpnd(sProcId, PM_PROCESS, sProcId, false, false, null);
        return res;
    }

    // Returns the default session, i.e., the one that triggered the event.
    // Parameters: None.
    private ActOpnd[] evalFun_session_default(EventContext eventCtx,
                                              String sFunType, Vector<ActOpnd> funArgs) {
        ActOpnd[] res = new ActOpnd[1];

        String sSessId = eventCtx.getSessId();
        if (sSessId == null) {
            res[0] = new ActOpnd(null, null, null, false, false,
                    "No session in the event context");
            return res;
        }
        String sSessName = getEntityName(sSessId, PM_SESSION);
        if (sSessName == null) {
            res[0] = new ActOpnd(null, null, null, false, false,
                    "No session with id " + sSessId);
            return res;
        }
        res[0] = new ActOpnd(sSessName, PM_SESSION, sSessId, false, false, null);
        return res;
    }

    // Returns the default user, i.e., the session user.
    // Parameters: None.
    private ActOpnd[] evalFun_user_default(EventContext eventCtx,
                                           String sFunType, Vector<ActOpnd> funArgs) {
        ActOpnd[] res = new ActOpnd[1];

        String sSessId = eventCtx.getSessId();
        String sUserId = getSessionUserId(sSessId);
        if (sUserId == null) {
            res[0] = new ActOpnd(null, null, null, false, false,
                    "No user for session " + sSessId);
            return res;
        }
        String sUserName = getEntityName(sUserId, PM_NODE_USER);
        if (sUserName == null) {
            res[0] = new ActOpnd(null, null, null, false, false,
                    "No user with id " + sUserId);
            return res;
        }
        res[0] = new ActOpnd(sUserName, PM_NODE_USER, sUserId, false, false,
                null);
        return res;
    }

    // Returns the name attribute of the new user. Its name is "<user> name",
    // where <user> is the new user. The event name must be "User create",
    // the object name must be the new user name, and the object class
    // must be "User".
    // Parameters: None.
    private ActOpnd[] evalFun_uattr_name_of_new_user(EventContext eventCtx,
                                                     String sFunType, Vector<ActOpnd> funArgs) {
        ActOpnd[] res = new ActOpnd[1];

        String sEventName = eventCtx.getEventName();
        if (!sEventName.equalsIgnoreCase(PM_EVENT_USER_CREATE)) {
            res[0] = new ActOpnd(null, null, null, false, false,
                    "Event is not \"" + PM_EVENT_USER_CREATE + "\"");
            return res;
        }
        String sUserName = eventCtx.getObjName();
        String sClass = eventCtx.getObjClass();
        if (!sClass.equalsIgnoreCase(PM_CLASS_USER_NAME)) {
            res[0] = new ActOpnd(null, null, null, false, false,
                    "Object class is not \"User\"");
            return res;
        }
        String sUserId = getEntityId(sUserName, PM_NODE_USER);
        if (sUserId == null) {
            res[0] = new ActOpnd(null, null, null, false, false, "User \""
                    + sUserName + "\" not yet created");
            return res;
        }
        String sAttrName = getUserFullName(sUserId);
        String sAttrId = getEntityId(sAttrName, PM_NODE_UATTR);
        // It's not an error to get a null id for the user name attribute.
        // It might not be created yet. But if it is already created, get the
        // id.
        res[0] = new ActOpnd(sAttrName, PM_NODE_UATTR, sAttrId, false, false,
                null);

        return res;
    }

    // Returns the name attribute of the user passed as argument,
    // i.e., the user attribute that has the full name of the user as name.
    // Parameters: a user.
    private ActOpnd[] evalFun_uattr_name_of_user(EventContext eventCtx,
                                                 String sFunType, Vector<ActOpnd> funArgs) {
        ActOpnd[] res = new ActOpnd[1];

        if (funArgs.isEmpty() || funArgs.size() != 1) {
            res[0] = new ActOpnd(null, null, null, false, false,
                    "Incorrect number of arguments for function uattr_user_name");
            return res;
        }
        ActOpnd arg = funArgs.get(0);

        if (!arg.getType().equalsIgnoreCase(PM_NODE_USER)) {
            res[0] = new ActOpnd(null, null, null, false, false,
                    "The argument of function uattr_user_name is not a user");
            return res;
        }
        String sAttrName = getUserFullName(arg.getId());
        String sAttrId = getEntityId(sAttrName, PM_NODE_UATTR);
        // We may get a null id for the attribute. This is not an error,
        // it might not be created yet. But if it's there, we need the id.
        res[0] = new ActOpnd(sAttrName, PM_NODE_UATTR, sAttrId, false, false,
                null);
        return res;
    }

    // Returns the property "nameof=<user>", where <user> is a user passed as
    // argument.
    // Parameters: a user.
    private ActOpnd[] evalFun_prop_name_of_user(EventContext eventCtx,
                                                String sFunType, Vector<ActOpnd> funArgs) {
        ActOpnd[] res = new ActOpnd[1];

        if (funArgs.isEmpty() || funArgs.size() != 1) {
            res[0] = new ActOpnd(null, null, null, false, false,
                    "Incorrect number of arguments for function prop_user_name");
            return res;
        }
        ActOpnd arg = funArgs.get(0);
        if (!arg.getType().equalsIgnoreCase(PM_NODE_USER)) {
            res[0] = new ActOpnd(null, null, null, false, false,
                    "Argument of function uattr_user_name is not a user");
            return res;
        }
        String sProp = "nameof=" + arg.getName();
        res[0] = new ActOpnd(sProp, PM_UNKNOWN, null, false, false, null);
        return res;
    }

    // Returns the property "usersof=discretionary".
    // Parameters: None.
    private ActOpnd[] evalFun_prop_discr_users(EventContext eventCtx,
                                               String sFunType, Vector<ActOpnd> funArgs) {
        ActOpnd[] res = new ActOpnd[1];
        res[0] = new ActOpnd("usersof=discretionary", PM_UNKNOWN, null, false,
                false, null);
        return res;
    }

    // Returns a policy with the property "type=discretionary", if one exists.
    // Parameters: None.
    private ActOpnd[] evalFun_pol_discr(EventContext eventCtx, String sFunType,
                                        Vector<ActOpnd> funArgs) {
        ActOpnd[] res = new ActOpnd[1];

        String sProp = "type=discretionary";
        String sPolId = getEntityWithPropInternal(PM_NODE_POL, sProp);
        System.out.println("=============policy with property " + sProp
                + " found " + sPolId);
        if (sPolId == null) {
            res[0] = new ActOpnd(null, null, null, false, false,
                    "No policy with property " + sProp);
            return res;
        }
        String sPol = getEntityName(sPolId, PM_NODE_POL);
        if (sPol == null) {
            res[0] = new ActOpnd(null, null, null, false, false,
                    "No policy with id " + sPolId);
            return res;
        }
        res[0] = new ActOpnd(sPol, PM_NODE_POL, sPolId, false, false, null);
        return res;
    }

    // Returns the user attribute representing the lowest clearance level of the
    // mls policy, if one exists.
    // Parameters: None.
    private ActOpnd[] evalFun_uattr_lowest_level(EventContext eventCtx,
                                                 String sFunType, Vector<ActOpnd> funArgs) {
        ActOpnd[] res = new ActOpnd[1];

        String sProp = "type=mls";
        String sPolId = getEntityWithPropInternal(PM_NODE_POL, sProp);
        System.out.println("=============policy with property " + sProp
                + " found " + sPolId);
        if (sPolId == null) {
            res[0] = new ActOpnd(null, null, null, false, false,
                    "No policy with property " + sProp);
            return res;
        }
        String sPolName = getEntityName(sPolId, PM_NODE_POL);
        if (sPolName == null) {
            res[0] = new ActOpnd(null, null, null, false, false,
                    "No policy with id " + sPolId);
            return res;
        }
        String sPrefix = "levels=";
        String sLevelsProp = getPropertyWithPrefix(sPrefix, sPolId, PM_NODE_POL);
        if (sLevelsProp == null) {
            res[0] = new ActOpnd(null, null, null, false, false,
                    "No levels specified in policy " + sPolName);
            return res;
        }
        String sLevels = sLevelsProp.substring(sPrefix.length());
        String[] pieces = sLevels.split(PM_LIST_MEMBER_SEP);
        if (pieces.length < 1 || pieces[0] == null) {
            res[0] = new ActOpnd(null, null, null, false, false,
                    "No lowest level specified in policy " + sPolName);
            return res;
        }
        String sUattrId = getEntityId(pieces[0], PM_NODE_UATTR);
        if (sUattrId == null) {
            res[0] = new ActOpnd(null, null, null, false, false,
                    "No user attribute at lowest level " + pieces[0]);
            return res;
        }
        res[0] = new ActOpnd(pieces[0], PM_NODE_UATTR, sUattrId, false, false,
                null);
        return res;
    }

    // Returns a policy with the property "type=identity", if one exists.
    // Parameters: None.
    private ActOpnd[] evalFun_pol_id(EventContext eventCtx, String sFunType,
                                     Vector<ActOpnd> funArgs) {
        ActOpnd[] res = new ActOpnd[1];

        String sProp = "type=identity";
        String sPolId = getEntityWithPropInternal(PM_NODE_POL, sProp);
        System.out.println("=============policy with property " + sProp
                + " found " + sPolId);
        if (sPolId == null) {
            res[0] = new ActOpnd(null, null, null, false, false,
                    "No policy with property " + sProp);
            return res;
        }
        String sPol = getEntityName(sPolId, PM_NODE_POL);
        if (sPol == null) {
            res[0] = new ActOpnd(null, null, null, false, false,
                    "No policy with id " + sPolId);
            return res;
        }
        res[0] = new ActOpnd(sPol, PM_NODE_POL, sPolId, false, false, null);
        return res;
    }

    // Returns a policy with the property passed as the sole argument.
    // Parameters: A property.
    private ActOpnd[] evalFun_pol_with_prop(EventContext eventCtx,
                                            String sFunType, Vector<ActOpnd> funArgs) {
        ActOpnd[] res = new ActOpnd[1];

        if (funArgs.isEmpty() || funArgs.size() != 1) {
            res[0] = new ActOpnd(null, null, null, false, false,
                    "Incorrect number of arguments for function pol_with_prop");
            return res;
        }
        ActOpnd arg = funArgs.get(0);
        String sProp = arg.getName();
        String sPolId = getEntityWithPropInternal(PM_NODE_POL, sProp);
        System.out.println("=============policy with property " + sProp
                + " found " + sPolId);
        if (sPolId == null) {
            res[0] = new ActOpnd(null, null, null, false, false,
                    "No policy with property " + sProp);
            return res;
        }
        String sPol = getEntityName(sPolId, PM_NODE_POL);
        if (sPol == null) {
            res[0] = new ActOpnd(null, null, null, false, false,
                    "No policy with id " + sPolId);
            return res;
        }
        res[0] = new ActOpnd(sPol, PM_NODE_POL, sPolId, false, false, null);
        return res;
    }

    private Packet applyActionAssignLike(EventContext eventCtx, String sActionId) {
        return successPacket();
    }

    private Packet applyActionGrant(EventContext eventCtx, String sActionId) {
        try {
            Attributes actAttrs = ctx.getAttributes("CN=" + sActionId + ","
                    + sRuleContainerDN);
            Attribute attr = actAttrs.get("pmOpnd1");
            if (attr == null) {
                return failurePacket("No operand 1 in \"Grant\" action "
                        + sActionId);
            }
            HashSet<ActOpnd> hsOpnd1 = new HashSet<ActOpnd>();
            String sLastError = null;
            for (NamingEnumeration<?> enumer = attr.getAll(); enumer.hasMore(); ) {
                String sOpndId = (String) enumer.next();
                // Get the runtime action operand and insert it into the HashSet
                // of
                // first operands. Most of the times, the run-time operand is
                // the same as the
                // compile-time operand. A function operand at run-time is
                // different.
                ActOpnd[] actOpnds = evalOpnd(eventCtx, sOpndId);
                sLastError = actOpnds[0].getError();
                if (sLastError != null) {
                    System.out.println("Last error when evaluating operand 1: "
                            + sLastError);
                    continue;
                }
                for (int i = 0; i < actOpnds.length; i++) {
                    hsOpnd1.add(actOpnds[i]);
                }
            }
            printOpndSet(hsOpnd1, "Set of first operands in \"Grant\"");
            if (hsOpnd1.isEmpty()) {
                return failurePacket("No first operands in grant. Last error was: "
                        + sLastError);
            }

            attr = actAttrs.get("pmOpnd2");
            if (attr == null) {
                return failurePacket("No operand 2 in \"Grant\" action "
                        + sActionId);
            }
            HashSet<ActOpnd> hsOpnd2 = new HashSet<ActOpnd>();
            for (NamingEnumeration<?> enumer = attr.getAll(); enumer.hasMore(); ) {
                String sOpndId = (String) enumer.next();
                ActOpnd[] actOpnds = evalOpnd(eventCtx, sOpndId);
                sLastError = actOpnds[0].getError();
                if (sLastError != null) {
                    System.out.println("Last error when evaluating operand 2: "
                            + sLastError);
                    continue;
                }
                for (int i = 0; i < actOpnds.length; i++) {
                    hsOpnd2.add(actOpnds[i]);
                }
            }
            printOpndSet(hsOpnd2, "Set of second operands in \"Grant\"");
            if (hsOpnd2.isEmpty()) {
                return failurePacket("No second operands in \"Grant\". Last error was: "
                        + sLastError);
            }

            attr = actAttrs.get("pmOpnd3");
            if (attr == null) {
                return failurePacket("No operand 3 in \"Grant\" action "
                        + sActionId);
            }
            HashSet<ActOpnd> hsOpnd3 = new HashSet<ActOpnd>();
            for (NamingEnumeration<?> enumer = attr.getAll(); enumer.hasMore(); ) {
                String sOpndId = (String) enumer.next();
                ActOpnd[] actOpnds = evalOpnd(eventCtx, sOpndId);
                sLastError = actOpnds[0].getError();
                if (sLastError != null) {
                    System.out.println("Last error when evaluating operand 3: "
                            + sLastError);
                    continue;
                }
                for (int i = 0; i < actOpnds.length; i++) {
                    hsOpnd3.add(actOpnds[i]);
                }
            }
            printOpndSet(hsOpnd3, "Set of third operands in \"Grant\"");
            if (hsOpnd3.isEmpty()) {
                return failurePacket("No third operands in \"Grant\". Last error was: "
                        + sLastError);
            }

            // Generate a name for the operation set.
            Random random = new Random();
            byte[] bytes = new byte[4];
            random.nextBytes(bytes);
            String sOpset = byteArray2HexString(bytes);
            System.out.println("============opset name is " + sOpset);
            // Create an empty opset and assign it to connector.
            Packet res =  addOpsetAndOpInternal(sOpset, null, sOpset,
                    sOpset, null, null, null, null, null);
            if (res.hasError()) {
                return res;
            }
            // Get the opset name and id from the result.
            String sLine = res.getStringValue(0);
            String[] pieces = sLine.split(PM_FIELD_DELIM);
            String sOpsetId = pieces[1];
            // Add all the ops in operands 2 to the new opset.
            Iterator<ActOpnd> iter2 = hsOpnd2.iterator();
            while (iter2.hasNext()) {
                ActOpnd opnd2 = iter2.next();
                res =  addOpsetAndOpInternal(sOpset, null, null, null,
                        opnd2.getName(), null, null, null, null);
                if (res.hasError()) {
                    return res;
                }
            }

            // Assign each operand1 to the opset.
            Iterator<ActOpnd> iter1 = hsOpnd1.iterator();
            while (iter1.hasNext()) {
                ActOpnd opnd1 = iter1.next();
                res =  assignInternal(opnd1.getId(), opnd1.getType(),
                        sOpsetId, PM_NODE_OPSET);
                if (res.hasError()) {
                    return res;
                }
            }

            // Assign the opset to each operand3.
            Iterator<ActOpnd> iter3 = hsOpnd3.iterator();
            while (iter3.hasNext()) {
                ActOpnd opnd3 = iter3.next();
                res =  assignInternal(sOpsetId, PM_NODE_OPSET,
                        opnd3.getId(), opnd3.getType());
                if (res.hasError()) {
                    return res;
                }
            }
        } catch (Exception e) {
            e.printStackTrace();
            return failurePacket("Exception while dispatching event action");
        }
        return successPacket();
    }

    private Packet applyActionDeny(EventContext eventCtx, String sActionId) {
        try {
            Attributes actAttrs = ctx.getAttributes("CN=" + sActionId + ","
                    + sRuleContainerDN);
            Attribute attr = actAttrs.get("pmIsIntrasession");
            if (attr == null) {
                return failurePacket("No intrasession attribute in \"Deny\" action "
                        + sActionId);
            }
            boolean bIntrasession = ((String) attr.get()).equals("TRUE");
            attr = actAttrs.get("pmIsIntersection");
            if (attr == null) {
                return failurePacket("No intersection attribute in \"Deny\" action "
                        + sActionId);
            }
            boolean bIntersection = ((String) attr.get()).equals("TRUE");

            attr = actAttrs.get("pmOpnd1");
            if (attr == null) {
                return failurePacket("No operand 1 in \"Deny\" action "
                        + sActionId);
            }
            String sLastError = null;

            // There should be only one first operand - a session, a user or a
            // user attribute.
            String sOpndId = (String) attr.get();
            // Get the runtime action operand
            ActOpnd[] actOpnds = evalOpnd(eventCtx, sOpndId);
            sLastError = actOpnds[0].getError();
            if (sLastError != null) {
                System.out.println("Last error when evaluating operand 1: "
                        + sLastError);
                return failurePacket("No first operands in \"Deny\". Last error was: "
                        + sLastError);
            }
            ActOpnd actOpnd1 = actOpnds[0];
            printOpnd(actOpnd1, "First operand in \"Deny\"");

            attr = actAttrs.get("pmOpnd2");
            if (attr == null) {
                return failurePacket("No operand 2 in \"Deny\" action "
                        + sActionId);
            }
            HashSet<ActOpnd> hsOpnd2 = new HashSet<ActOpnd>();
            for (NamingEnumeration<?> enumer = attr.getAll(); enumer.hasMore(); ) {
                sOpndId = (String) enumer.next();
                actOpnds = evalOpnd(eventCtx, sOpndId);
                sLastError = actOpnds[0].getError();
                if (sLastError != null) {
                    System.out.println("Last error when evaluating operand 2: "
                            + sLastError);
                    continue;
                }
                for (int i = 0; i < actOpnds.length; i++) {
                    hsOpnd2.add(actOpnds[i]);
                }
            }
            printOpndSet(hsOpnd2, "Set of second operands in \"Deny\"");
            if (hsOpnd2.isEmpty()) {
                return failurePacket("No second operands in \"Deny\". Last error was: "
                        + sLastError);
            }

            attr = actAttrs.get("pmOpnd3");
            if (attr == null) {
                return failurePacket("No operand 3 in \"Deny\" action "
                        + sActionId);
            }
            HashSet<ActOpnd> hsOpnd3 = new HashSet<ActOpnd>();
            for (NamingEnumeration<?> enumer = attr.getAll(); enumer.hasMore(); ) {
                sOpndId = (String) enumer.next();
                actOpnds = evalOpnd(eventCtx, sOpndId);
                sLastError = actOpnds[0].getError();
                if (sLastError != null) {
                    System.out.println("Last error when evaluating operand 3: "
                            + sLastError);
                    continue;
                }
                for (int i = 0; i < actOpnds.length; i++) {
                    hsOpnd3.add(actOpnds[i]);
                }
            }
            printOpndSet(hsOpnd3, "Set of third operands in \"Deny\"");
            if (hsOpnd3.isEmpty()) {
                return failurePacket("No third operands in \"Deny\". Last error was: "
                        + sLastError);
            }

            // Generate a name for the deny constraint.
            Random random = new Random();
            byte[] bytes = new byte[4];
            random.nextBytes(bytes);
            String sDenyName = byteArray2HexString(bytes);
            System.out.println("============deny name is " + sDenyName);
            String sType = actOpnd1.getType();
            String sDenyType = null;
            if (sType.equalsIgnoreCase(PM_SESSION)) {
                sDenyType = PM_DENY_SESSION;
            } else if (sType.equalsIgnoreCase(PM_PROCESS)) {
                sDenyType = PM_DENY_PROCESS;
            } else if (sType.equalsIgnoreCase(PM_NODE_USER)) {
                sDenyType = PM_DENY_USER_ID;
            } else if (sType.equalsIgnoreCase(PM_NODE_UATTR)) {
                sDenyType = PM_DENY_ACROSS_SESSIONS;
                if (bIntrasession) {
                    sDenyType = PM_DENY_INTRA_SESSION;
                }
            } else {
                return failurePacket("Incorrect type for first \"Deny\" operand");
            }

            String sSimDeny = getSimilarDeny(sDenyType, actOpnd1.getName(),
                    actOpnd1.getId(), bIntersection, hsOpnd2, hsOpnd3);
            if (sSimDeny != null) {
                System.out.println("A similar deny constraint exists.");
                return successPacket();
            }

            // Create a deny constraint of the correct class/type.
            System.out.println("Creating the deny relation");
            Packet res =  addDenyInternal(sDenyName, sDenyType,
                    actOpnd1.getName(), actOpnd1.getId(), null, null, null,
                    bIntersection);
            if (res.hasError()) {
                return res;
            }

            // Get the deny name and id from the result.
            String sLine = res.getStringValue(0);
            String[] pieces = sLine.split(PM_FIELD_DELIM);
            sDenyName = pieces[0];

            // Add all the ops in operands 2 to the new deny constraint.
            System.out.println("Adding the operations to the deny relation");
            Iterator<ActOpnd> iter2 = hsOpnd2.iterator();
            while (iter2.hasNext()) {
                ActOpnd opnd2 = iter2.next();
                res =  addDenyInternal(sDenyName, null, null, null,
                        opnd2.getName(), null, null, bIntersection);
                if (res.hasError()) {
                    return res;
                }
            }

            // Add all the containers (object attributes) to the new deny
            // constraint.
            System.out.println("Adding the containers to the deny relation");
            Iterator<ActOpnd> iter3 = hsOpnd3.iterator();
            while (iter3.hasNext()) {
                ActOpnd opnd3 = iter3.next();
                String sContName;
                if (opnd3.isComplement()) {
                    sContName = "!" + opnd3.getName();
                } else {
                    sContName = opnd3.getName();
                }
                res =  addDenyInternal(sDenyName, null, null, null,
                        null, sContName, opnd3.getId(), bIntersection);
                if (res.hasError()) {
                    return res;
                }
            }
        } catch (Exception e) {
            e.printStackTrace();
            return failurePacket("Exception while dispatching event action");
        }
        return successPacket();
    }

    // Apply a "create" action. First evaluate the operands, because the
    // run-time value of an operand could be different from the compile-time
    // value (when the operand is a function).
    // The first operand specifies the entity to be created (usually name and
    // type).
    // The second operand specifies the PM entity represented by the entity to
    // be
    // created if that entity is an object, or is empty.
    // The third operand specifies the properties of the entity to be created,
    // or is empty.
    // The fourth operand specifies the container where the entity to be created
    // should reside.
    private Packet applyActionCreate(EventContext eventCtx, String sActionId) {
        try {
            Attributes actAttrs = ctx.getAttributes("CN=" + sActionId + ","
                    + sRuleContainerDN);
            Attribute attr = actAttrs.get("pmOpnd1");
            if (attr == null) {
                return failurePacket("No operand 1 in \"Create\" action");
            }
            HashSet<ActOpnd> hsOpnd1 = new HashSet<ActOpnd>();
            String sLastError = null;
            for (NamingEnumeration<?> enumer = attr.getAll(); enumer.hasMore(); ) {
                String sOpndId = (String) enumer.next();
                System.out.println("Evaluating first operand " + sOpndId);
                // Get the runtime action operand and insert it into the HashSet
                // of
                // first operands. Most of the times, the run-time operand is
                // the same as the
                // compile-time operand. A function operand at run-time is
                // different.
                ActOpnd[] actOpnds = evalOpnd(eventCtx, sOpndId);
                sLastError = actOpnds[0].getError();
                if (sLastError != null) {
                    System.out.println("Last error when evaluating operand 1: "
                            + sLastError);
                    continue;
                }
                for (int i = 0; i < actOpnds.length; i++) {
                    hsOpnd1.add(actOpnds[i]);
                }
            }
            printOpndSet(hsOpnd1, "Set of first operands in \"Create\"");
            if (hsOpnd1.isEmpty()) {
                return failurePacket("No first operands in \"Create\". Last error was: "
                        + sLastError);
            }

            attr = actAttrs.get("pmOpnd2");
            HashSet<ActOpnd> hsOpnd2 = new HashSet<ActOpnd>();
            if (attr != null) {
                for (NamingEnumeration<?> enumer = attr.getAll(); enumer.hasMore(); ) {
                    String sOpndId = (String) enumer.next();
                    System.out.println("Evaluating second operand " + sOpndId);
                    ActOpnd[] actOpnds = evalOpnd(eventCtx, sOpndId);
                    sLastError = actOpnds[0].getError();
                    if (sLastError != null) {
                        System.out.println("Last error when evaluating operand 2: "
                                + sLastError);
                        continue;
                    }
                    for (int i = 0; i < actOpnds.length; i++) {
                        hsOpnd2.add(actOpnds[i]);
                    }
                }
            }
            printOpndSet(hsOpnd2, "Set of second operands in \"Create\"");

            attr = actAttrs.get("pmOpnd3");
            HashSet<ActOpnd> hsOpnd3 = new HashSet<ActOpnd>();
            if (attr != null) {
                for (NamingEnumeration<?> enumer = attr.getAll(); enumer.hasMore(); ) {
                    String sOpndId = (String) enumer.next();
                    System.out.println("Evaluating third operand " + sOpndId);
                    ActOpnd[] actOpnds = evalOpnd(eventCtx, sOpndId);
                    sLastError = actOpnds[0].getError();
                    if (sLastError != null) {
                        System.out.println("Last error when evaluating operand 3: "
                                + sLastError);
                        continue;
                    }
                    for (int i = 0; i < actOpnds.length; i++) {
                        hsOpnd3.add(actOpnds[i]);
                    }
                }
            }
            printOpndSet(hsOpnd3, "Set of third operands in \"Create\"");

            attr = actAttrs.get("pmOpnd4");
            HashSet<ActOpnd> hsOpnd4 = new HashSet<ActOpnd>();
            if (attr != null) {
                for (NamingEnumeration<?> enumer = attr.getAll(); enumer.hasMore(); ) {
                    String sOpndId = (String) enumer.next();
                    System.out.println("Evaluating fourth operand " + sOpndId);
                    ActOpnd[] actOpnds = evalOpnd(eventCtx, sOpndId);
                    sLastError = actOpnds[0].getError();
                    if (sLastError != null) {
                        System.out.println("Last error when evaluating operand 4: "
                                + sLastError);
                        continue;
                    }
                    for (int i = 0; i < actOpnds.length; i++) {
                        hsOpnd4.add(actOpnds[i]);
                    }
                }
            }
            printOpndSet(hsOpnd4, "Set of fourth operands in \"Create\"");

            // Create entity specified by operand 1...
            ActOpnd opnd1 = null;
            Iterator<ActOpnd> iter = hsOpnd1.iterator();
            while (iter.hasNext()) {
                opnd1 = iter.next();
            }
            // opnd1 cannot be null.
            String sEntType = opnd1.getType();
            String sEntName = opnd1.getName();

            // ...within the container specified in operand 4...
            ActOpnd opnd4 = null;
            iter = hsOpnd4.iterator();
            while (iter.hasNext()) {
                opnd4 = iter.next();
            }
            String sContType = null;
            String sContId = null;
            if (opnd4 != null) {
                sContType = opnd4.getType();
                sContId = opnd4.getId();
            }

            // ...with the properties specified in operands 3...
            ActOpnd opnd3 = null;
            int n = hsOpnd3.size();
            String[] sProps = null;
            if (n > 0) {
                sProps = new String[n];
                iter = hsOpnd3.iterator();
                int i = 0;
                while (iter.hasNext()) {
                    opnd3 = iter.next();
                    sProps[i++] = opnd3.getName();
                }
            }

            // ...and (if the new entity is an object) representing the entity
            // specified by operand 2 (ignored if the entity to be created
            // is NOT an object).
            ActOpnd opnd2 = null;
            iter = hsOpnd2.iterator();
            while (iter.hasNext()) {
                opnd2 = iter.next();
            }

            String sRepEntName = null;
            String sRepEntId = null;
            String sRepEntType = null;
            boolean bInh = false;
            if (opnd2 != null) {
                sRepEntName = opnd2.getName();
                sRepEntId = opnd2.getId();
                sRepEntType = opnd2.getType();
                bInh = opnd2.isSubgraph();
            }

            System.out.println(".........Represented entity name "
                    + sRepEntName);
            System.out.println(".........Represented entity id " + sRepEntId);
            System.out.println(".........Represented entity type "
                    + sRepEntType);
            System.out.println(".........Represented entity subgraph " + bInh);

            Packet result = null;

            if (!sEntType.equalsIgnoreCase(PM_RULE)
                    && (sContType == null || sContId == null)) {
                return failurePacket("Container unspecified in operand 4!");
            }

            if (sEntType.equalsIgnoreCase(PM_RULE)) {
                result =  successPacket("Now compile rule: " + sEntName);
                System.out.println(result.getStringValue(0));

                // Compile the rule and insert it into the enabled script.
                Packet script = new Packet();
                // The function that processes the script expects it to start at
                // item 3.
                try {
                    script.addItem(ItemType.RESPONSE_TEXT, "Filler");
                    script.addItem(ItemType.RESPONSE_TEXT, "Filler");
                    script.addItem(ItemType.RESPONSE_TEXT, "Filler");
                    script.addItem(ItemType.RESPONSE_TEXT, "script genrule");
                    script.addItem(ItemType.RESPONSE_TEXT, sEntName);
                } catch (Exception e) {
                    e.printStackTrace();
                    return failurePacket("Exception when building the result packet");
                }
                Packet res =  compileScriptAndAddToEnabled(null, script);
                if (res == null) {
                    return failurePacket("compileScript... returned null!");
                }
                return res; // failure or success, possibly name:id of the
                // compiled script.

            } else if (sEntType.equalsIgnoreCase(PM_NODE_POL)) {
                result =  addPcInternal(sEntName, null, sEntName,
                        sEntName, sProps);
            } else if (sEntType.equalsIgnoreCase(PM_NODE_USER)) {
                result =  addUserInternal(sEntName, null, sEntName,
                        sEntName, sEntName, sContId, sContType);
            } else if (sEntType.equalsIgnoreCase(PM_NODE_UATTR)) {
                result =  addUattrInternal(sEntName, sEntName,
                        sEntName, sContId, sContType, sProps);
            } else if (sEntType.equalsIgnoreCase(PM_NODE_OATTR)) {
                result =  addOattrInternal(sEntName, null, sEntName,
                        sEntName, sContId, sContType, null, sProps);
            } else if (sEntType.equalsIgnoreCase(PM_OBJ)) {
                // Only an object representing a PM entity/subgraph can be
                // created
                // as a response to an event.
                if (opnd2 == null) {
                    return failurePacket("The object to create as a response must represent a PM entity!");
                }
                // Find the object class based on the represented entity type.
                String sObjClass = typeToClass(sRepEntType);
                result =  addObjectInternal(sEntName, null, null,
                        sEntName, sEntName, sContId, sContType, sObjClass,
                        null, null, null, sRepEntName, sRepEntId, bInh, null,
                        null, null, null, null, null, null);
            } else {
                return failurePacket("Creation of this type of entity not implemented");
            }
            if (result.hasError()) {
                return result;
            }
        } catch (Exception e) {
            e.printStackTrace();
            return failurePacket("Exception while dispatching event action");
        }

        return successPacket();
    }

    private Packet matchEvent(EventContext eventCtx, String sRuleId) {
        System.out.println("Matching event against rule " + sRuleId + "...");
        // Get rule's event pattern.
        try {
            Attributes ruleAttrs = ctx.getAttributes("CN=" + sRuleId + ","
                    + sRuleContainerDN);
            Attribute attr = ruleAttrs.get("pmEventPattern");
            if (attr == null) {
                return failurePacket("No event pattern in rule " + sRuleId);
            }
            String sPatternId = (String) attr.get();

            Packet res =  eventUserMatchesPattern(eventCtx.getSessId(),
                    eventCtx.getProcId(), sPatternId);
            if (res.hasError()) {
                return res;
            }

            res =  eventNameMatchesPattern(eventCtx.getEventName(),
                    sPatternId);
            if (res.hasError()) {
                return res;
            }

            res =  eventObjMatchesPattern(eventCtx, sPatternId);
            return res;
        } catch (Exception e) {
            if (debugFlag) {
                e.printStackTrace();
            }
            return failurePacket("Exception while matching event to pattern in rule "
                    + sRuleId + ": " + e.getMessage());
        }
    }

    // Matching the event's object spec against the pattern's object spec and
    // container specs.
    //
    // The event's object spec should contain: the object name, the object id,
    // the obj class name, the list of first level containers of the object
    // in the format t1|name1,t2|name2,..., where ti is the container
    // type, and namei is the container name, and finally the id of the
    // object's associated attribute.
    //
    // The pattern's object spec may be missing, or is '*', or is 'b'|associd.
    // The pattern's container spec may be missing, or is a list
    // t1|id1,t2|id2,..., where ti is 'b' or 'oc', and idi is the id of an
    // object attribute or object class.
    //
    // The matching algorithm.
    // If the pattern's object spec is not missing and is not '*',
    // check whether the event's object is the one specified in the
    // pattern's object spec. If not, return false.
    // If the pattern's container spec is missing, return true.
    // If the event's object is contained in one of the pattern's object
    // attributes, or the event's object class is the same as one of the
    // pattern's classes, return true.
    // Otherwise return false.
    private Packet eventObjMatchesPattern(EventContext eventCtx,
                                          String sPatternId) {
        // The event name, object name, id, class, containers, assoc oattr.
        String sEventName = eventCtx.getEventName();
        String sEventObjName = eventCtx.getObjName();
        String sEventObjId = eventCtx.getObjId();
        String sEventObjClass = eventCtx.getObjClass();
        String sEventContainers = eventCtx.getCtx1();
        String sEventAssocId = eventCtx.getCtx2();

        if (sEventObjClass != null
                && sEventObjClass.equalsIgnoreCase(PM_CLASS_FILE_NAME)
                && sEventObjId != null) {
            sEventAssocId = getAssocOattr(sEventObjId);
        }
        String sEventObjClassId = null;
        if (sEventObjClass != null) {
            sEventObjClassId = getEntityId(sEventObjClass, PM_OBJ_CLASS);
        }

        System.out.println("===========Event's name is " + sEventName);
        System.out.println("===========Event's object name is " + sEventObjName);
        System.out.println("===========Event's object id is " + sEventObjId);
        System.out.println("===========Event's object class " + sEventObjClass);
        System.out.println("===========Event's object class id "
                + sEventObjClassId);
        System.out.println("===========Event's object containers are "
                + sEventContainers);
        System.out.println("===========Event's object assoc id is "
                + sEventAssocId);
        System.out.println("===========");

        try {
            Attributes patternAttrs = ctx.getAttributes("CN=" + sPatternId
                    + "," + sRuleContainerDN);
            Attribute attr = patternAttrs.get("pmObjSpec");

            String sPatObjSpec = null;
            String sPatContSpec = null;

            if (attr != null) {
                sPatObjSpec = (String) attr.get();
            }
            System.out.println("===========Pattern's object spec is "
                    + sPatObjSpec);

            attr = patternAttrs.get("pmContSpec");
            if (attr != null) {
                for (NamingEnumeration<?> enumer = attr.getAll(); enumer.hasMore(); ) {
                    sPatContSpec = (String) enumer.next();
                    System.out.println("===========Pattern's container spec is "
                            + sPatContSpec);
                }
            }

            // Let's match the event's object against the pattern's objspec.

            // If the pattern's objspec is not null and is not '*', check
            // the objname/objid of the event against the pattern's.
            if (sPatObjSpec != null && !sPatObjSpec.equals("*")) {
                // The pattern's objspec has the format type|name, where the
                // type should be 'b'.
                String[] pieces = sPatObjSpec.split(PM_ALT_DELIM_PATTERN);
                // Pieces[0] is the type (oc or b). Pieces[1] is the id.
                String sPatObjName = pieces[1];

                if (!sEventObjName.equalsIgnoreCase(sPatObjName)) {
                    return failurePacket("Event's object does not match pattern object spec!");
                }
            }

            // Now let's match the event's object against the pattern's
            // container specs.
            // If the pattern has no container specs, the event matches the
            // pattern.
            if (sPatContSpec == null || sPatContSpec.equals("*")) {
                return successPacket();
            }

            // VERY IMPORTANT NOTE: Probably we need to check that the event's
            // object is still included in the original containers as specified
            // in the event. This would prevent applying rules in cascade if the
            // object location is changed by the first (and subsequent) rule.
            if (sEventContainers != null) {
                String[] pieces = sEventContainers.split(PM_LIST_MEMBER_SEP);
                for (int i = 0; i < pieces.length; i++) {
                    String[] sTypeAndName = pieces[i].split(PM_ALT_DELIM_PATTERN);
                    System.out.println("Container no. " + i + ": "
                            + sTypeAndName[0] + "|" + sTypeAndName[1]);
                    String sEventContId = getEntityId(sTypeAndName[1],
                            sTypeAndName[0]);
                    if (!attrIsAscendant(sEventAssocId, sEventContId,
                            PM_NODE_OATTR)) {
                        return failurePacket("Event's object is no longer in the original containers!");
                    }
                }
            }

            // To match, the event's object must be included in at least one of
            // the pattern's containers.
            for (NamingEnumeration<?> enumer = attr.getAll(); enumer.hasMore(); ) {
                sPatContSpec = (String) enumer.next();
                System.out.println("For pattern's container spec "
                        + sPatContSpec);

                String[] pieces = sPatContSpec.split(PM_ALT_DELIM_PATTERN);
                // Pieces[0] is the type (oc or b or rec). Pieces[1] is the id
                // or *
                // (in the case "any record").
                if (pieces[0].equalsIgnoreCase(PM_OBJ_CLASS)) {
                    if (sEventObjClassId != null
                            && sEventObjClassId.equalsIgnoreCase(pieces[1])) {
                        System.out.println("Event obj class matches pattern cont spec");
                        return successPacket();
                    }
                } else if (pieces[0].equalsIgnoreCase(PM_NODE_OATTR)) {
                    if (sEventAssocId != null
                            && attrIsAscendant(sEventAssocId, pieces[1],
                            PM_NODE_OATTR)) {
                        System.out.println("Event obj is contained in pattern cont spec");
                        return successPacket();
                    }
                } else if (pieces[0].equalsIgnoreCase(PM_RECORD)) {
                    String sRecordId = pieces[1];
                    if (sEventAssocId != null) {
                        if (sRecordId.equals("*") && isInARecord(sEventAssocId)) {
                            return successPacket();
                        } else if (!sRecordId.equals("*")
                                && isInRecord(sEventAssocId, sRecordId)) {
                            return successPacket();
                        }
                    }
                }
                System.out.println("Event obj does not match this pattern cont spec. Continuing...");
            }
            return failurePacket("Event's object does not match pattern container specs!");
        } catch (Exception e) {
            e.printStackTrace();
            return failurePacket("Exception during event object matching!");
        }
    }

    private Packet eventNameMatchesPattern(String sEventOp, String sPatternId) {
        // System.out.println("<<<eventNameMatchesPattern " + sPatternId);
        // Get the op specs from the pattern.
        try {
            Attributes patternAttrs = ctx.getAttributes("CN=" + sPatternId
                    + "," + sRuleContainerDN);
            Attribute attr = patternAttrs.get("pmOpSpec");
            if (attr == null) {
                return successPacket();
            }
            String sOpSpec = (String) attr.get();
            if (sOpSpec.equals("*")) {
                return successPacket();
            }

            for (NamingEnumeration<?> enumer = attr.getAll(); enumer.hasMore(); ) {
                sOpSpec = (String) enumer.next();
                if (sEventOp.equalsIgnoreCase(sOpSpec)) {
                    return successPacket();
                }
            }
            return failurePacket("Event operation doesn't match specs!");
        } catch (Exception e) {
            e.printStackTrace();
            return failurePacket("Exception during event operation matching!");
        }
    }

    private Packet eventUserMatchesPattern(String sSessId, String sProcId,
                                           String sPatternId) {
        // System.out.println("<<<userMatchesPattern " + sPatternId);
        // Get the user specs from the pattern.
        try {
            Attributes patternAttrs = ctx.getAttributes("CN=" + sPatternId
                    + "," + sRuleContainerDN);
            Attribute attr = patternAttrs.get("pmUserSpec");

            // If user spec is missing from the pattern, or is empty, the user
            // can be
            // anything. We still need to check the pc specs.
            if (attr == null) {
                // System.out.println("No user specs in pattern");
                if (userMatchesPatternPc(sSessId, sPatternId)) {
                    return successPacket();
                } else {
                    return failurePacket("Event user does not match the pattern!");
                }
            }

            // If user spec contains '*', the user can be anything. We still
            // need
            // to check the pc specs.
            String sUserSpec = (String) attr.get();
            if (sUserSpec.equals("*")) {
                // System.out.println("The pattern specifies any user (*)");
                if (userMatchesPatternPc(sSessId, sPatternId)) {
                    return successPacket();
                } else {
                    return failurePacket("Event user does not match the pattern!");
                }
            }

            // At least a user, a user attribute, a session, or a process
            // is specified in the pattern.
            // Check whether the event's user/session/process matches any of
            // those specified.
            String sSessUserId = getSessionUserId(sSessId);
            // System.out.println("Event user is " + sSessUserId);

            for (NamingEnumeration<?> enumer = attr.getAll(); enumer.hasMore(); ) {
                sUserSpec = (String) enumer.next();
                System.out.println("Found user spec " + sUserSpec);

                String[] pieces = sUserSpec.split(PM_ALT_DELIM_PATTERN);
                if (pieces[0].equalsIgnoreCase(PM_NODE_USER)) {
                    // The spec is a user.
                    if (!sSessUserId.equalsIgnoreCase(pieces[1])) {
                        continue;
                    }
                    if (userMatchesPatternPc(sSessId, sPatternId)) {
                        return successPacket();
                    }
                } else if (pieces[0].equalsIgnoreCase(PM_NODE_UATTR)) {
                    // The spec is a user attribute, not necessarily active for
                    // the user.
                    // We check only that the user has that attribute.
                    if (!userIsAscendant(sSessUserId, pieces[1])) {
                        continue;
                    }
                    if (userAttrMatchesPatternPc(sSessId, pieces[1], sPatternId)) {
                        return successPacket();
                    }
                } else if (pieces[0].equalsIgnoreCase(PM_SESSION)) {
                    // The spec is a session.
                    // We check only that the current session is the same as the
                    // one in spec.
                    if (!sSessId.equalsIgnoreCase(pieces[1])) {
                        continue;
                    }
                    if (userAttrMatchesPatternPc(sSessId, pieces[1], sPatternId)) {
                        return successPacket();
                    }
                } else if (pieces[0].equalsIgnoreCase(PM_PROCESS)) {
                    // The spec is a process.
                    // We check only that the current process is the same as the
                    // one in spec.
                    if (!sProcId.equalsIgnoreCase(pieces[1])) {
                        continue;
                    }
                    if (userAttrMatchesPatternPc(sSessId, pieces[1], sPatternId)) {
                        return successPacket();
                    }
                } else {
                    // The spec is an active user attribute. Check whether the
                    // user
                    // is active in that attribute in the current session.
                    if (userIsActiveInAttr(sSessId, pieces[1])) {
                        System.out.println("Session user found active in attribute "
                                + getEntityName(pieces[1],
                                PM_NODE_UATTR));
                        return successPacket();
                    }
                    System.out.println("Session user NOT active in attribute "
                            + getEntityName(pieces[1], PM_NODE_UATTR));
                }
            }
            return failurePacket("Event user does not match pattern!");
        } catch (Exception e) {
            if (debugFlag) {
                e.printStackTrace();
            }
            return failurePacket("Exception while matching event user to pattern "
                    + sPatternId + ": " + e.getMessage());
        }
    }

    private boolean userMatchesPatternPc(String sSessId, String sPatternId) {
        // System.out.println("<<<userMatchesPatternPc " + sPatternId);
        try {
            Attributes patternAttrs = ctx.getAttributes("CN=" + sPatternId
                    + "," + sRuleContainerDN);
            Attribute attr = patternAttrs.get("pmIsAny");
            boolean isAny = ((String) attr.get()).equals("TRUE");
            attr = patternAttrs.get("pmIsActive");
            boolean isActive = ((String) attr.get()).equals("TRUE");
            attr = patternAttrs.get("pmPolicySpec");
            if (isActive) {
                // System.out.println("User must be active");
                if (isAny) {
                    // If no pc specs:
                    // System.out.println("Pc is any of...");
                    if (attr == null) {
                        return userIsActive(sSessId);
                    }

                    // If a pc spec containing *:
                    String s = (String) attr.get();
                    // System.out.println("The case: get first pc spec and see if it's *: "
                    // + s);
                    if (s.equals("*")) {
                        return userIsActive(sSessId);
                    }

                    // Some pc specs:
                    return userIsActiveInAnyPolicy(sSessId, attr);
                } else {
                    // It's each policy.
                    return userIsActiveInEachPolicy(sSessId, attr);
                }
            } else {
                // System.out.println("User doesn't have to be active");
                // It's sufficient to be in, not necessarily active.
                if (isAny) {
                    // If no pc specs:
                    // System.out.println("Pc is any of...");
                    if (attr == null) {
                        return true;
                    }

                    // If a pc spec containing *:
                    String s = (String) attr.get();
                    // System.out.println("The case: get first pc spec and see if it's *: "
                    // + s);
                    if (s.equals("*")) {
                        return true;
                    }

                    // Some pc specs:
                    return userIsInAnyPolicy(sSessId, attr);
                } else {
                    // It's each policy.
                    return userIsInEachPolicy(sSessId, attr);
                }
            }
        } catch (Exception e) {
            if (debugFlag) {
                e.printStackTrace();
            }
            return false;
        }
    }

    private boolean userIsActive(String sSessId) {
        HashSet<String> hs = getSessionActiveAttrSet(sSessId);
        return (!hs.isEmpty());
    }

    // Whether the session's user is active in the specified attribute.
    private boolean userIsActiveInAttr(String sSessId, String sUattrId) {
        HashSet<String> hs = getSessionActiveAttrSet(sSessId);
        Iterator<String> iter = hs.iterator();
        while (iter.hasNext()) {
            String sCrtActiveId = iter.next();
            if (sCrtActiveId.equalsIgnoreCase(sUattrId)) {
                return true;
            }
        }
        return false;
    }

    // The Attribute attr contains all values of pmPcSpec.
    private boolean userIsActiveInAnyPolicy(String sSessId, Attribute attr) {
        if (attr == null) {
            return true;
        }

        HashSet<String> hs = getSessionActiveAttrSet(sSessId);

        try {
            for (NamingEnumeration<?> enumer = attr.getAll(); enumer.hasMore(); ) {
                String sPcSpec = (String) enumer.next();
                String[] pieces = sPcSpec.split(PM_ALT_DELIM_PATTERN);
                if (userIsActiveInPolicy(hs, pieces[1])) {
                    return true;
                }
            }
            return false;
        } catch (Exception e) {
            e.printStackTrace();
            return false;
        }
    }

    // The Attribute attr contains all values of pmPcSpec.
    private boolean userIsActiveInEachPolicy(String sSessId, Attribute attr) {
        if (attr == null) {
            return true;
        }

        HashSet<String> hs = getSessionActiveAttrSet(sSessId);
        try {
            for (NamingEnumeration<?> enumer = attr.getAll(); enumer.hasMore(); ) {
                String sPcSpec = (String) enumer.next();
                String[] pieces = sPcSpec.split(PM_ALT_DELIM_PATTERN);
                if (!userIsActiveInPolicy(hs, pieces[1])) {
                    return false;
                }
            }
            return true;
        } catch (Exception e) {
            e.printStackTrace();
            return false;
        }
    }

    // At least one of the session's active attributes must be in the
    // specified policy.
    private boolean userIsActiveInPolicy(HashSet<String> activeAttrs,
                                         String sPolId) {
        Iterator<String> iter = activeAttrs.iterator();
        while (iter.hasNext()) {
            String sAttrId = iter.next();
            if (attrIsAscendantToPolicy(sAttrId, PM_NODE_UATTR, sPolId)) {
                return true;
            }
        }
        return false;
    }

    private boolean userIsInAnyPolicy(String sSessId, Attribute attr) {
        if (attr == null) {
            return true;
        }
        try {
            for (NamingEnumeration<?> enumer = attr.getAll(); enumer.hasMore(); ) {
                String sPcSpec = (String) enumer.next();
                String[] pieces = sPcSpec.split(PM_ALT_DELIM_PATTERN);
                if (userIsInPolicy(sSessId, pieces[1])) {
                    return true;
                }
            }
            return false;
        } catch (Exception e) {
            e.printStackTrace();
            return false;
        }
    }

    private boolean userIsInEachPolicy(String sSessId, Attribute attr) {
        if (attr == null) {
            return true;
        }
        try {
            for (NamingEnumeration<?> enumer = attr.getAll(); enumer.hasMore(); ) {
                String sPcSpec = (String) enumer.next();
                String[] pieces = sPcSpec.split(PM_ALT_DELIM_PATTERN);
                if (!userIsInPolicy(sSessId, pieces[1])) {
                    return false;
                }
            }
            return true;
        } catch (Exception e) {
            e.printStackTrace();
            return false;
        }
    }

    private boolean userIsInPolicy(String sSessId, String sPolId) {
        String sUserId = getSessionUserId(sSessId);
        return userIsAscendantToPolicy(sUserId, sPolId);
    }

    private boolean userAttrMatchesPatternPc(String sSessId, String sAttrId,
                                             String sPatternId) {
        System.out.println("[userAttrMatchesPatternPc " + sAttrId
                + ", pattern = " + sPatternId);
        try {
            Attributes patternAttrs = ctx.getAttributes("CN=" + sPatternId
                    + "," + sRuleContainerDN);
            Attribute attr = patternAttrs.get("pmIsAny");
            boolean isAny = ((String) attr.get()).equals("TRUE");
            attr = patternAttrs.get("pmIsActive");
            boolean isActive = ((String) attr.get()).equals("TRUE");
            attr = patternAttrs.get("pmPcSpec");
            if (isActive) {
                HashSet<String> hs = getSessionActiveAttrSet(sSessId);
                if (!hs.contains(sAttrId)) {
                    return false;
                }
            }

            if (isAny) {
                // If no pc specs:
                if (attr == null) {
                    return true;
                }

                // If a pc spec containing *:
                String s = (String) attr.get();
                System.out.println("The case: get first pc spec and see if it's *: "
                        + s);
                if (s.equals("*")) {
                    return true;
                }

                // Some pc specs:
                return userAttrIsInAnyPolicy(sAttrId, attr);
            } else {
                // It's each policy.
                return userAttrIsInEachPolicy(sAttrId, attr);
            }
        } catch (Exception e) {
            if (debugFlag) {
                e.printStackTrace();
            }
            return false;
        }
    }

    private boolean userAttrIsInAnyPolicy(String sAttrId, Attribute attr) {
        if (attr == null) {
            return true;
        }
        try {
            for (NamingEnumeration<?> enumer = attr.getAll(); enumer.hasMore(); ) {
                String sPcSpec = (String) enumer.next();
                String[] pieces = sPcSpec.split(PM_ALT_DELIM_PATTERN);
                if (attrIsAscendantToPolicy(sAttrId, PM_NODE_UATTR, pieces[1])) {
                    return true;
                }
            }
            return false;
        } catch (Exception e) {
            e.printStackTrace();
            return false;
        }
    }

    private boolean userAttrIsInEachPolicy(String sAttrId, Attribute attr) {
        if (attr == null) {
            return true;
        }
        try {
            for (NamingEnumeration<?> enumer = attr.getAll(); enumer.hasMore(); ) {
                String sPcSpec = (String) enumer.next();
                String[] pieces = sPcSpec.split(PM_ALT_DELIM_PATTERN);
                if (!attrIsAscendantToPolicy(sAttrId, PM_NODE_UATTR, pieces[1])) {
                    return false;
                }
            }
            return true;
        } catch (Exception e) {
            e.printStackTrace();
            return false;
        }
    }

    // Add a property to a PM entity (user attr, obj attr, or policy).
    private Packet addProp(String sSessId, String sId, String sType,
                           String sIsVos, String sProp) {
        if (sIsVos.equalsIgnoreCase("yes")) {
            sId = getAdminVosNodeOrigId(sId);
        }

        // Test permissions.

        return addPropInternal(sId, sType, sProp);
    }

    private Packet addPropInternal(String sId, String sType, String sProp) {
        ModificationItem[] mods = new ModificationItem[1];
        mods[0] = new ModificationItem(DirContext.ADD_ATTRIBUTE,
                new BasicAttribute("pmProperty", sProp));
        String sDn;
        if (sType.equalsIgnoreCase(PM_NODE_UATTR)) {
            sDn = "CN=" + sId + "," + sUserAttrContainerDN;
        } else if (sType.equalsIgnoreCase(PM_NODE_OATTR)) {
            sDn = "CN=" + sId + "," + sObjAttrContainerDN;
        } else if (sType.equalsIgnoreCase(PM_NODE_POL)) {
            sDn = "CN=" + sId + "," + sPolicyContainerDN;
        } else {
            return failurePacket("Invalid entity type!");
        }

        try {
            ctx.modifyAttributes(sDn, mods);
        } catch (Exception e) {
            e.printStackTrace();
            return failurePacket("Unable to add property " + sProp
                    + " to the entity!");
        }
        return successPacket();
    }

    private Packet replaceProp(String sSessId, String sId, String sType,
                               String sIsVos, String sOldProp, String sNewProp) {
        if (sIsVos.equalsIgnoreCase("yes")) {
            sId = getAdminVosNodeOrigId(sId);
        }
        ModificationItem[] mods = new ModificationItem[2];
        mods[0] = new ModificationItem(DirContext.REMOVE_ATTRIBUTE,
                new BasicAttribute("pmProperty", sOldProp));
        mods[1] = new ModificationItem(DirContext.ADD_ATTRIBUTE,
                new BasicAttribute("pmProperty", sNewProp));
        String sDn;
        if (sType.equalsIgnoreCase(PM_NODE_UATTR)) {
            sDn = "CN=" + sId + "," + sUserAttrContainerDN;
        } else if (sType.equalsIgnoreCase(PM_NODE_OATTR)) {
            sDn = "CN=" + sId + "," + sObjAttrContainerDN;
        } else if (sType.equalsIgnoreCase(PM_NODE_POL)) {
            sDn = "CN=" + sId + "," + sPolicyContainerDN;
        } else {
            return failurePacket("Invalid entity type!");
        }

        try {
            ctx.modifyAttributes(sDn, mods);
        } catch (Exception e) {
            e.printStackTrace();
            return failurePacket("Unable to replace property " + sOldProp
                    + " by " + sNewProp + "!");
        }
        return successPacket();
    }

    private Packet removeProp(String sSessId, String sId, String sType,
                              String sIsVos, String sProp) {
        if (sIsVos.equalsIgnoreCase("yes")) {
            sId = getAdminVosNodeOrigId(sId);
        }
        ModificationItem[] mods = new ModificationItem[1];
        mods[0] = new ModificationItem(DirContext.REMOVE_ATTRIBUTE,
                new BasicAttribute("pmProperty", sProp));
        String sDn;
        if (sType.equalsIgnoreCase(PM_NODE_UATTR)) {
            sDn = "CN=" + sId + "," + sUserAttrContainerDN;
        } else if (sType.equalsIgnoreCase(PM_NODE_OATTR)) {
            sDn = "CN=" + sId + "," + sObjAttrContainerDN;
        } else if (sType.equalsIgnoreCase(PM_NODE_POL)) {
            sDn = "CN=" + sId + "," + sPolicyContainerDN;
        } else {
            return failurePacket("Invalid entity type!");
        }

        try {
            ctx.modifyAttributes(sDn, mods);
        } catch (Exception e) {
            e.printStackTrace();
            return failurePacket("Unable to remove property " + sProp
                    + " from the entity!");
        }
        return successPacket();
    }

    // Get the properties set of a PM entity.
    private HashSet<String> getProps(String sId, String sType) {
        HashSet<String> hs = new HashSet<String>();
        String sDn = null;
        if (sType.equalsIgnoreCase(PM_NODE_UATTR)) {
            sDn = "CN=" + sId + "," + sUserAttrContainerDN;
        } else if (sType.equalsIgnoreCase(PM_NODE_OATTR)) {
            sDn = "CN=" + sId + "," + sObjAttrContainerDN;
        } else if (sType.equalsIgnoreCase(PM_NODE_POL)) {
            sDn = "CN=" + sId + "," + sPolicyContainerDN;
        } else {
            return hs;
        }

        try {
            Attribute attr = ctx.getAttributes(sDn).get("pmProperty");
            if (attr != null) {
                for (NamingEnumeration<?> enumer = attr.getAll(); enumer.hasMore(); ) {
                    hs.add((String) enumer.next());
                }
            }
        } catch (Exception e) {
            if (debugFlag) {
                e.printStackTrace();
            }
        }
        return hs;
    }

    // Return the property of the entity specified by id and type that starts
    // with the specified prefix, if one exists. Otherwise return null.
    private String getPropertyWithPrefix(String sPrefix, String sId,
                                         String sType) {
        String sDn = null;
        if (sType.equalsIgnoreCase(PM_NODE_UATTR)) {
            sDn = "CN=" + sId + "," + sUserAttrContainerDN;
        } else if (sType.equalsIgnoreCase(PM_NODE_OATTR)) {
            sDn = "CN=" + sId + "," + sObjAttrContainerDN;
        } else if (sType.equalsIgnoreCase(PM_NODE_POL)) {
            sDn = "CN=" + sId + "," + sPolicyContainerDN;
        } else {
            return null;
        }

        try {
            Attribute attr = ctx.getAttributes(sDn).get("pmProperty");
            if (attr == null) {
                return null;
            }
            for (NamingEnumeration<?> enumer = attr.getAll(); enumer.hasMore(); ) {
                String sProp = (String) enumer.next();
                if (sProp.startsWith(sPrefix)) {
                    return sProp;
                }
            }
            return null;
        } catch (Exception e) {
            if (debugFlag) {
                e.printStackTrace();
            }
            return null;
        }
    }

    // Returns:
    // item 0: <name>:<id>
    // item 1: <description>
    // item 2: <other info>
    // item 3 and following: <property>
    private Packet getPcInfo(String sSessId, String sPcId, String sIsVos) {
        Packet res = new Packet();

        if (sIsVos.equalsIgnoreCase("yes")) {
            sPcId = getAdminVosNodeOrigId(sPcId);
        }

        try {
            Attributes attrs = ctx.getAttributes("CN=" + sPcId + ","
                    + sPolicyContainerDN);
            String sPcName = (String) attrs.get("pmName").get();
            String sDescr = (String) attrs.get("pmDescription").get();
            String sInfo = (String) attrs.get("pmOtherInfo").get();
            res.addItem(ItemType.RESPONSE_TEXT, sPcName + PM_FIELD_DELIM
                    + sPcId);
            res.addItem(ItemType.RESPONSE_TEXT, sDescr);
            res.addItem(ItemType.RESPONSE_TEXT, sInfo);

            Attribute attr = attrs.get("pmProperty");
            if (attr != null) {
                for (NamingEnumeration<?> enumer = attr.getAll(); enumer.hasMore(); ) {
                    res.addItem(ItemType.RESPONSE_TEXT, (String) enumer.next());
                }
            }
            return res;
        } catch (NameNotFoundException e) {
            if (debugFlag) {
                e.printStackTrace();
            }
            return failurePacket("No such policy class!");
        } catch (Exception e) {
            if (debugFlag) {
                e.printStackTrace();
            }
            return failurePacket("Exception during getPcInfo: "
                    + e.getMessage());
        }
    }

    // Returns:
    // item 0: <name>:<id>
    // item 1: <description>
    // item 2: <other info>
    // item 3 and following: <property>
    private Packet getAttrInfo(String sSessId, String sAttrId,
                               String sAttrType, String sIsVos) {
        if (sIsVos.equalsIgnoreCase("yes")) {
            sAttrId = getAdminVosNodeOrigId(sAttrId);
        }

        Packet result = new Packet();

        String sDn;
        if (sAttrType.equalsIgnoreCase(PM_NODE_UATTR)) {
            sDn = "CN=" + sAttrId + "," + sUserAttrContainerDN;
        } else if (sAttrType.equalsIgnoreCase(PM_NODE_OATTR)) {
            sDn = "CN=" + sAttrId + "," + sObjAttrContainerDN;
        } else {
            return failurePacket("Invalid attribute type!");
        }

        try {
            Attributes attrs = ctx.getAttributes(sDn);
            String sAttrName = (String) attrs.get("pmName").get();
            String sDescr = (String) attrs.get("pmDescription").get();
            String sInfo = (String) attrs.get("pmOtherInfo").get();
            result.addItem(ItemType.RESPONSE_TEXT, sAttrName + PM_FIELD_DELIM
                    + sAttrId);
            result.addItem(ItemType.RESPONSE_TEXT, sDescr);
            result.addItem(ItemType.RESPONSE_TEXT, sInfo);

            Attribute attr = attrs.get("pmProperty");
            if (attr != null) {
                for (NamingEnumeration<?> enumer = attr.getAll(); enumer.hasMore(); ) {
                    result.addItem(ItemType.RESPONSE_TEXT,
                            (String) enumer.next());
                }
            }
            return result;
        } catch (NameNotFoundException e) {
            if (debugFlag) {
                e.printStackTrace();
            }
            return failurePacket("No such attribute!");
        } catch (Exception e) {
            if (debugFlag) {
                e.printStackTrace();
            }
            return failurePacket("Exception during getAttrInfo: "
                    + e.getMessage());
        }
    }

    // Returns:
    // item 0: <name>:<id>
    // item 1: <description>
    // item 2: <other info>
    // item 3: <full name>
    // item 4 and following: <property>
    private Packet getUserInfo(String sSessId, String sUserId) {
        Packet result = new Packet();

        try {
            Attributes attrs = ctx.getAttributes("CN=" + sUserId + ","
                    + sUserContainerDN);
            String sUserName = (String) attrs.get("pmName").get();
            String sFullName = (String) attrs.get("pmFullName").get();
            String sInfo = (String) attrs.get("pmOtherInfo").get();
            result.addItem(ItemType.RESPONSE_TEXT, sUserName + PM_FIELD_DELIM
                    + sUserId);
            result.addItem(ItemType.RESPONSE_TEXT, sFullName);
            result.addItem(ItemType.RESPONSE_TEXT, sInfo);

            Attribute attr = attrs.get("pmProperty");
            if (attr != null) {
                for (NamingEnumeration<?> enumer = attr.getAll(); enumer.hasMore(); ) {
                    result.addItem(ItemType.RESPONSE_TEXT,
                            (String) enumer.next());
                }
            }
            return result;
        } catch (NameNotFoundException e) {
            if (debugFlag) {
                e.printStackTrace();
            }
            return failurePacket("No such user!");
        } catch (Exception e) {
            if (debugFlag) {
                e.printStackTrace();
            }
            return failurePacket("Exception during getUserInfo: "
                    + e.getMessage());
        }
    }

    private String getUserFullName(String sUserId) {
        try {
            Attributes attrs = ctx.getAttributes("CN=" + sUserId + ","
                    + sUserContainerDN);
            return (String) attrs.get("pmFullName").get();
        } catch (Exception e) {
            if (debugFlag) {
                e.printStackTrace();
            }
            return null;
        }
    }

    private Packet getScripts() throws Exception {
        Packet result = new Packet();
        NamingEnumeration<?> scripts;
        try {
            SearchControls constraints = new SearchControls();
            constraints.setSearchScope(SearchControls.ONELEVEL_SCOPE);
            constraints.setReturningAttributes(new String[]{"pmId", "pmName"});
            scripts = ctx.search(sRuleContainerDN, "(objectClass="
                    + sScriptClass + ")", constraints);
        } catch (CommunicationException e) {
            if (debugFlag) {
                e.printStackTrace();
            }
            return failurePacket("AD connection error");
        } catch (Exception e) {
            if (debugFlag) {
                e.printStackTrace();
            }
            return failurePacket("Exception: " + e.getMessage());
        }

        while (scripts != null && scripts.hasMore()) {
            SearchResult sr = (SearchResult) scripts.next();
            String sName = (String) sr.getAttributes().get("pmName").get();
            String sId = (String) sr.getAttributes().get("pmId").get();
            result.addItem(ItemType.RESPONSE_TEXT, sName + PM_FIELD_DELIM + sId);
        }
        return result;
    }

    // Enable the script specified by its id. Returns the enabled script name
    // and id,
    // or failure.
    private Packet enableScript(String sSessId, String sScriptId) {
        // Make sure the script exists.
        String sName = getEntityName(sScriptId, PM_SCRIPT);
        if (sName == null) {
            return failurePacket("Script does not exist!");
        }

        // Enable it.
        ModificationItem[] mods = new ModificationItem[1];
        mods[0] = new ModificationItem(DirContext.REPLACE_ATTRIBUTE,
                new BasicAttribute("pmIsEnabled", "TRUE"));
        try {
            ctx.modifyAttributes("CN=" + sScriptId + "," + sRuleContainerDN,
                    mods);
            Packet res = new Packet();
            res.addItem(ItemType.RESPONSE_TEXT, sName + PM_FIELD_DELIM
                    + sScriptId);
            return res;
        } catch (Exception e) {
            if (debugFlag) {
                e.printStackTrace();
            }
            return failurePacket(e.getMessage());
        }
    }

    private Packet disableEnabledScript(String sSessId) {
        String sScriptId = getEnabledScriptId();
        if (sScriptId == null) {
            return failurePacket("No script is enabled!");
        }

        // Disable it.
        ModificationItem[] mods = new ModificationItem[1];
        mods[0] = new ModificationItem(DirContext.REPLACE_ATTRIBUTE,
                new BasicAttribute("pmIsEnabled", "FALSE"));
        try {
            ctx.modifyAttributes("CN=" + sScriptId + "," + sRuleContainerDN,
                    mods);
            return successPacket();
        } catch (Exception e) {
            if (debugFlag) {
                e.printStackTrace();
            }
            return failurePacket(e.getMessage());
        }
    }

    private Packet getEnabledScript() {
        Packet res = new Packet();

        String sId = getEnabledScriptId();
        if (sId == null) {
            return res;
        }

        String sName = getEntityName(sId, PM_SCRIPT);
        if (sName == null) {
            return failurePacket("Inconsistency: Enabled script does not exist!");
        }
        try {
            res.addItem(ItemType.RESPONSE_TEXT, sName + PM_FIELD_DELIM + sId);
        } catch (Exception e) {
            e.printStackTrace();
            return failurePacket("Exception when building the result packet");
        }
        return res;
    }

    private String getEnabledScriptId() {
        NamingEnumeration<?> scripts;
        try {
            SearchControls constraints = new SearchControls();
            constraints.setSearchScope(SearchControls.ONELEVEL_SCOPE);
            constraints.setReturningAttributes(new String[]{"pmId", "pmName"});
            scripts = ctx.search(sRuleContainerDN, "(&(objectClass="
                    + sScriptClass + ")(pmIsEnabled=TRUE))", constraints);
            if (scripts == null || !scripts.hasMore()) {
                return null;
            }
            SearchResult sr = (SearchResult) scripts.next();
            String sId = (String) sr.getAttributes().get("pmId").get();
            return sId;
        } catch (Exception e) {
            if (debugFlag) {
                e.printStackTrace();
            }
            return null;
        }
    }

    private Packet deleteScriptRule(String sScriptId, String sLabel) {
        if (sScriptId == null) {
            return failurePacket("The script id is null!");
        }
        String sName = getEntityName(sScriptId, PM_SCRIPT);
        if (sName == null) {
            return failurePacket("No such script!");
        }
        if (sLabel == null || sLabel.length() == 0) {
            return failurePacket("Null or empty rule label!");
        }

        try {
            // The script attributes.
            Attributes attrs = ctx.getAttributes("CN=" + sScriptId + ","
                    + sRuleContainerDN);

            // Get the rule count, the first rule, and the last rule of the
            // script.
            int count = (Integer.valueOf((String) attrs.get("pmCount").get())).intValue();

            String sFirstRuleId = null;
            Attribute attr = attrs.get("pmFirst");
            if (attr != null) {
                sFirstRuleId = (String) attr.get();
            }

            String sLastRuleId = null;
            attr = attrs.get("pmLast");
            if (attr != null) {
                sLastRuleId = (String) attr.get();
            }

            // Walk sequentially through the script, looking for a rule with the
            // specified label.
            String sCrtRuleId = sFirstRuleId;
            Attributes ruleAttrs = null;
            while (sCrtRuleId != null) {
                // Get the crt rule label.
                ruleAttrs = ctx.getAttributes("CN=" + sCrtRuleId + ","
                        + sRuleContainerDN);
                String sCrtRuleLabel = null;
                attr = ruleAttrs.get("pmLabel");
                if (attr != null) {
                    sCrtRuleLabel = (String) attr.get();
                }

                if (sCrtRuleLabel.equalsIgnoreCase(sLabel)) {
                    break;
                }

                attr = ruleAttrs.get("pmNext");
                if (attr == null) {
                    sCrtRuleId = null;
                } else {
                    sCrtRuleId = (String) attr.get();
                }
            }

            // If sCrtRuleId is null, we didn't find a rule with that label.
            if (sCrtRuleId == null) {
                return failurePacket("No rule with label \"" + sLabel + "\"!");
            }

            // We found a rule. Its attributes are ruleAttrs.
            // The rule may be the first, the last, or in the middle of the
            // script.
            if (sCrtRuleId.equalsIgnoreCase(sFirstRuleId)) {
                // The target rule is the first in script.
                // Find the next rule relative to the current rule.
                String sNextRuleId = null;
                attr = ruleAttrs.get("pmNext");
                if (attr != null) {
                    sNextRuleId = (String) attr.get();
                }
                if (sNextRuleId == null) {
                    // If this is the only rule in script then set the script
                    // empty.
                    ModificationItem[] mods = new ModificationItem[2];
                    mods[0] = new ModificationItem(DirContext.REMOVE_ATTRIBUTE,
                            new BasicAttribute("pmFirst", sFirstRuleId));
                    mods[1] = new ModificationItem(DirContext.REMOVE_ATTRIBUTE,
                            new BasicAttribute("pmLast", sLastRuleId));
                    ctx.modifyAttributes("CN=" + sScriptId + ","
                            + sRuleContainerDN, mods);
                } else {
                    // Otherwise, set script.first to point to crt.next rule ...
                    ModificationItem[] mods = new ModificationItem[1];
                    mods[0] = new ModificationItem(
                            DirContext.REPLACE_ATTRIBUTE, new BasicAttribute(
                            "pmFirst", sNextRuleId));
                    ctx.modifyAttributes("CN=" + sScriptId + ","
                            + sRuleContainerDN, mods);

                    // .. and set next rule's pmPrev pointer to null.
                    mods[0] = new ModificationItem(DirContext.REMOVE_ATTRIBUTE,
                            new BasicAttribute("pmPrev", sCrtRuleId));
                    ctx.modifyAttributes("CN=" + sNextRuleId + ","
                            + sRuleContainerDN, mods);
                }
            } else if (sCrtRuleId.equalsIgnoreCase(sLastRuleId)) {
                // The target rule is the last in script.
                // Find the previous rule relative to the current rule.
                String sPrevRuleId = null;
                attr = ruleAttrs.get("pmPrev");
                if (attr != null) {
                    sPrevRuleId = (String) attr.get();
                }
                if (sPrevRuleId == null) {
                    // If the target rule is the only rule in script then set
                    // the script empty.
                    ModificationItem[] mods = new ModificationItem[2];
                    mods[0] = new ModificationItem(DirContext.REMOVE_ATTRIBUTE,
                            new BasicAttribute("pmFirst", sFirstRuleId));
                    mods[1] = new ModificationItem(DirContext.REMOVE_ATTRIBUTE,
                            new BasicAttribute("pmLast", sLastRuleId));
                    ctx.modifyAttributes("CN=" + sScriptId + ","
                            + sRuleContainerDN, mods);
                } else {
                    // Otherwise, set script.last to point to crt.prev rule ...
                    ModificationItem[] mods = new ModificationItem[1];
                    mods[0] = new ModificationItem(
                            DirContext.REPLACE_ATTRIBUTE, new BasicAttribute(
                            "pmLast", sPrevRuleId));
                    ctx.modifyAttributes("CN=" + sScriptId + ","
                            + sRuleContainerDN, mods);

                    // .. and set prevous rule's pmNext pointer to null.
                    mods[0] = new ModificationItem(DirContext.REMOVE_ATTRIBUTE,
                            new BasicAttribute("pmNext", sCrtRuleId));
                    ctx.modifyAttributes("CN=" + sPrevRuleId + ","
                            + sRuleContainerDN, mods);
                }
            } else {
                // The target rule is in the middle of the script. First get the
                // previous and next rules, then set their pmNext and pmPrev
                // pointers
                // correctly.
                String sNextRuleId = (String) ruleAttrs.get("pmNext").get();
                String sPrevRuleId = (String) ruleAttrs.get("pmPrev").get();

                ModificationItem[] mods = new ModificationItem[1];
                mods[0] = new ModificationItem(DirContext.REPLACE_ATTRIBUTE,
                        new BasicAttribute("pmNext", sNextRuleId));
                ctx.modifyAttributes("CN=" + sPrevRuleId + ","
                        + sRuleContainerDN, mods);

                mods[0] = new ModificationItem(DirContext.REPLACE_ATTRIBUTE,
                        new BasicAttribute("pmPrev", sPrevRuleId));
                ctx.modifyAttributes("CN=" + sNextRuleId + ","
                        + sRuleContainerDN, mods);
            }

            // Now decrease the rank for all rules following the target rule.
            attr = ruleAttrs.get("pmNext");
            while (attr != null) {
                String sNextRuleId = (String) attr.get();
                // Increase the rank of each source rule.
                ruleAttrs = ctx.getAttributes("CN=" + sNextRuleId + ","
                        + sRuleContainerDN);
                int rank = (Integer.valueOf((String) ruleAttrs.get("pmRank").get())).intValue() - 1;
                ModificationItem[] mods = new ModificationItem[1];
                mods[0] = new ModificationItem(DirContext.REPLACE_ATTRIBUTE,
                        new BasicAttribute("pmRank", String.valueOf(rank)));
                ctx.modifyAttributes("CN=" + sNextRuleId + ","
                        + sRuleContainerDN, mods);

                attr = ruleAttrs.get("pmNext");
            }

            // Update the rule count in the destination script.
            ModificationItem[] mods = new ModificationItem[1];
            mods[0] = new ModificationItem(DirContext.REPLACE_ATTRIBUTE,
                    new BasicAttribute("pmCount", String.valueOf(count - 1)));
            ctx.modifyAttributes("CN=" + sScriptId + "," + sRuleContainerDN,
                    mods);

            // Delete the rule record.
            String sRes = deleteRule(sCrtRuleId);
            if (sRes != null) {
                return failurePacket(sRes);
            }
            return successPacket();
        } catch (Exception e) {
            if (debugFlag) {
                e.printStackTrace();
            }
            return failurePacket("Exception when deleting a rule from a script: "
                    + e.getMessage());
        }
    }

    // Compile and add to the enabled script, if one exists.
    // Otherwise, enable the new script. Returns the name and id of the
    // enabled script.
    private Packet compileScriptAndAddToEnabled(String sSessId, Packet cmdPacket) {
        // Create a temporary file.
        File ftemp = null;

        // The rules start at item 3 (0 = cmd code, 1 = sess id, 2 = filler).
        try {
            ftemp = File.createTempFile("evr", ".evr", null);
            FileOutputStream fos = new FileOutputStream(ftemp);
            PrintWriter pw = new PrintWriter(fos);
            for (int i = 3; i < cmdPacket.size(); i++) {
                String sLine = cmdPacket.getStringValue(i);
                if (sLine == null) {
                    continue;
                }
                pw.println(sLine);
            }
            pw.close();
        } catch (Exception e) {
            if (debugFlag) {
                e.printStackTrace();
            }
            return failurePacket("Exception while writing the rules to a temporary file: "
                    + e.getMessage());
        }

        // Create a new parser object and parse the script. Note that if parsing
        // is
        // successful, the script code is written in the active directory. An
        // object
        // of class pmClassScript with the script's id and name is created.
        // Other
        // scripts stored in the AD might have the same name.
        RuleParser ruleParser = new RuleParser(ftemp, this);
        String sResult = ruleParser.parse();
        if (sResult != null) {
            return failurePacket(sResult);
        }

        // Compilation is OK.
        // If no script is enabled, delete the scripts with the same
        // name as the new script and enable the new script.
        Packet res;

        String sEnScriptId = getEnabledScriptId();
        String sEnScriptName = null;

        if (sEnScriptId != null) {
            sEnScriptName = getEntityName(sEnScriptId, PM_SCRIPT);
            if (sEnScriptName == null) {
                sEnScriptId = null;
            }
        }

        if (sEnScriptId == null) {
            res =  deleteScriptsWithNameExcept(sSessId,
                    ruleParser.getScriptName(), ruleParser.getScriptId());
            if (res.hasError()) {
                return res;
            }
            sEnScriptId = ruleParser.getScriptId();

            res =  enableScript(sSessId, sEnScriptId);
            if (res.hasError()) {
                return res;
            }

            saveScriptSource(ruleParser.getScriptId(),
                    ruleParser.getScriptName(), cmdPacket);

            return res;
        }

        // An enabled script exists. Add the new script to it.
        res =  addScript(sSessId, ruleParser.getScriptId(), sEnScriptId);
        if (res.hasError()) {
            return res;
        }

        // Now add the source for the compiled script to the end of the old
        // source.
        addScriptSource(sEnScriptId, sEnScriptName, cmdPacket);

        res = new Packet();
        try {
            res.addItem(ItemType.RESPONSE_TEXT,
                    getEntityName(sEnScriptId, PM_SCRIPT) + PM_FIELD_DELIM
                            + sEnScriptId);
        } catch (Exception e) {
            e.printStackTrace();
            return failurePacket("Exception when building the result packet");
        }
        return res;
    }

    // Compile and enable the script (deleting all other scripts with the same
    // name).
    // The script starts at item 3 in the packet.
    private Packet compileScriptAndEnable(String sSessId, Packet cmdPacket) {
        // Create a temporary file.
        File ftemp = null;

        // The rules start at item 3 (0 = cmd code, 1 = sess id, 2 = filler).
        try {
            ftemp = File.createTempFile("evr", ".evr", null);
            FileOutputStream fos = new FileOutputStream(ftemp);
            PrintWriter pw = new PrintWriter(fos);
            for (int i = 3; i < cmdPacket.size(); i++) {
                String sLine = cmdPacket.getStringValue(i);
                if (sLine == null) {
                    continue;
                }
                pw.println(sLine);
            }
            pw.close();
        } catch (Exception e) {
            if (debugFlag) {
                e.printStackTrace();
            }
            return failurePacket("Exception while writing the rules to a temporary file: "
                    + e.getMessage());
        }

        // Create a new parser object and parse the script. Note that if parsing
        // is
        // successful, the script code is written in the active directory. An
        // object
        // of class pmClassScript with the script's id and name is created.
        // Other
        // scripts stored in the AD might have the same name.
        RuleParser ruleParser = new RuleParser(ftemp, this);
        String sResult = ruleParser.parse();

        // Delete the other scripts with the same name.
        if (sResult == null) {
            Packet res =  deleteScriptsWithNameExcept(sSessId,
                    ruleParser.getScriptName(), ruleParser.getScriptId());
            if (res.hasError()) {
                return res;
            }

            // Enable the new script.
            String sEnScriptId = ruleParser.getScriptId();
            res =  enableScript(sSessId, sEnScriptId);
            if (res.hasError()) {
                return res;
            }
            saveScriptSource(ruleParser.getScriptId(),
                    ruleParser.getScriptName(), cmdPacket);
            return res;
        }
        return failurePacket(sResult);
    }

    // Let scr be the script contained in the command.
    //
    // compile scr;
    // if (compilation fails) return failurePacket("Compilation failed!");
    //
    // if (! synonymExists(scr)) {
    // save scr;
    // return scr's name and id;
    // }
    //
    // s = synonym(scr);
    //
    // if (sDelOthers != "yes") {
    // delete scr;
    // return failurePacket("Synonym script exists!");
    // }
    //
    // if (s is enabled) {
    // delete scr;
    // return
    // failurePacket("another script with the same name exists and is enabled");
    // }
    //
    // delete s;
    // save scr;
    // return scr's name and id;
    private Packet compileScript(String sSessId, String sDeleteOthers,
                                 Packet cmd) {
        // Create a temporary file.
        File ftemp = null;

        // The rules start at item 3 (0 = cmd code, 1 = sess id, 2 =
        // sDeleteOthers).
        // Some items could be empty, the String used to extract them would be
        // null,
        // skip them.
        try {
            ftemp = File.createTempFile("evr", ".evr", null);
            FileOutputStream fos = new FileOutputStream(ftemp);
            PrintWriter pw = new PrintWriter(fos);

            // Copy the lines to the temp file.
            for (int i = 3; i < cmd.size(); i++) {
                String sLine = cmd.getStringValue(i);
                if (sLine == null) {
                    continue;
                }
                pw.println(sLine);
            }
            pw.close();
        } catch (Exception e) {
            if (debugFlag) {
                e.printStackTrace();
            }
            return failurePacket("Exception while writing the rules to a temporary file: "
                    + e.getMessage());
        }

        // Create a new parser object and parse the script. Note that if parsing
        // is
        // successful, the script code is written in the active directory. An
        // object
        // of class pmClassScript with the script's id and name is created.
        // Other
        // scripts stored in the AD might have the same name.
        RuleParser ruleParser = new RuleParser(ftemp, this);
        String sResult = ruleParser.parse();

        // If the compilation failed, return failure.
        if (sResult != null) {
            System.out.println("Error during compilation:" + sResult);
            return failurePacket(sResult);
        } else {
            System.out.println("Successful compilation of script "
                    + ruleParser.getScriptName());
        }

        // Compilation was successful.
        // If there is no other script with the same name, return the new
        // script's name and id.
        Packet res = new Packet();
        if (!synonymScriptsExist(ruleParser.getScriptName())) {
            System.out.println("No other scripts with the same name exist!");
            try {
                res.addItem(ItemType.RESPONSE_TEXT, ruleParser.getScriptName()
                        + PM_FIELD_DELIM + ruleParser.getScriptId());
            } catch (Exception e) {
                e.printStackTrace();
                return failurePacket("Exception when building the result packet");
            }

            System.out.println("Trying to save script source!");
            saveScriptSource(ruleParser.getScriptId(),
                    ruleParser.getScriptName(), cmd);
            System.out.println("Saved script source!");

            return res;
        }

        // There is a script with the same name.
        // If sDeleteOthers is not "yes", delete the new script and return
        // failure.
        if (!sDeleteOthers.equalsIgnoreCase("yes")) {
        	System.out.println("I am at 13145 pmEngin");
            sResult = deleteScriptInternal(ruleParser.getScriptId());
            if (sResult == null) {
                return failurePacket("A script with the same name exists. The new script was deleted!");
            } else {
                return failurePacket("A script with the same name exists. Error while deleting the new script!");
            }
        }

        // There is a script with the same name, and sDeleteOthers is "yes".
        // If the synonym script is enabled, we delete the new script.
        String sEnScriptId = getEnabledScriptId();
        if (sEnScriptId != null) {
            String sEnName = getEntityName(sEnScriptId, PM_SCRIPT);
            if (sEnName == null) {
                return failurePacket("Inconsistency: the enabled script "
                        + sEnScriptId + " does not exist!");
            }
            if (sEnName.equalsIgnoreCase(ruleParser.getScriptName())) {
                // Delete the script just compiled and return failure.
            	System.out.println("13164 in PmEngin");
                sResult = deleteScriptInternal(ruleParser.getScriptId());
                if (sResult == null) {
                    return failurePacket("A script with the same name exists and is enabled. The new script was deleted!");
                }
                return failurePacket("A script with the same name exists and is enabled. Error while deleting the new script!");
            }
        }

        // The synonyn is not enabled. Delete it.
        res =  deleteScriptsWithNameExcept(sSessId,
                ruleParser.getScriptName(), ruleParser.getScriptId());
        if (res.hasError()) {
            return failurePacket("A script with the same name exists. Error while deleting it!");
        }
        res = new Packet();

        try {
            res.addItem(ItemType.RESPONSE_TEXT, ruleParser.getScriptName()
                    + PM_FIELD_DELIM + ruleParser.getScriptId());
        } catch (Exception e) {
            e.printStackTrace();
            return failurePacket("Exception when building the result packet");
        }

        saveScriptSource(ruleParser.getScriptId(), ruleParser.getScriptName(),
                cmd);

        return res;
    }

    // Add a source script to the end of the source of a compiled script.
    // Parameters:
    // sScriptId and sScriptName: the id and name of the compiled script.
    // cmd: a Packet that contains the source script starting at item 3.
    private Packet addScriptSource(String sScriptId, String sScriptName,
                                   Packet cmd) {
        Attributes scriptAttrs;
        Attribute attr;
        String sSrcScriptId;

        try {
            // First get the source script of the compiled script.
            scriptAttrs = ctx.getAttributes("CN=" + sScriptId + ","
                    + sRuleContainerDN);
            attr = scriptAttrs.get("pmSourceId");
            if (attr == null) {
                return failurePacket("No source for the script " + sScriptName);
            }
            sSrcScriptId = (String) attr.get();
        } catch (Exception e) {
            if (debugFlag) {
                e.printStackTrace();
            }
            return failurePacket("Exception while extracting the attributes of script "
                    + sScriptName);
        }

        // For each line of the source to be added, create a source line object
        // and link it to the source script.
        for (int i = 3, n = 0; i < cmd.size(); i++) {
            String sLine = cmd.getStringValue(i);
            addLineToSourceScript(++n, sLine, sSrcScriptId);
        }
        return successPacket();
    }

    // Save a source script in the AD and set it as the source script of a
    // compiled
    // script.
    // Parameters:
    // sScriptId and sScriptName: the id and name of the compiled script.
    // cmd: a Packet that contains the source script starting at item 3.
    private Packet saveScriptSource(String sScriptId, String sScriptName,
                                    Packet cmd) {
        // Generate the source script id and prepare the attributes.
        RandomGUID myGUID = new RandomGUID();
        String sSourceScriptId = myGUID.toStringNoDashes();
        Attributes attrs = new BasicAttributes(true);
        attrs.put("objectClass", sScriptSourceClass);
        attrs.put("pmId", sSourceScriptId);
        attrs.put("pmName", sScriptName);
        // The source script must point to the compiled script with its
        // pmScriptId.
        attrs.put("pmScriptId", sScriptId);

        // Prepare the path and create the new object.
        String sDn = "CN=" + sSourceScriptId + "," + sRuleContainerDN;
        try {
            ctx.bind(sDn, null, attrs);
        } catch (Exception e) {
            if (debugFlag) {
                e.printStackTrace();
            }
            return failurePacket("Could not create source script object "
                    + sScriptName);
        }

        // The compiled script must point to the source script with its
        // pmSourceId.
        ModificationItem[] mods = new ModificationItem[1];
        mods[0] = new ModificationItem(DirContext.REPLACE_ATTRIBUTE,
                new BasicAttribute("pmSourceId", sSourceScriptId));
        try {
            ctx.modifyAttributes("CN=" + sScriptId + "," + sRuleContainerDN,
                    mods);
        } catch (Exception e) {
            if (debugFlag) {
                e.printStackTrace();
            }
            return failurePacket("Could not link the compiled script to the source script!");
        }

        // For each line create a source line object and link it in a list.
        for (int i = 3, n = 0; i < cmd.size(); i++) {
            String sLine = cmd.getStringValue(i);
            addLineToSourceScript(++n, sLine, sSourceScriptId);
        }
        return successPacket();
    }

    private Packet addLineToSourceScript(int n, String sLine,
                                         String sSourceScriptId) {
        try {
            System.out.println("Adding line " + n + ":<" + sLine + ">");

            // Extract previous line id from pmLast of the source script object.
            // Get script's attributes.
            Attributes scriptAttrs = ctx.getAttributes("CN=" + sSourceScriptId
                    + "," + sRuleContainerDN);
            String sPrevLineId = null;
            Attribute attr = scriptAttrs.get("pmLast");
            if (attr != null) {
                sPrevLineId = (String) attr.get();
            }

            // Create a new source line object.
            RandomGUID myGUID = new RandomGUID();
            String sCrtLineId = myGUID.toStringNoDashes();
            Attributes basicAttrs = new BasicAttributes(true);
            basicAttrs.put("objectClass", sSourceLineClass);
            basicAttrs.put("pmId", sCrtLineId);
            if (sLine != null && sLine.length() > 0) {
                basicAttrs.put("pmText", sLine);
            }
            if (sPrevLineId != null) {
                basicAttrs.put("pmPrev", sPrevLineId);
            }
            ctx.bind("CN=" + sCrtLineId + "," + sRuleContainerDN, null,
                    basicAttrs);

            // Insert the new object in the linked list.
            ModificationItem[] mods = new ModificationItem[1];
            if (sPrevLineId == null) {
                // This is the first line, the script must point to it with
                // pmFirst.
                mods[0] = new ModificationItem(DirContext.ADD_ATTRIBUTE,
                        new BasicAttribute("pmFirst", sCrtLineId));
                ctx.modifyAttributes("CN=" + sSourceScriptId + ","
                        + sRuleContainerDN, mods);
            } else {
                // This is not the first line, the previous line must point to
                // it with
                // pmNext.
                mods[0] = new ModificationItem(DirContext.ADD_ATTRIBUTE,
                        new BasicAttribute("pmNext", sCrtLineId));
                ctx.modifyAttributes("CN=" + sPrevLineId + ","
                        + sRuleContainerDN, mods);
            }

            // pmLast of the script must point to this new line.
            mods[0] = new ModificationItem(DirContext.REPLACE_ATTRIBUTE,
                    new BasicAttribute("pmLast", sCrtLineId));
            ctx.modifyAttributes("CN=" + sSourceScriptId + ","
                    + sRuleContainerDN, mods);

            return successPacket();
        } catch (Exception e) {
            if (debugFlag) {
                e.printStackTrace();
            }
            return failurePacket("Error while saving source line " + n);
        }
    }

    private boolean synonymScriptsExist(String sScriptName) {
        int howmany = 0;
        NamingEnumeration<?> scripts;
        try {
            SearchControls constraints = new SearchControls();
            constraints.setSearchScope(SearchControls.ONELEVEL_SCOPE);
            constraints.setReturningAttributes(new String[]{"pmId", "pmName"});
            scripts = ctx.search(sRuleContainerDN, "(&(objectClass="
                    + sScriptClass + ")(pmName=" + sScriptName + "))",
                    constraints);
            while (scripts != null && scripts.hasMore()) {
                SearchResult sr = (SearchResult) scripts.next();
                String sName = (String) sr.getAttributes().get("pmName").get();
                if (sName.equals(sScriptName)) {
                    howmany++;
                }
                if (howmany >= 2) {
                    return true;
                }
            }
        } catch (Exception e) {
            if (debugFlag) {
                e.printStackTrace();
            }
        }
        return false;
    }

    // Add the rules of the source script to the end of the destination script.
    // Both scripts must exist. Take into account the case when the destination
    // script exists but is empty (pmFirst and pmLast are not set).
    // The source script is destroyed after the operation.
    // Return success or failure.
    private Packet addScript(String sSessId, String sSrcScriptId,
                             String sDstScriptId) {
        // If the source script does not exist, return failure.
        if (sSrcScriptId == null) {
            return failurePacket("Source script id is null!");
        }
        String sName = getEntityName(sSrcScriptId, PM_SCRIPT);
        if (sName == null) {
            return failurePacket("Source script does not exist!");
        }

        // If the destination script does not exist, return failure.
        if (sDstScriptId == null) {
            return failurePacket("Destination script id is null!");
        }
        sName = getEntityName(sDstScriptId, PM_SCRIPT);
        if (sName == null) {
            return failurePacket("Destination script does not exist!");
        }

        try {
            // The target and destination script attributes.
            Attributes dstAttrs = ctx.getAttributes("CN=" + sDstScriptId + ","
                    + sRuleContainerDN);
            Attributes srcAttrs = ctx.getAttributes("CN=" + sSrcScriptId + ","
                    + sRuleContainerDN);

            // Get the rule count, the first rule, and the last rule of the
            // source script.
            int srcCount = (Integer.valueOf((String) srcAttrs.get("pmCount").get())).intValue();
            String sSrcFirstRuleId = null;
            Attribute attr = srcAttrs.get("pmFirst");
            if (attr != null) {
                sSrcFirstRuleId = (String) attr.get();
            }
            String sSrcLastRuleId = null;
            attr = srcAttrs.get("pmLast");
            if (attr != null) {
                sSrcLastRuleId = (String) attr.get();
            }

            // If the source script is empty, return success.
            if (sSrcFirstRuleId == null) {
                // Delete the source script record.
                ctx.destroySubcontext("CN=" + sSrcScriptId + ","
                        + sRuleContainerDN);
                return successPacket();
            }

            // Get the rule count and the last rule of the destination script.
            int dstCount = (Integer.valueOf((String) dstAttrs.get("pmCount").get())).intValue();
            String sDstLastRuleId = null;
            attr = dstAttrs.get("pmLast");
            if (attr != null) {
                sDstLastRuleId = (String) attr.get();
            }

            // If the last rule of the destination does not exist
            // (sDstLastRuleId is
            // null), that means the destination script is empty. To add the
            // source
            // we need to copy the source first rule, last rule, and count to
            // the
            // destination.
            if (sDstLastRuleId == null) {
                ModificationItem[] mods = new ModificationItem[3];
                mods[0] = new ModificationItem(DirContext.ADD_ATTRIBUTE,
                        new BasicAttribute("pmFirst", sSrcFirstRuleId));
                mods[1] = new ModificationItem(DirContext.ADD_ATTRIBUTE,
                        new BasicAttribute("pmLast", sSrcLastRuleId));
                mods[2] = new ModificationItem(DirContext.REPLACE_ATTRIBUTE,
                        new BasicAttribute("pmCount", String.valueOf(srcCount)));
                ctx.modifyAttributes("CN=" + sDstScriptId + ","
                        + sRuleContainerDN, mods);
                // Delete the source script record.
                ctx.destroySubcontext("CN=" + sSrcScriptId + ","
                        + sRuleContainerDN);
                return successPacket();
            }

            // Set pmNext in the last destination rule to the first source rule.
            ModificationItem[] mods = new ModificationItem[1];
            mods[0] = new ModificationItem(DirContext.ADD_ATTRIBUTE,
                    new BasicAttribute("pmNext", sSrcFirstRuleId));
            ctx.modifyAttributes("CN=" + sDstLastRuleId + ","
                    + sRuleContainerDN, mods);

            // Set the pmPrev in the first source rule to the last destination
            // rule.
            mods[0] = new ModificationItem(DirContext.ADD_ATTRIBUTE,
                    new BasicAttribute("pmPrev", sDstLastRuleId));
            ctx.modifyAttributes("CN=" + sSrcFirstRuleId + ","
                    + sRuleContainerDN, mods);

            // Loop over source rules.
            String sLastSrcRuleId = null;// last processed source rule (not the
            // last source rule).
            String sCrtSrcRuleId = sSrcFirstRuleId;
            while (sCrtSrcRuleId != null) {
                // Increase the rank of each source rule.
                Attributes ruleAttrs = ctx.getAttributes("CN=" + sCrtSrcRuleId
                        + "," + sRuleContainerDN);
                int rank = (Integer.valueOf((String) ruleAttrs.get("pmRank").get())).intValue() + dstCount;
                mods[0] = new ModificationItem(DirContext.REPLACE_ATTRIBUTE,
                        new BasicAttribute("pmRank", String.valueOf(rank)));
                ctx.modifyAttributes("CN=" + sCrtSrcRuleId + ","
                        + sRuleContainerDN, mods);

                // Save the rule just processed, so we get the last source rule
                // after the loop.
                sLastSrcRuleId = sCrtSrcRuleId;

                // Next source rule.
                attr = ruleAttrs.get("pmNext");
                if (attr == null) {
                    sCrtSrcRuleId = null;
                } else {
                    sCrtSrcRuleId = (String) attr.get();
                }
            }

            // Update the rule count in the destination script.
            mods[0] = new ModificationItem(DirContext.REPLACE_ATTRIBUTE,
                    new BasicAttribute("pmCount", String.valueOf(dstCount
                            + srcCount)));
            ctx.modifyAttributes("CN=" + sDstScriptId + "," + sRuleContainerDN,
                    mods);

            // Update the last rule id in the destination script.
            mods[0] = new ModificationItem(DirContext.REPLACE_ATTRIBUTE,
                    new BasicAttribute("pmLast", sLastSrcRuleId));
            ctx.modifyAttributes("CN=" + sDstScriptId + "," + sRuleContainerDN,
                    mods);

            // Delete the source script record.
            ctx.destroySubcontext("CN=" + sSrcScriptId + "," + sRuleContainerDN);

            return successPacket();
        } catch (Exception e) {
            if (debugFlag) {
                e.printStackTrace();
            }
            return failurePacket("Exception when adding scripts: "
                    + e.getMessage());
        }
    }

    // Add the rules of script sScriptId to the end of the enabled script.
    // If no enabled script exists, the script sScriptId is enabled.
    // Return success or failure.
    private Packet addScriptToEnabled(String sSessId, String sScriptId) {
        return successPacket();
    }

    private Packet getSourceScript(String sSessId, String sScriptId) {
        String sName = getEntityName(sScriptId, PM_SCRIPT);
        if (sName == null) {
            return failurePacket("Script does not exist!");
        }
        Packet script = new Packet();

        try {
            Attributes scriptAttrs = ctx.getAttributes("CN=" + sScriptId + ","
                    + sRuleContainerDN);
            Attribute attr = scriptAttrs.get("pmSourceId");
            if (attr == null) {
                return failurePacket("No source for script " + sName
                        + " with id " + sScriptId);
            }
            String sSourceScriptId = (String) attr.get();

            Attributes sourceAttrs = ctx.getAttributes("CN=" + sSourceScriptId
                    + "," + sRuleContainerDN);
            attr = sourceAttrs.get("pmFirst");
            while (attr != null) {
                String sSourceLineId = (String) attr.get();
                sourceAttrs = ctx.getAttributes("CN=" + sSourceLineId + ","
                        + sRuleContainerDN);
                String sLine = "";
                attr = sourceAttrs.get("pmText");
                if (attr != null) {
                    sLine = (String) attr.get();
                }
                script.addItem(ItemType.RESPONSE_TEXT, sLine);
                attr = sourceAttrs.get("pmNext");
            }
            return script;
        } catch (Exception e) {
            e.printStackTrace();
            return failurePacket("Error while extracting source script!");
        }
    }

    // Delete the script specified by its id. The enabled script cannot be
    // deleted.
    private Packet deleteScript(String sSessId, String sScriptId) {
        // If the script to be deleted is the enabled script, return failure.
        String sEnScriptId = getEnabledScriptId();
        if (sEnScriptId != null && sEnScriptId.equalsIgnoreCase(sScriptId)) {
            return failurePacket("The enabled script cannot be deleted!");
        }
        System.out.println("i am at 13582 pmEngin");
        String res = deleteScriptInternal(sScriptId);
        if (res == null) {
            return successPacket();
        } else {
            return failurePacket(res);
        }
    }

    public String deleteScriptInternal(String sScriptId) {
        System.out.println(">>>>>>>>>>>>Delete Script " + sScriptId);
        try {
            Attributes scriptAttrs = ctx.getAttributes("CN=" + sScriptId + ","
                    + sRuleContainerDN);

            Attribute attr = scriptAttrs.get("pmSourceId");
            if (attr != null) {
                String sSourceScriptId = (String) attr.get();
                deleteSourceScript(sSourceScriptId);
            }

            attr = scriptAttrs.get("pmFirst");
            while (attr != null) {
                String sRuleId = (String) attr.get();
                Attributes ruleAttrs = ctx.getAttributes("CN=" + sRuleId + ","
                        + sRuleContainerDN);
                attr = ruleAttrs.get("pmNext");
                String result = deleteRule(sRuleId);
                if (result != null) {
                    return result;
                }
            }

            System.out.println("^^^^^^^Deleting script " + sScriptId);
            ctx.destroySubcontext("CN=" + sScriptId + "," + sRuleContainerDN);
        } catch (Exception e) {
            if (debugFlag) {
                e.printStackTrace();
            }
            return "Exception while deleting the EVER script " + sScriptId;
        }
        return null;
    }

    private String deleteSourceScript(String sSourceScriptId) {
        try {
            Attributes scriptAttrs = ctx.getAttributes("CN=" + sSourceScriptId
                    + "," + sRuleContainerDN);
            Attribute attr = scriptAttrs.get("pmFirst");
            while (attr != null) {
                String sSourceLineId = (String) attr.get();
                Attributes lineAttrs = ctx.getAttributes("CN=" + sSourceLineId
                        + "," + sRuleContainerDN);
                attr = lineAttrs.get("pmNext");
                ctx.destroySubcontext("CN=" + sSourceLineId + ","
                        + sRuleContainerDN);
            }
            ctx.destroySubcontext("CN=" + sSourceScriptId + ","
                    + sRuleContainerDN);
            return null;
        } catch (Exception e) {
            if (debugFlag) {
                e.printStackTrace();
            }
            return "Exception while deleting the source script "
                    + sSourceScriptId;
        }
    }

    public String deleteRule(String sRuleId) {
        System.out.println(">>>>>>>>>>>>Delete Rule " + sRuleId);
        String result = null;
        try {
            Attributes ruleAttrs = ctx.getAttributes("CN=" + sRuleId + ","
                    + sRuleContainerDN);
            Attribute attr = ruleAttrs.get("pmEventPattern");
            if (attr != null) {
                String sPatternId = (String) attr.get();
                result = deletePattern(sPatternId);
                if (result != null) {
                    return result;
                }
            }

            attr = ruleAttrs.get("pmAction");
            if (attr != null) {
                for (NamingEnumeration<?> enumer = attr.getAll(); enumer.hasMore(); ) {
                    String sActionId = (String) enumer.next();
                    result = deleteAction(sActionId);
                    if (result != null) {
                        return result;
                    }
                }
            }
            System.out.println("^^^^^^^Deleting rule " + sRuleId);
            ctx.destroySubcontext("CN=" + sRuleId + "," + sRuleContainerDN);
        } catch (Exception e) {
            if (debugFlag) {
                e.printStackTrace();
            }
            return "Exception while deleting the rule " + sRuleId;
        }
        return null;
    }

    private String deletePattern(String sPatternId) {
        System.out.println(">>>>>>>>>>>>Delete Pattern " + sPatternId);
        System.out.println("^^^^^^^Deleting pattern " + sPatternId);
        try {
            ctx.destroySubcontext("CN=" + sPatternId + "," + sRuleContainerDN);
        } catch (Exception e) {
            if (debugFlag) {
                e.printStackTrace();
            }
            return "Exception while deleting the pattern " + sPatternId;
        }
        return null;
    }

    private String deleteAction(String sActionId) {
        System.out.println(">>>>>>>>>>>>Delete Action " + sActionId);
        String result = null;
        try {
            Attributes actionAttrs = ctx.getAttributes("CN=" + sActionId + ","
                    + sRuleContainerDN);
            Attribute attr = actionAttrs.get("pmCondition");
            if (attr != null) {
                for (NamingEnumeration<?> enumer = attr.getAll(); enumer.hasMore(); ) {
                    String sCondId = (String) enumer.next();
                    result = deleteCondition(sCondId);
                    if (result != null) {
                        return result;
                    }
                }
            }

            attr = actionAttrs.get("pmOpnd1");
            if (attr != null) {
                for (NamingEnumeration<?> enumer = attr.getAll(); enumer.hasMore(); ) {
                    String sOpndId = (String) enumer.next();
                    result = deleteOperand(sOpndId);
                    if (result != null) {
                        return result;
                    }
                }
            }

            attr = actionAttrs.get("pmOpnd2");
            if (attr != null) {
                for (NamingEnumeration<?> enumer = attr.getAll(); enumer.hasMore(); ) {
                    String sOpndId = (String) enumer.next();
                    result = deleteOperand(sOpndId);
                    if (result != null) {
                        return result;
                    }
                }
            }

            attr = actionAttrs.get("pmOpnd3");
            if (attr != null) {
                for (NamingEnumeration<?> enumer = attr.getAll(); enumer.hasMore(); ) {
                    String sOpndId = (String) enumer.next();
                    result = deleteOperand(sOpndId);
                    if (result != null) {
                        return result;
                    }
                }
            }

            attr = actionAttrs.get("pmOpnd4");
            if (attr != null) {
                for (NamingEnumeration<?> enumer = attr.getAll(); enumer.hasMore(); ) {
                    String sOpndId = (String) enumer.next();
                    result = deleteOperand(sOpndId);
                    if (result != null) {
                        return result;
                    }
                }
            }

            System.out.println("^^^^^^^Deleting action " + sActionId);
            ctx.destroySubcontext("CN=" + sActionId + "," + sRuleContainerDN);
        } catch (Exception e) {
            if (debugFlag) {
                e.printStackTrace();
            }
            return "Exception while deleting the action " + sActionId;
        }
        return null;
    }

    private String deleteCondition(String sCondId) {
        System.out.println(">>>>>>>>>>>>Delete Condition " + sCondId);
        String result = null;
        try {
            Attributes actionAttrs = ctx.getAttributes("CN=" + sCondId + ","
                    + sRuleContainerDN);
            Attribute attr = actionAttrs.get("pmOpnd1");
            if (attr != null) {
                for (NamingEnumeration<?> enumer = attr.getAll(); enumer.hasMore(); ) {
                    String sOpndId = (String) enumer.next();
                    result = deleteOperand(sOpndId);
                    if (result != null) {
                        return result;
                    }
                }
            }
            ctx.destroySubcontext("CN=" + sCondId + "," + sRuleContainerDN);
        } catch (Exception e) {
            if (debugFlag) {
                e.printStackTrace();
            }
            return "Exception while deleting the condition " + sCondId;
        }
        return null;
    }

    private String deleteOperand(String sOpndId) {
        System.out.println(">>>>>>>>>>>>Delete Operand " + sOpndId);
        String result = null;
        try {
            Attributes opndAttrs = ctx.getAttributes("CN=" + sOpndId + ","
                    + sRuleContainerDN);
            Attribute attr = opndAttrs.get("pmArgs");
            if (attr != null) {
                String sArgs = (String) attr.get();
                String[] pieces = sArgs.split(PM_ALT_DELIM_PATTERN);
                for (int i = 0; i < pieces.length; i++) {
                    result = deleteOperand(pieces[i]);
                    if (result != null) {
                        return result;
                    }
                }
            }
            System.out.println("^^^^^^^Deleting operand " + sOpndId);
            ctx.destroySubcontext("CN=" + sOpndId + "," + sRuleContainerDN);
        } catch (Exception e) {
            if (debugFlag) {
                e.printStackTrace();
            }
            return "Exception while deleting the operand " + sOpndId;
        }
        return null;
    }

    // Delete all scripts of the specified name, except the one with the
    // specified id.
    private Packet deleteScriptsWithNameExcept(String sSessId,
                                               String sScriptName, String sScriptId) {
        // Find all script records with the specified name.
        NamingEnumeration<?> scripts;

        try {
            SearchControls constraints = new SearchControls();
            constraints.setSearchScope(SearchControls.ONELEVEL_SCOPE);
            constraints.setReturningAttributes(new String[]{"pmId", "pmName"});
            scripts = ctx.search(sRuleContainerDN, "(&(objectClass="
                    + sScriptClass + ")(pmName=" + sScriptName + "))",
                    constraints);
            while (scripts != null && scripts.hasMore()) {
                SearchResult sr = (SearchResult) scripts.next();
                Attribute attr = sr.getAttributes().get("pmId");
                if (attr != null) {
                    String sId = (String) attr.get();
                    if (!sId.equalsIgnoreCase(sScriptId)) {
                    	System.out.println("I am at 13846 in pmEngin");
                        String sRes = deleteScriptInternal(sId);
                        if (sRes != null) {
                            return failurePacket(sRes);
                        }
                        continue;
                    }
                }
            }
        } catch (Exception e) {
            if (debugFlag) {
                e.printStackTrace();
            }
        }
        return successPacket();
    }

    // This is called from the parser at the start of a new compilation.
    // It creates a script record with the specified name and id.
    public String createScriptRecord(String scriptId, String scriptName) {
        Attributes attrs = new BasicAttributes(true);

        attrs.put("objectClass", sScriptClass);
        attrs.put("pmId", scriptId);
        attrs.put("pmName", scriptName);
        attrs.put("pmIsEnabled", "FALSE");
        attrs.put("pmCount", String.valueOf(0));
        String sScriptDn = "CN=" + scriptId + "," + sRuleContainerDN;
        try {
            ctx.bind(sScriptDn, null, attrs);
        } catch (Exception e) {
            e.printStackTrace();
            return "Unable to create AD Script object!";
        }
        return null;
    }

    // Called from the parser for one rule if parsing is OK for that rule.
    // Generate the code for the rule.
    public String generateRuleCode(RuleSpec ruleSpec, String scriptId,
                                   String prevRuleId) {
        String result = checkRuleSemantics(ruleSpec);
        if (result != null) {
            return result;
        }

        result = writeRuleCode(ruleSpec);
        if (result != null) {
            return result;
        }

        return addRuleToScript(ruleSpec, scriptId, prevRuleId);
    }

    // If this is the first rule (prevRuleId = null), add the rule to the script
    // record as the first rule.
    // Otherwise, set the double link between previous rule and this rule.
    // Increase the rule count in the script record.
    private String addRuleToScript(RuleSpec ruleSpec, String scriptId,
                                   String prevRuleId) {
        String crtRuleId = ruleSpec.getId();
        ModificationItem[] mods = new ModificationItem[1];
        if (prevRuleId == null) {
            // This is the first rule.
            mods[0] = new ModificationItem(DirContext.ADD_ATTRIBUTE,
                    new BasicAttribute("pmFirst", crtRuleId));
            try {
                ctx.modifyAttributes("CN=" + scriptId + "," + sRuleContainerDN,
                        mods);
            } catch (Exception e) {
                e.printStackTrace();
                return "Unable to add rule id as the script's first rule!";
            }
        } else {
            mods[0] = new ModificationItem(DirContext.ADD_ATTRIBUTE,
                    new BasicAttribute("pmNext", crtRuleId));
            try {
                ctx.modifyAttributes("CN=" + prevRuleId + ","
                        + sRuleContainerDN, mods);
            } catch (Exception e) {
                e.printStackTrace();
                return "Unable to set the link previous rule ---> this rule!";
            }
            mods[0] = new ModificationItem(DirContext.ADD_ATTRIBUTE,
                    new BasicAttribute("pmPrev", prevRuleId));
            try {
                ctx.modifyAttributes(
                        "CN=" + crtRuleId + "," + sRuleContainerDN, mods);
            } catch (Exception e) {
                e.printStackTrace();
                return "Unable to set the link this rule ---> previous rule!";
            }
        }
        try {
            Attributes attrs = ctx.getAttributes("CN=" + scriptId + ","
                    + sRuleContainerDN);
            int count = (Integer.valueOf((String) attrs.get("pmCount").get())).intValue() + 1;
            mods = new ModificationItem[2];
            mods[0] = new ModificationItem(DirContext.REPLACE_ATTRIBUTE,
                    new BasicAttribute("pmCount", String.valueOf(count)));
            mods[1] = new ModificationItem(DirContext.REPLACE_ATTRIBUTE,
                    new BasicAttribute("pmLast", crtRuleId));
            ctx.modifyAttributes("CN=" + scriptId + "," + sRuleContainerDN,
                    mods);
        } catch (Exception e) {
            e.printStackTrace();
            return "Unable to update the rule count or the last rule id in the script record!";
        }
        return null;
    }

    private String writeRuleCode(RuleSpec ruleSpec) {
        String result = null;

        // Get the pattern spec and the action specs.
        Vector<ActionSpec> actSpecs = ruleSpec.getActions();

        result = writeRuleRecord(ruleSpec);
        if (result != null) {
            return result;
        }

        result = writePatternRecord(ruleSpec.getPattern());
        if (result != null) {
            return result;
        }

        // Write the actions to AD.
        traceTitle("RESPONSE ACTIONS");
        if (actSpecs.isEmpty()) {
            return null;
        }

        String sPrevActId = null;

        for (int nActRank = 0; nActRank < actSpecs.size(); nActRank++) {
            ActionSpec actSpec = actSpecs.get(nActRank);

            // First create the AD record, links, etc.
            result = createActionRecord(actSpec, sPrevActId, nActRank);

            // Write the condition record.
            result = writeActionCondRecord(actSpec);
            if (result != null) {
                return result;
            }

            // Then fill in the record.
            String type = actSpec.getType();
            if (type.startsWith(RuleScanner.PM_VALUE_ASSIGN)) {
                result = writeAssignActionRecord(actSpec);
                if (result != null) {
                    return result;
                }
            } else if (type.startsWith(RuleScanner.PM_VALUE_GRANT)) {
                result = writeGrantActionRecord(actSpec);
                if (result != null) {
                    return result;
                }
            } else if (type.startsWith(RuleScanner.PM_VALUE_CREATE)) {
                result = writeCreateActionRecord(actSpec);
                if (result != null) {
                    return result;
                }
            } else if (type.startsWith(RuleScanner.PM_VALUE_DENY)) {
                result = writeDenyActionRecord(actSpec);
                if (result != null) {
                    return result;
                }
            } else if (type.startsWith(RuleScanner.PM_VALUE_DELETE + " "
                    + RuleScanner.PM_VALUE_ASSIGNMENT)) {
                result = writeDeassignActionRecord(actSpec);
                if (result != null) {
                    return result;
                }
            } else if (type.startsWith(RuleScanner.PM_VALUE_DELETE + " "
                    + RuleScanner.PM_VALUE_DENY)) {
                result = writeDeleteDenyActionRecord(actSpec);
                if (result != null) {
                    return result;
                }
            } else if (type.startsWith(RuleScanner.PM_VALUE_DELETE + " "
                    + RuleScanner.PM_VALUE_RULE)) {
                result = writeDeleteRuleActionRecord(actSpec);
                if (result != null) {
                    return result;
                }
            }
            sPrevActId = actSpec.getId();
        }

        return null;
    }

    private String writePatternRecord(PatternSpec patSpec) {
        ModificationItem[] mods = new ModificationItem[1];
        Attributes attrs = new BasicAttributes(true);

        String sPatternId = patSpec.getId();
        attrs.put("objectClass", sEventPatternClass);
        attrs.put("pmId", sPatternId);
        attrs.put("pmIsAny", (patSpec.isAny() ? "TRUE" : "FALSE"));
        attrs.put("pmIsActive", (patSpec.isActive() ? "TRUE" : "FALSE"));
        String sPatternDn = "CN=" + sPatternId + "," + sRuleContainerDN;
        try {
            ctx.bind(sPatternDn, null, attrs);
        } catch (Exception e) {
            e.printStackTrace();
            return "Unable to create AD Event Pattern object!";
        }
        traceTitle("EVENT PATTERN id = " + patSpec.getId());
        traceLine("  isAny = " + patSpec.isAny());
        traceLine("  isActive = " + patSpec.isActive());

        // Write the user specs:
        traceTitle("Event users");
        Set<UserSpec> UserSet = patSpec.getUserSpecs();
        if (UserSet.isEmpty()) {
            mods[0] = new ModificationItem(DirContext.ADD_ATTRIBUTE,
                    new BasicAttribute("pmUserSpec", "*"));
            try {
                ctx.modifyAttributes(sPatternDn, mods);
            } catch (Exception e) {
                e.printStackTrace();
                return "Unable to add a user specification to the event pattern object!";
            }
            traceLine("  userSpec(\"*\", \"" + PmEngine.PM_NODE_USER + "\")");
        } else {
            Iterator<UserSpec> hsiter;
            hsiter = UserSet.iterator();
            while (hsiter.hasNext()) {
                UserSpec spec = hsiter.next();
                mods[0] = new ModificationItem(DirContext.ADD_ATTRIBUTE,
                        new BasicAttribute("pmUserSpec", spec.getType()
                                + PM_ALT_FIELD_DELIM + spec.getId()));
                try {
                    ctx.modifyAttributes(sPatternDn, mods);
                } catch (Exception e) {
                    e.printStackTrace();
                    return "Unable to add a user specification to the event pattern object!";
                }
                traceLine("  userSpec(name = \"" + spec.getName() + "\", "
                        + "id = \"" + spec.getId() + "\", " + "type = \""
                        + spec.getType() + "\")");
            }
        }
        // Write the policy specs.
        traceTitle("Event policy classes");
        Set<PcSpec> pcSet = patSpec.getPcSpecs();
        if (pcSet.isEmpty()) {
            mods[0] = new ModificationItem(DirContext.ADD_ATTRIBUTE,
                    new BasicAttribute("pmPolicySpec", "*"));
            try {
                ctx.modifyAttributes(sPatternDn, mods);
            } catch (Exception e) {
                e.printStackTrace();
                return "Unable to add a policy specification to the event pattern object!";
            }
            traceLine("  policySpec(\"*\", \"" + PmEngine.PM_NODE_POL + "\")");
        } else {
            Iterator<PcSpec> hsiter = pcSet.iterator();
            while (hsiter.hasNext()) {
                PcSpec spec = hsiter.next();
                mods[0] = new ModificationItem(DirContext.ADD_ATTRIBUTE,
                        new BasicAttribute("pmPolicySpec", spec.getType()
                                + PM_ALT_FIELD_DELIM + spec.getId()));
                try {
                    ctx.modifyAttributes(sPatternDn, mods);
                } catch (Exception e) {
                    e.printStackTrace();
                    return "Unable to add a policy specification to the event pattern object!";
                }
                traceLine("  pcSpec(name = \"" + spec.getName() + "\", "
                        + "id = \"" + spec.getId() + "\", " + "type = \""
                        + spec.getType() + "\")");
            }
        }

        // Write the op specs.
        traceTitle("Event operations");
        Set<OpSpec> opSet = patSpec.getOpSpecs();
        if (opSet.isEmpty()) {
            mods[0] = new ModificationItem(DirContext.ADD_ATTRIBUTE,
                    new BasicAttribute("pmOpSpec", "*"));
            try {
                ctx.modifyAttributes(sPatternDn, mods);
            } catch (Exception e) {
                e.printStackTrace();
                return "Unable to add an operation specification to the event pattern object!";
            }
            traceLine("  opSpec(\"*\", \"" + PmEngine.PM_OP + "\")");
        } else {
            Iterator<OpSpec> hsiter = opSet.iterator();
            while (hsiter.hasNext()) {
                OpSpec spec = (OpSpec) hsiter.next();
                mods[0] = new ModificationItem(DirContext.ADD_ATTRIBUTE,
                        new BasicAttribute("pmOpSpec", spec.getName()));
                try {
                    ctx.modifyAttributes(sPatternDn, mods);
                } catch (Exception e) {
                    e.printStackTrace();
                    return "Unable to add an operation specification to the event pattern object!";
                }
                traceLine("  opSpec(\"" + spec.getName() + "\", \""
                        + spec.getType() + "\")");
            }
        }

        // Write the obj specs. There is only one. If multiple objects are
        // desired,
        // use their associated object attributes as containers.
        traceTitle("Event objects");
        Set<ObjSpec> hs = patSpec.getObjSpecs();
        if (hs.isEmpty()) {
            mods[0] = new ModificationItem(DirContext.ADD_ATTRIBUTE,
                    new BasicAttribute("pmObjSpec", "*"));
            try {
                ctx.modifyAttributes(sPatternDn, mods);
            } catch (Exception e) {
                e.printStackTrace();
                return "Unable to add an object/attribute/class specification to the event pattern object!";
            }
            traceLine("  objSpec(\"*\", \"" + PmEngine.PM_OBJ + "\")");
        } else {
            Iterator<ObjSpec> hsiter = hs.iterator();
            while (hsiter.hasNext()) {
                ObjSpec spec = hsiter.next();
                mods[0] = new ModificationItem(DirContext.ADD_ATTRIBUTE,
                        new BasicAttribute("pmObjSpec", spec.getType()
                                + PM_ALT_FIELD_DELIM + spec.getName()));
                try {
                    ctx.modifyAttributes(sPatternDn, mods);
                } catch (Exception e) {
                    e.printStackTrace();
                    return "Unable to add an object specification to the event pattern object!";
                }
                traceLine("  objSpec(name = \"" + spec.getName() + "\", "
                        + "id = \"" + spec.getId() + "\", " + "type = \""
                        + spec.getType() + "\")");
            }
        }

        // Write the container specs.
        traceTitle("Event object containers");
        Set<ContSpec> contSet = patSpec.getContSpecs();
        if (contSet.isEmpty()) {
            mods[0] = new ModificationItem(DirContext.ADD_ATTRIBUTE,
                    new BasicAttribute("pmContSpec", "*"));
            try {
                ctx.modifyAttributes(sPatternDn, mods);
            } catch (Exception e) {
                e.printStackTrace();
                return "Unable to add an object container (attribute or class) specification to the event pattern object!";
            }
            traceLine("  contSpec(\"*\", \"" + PmEngine.PM_OBJ + "\")");
        } else {
            Iterator<ContSpec> hsiter = contSet.iterator();
            while (hsiter.hasNext()) {
                ContSpec spec = (ContSpec) hsiter.next();
                mods[0] = new ModificationItem(DirContext.ADD_ATTRIBUTE,
                        new BasicAttribute("pmContSpec", spec.getType()
                                + PM_ALT_FIELD_DELIM + spec.getId()));
                try {
                    ctx.modifyAttributes(sPatternDn, mods);
                } catch (Exception e) {
                    e.printStackTrace();
                    return "Unable to add an object container (attribute or class) specification to the event pattern object!";
                }
                traceLine("  contSpec(name = \"" + spec.getName() + "\", "
                        + "id = \"" + spec.getId() + "\", " + "type = \""
                        + spec.getType() + "\")");
            }
        }

        return null;
    }

    private String writeRuleRecord(RuleSpec ruleSpec) {
        String sLabel = ruleSpec.getLabel();
        PatternSpec patSpec = ruleSpec.getPattern();
        List<ActionSpec> actSpecs = ruleSpec.getActions();
        ModificationItem[] mods = new ModificationItem[1];

        Attributes attrs = new BasicAttributes(true);
        String sRuleId = ruleSpec.getId();
        attrs.put("objectClass", sRuleClass);
        attrs.put("pmId", sRuleId);
        if (sLabel != null) {
            attrs.put("pmLabel", sLabel);
        }
        attrs.put("pmRank", String.valueOf(ruleSpec.getRank()));
        attrs.put("pmEventPattern", patSpec.getId());

        // Set the number of actions in the rule.
        int nActs = actSpecs.size();
        attrs.put("pmCount", String.valueOf(nActs));
        // Set the id of the first action in the rule.
        if (nActs > 0) {
            attrs.put("pmFirst", ( actSpecs.get(0)).getId());
            attrs.put("pmLast", ( actSpecs.get(nActs - 1)).getId());
        }

        String sRuleDn = "CN=" + sRuleId + "," + sRuleContainerDN;
        try {
            ctx.bind(sRuleDn, null, attrs);
        } catch (Exception e) {
            e.printStackTrace();
            return "Unable to create AD Rule object!";
        }
        traceTitle("RULE id = " + ruleSpec.getId());
        traceLine("  event id = " + patSpec.getId());

        for (int vindex = 0; vindex < actSpecs.size(); vindex++) {
            ActionSpec actSpec =  actSpecs.get(vindex);
            mods[0] = new ModificationItem(DirContext.ADD_ATTRIBUTE,
                    new BasicAttribute("pmAction", actSpec.getId()));
            try {
                ctx.modifyAttributes(sRuleDn, mods);
            } catch (Exception e) {
                e.printStackTrace();
                return "Unable to add action id to the rule object!";
            }
            traceLine("  action id = " + actSpec.getId());
        }
        return null;

    }

    private String checkRuleSemantics(RuleSpec ruleSpec) {
        PatternSpec patSpec = ruleSpec.getPattern();
        List<ActionSpec> actSpecs = ruleSpec.getActions();
        String result = null;

        // Check user specs in the event pattern. Note that the user spec
        // could in fact be a session spec or a process spec.
        Set<UserSpec> hs = patSpec.getUserSpecs();
        Iterator<UserSpec> hsiter;
        hsiter = hs.iterator();
        while (hsiter.hasNext()) {
            UserSpec spec = hsiter.next();
            String sType = spec.getType();
            if (sType.equalsIgnoreCase(PM_NODE_AUATTR)) {
                sType = PM_NODE_UATTR;
            }
            String sName = spec.getName();
            String sId = spec.getId();
            if (sId == null) {
                if (sName == null) {
                    return "The user spec has both name and id null!";
                }
                sId = getEntityId(sName, sType);
                if (sId == null) {
                    return "No entity " + sName + " of type " + sType;
                }
                spec.setId(sId);
            } else {
                if (sName == null) {
                    sName = getEntityName(sId, sType);
                    if (sName == null) {
                        return "No entity with id " + sId + " of type " + sType;
                    }
                }
                spec.setName(sName);
            }
        }

        // Check policy class specs in the event pattern:
        Set<PcSpec> pcSpec = patSpec.getPcSpecs();
        Iterator<PcSpec> pcIterator = pcSpec.iterator();
        while (pcIterator.hasNext()) {
            PcSpec spec = pcIterator.next();
            String sType = spec.getType();
            String sName = spec.getName();
            String sId = getEntityId(sName, sType);
            if (sId == null) {
                return ("No PM policy class \"" + sName + "\"!");
            }
            spec.setId(sId);
        }

        // Check event/op specs in the event pattern:
        Set<OpSpec> opSet = patSpec.getOpSpecs();
        Iterator<OpSpec> opIterator = opSet.iterator();
        while (opIterator.hasNext()) {
            OpSpec spec = opIterator.next();
            String sName = spec.getName();
            System.out.println("Op name = " + sName);
            if (!isEvent(sName)) {
                return ("No PM event \"" + sName + "\"!");
            }
        }

        // Check object specs in the event pattern:
        Set<ObjSpec> objSet = patSpec.getObjSpecs();
        Iterator<ObjSpec> objIterator = objSet.iterator();
        while (opIterator.hasNext()) {
            ObjSpec spec = objIterator.next();
            String sName = spec.getName();
            String sId = null;

            // sType can be: PM_OBJ. Change the type to object attribute
            // and check that the object really exists.
            spec.setType(PM_NODE_OATTR);
            sId = getEntityId(sName, PM_NODE_OATTR);

            // When the target object is the object just created and written,
            // the object name is unknown at compile time, so we don't signal
            // an error now. We just let the id be null.

            // if (sId == null || !hasAssocObj(sId)) return "No object \"" +
            // sName + "\"!";

            spec.setId(sId);
        }

        // Check container specs in the event pattern:
        Set<ContSpec> contSpecs = patSpec.getContSpecs();
        Iterator<ContSpec> contIterator = contSpecs.iterator();
        while (contIterator.hasNext()) {
            ContSpec spec = contIterator.next();
            System.out.println("Container before: \n" + spec);
            String sName = spec.getName();
            String sType = spec.getType();
            String sId = null;

            // sType can be: PM_OBJ, PM_NODE_OATTR, PM_RECORD, or PM_OBJ_CLASS.
            // Instead of
            // objects use the associated object attributes.
            // For records (containers with a small addition - a template plus
            // other
            // few things), the name can be * (for "any record").
            if (sType.equalsIgnoreCase(PM_OBJ)) {
                sType = PM_NODE_OATTR;
                spec.setType(PM_NODE_OATTR);
            } else if (sType.equalsIgnoreCase(PM_RECORD)) {
                sType = PM_NODE_OATTR;
            }
            // getIdOfEntityWithNameAndType(*, t) should return * (any).
            sId = getEntityId(sName, sType);
            if (sId == null) {
                return "No object or object attribute or class \"" + sName
                        + "\"!";
            }
            spec.setId(sId);
            System.out.println("Container After: \n" + spec);
        }

        // Check actions in the rule.
        for (int vindex = 0; vindex < actSpecs.size(); vindex++) {
            ActionSpec actSpec = actSpecs.get(vindex);

            // Check the action's condition.
            result = checkCondSemantics(actSpec);
            if (result != null) {
                return result;
            }

            String type = actSpec.getType();
            if (type.startsWith(RuleScanner.PM_VALUE_ASSIGN)) {
                result = checkAssignSemantics(actSpec);
                if (result != null) {
                    return result;
                }
            } else if (type.startsWith(RuleScanner.PM_VALUE_GRANT)) {
                result = checkGrantSemantics(actSpec);
                if (result != null) {
                    return result;
                }
            } else if (type.startsWith(RuleScanner.PM_VALUE_CREATE)) {
                result = checkCreateSemantics(actSpec);
                if (result != null) {
                    return result;
                }
            } else if (type.startsWith(RuleScanner.PM_VALUE_DENY)) {
                result = checkDenySemantics(actSpec);
                if (result != null) {
                    return result;
                }
            } else if (type.startsWith(RuleScanner.PM_VALUE_DELETE + " "
                    + RuleScanner.PM_VALUE_ASSIGNMENT)) {
                result = checkDeassignSemantics(actSpec);
                if (result != null) {
                    return result;
                }
            } else if (type.startsWith(RuleScanner.PM_VALUE_DELETE + " "
                    + RuleScanner.PM_VALUE_DENY)) {
                result = checkDeleteDenySemantics(actSpec);
                if (result != null) {
                    return result;
                }
            }
        }

        return null;
    }

    private String checkCondSemantics(ActionSpec actSpec) {
        CondSpec condSpec = actSpec.getCondSpec();
        System.out.println("Checking condition's semantics");
        if (condSpec == null) {
            return null;
        }
        String sType = condSpec.getType();
        System.out.println("Condition of type " + sType);
        if (!sType.equalsIgnoreCase(RuleScanner.PM_VALUE_EXISTS)) {
            return "Condition type is not \"" + RuleScanner.PM_VALUE_EXISTS
                    + "\"!";
        }
        Set<List<OpndSpec>> opnds = condSpec.getOpnds1();
        String result = null;
        Iterator<List<OpndSpec>> hsiter = opnds.iterator();
        while (hsiter.hasNext()) {
            List<OpndSpec> opndVec = hsiter.next();
            if (!opndVec.isEmpty()) {
                result = checkOpndSemantics(opndVec, 0, false);
                if (result != null) {
                    return result;
                }
            }
        }
        return null;
    }

    private String checkDeassignSemantics(ActionSpec actSpec) {
        Set<List<OpndSpec>> opnds1 = actSpec.getOpnds1();
        Set<List<OpndSpec>> opnds2 = actSpec.getOpnds2();
        String result = null;

        Iterator<List<OpndSpec>> hsiter = opnds1.iterator();
        while (hsiter.hasNext()) {
            List<OpndSpec> opndVec = hsiter.next();
            if (!opndVec.isEmpty()) {
                result = checkOpndSemantics(opndVec, 0, true);
                if (result != null) {
                    return result;
                }
            }
        }

        hsiter = opnds2.iterator();
        while (hsiter.hasNext()) {
            List<OpndSpec> opndVec = hsiter.next();
            if (!opndVec.isEmpty()) {
                result = checkOpndSemantics(opndVec, 0, true);
                if (result != null) {
                    return result;
                }
            }
        }

        return null;
    }

    private String checkAssignSemantics(ActionSpec actSpec) {
        Set<List<OpndSpec>> opnds1 = actSpec.getOpnds1();
        Set<List<OpndSpec>> opnds2 = actSpec.getOpnds2();
        String result = null;

        Iterator<List<OpndSpec>> hsiter = opnds1.iterator();
        while (hsiter.hasNext()) {
            List<OpndSpec> opndVec = hsiter.next();
            if (!opndVec.isEmpty()) {
                result = checkOpndSemantics(opndVec, 0, true);
                if (result != null) {
                    return result;
                }
            }
        }

        Iterator<List<OpndSpec>> opnds2Iterator = opnds2.iterator();
        while (opnds2Iterator.hasNext()) {
            List<OpndSpec> opndVec = opnds2Iterator.next();
            if (!opndVec.isEmpty()) {
                result = checkOpndSemantics(opndVec, 0, true);
                if (result != null) {
                    return result;
                }
            }
        }

        return null;
    }

    // Check the semantics of the operand contained in a vector.
    // The operand is a PM entity name or function call and is stored as a tree
    // in a vector. First item (0) is the root of the tree. Each item points
    // to its children and to its parent. A simple name does not have children.
    // A function call has its arguments as children. Each item is of class
    // OpndSpec. A side effect of the semantic checks is setting the ids of
    // existing PM entities.
    // The arguments are: the vector containing the operand, the index
    // of the component to be first checked, and a boolean that indicates
    // whether to check the existence of a PM entity or not.
    private String checkOpndSemantics(List<OpndSpec> opndVec, int index,
                                      boolean checkExist) {
        String result = null;
        OpndSpec os = opndVec.get(index);

        // Operand is a PM entity (process, session, user, uattr, object, oattr,
        // policy, base, opset, class).
        if (!os.isFunction()) {
            String sName = os.getOrigName();
            String sType = os.getType();
            String sOrigId = null;
            if (!checkExist) {
                RandomGUID myGUID = new RandomGUID();
                os.setOrigId(myGUID.toStringNoDashes());
                return null;
            }
            if (sType.equalsIgnoreCase(PM_SESSION)) {
                // Look for the operand as a session.
                sOrigId = getEntityId(sName, PM_SESSION);
                if (sOrigId == null) {
                    return "No PM entity \"" + sName + "\" of type \"" + sType
                            + "\"";
                }
            } else if (sType.equalsIgnoreCase(PM_PROCESS)) {
                // Look for the operand as a process.
                // The process name and id are identical.
                sOrigId = sName;
            } else if (sType.equalsIgnoreCase(PM_OBJ)) {
                // Look for the operand as an object attribute but associated to
                // an object.
                sOrigId = getEntityId(sName, PM_NODE_OATTR);
                if (sOrigId == null) {
                    return "No PM entity \"" + sName + "\" of type \"" + sType
                            + "\"";
                }
                if (!hasAssocObj(sOrigId)) {
                    return "No PM entity \"" + sName + "\" of type \"" + sType
                            + "\"";
                }
            } else if (sType.equalsIgnoreCase(PM_UNKNOWN)) {
                RandomGUID myGUID = new RandomGUID();
                sOrigId = myGUID.toStringNoDashes();
            } else if (sType.equalsIgnoreCase(PM_NODE_CONN)) {
                sOrigId = getEntityId(PM_CONNECTOR_NAME, sType);
                if (sOrigId == null) {
                    return "No PM entity \"" + PM_CONNECTOR_NAME
                            + "\" of type \"" + sType + "\"";
                }
            } else {
                sOrigId = getEntityId(sName, sType);
                if (sOrigId == null) {
                    return "No PM entity \"" + sName + "\" of type \"" + sType
                            + "\"";
                }
            }
            os.setOrigId(sOrigId);
            return null;
        }

        // Operand is a function.
        String sFunName = os.getOrigName();
        // Find out whether the function exists.
        if (!evrFunctionExists(sFunName)) {
            return "No EVER function \"" + sFunName + "\"";
        }
        os.setOrigId("F");

        // Check the number of arguments against the number of parameters. Note
        // that
        // the number of arguments may be larger than the number of parameters.
        List<Integer> children = os.getChildren();
        result = checkNumberOfArgs(sFunName, children.size());
        if (result != null) {
            return result;
        }

        // For each function parameter, check the corresponding argument type
        // against the
        // parameter type. Some arguments may not have corresponding parameters.
        // We don't
        // check those arguments.
        for (int j = 0; j < children.size(); j++) {
            int child = children.get(j).intValue();
            result = checkOpndSemantics(opndVec, child, checkExist);
            if (result != null) {
                return result;
            }

            // Check whether the argument type matches the function parameter
            // type.
            result = checkFunctionArg(sFunName, j,
                    opndVec.get(child));
            if (result != null) {
                return result;
            }
        }

        // Check the function type.
        String sFunType = os.getType();
        result = checkFunctionType(sFunName, sFunType);
        if (result != null) {
            return result;
        }

        // Anything else???

        return result;
    }

    // First argument is the function name.
    // Second argument is the number of actual arguments.
    // One can find the number of formal parameters using the function name.
    // Originally, we wanted the number of formal parameters to be the same
    // as the number of actual arguments, but later we thought about allowing
    // functions with an unknown number of arguments, so we allow
    // the number of actual arguments to be larger than the number
    // of formal parameters, and we check the types only for the common ones.
    // Returns null, or err message: number of arguments mismatch.
    private String checkNumberOfArgs(String sFunName, int nArgCount) {
        int nParamCount = 0;

        try {
            String sTypes = getEvrFunctionParamTypes(sFunName);
            if (sTypes == null) {
                nParamCount = 0;
            } else {
                String[] pieces = sTypes.split(",");
                nParamCount = pieces.length;
            }
            // if (nArgCount != nParamCount) return
            // "Argument number mismatch for function " + sFunName;
            if (nArgCount < nParamCount) {
                return "Too few arguments for function " + sFunName;
            }
            return null;
        } catch (Exception e) {
            if (debugFlag) {
                e.printStackTrace();
            }
            return "Exception when matching the number of arguments for function "
                    + sFunName;
        }
    }

    // Tries to match the nth argument and parameter types. The argument type
    // probably is PM_UNKNOWN.
    // If the parameter type is PM_UNKNOWN, do not check further.
    // Otherwise, check whether an entity of the param type with the name of
    // the argument exists.
    // Returns null if OK, or err message if argument type mismatch.
    private String checkFunctionArg(String sFunName, int argIndex, OpndSpec arg) {
        try {
            String sTypes = getEvrFunctionParamTypes(sFunName);
            // If the function has no parameters, we still allow arguments.
            if (sTypes == null) {
                return null;
            }

            // Get the parameter count.
            String[] pieces = sTypes.split(",");
            int nParamCount = pieces.length;

            // We don't check arguments that do not have corresponding
            // parameters.
            if (argIndex >= nParamCount) {
                return null;
            }

            // Get the param type.
            String sParamType = pieces[argIndex];

            // If the param type is unknown, ok.
            if (sParamType.equalsIgnoreCase(PM_UNKNOWN)) {
                return null;
            }

            // The param type is known. First get the argument name.
            String sArgName = arg.getOrigName();

            // If the argument is a function call, check this function type
            // against
            // the parameter type.
            if (arg.isFunction()) {
                if (!evrFunctionExists(sArgName)) {
                    return "No EVER function \"" + sArgName + "\"";
                }
                return checkFunctionType(sArgName, sParamType);
            }

            // Otherwise, check that an entity of the parameter type with the
            // name
            // of the argument exists.
            String sOrigId = getEntityId(sArgName, sParamType);
            if (sOrigId == null) {
                return "No entity " + sArgName + " of type " + sParamType
                        + " (argument " + argIndex + " of function " + sFunName
                        + ")";
            }
            arg.setOrigId(sOrigId);
            arg.setType(sParamType);
            return null;
        } catch (Exception e) {
            if (debugFlag) {
                e.printStackTrace();
            }
            return "Exception when matching the number of arguments of function "
                    + sFunName;
        }
    }

    // Tries to match the declared and required function type.
    // The required type may be unknown (no check), or specified explicitly
    // in the EVER script, or is the type of another function's parameter,
    // like in f1(f2(...)), where sFunId identifies f2, and sActType
    // is the type of the first argument of f1.
    // Returns null, or err message: function type mismatch.
    private String checkFunctionType(String sFunName, String sReqType) {
        if (sReqType.equalsIgnoreCase(PM_UNKNOWN)) {
            return null;
        }
        try {
            String sDclType = getEvrFunctionType(sFunName);
            if (sDclType == null) {
                return "No function or no type for function " + sFunName;
            }

            if (sDclType.equalsIgnoreCase(sReqType)) {
                return null;
            }
            if (sDclType.equalsIgnoreCase(PM_NODE_OATTR)
                    && sReqType.equalsIgnoreCase(PM_OBJ)) {
                return null;
            }
            return "Type mismatch for function " + sFunName;
        } catch (Exception e) {
            if (debugFlag) {
                e.printStackTrace();
            }
            return "Exception when matching the type of function " + sFunName;
        }
    }

    private String getEvrFunctionType(String sName) {
        for (int i = 0; i < evrFunctions.length; i++) {
            if (sName.equalsIgnoreCase(evrFunctions[i].getName())) {
                return evrFunctions[i].getType();
            }
        }
        return null;
    }

    private String getEvrFunctionParamTypes(String sName) {
        for (int i = 0; i < evrFunctions.length; i++) {
            if (sName.equalsIgnoreCase(evrFunctions[i].getName())) {
                return evrFunctions[i].getParamTypes();
            }
        }
        return null;
    }

    private boolean evrFunctionExists(String sName) {
        for (int i = 0; i < evrFunctions.length; i++) {
            if (sName.equalsIgnoreCase(evrFunctions[i].getName())) {
                return true;
            }
        }
        return false;
    }

    private String checkGrantSemantics(ActionSpec actSpec) {
        Set<List<OpndSpec>> opnds1 = actSpec.getOpnds1();
        Set<List<OpndSpec>> opnds2 = actSpec.getOpnds2();
        Set<List<OpndSpec>> opnds3 = actSpec.getOpnds3();
        String result = null;

        // Opnds1 is a HashSet; each item is a vector of OpndsSpecs
        // that describes a user attribute.
        Iterator<List<OpndSpec>> hsiter = opnds1.iterator();
        while (hsiter.hasNext()) {
            List<OpndSpec> opndVec = hsiter.next();
            if (!opndVec.isEmpty()) {
                result = checkOpndSemantics(opndVec, 0, true);
                if (result != null) {
                    return result;
                }
            }
        }

        hsiter = opnds2.iterator();
        while (hsiter.hasNext()) {
            List<OpndSpec> opndVec = hsiter.next();
            Iterator<OpndSpec> hsiter2 = opndVec.iterator();
            while (hsiter2.hasNext()) {
                OpndSpec os = hsiter2.next();
                if (!isOperation(os.getOrigName())) {
                    return "\"" + os.getOrigName() + "\" is not an operation";
                }
            }
        }

        // Opnds3 is a HashSet; each item is a vector of OpndsSpecs
        // that describes an object (attribute).
        hsiter = opnds3.iterator();
        while (hsiter.hasNext()) {
            List<OpndSpec> opndVec = hsiter.next();
            if (!opndVec.isEmpty()) {
                result = checkOpndSemantics(opndVec, 0, true);
                if (result != null) {
                    return result;
                }
            }
        }

        return null;
    }

    // Opnds1 = what to create, opnds2 = representing what,
    // opnds3 = what properties, opnds4 = where to create.
    private String checkCreateSemantics(ActionSpec actSpec) {
        Set<List<OpndSpec>> opnds1 = actSpec.getOpnds1();
        Set<List<OpndSpec>> opnds2 = actSpec.getOpnds2();
        Set<List<OpndSpec>> opnds3 = actSpec.getOpnds3();
        Set<List<OpndSpec>> opnds4 = actSpec.getOpnds4();
        String result = null;

        // Opnds1 is a HashSet; each item (there should be exactly one item)
        // is a vector of OpndsSpec that describes the entity to be created.
        Iterator<List<OpndSpec>> hsiter = opnds1.iterator();
        while (hsiter.hasNext()) {
            List<OpndSpec> opndVec = hsiter.next();
            if (!opndVec.isEmpty()) {
                result = checkOpndSemantics(opndVec, 0, false);
                if (result != null) {
                    return result;
                }
            }
        }

        // Opnds2 is a HashSet; each item (there should be exactly one item)
        // is a vector of OpndsSpec that describes the entity represented
        // by the entity to be created. In Addition, the entity to be created
        // must
        // be an object.
        hsiter = opnds2.iterator();
        while (hsiter.hasNext()) {
            List<OpndSpec> opndVec = hsiter.next();
            if (!opndVec.isEmpty()) {
                result = checkOpndSemantics(opndVec, 0, true);
                if (result != null) {
                    return result;
                }
            }
        }

        // Opnds3 is a HashSet; each item (there may be more than one or none)
        // is a vector of OpndsSpec that defines a property of the entity to be
        // created.
        hsiter = opnds3.iterator();
        while (hsiter.hasNext()) {
            List<OpndSpec> opndVec = hsiter.next();
            if (!opndVec.isEmpty()) {
                result = checkOpndSemantics(opndVec, 0, false);
                if (result != null) {
                    return result;
                }
            }
        }

        // Opnds4 is a HashSet; each item (there should be exactly one item)
        // is a vector of OpndsSpec that defines the container where the new
        // entity is to be created.
        hsiter = opnds4.iterator();
        while (hsiter.hasNext()) {
            List<OpndSpec> opndVec = hsiter.next();
            if (!opndVec.isEmpty()) {
                result = checkOpndSemantics(opndVec, 0, true);
                if (result != null) {
                    return result;
                }
            }
        }

        return null;
    }

    private String checkDenySemantics(ActionSpec actSpec) {
        Set<List<OpndSpec>> opnds1 = actSpec.getOpnds1();
        Set<List<OpndSpec>> opnds2 = actSpec.getOpnds2();
        Set<List<OpndSpec>> opnds3 = actSpec.getOpnds3();
        String result = null;

        // Opnds1 is a HashSet; each item is a vector of OpndsSpecs
        // that describes a user, user attribute, session, or process.
        Iterator<List<OpndSpec>> hsiter = opnds1.iterator();
        while (hsiter.hasNext()) {
            List<OpndSpec> opndVec = hsiter.next();
            if (!opndVec.isEmpty()) {
                result = checkOpndSemantics(opndVec, 0, true);
                if (result != null) {
                    return result;
                }
            }
        }

        // Opnds2 is a HashSet; each item is a OpndsSpec containing
        // exactly one granted operation.
        hsiter = opnds2.iterator();
        while (hsiter.hasNext()) {
            List<OpndSpec> opndSpecList = hsiter.next();

            Iterator<OpndSpec> hister2 = opndSpecList.iterator();
            while (hister2.hasNext()) {
                OpndSpec os = hister2.next();

                if (!isOperation(os.getOrigName())) {
                    return "\"" + os.getOrigName() + "\" is not an operation";
                }
            }

        }

        // Opnds3 is a HashSet; each item is a vector of OpndsSpecs
        // that describes an object attribute.
        hsiter = opnds3.iterator();
        while (hsiter.hasNext()) {
            List<OpndSpec> opndVec = hsiter.next();
            if (!opndVec.isEmpty()) {
                result = checkOpndSemantics(opndVec, 0, true);
                if (result != null) {
                    return result;
                }
            }
        }
        return null;
    }

    private String checkDeleteDenySemantics(ActionSpec actSpec) {
        Set<List<OpndSpec>> opnds1 = actSpec.getOpnds1();
        Set<List<OpndSpec>> opnds2 = actSpec.getOpnds2();
        Set<List<OpndSpec>> opnds3 = actSpec.getOpnds3();
        String result = null;

        // Opnds1 is a HashSet; each item is a vector of OpndsSpecs
        // that describes a user or user attribute.
        Iterator<List<OpndSpec>> hsiter = opnds1.iterator();
        while (hsiter.hasNext()) {
            List<OpndSpec> opndVec = hsiter.next();
            if (!opndVec.isEmpty()) {
                result = checkOpndSemantics(opndVec, 0, true);
                if (result != null) {
                    return result;
                }
            }
        }

        hsiter = opnds2.iterator();
        while (hsiter.hasNext()) {
            List<OpndSpec> opndSpecList = hsiter.next();
            Iterator<OpndSpec> hister2 = opndSpecList.iterator();
            while (hister2.hasNext()) {
                OpndSpec os = hister2.next();
                if (!isOperation(os.getOrigName())) {
                    return "\"" + os.getOrigName() + "\" is not an operation";
                }
            }
        }

        // Opnds3 is a HashSet; each item is a vector of OpndsSpecs
        // that describes an object attribute.
        hsiter = opnds3.iterator();
        while (hsiter.hasNext()) {
            List<OpndSpec> opndVec = hsiter.next();
            if (!opndVec.isEmpty()) {
                result = checkOpndSemantics(opndVec, 0, true);
                if (result != null) {
                    return result;
                }
            }
        }
        return null;
    }

    private String createActionRecord(ActionSpec actSpec, String sPrevActId,
                                      int nActRank) {
        traceTitle("Action " + actSpec.getType() + ", id = " + actSpec.getId());
        Attributes attrs = new BasicAttributes(true);
        String sCrtActId = actSpec.getId();
        attrs.put("objectClass", sActionClass);
        attrs.put("pmId", sCrtActId);
        attrs.put("pmType", actSpec.getType());
        attrs.put("pmIsIntrasession", (actSpec.isIntrasession() ? "TRUE"
                : "FALSE"));
        attrs.put("pmIsIntersection", (actSpec.isIntersection() ? "TRUE"
                : "FALSE"));
        attrs.put("pmRank", String.valueOf(nActRank));

        // If there is a previous action record, set the back link to it.
        if (sPrevActId != null) {
            attrs.put("pmPrev", sPrevActId);
        }
        try {
            ctx.bind("CN=" + sCrtActId + "," + sRuleContainerDN, null, attrs);
        } catch (Exception e) {
            e.printStackTrace();
            return "Unable to create AD Action object!";
        }

        // If there is a previous action record, set the forward link to crt
        // record in it.
        if (sPrevActId != null) {
            ModificationItem[] mods = new ModificationItem[1];
            mods[0] = new ModificationItem(DirContext.ADD_ATTRIBUTE,
                    new BasicAttribute("pmNext", sCrtActId));
            try {
                ctx.modifyAttributes("CN=" + sPrevActId + ","
                        + sRuleContainerDN, mods);
            } catch (Exception e) {
                e.printStackTrace();
                return "Unable to set the forward link in an action object!";
            }
        }
        return null;
    }

    private String writeActionCondRecord(ActionSpec actSpec) {
        ModificationItem[] mods = new ModificationItem[1];
        Iterator<List<OpndSpec>> hsiter;
        List<OpndSpec> opndVec;

        CondSpec condSpec = actSpec.getCondSpec();
        if (condSpec == null) {
            return null;
        }

        String sCondId = condSpec.getId();
        traceTitle("Condition " + condSpec.getType() + ", id = " + sCondId);

        // Insert the link to the condition in the action record.
        String sActionDn = "CN=" + actSpec.getId() + "," + sRuleContainerDN;
        mods[0] = new ModificationItem(DirContext.ADD_ATTRIBUTE,
                new BasicAttribute("pmCondition", sCondId));
        try {
            ctx.modifyAttributes(sActionDn, mods);
        } catch (Exception e) {
            e.printStackTrace();
            return "Unable to add a condition to the action object!";
        }

        // Build the condition AD object.
        Attributes attrs = new BasicAttributes(true);
        String sCondDn = "CN=" + sCondId + "," + sRuleContainerDN;
        attrs.put("objectClass", sConditionClass);
        attrs.put("pmId", sCondId);
        attrs.put("pmType", condSpec.getType());
        attrs.put("pmIsNegated", condSpec.isNegated() ? "TRUE" : "FALSE");

        try {
            ctx.bind(sCondDn, null, attrs);
        } catch (Exception e) {
            e.printStackTrace();
            return "Unable to create AD Condition object!";
        }

        // Insert the links to operands into the condition object.
        Set<List<OpndSpec>> opnds1 = condSpec.getOpnds1();
        hsiter = opnds1.iterator();
        while (hsiter.hasNext()) {
            opndVec = hsiter.next();
            if (opndVec.size() > 0) {
                String sOpndId = opndVec.get(0).getId();
                mods[0] = new ModificationItem(DirContext.ADD_ATTRIBUTE,
                        new BasicAttribute("pmOpnd1", sOpndId));
                try {
                    ctx.modifyAttributes(sCondDn, mods);
                } catch (Exception e) {
                    e.printStackTrace();
                    return "Unable to add an operand 1 id to the condition object!";
                }
                traceLine("  opnd1 id = " + sOpndId);
            }
        }

        // Write the operand AD objects.
        traceTitle("  First Operands:");
        String result = writeOpndRecords(opnds1);
        if (result != null) {
            return result;
        }

        return null;
    }

    private String writeDeleteRuleActionRecord(ActionSpec actSpec) {
        ModificationItem[] mods = new ModificationItem[1];
        Iterator<List<OpndSpec>> hsiter;

        String sActionDn = "CN=" + actSpec.getId() + "," + sRuleContainerDN;

        Set<List<OpndSpec>> opnds1 = actSpec.getOpnds1();

        hsiter = opnds1.iterator();
        while (hsiter.hasNext()) {
            String sOpndId = hsiter.next().get(0).getId();
            mods[0] = new ModificationItem(DirContext.ADD_ATTRIBUTE,
                    new BasicAttribute("pmOpnd1", sOpndId));
            try {
                ctx.modifyAttributes(sActionDn, mods);
            } catch (Exception e) {
                e.printStackTrace();
                return "Unable to add an operand 1 id to the action object!";
            }
            traceLine("  opnd1 id = " + sOpndId);
        }

        traceTitle("  First Operands:");
        String result = writeOpndRecords(opnds1);
        if (result != null) {
            return result;
        }
        return null;
    }

    private String writeDeleteDenyActionRecord(ActionSpec actSpec) {
        ModificationItem[] mods = new ModificationItem[1];
        Iterator<List<OpndSpec>> hsiter;
        List<OpndSpec> opndVec;

        String sActionDn = "CN=" + actSpec.getId() + "," + sRuleContainerDN;

        Set<List<OpndSpec>> opnds1 = actSpec.getOpnds1();
        Set<List<OpndSpec>> opnds2 = actSpec.getOpnds2();
        Set<List<OpndSpec>> opnds3 = actSpec.getOpnds3();

        hsiter = opnds1.iterator();
        while (hsiter.hasNext()) {
            opndVec = hsiter.next();
            if (opndVec.size() > 0) {
                String sOpndId = opndVec.get(0).getId();
                mods[0] = new ModificationItem(DirContext.ADD_ATTRIBUTE,
                        new BasicAttribute("pmOpnd1", sOpndId));
                try {
                    ctx.modifyAttributes(sActionDn, mods);
                } catch (Exception e) {
                    e.printStackTrace();
                    return "Unable to add an operand 1 id to the action object!";
                }
                traceLine("  opnd1 id = " + sOpndId);
            }
        }

        hsiter = opnds2.iterator();
        while (hsiter.hasNext()) {
            String sOpndId = hsiter.next().get(0).getId();
            mods[0] = new ModificationItem(DirContext.ADD_ATTRIBUTE,
                    new BasicAttribute("pmOpnd2", sOpndId));
            try {
                ctx.modifyAttributes(sActionDn, mods);
            } catch (Exception e) {
                e.printStackTrace();
                return "Unable to add an operand 2 id to the action object!";
            }
            traceLine("  opnd2 id = " + sOpndId);
        }

        hsiter = opnds3.iterator();
        while (hsiter.hasNext()) {
            opndVec = hsiter.next();
            if (opndVec.size() > 0) {
                String sOpndId = opndVec.get(0).getId();
                mods[0] = new ModificationItem(DirContext.ADD_ATTRIBUTE,
                        new BasicAttribute("pmOpnd3", sOpndId));
                try {
                    ctx.modifyAttributes(sActionDn, mods);
                } catch (Exception e) {
                    e.printStackTrace();
                    return "Unable to add an operand 3 id to the action object!";
                }
                traceLine("  opnd3 id = " + sOpndId);
            }
        }

        traceTitle("  First Operands:");
        String result = writeOpndRecords(opnds1);
        if (result != null) {
            return result;
        }

        traceTitle("  Second Operands:");
        result = writeOpndRecords(opnds2);
        if (result != null) {
            return result;
        }

        traceTitle("  Third Operands:");
        result = writeOpndRecords(opnds3);
        if (result != null) {
            return result;
        }
        return null;
    }

    private String writeDeassignActionRecord(ActionSpec actSpec) {
        ModificationItem[] mods = new ModificationItem[1];
        Iterator<List<OpndSpec>> hsiter;
        List<OpndSpec> opndVec;

        String sActionDn = "CN=" + actSpec.getId() + "," + sRuleContainerDN;

        // Write the operands to the active directory.
        Set<List<OpndSpec>> opnds1 = actSpec.getOpnds1();
        Set<List<OpndSpec>> opnds2 = actSpec.getOpnds2();

        hsiter = opnds1.iterator();
        while (hsiter.hasNext()) {
            opndVec = hsiter.next();
            if (opndVec.size() > 0) {
                String sOpndId = opndVec.get(0).getId();
                mods[0] = new ModificationItem(DirContext.ADD_ATTRIBUTE,
                        new BasicAttribute("pmOpnd1", sOpndId));
                try {
                    ctx.modifyAttributes(sActionDn, mods);
                } catch (Exception e) {
                    e.printStackTrace();
                    return "Unable to add an operand 1 id to the action object!";
                }
                traceLine("  opnd1 id = " + sOpndId);
            }
        }

        hsiter = opnds2.iterator();
        while (hsiter.hasNext()) {
            opndVec = hsiter.next();
            if (opndVec.size() > 0) {
                String sOpndId = opndVec.get(0).getId();
                mods[0] = new ModificationItem(DirContext.ADD_ATTRIBUTE,
                        new BasicAttribute("pmOpnd2", sOpndId));
                try {
                    ctx.modifyAttributes(sActionDn, mods);
                } catch (Exception e) {
                    e.printStackTrace();
                    return "Unable to add an operand 2 id to the action object!";
                }
                traceLine("  opnd2 id = " + sOpndId);
            }
        }

        traceTitle("  First Operands:");
        String result = writeOpndRecords(opnds1);
        if (result != null) {
            return result;
        }

        traceTitle("  Second Operands:");
        result = writeOpndRecords(opnds2);
        if (result != null) {
            return result;
        }
        return null;
    }

    private String writeAssignActionRecord(ActionSpec actSpec) {
        ModificationItem[] mods = new ModificationItem[1];
        Iterator<List<OpndSpec>> hsiter;
        List<OpndSpec> opndVec;

        String sActionDn = "CN=" + actSpec.getId() + "," + sRuleContainerDN;

        // Write the operands to the active directory.
        Set<List<OpndSpec>> opnds1 = actSpec.getOpnds1();
        Set<List<OpndSpec>> opnds2 = actSpec.getOpnds2();

        hsiter = opnds1.iterator();
        while (hsiter.hasNext()) {
            opndVec = hsiter.next();
            if (opndVec.size() > 0) {
                String sOpndId = opndVec.get(0).getId();
                mods[0] = new ModificationItem(DirContext.ADD_ATTRIBUTE,
                        new BasicAttribute("pmOpnd1", sOpndId));
                try {
                    ctx.modifyAttributes(sActionDn, mods);
                } catch (Exception e) {
                    e.printStackTrace();
                    return "Unable to add an operand 1 id to the action object!";
                }
                traceLine("  opnd1 id = " + sOpndId);
            }
        }

        hsiter = opnds2.iterator();
        while (hsiter.hasNext()) {
            opndVec = hsiter.next();
            if (opndVec.size() > 0) {
                String sOpndId = opndVec.get(0).getId();
                mods[0] = new ModificationItem(DirContext.ADD_ATTRIBUTE,
                        new BasicAttribute("pmOpnd2", sOpndId));
                try {
                    ctx.modifyAttributes(sActionDn, mods);
                } catch (Exception e) {
                    e.printStackTrace();
                    return "Unable to add an operand 2 id to the action object!";
                }
                traceLine("  opnd2 id = " + sOpndId);
            }
        }

        traceTitle("  First Operands:");
        String result = writeOpndRecords(opnds1);
        if (result != null) {
            return result;
        }

        traceTitle("  Second Operands:");
        result = writeOpndRecords(opnds2);
        if (result != null) {
            return result;
        }
        return null;
    }

    private String writeCreateActionRecord(ActionSpec actSpec) {
        ModificationItem[] mods = new ModificationItem[1];
        Iterator<List<OpndSpec>> hsiter;
        List<OpndSpec> opndVec;

        String sActionDn = "CN=" + actSpec.getId() + "," + sRuleContainerDN;

        Set<List<OpndSpec>> opnds1 = actSpec.getOpnds1();
        Set<List<OpndSpec>> opnds2 = actSpec.getOpnds2();
        Set<List<OpndSpec>> opnds3 = actSpec.getOpnds3();
        Set<List<OpndSpec>> opnds4 = actSpec.getOpnds4();

        // There should be only one opnd1, containing the entity to be created.
        hsiter = opnds1.iterator();
        while (hsiter.hasNext()) {
            opndVec = hsiter.next();
            if (opndVec.size() > 0) {
                String sOpndId = opndVec.get(0).getId();
                mods[0] = new ModificationItem(DirContext.ADD_ATTRIBUTE,
                        new BasicAttribute("pmOpnd1", sOpndId));
                try {
                    ctx.modifyAttributes(sActionDn, mods);
                } catch (Exception e) {
                    e.printStackTrace();
                    return "Unable to add an operand 1 id to the action object!";
                }
                traceLine("  opnd1 id = " + sOpndId);
            }
        }

        // There should be at most one opnd2, containing the entity represented
        // by the entity to be created.
        hsiter = opnds2.iterator();
        while (hsiter.hasNext()) {
            opndVec = hsiter.next();
            if (opndVec.size() > 0) {
                String sOpndId = opndVec.get(0).getId();
                mods[0] = new ModificationItem(DirContext.ADD_ATTRIBUTE,
                        new BasicAttribute("pmOpnd2", sOpndId));
                try {
                    ctx.modifyAttributes(sActionDn, mods);
                } catch (Exception e) {
                    e.printStackTrace();
                    return "Unable to add an operand 2 id to the action object!";
                }
                traceLine("  opnd2 id = " + sOpndId);
            }
        }

        // Opnd3 contain the properties of the entity to be created.
        hsiter = opnds3.iterator();
        while (hsiter.hasNext()) {
            opndVec = hsiter.next();
            if (opndVec.size() > 0) {
                String sOpndId = opndVec.get(0).getId();
                mods[0] = new ModificationItem(DirContext.ADD_ATTRIBUTE,
                        new BasicAttribute("pmOpnd3", sOpndId));
                try {
                    ctx.modifyAttributes(sActionDn, mods);
                } catch (Exception e) {
                    e.printStackTrace();
                    return "Unable to add an operand 3 id to the action object!";
                }
                traceLine("  opnd3 id = " + sOpndId);
            }
        }

        // There should be only one opnd4, containing the container where the
        // entity in opnd1 is to be created.
        hsiter = opnds4.iterator();
        while (hsiter.hasNext()) {
            opndVec = hsiter.next();
            if (opndVec.size() > 0) {
                String sOpndId = opndVec.get(0).getId();
                mods[0] = new ModificationItem(DirContext.ADD_ATTRIBUTE,
                        new BasicAttribute("pmOpnd4", sOpndId));
                try {
                    ctx.modifyAttributes(sActionDn, mods);
                } catch (Exception e) {
                    e.printStackTrace();
                    return "Unable to add an operand 4 id to the action object!";
                }
                traceLine("  opnd4 id = " + sOpndId);
            }
        }

        traceTitle("  First Operands:");
        String result = writeOpndRecords(opnds1);
        if (result != null) {
            return result;
        }

        traceTitle("  Second Operands:");
        result = writeOpndRecords(opnds2);
        if (result != null) {
            return result;
        }

        traceTitle("  Third Operands:");
        result = writeOpndRecords(opnds3);
        if (result != null) {
            return result;
        }

        traceTitle("  Fourth Operands:");
        result = writeOpndRecords(opnds4);
        if (result != null) {
            return result;
        }

        return null;
    }

    private String writeGrantActionRecord(ActionSpec actSpec) {
        ModificationItem[] mods = new ModificationItem[1];
        Iterator<List<OpndSpec>> hsiter;
        List<OpndSpec> opndVec;

        String sActionDn = "CN=" + actSpec.getId() + "," + sRuleContainerDN;

        Set<List<OpndSpec>> opnds1 = actSpec.getOpnds1();
        Set<List<OpndSpec>> opnds2 = actSpec.getOpnds2();
        Set<List<OpndSpec>> opnds3 = actSpec.getOpnds3();

        hsiter = opnds1.iterator();
        while (hsiter.hasNext()) {
            opndVec = hsiter.next();
            if (opndVec.size() > 0) {
                String sOpndId = opndVec.get(0).getId();
                mods[0] = new ModificationItem(DirContext.ADD_ATTRIBUTE,
                        new BasicAttribute("pmOpnd1", sOpndId));
                try {
                    ctx.modifyAttributes(sActionDn, mods);
                } catch (Exception e) {
                    e.printStackTrace();
                    return "Unable to add an operand 1 id to the action object!";
                }
                traceLine("  opnd1 id = " + sOpndId);
            }
        }

        hsiter = opnds2.iterator();
        while (hsiter.hasNext()) {
            String sOpndId = hsiter.next().get(0).getId();
            mods[0] = new ModificationItem(DirContext.ADD_ATTRIBUTE,
                    new BasicAttribute("pmOpnd2", sOpndId));
            try {
                ctx.modifyAttributes(sActionDn, mods);
            } catch (Exception e) {
                e.printStackTrace();
                return "Unable to add an operand 2 id to the action object!";
            }
            traceLine("  opnd2 id = " + sOpndId);
        }

        hsiter = opnds3.iterator();
        while (hsiter.hasNext()) {
            opndVec = hsiter.next();
            if (opndVec.size() > 0) {
                String sOpndId = opndVec.get(0).getId();
                mods[0] = new ModificationItem(DirContext.ADD_ATTRIBUTE,
                        new BasicAttribute("pmOpnd3", sOpndId));
                try {
                    ctx.modifyAttributes(sActionDn, mods);
                } catch (Exception e) {
                    e.printStackTrace();
                    return "Unable to add an operand 3 id to the action object!";
                }
                traceLine("  opnd3 id = " + sOpndId);
            }
        }

        traceTitle("  First Operands:");
        String result = writeOpndRecords(opnds1);
        if (result != null) {
            return result;
        }

        traceTitle("  Second Operands:");
        result = writeOpndRecords(opnds2);
        if (result != null) {
            return result;
        }

        traceTitle("  Third Operands:");
        result = writeOpndRecords(opnds3);
        if (result != null) {
            return result;
        }
        return null;
    }

    private String writeDenyActionRecord(ActionSpec actSpec) {
        ModificationItem[] mods = new ModificationItem[1];
        Iterator<List<OpndSpec>> hsiter;
        List<OpndSpec> opndVec;

        String sActionDn = "CN=" + actSpec.getId() + "," + sRuleContainerDN;

        Set<List<OpndSpec>> opnds1 = actSpec.getOpnds1();
        Set<List<OpndSpec>> opnds2 = actSpec.getOpnds2();
        Set<List<OpndSpec>> opnds3 = actSpec.getOpnds3();

        hsiter = opnds1.iterator();
        while (hsiter.hasNext()) {
            opndVec = hsiter.next();
            if (opndVec.size() > 0) {
                String sOpndId = opndVec.get(0).getId();
                mods[0] = new ModificationItem(DirContext.ADD_ATTRIBUTE,
                        new BasicAttribute("pmOpnd1", sOpndId));
                try {
                    ctx.modifyAttributes(sActionDn, mods);
                } catch (Exception e) {
                    e.printStackTrace();
                    return "Unable to add an operand 1 id to the action object!";
                }
                traceLine("  opnd1 id = " + sOpndId);
            }
        }

        hsiter = opnds2.iterator();
        while (hsiter.hasNext()) {
            String sOpndId = hsiter.next().get(0).getId();
            mods[0] = new ModificationItem(DirContext.ADD_ATTRIBUTE,
                    new BasicAttribute("pmOpnd2", sOpndId));
            try {
                ctx.modifyAttributes(sActionDn, mods);
            } catch (Exception e) {
                e.printStackTrace();
                return "Unable to add an operand 2 id to the action object!";
            }
            traceLine("  opnd2 id = " + sOpndId);
        }

        hsiter = opnds3.iterator();
        while (hsiter.hasNext()) {
            opndVec = hsiter.next();
            if (opndVec.size() > 0) {
                String sOpndId = opndVec.get(0).getId();
                mods[0] = new ModificationItem(DirContext.ADD_ATTRIBUTE,
                        new BasicAttribute("pmOpnd3", sOpndId));
                try {
                    ctx.modifyAttributes(sActionDn, mods);
                } catch (Exception e) {
                    e.printStackTrace();
                    return "Unable to add an operand 3 id to the action object!";
                }
                traceLine("  opnd3 id = " + sOpndId);
            }
        }

        traceTitle("  First Operands:");
        String result = writeOpndRecords(opnds1);
        if (result != null) {
            return result;
        }

        traceTitle("  Second Operands:");
        result = writeOpndRecords(opnds2);
        if (result != null) {
            return result;
        }

        traceTitle("  Third Operands:");
        result = writeOpndRecords(opnds3);
        if (result != null) {
            return result;
        }
        return null;
    }

    // The argument is a HashSet. Each item is an OpndSpec containing
    // exactly one simple operand (e.g., an operation for a grant action).
    private String writeSimpleOpndRecords(Set<List<OpndSpec>> opndsSet) {
        return writeOpndRecords(opndsSet, Boolean.TRUE);
        /*
        List<OpndSpec> opnds = opndsSet.iterator().next();
        Iterator<OpndSpec> hsiter = opnds.iterator();
        while (hsiter.hasNext()) {
            OpndSpec os = hsiter.next();

            Attributes attrs = new BasicAttributes(true);
            String sOpndId = os.getId();
            attrs.put("objectClass", sOperandClass);
            attrs.put("pmId", sOpndId);
            attrs.put("pmType", os.getType());
            attrs.put("pmIsFunction", (os.isFunction() ? "TRUE" : "FALSE"));
            attrs.put("pmIsSubgraph", (os.isSubgraph() ? "TRUE" : "FALSE"));
            attrs.put("pmIsComplement", (os.isComplement() ? "TRUE" : "FALSE"));
            attrs.put("pmOriginalName", os.getOrigName());
            String sOpndDn = "CN=" + sOpndId + "," + sRuleContainerDN;
            try {
                ctx.bind(sOpndDn, null, attrs);
            } catch (Exception e) {
                e.printStackTrace();
                return "Unable to create AD Operand " + os.getOrigName();
            }
            traceTitle("    Operand with id = " + os.getId());
            traceLine("      id       = " + sOpndId);
            traceLine("      type     = " + os.getType());
            traceLine("      origName = " + os.getOrigName());
            traceLine("      subgraph = " + os.isSubgraph());
            traceLine("      function = " + os.isFunction());
            traceLine("      compl    = " + os.isComplement());
        }
        return null;
         *
         */
    }

    private String writeOpndRecords(Set<List<OpndSpec>> opnds) {
        return writeOpndRecords(opnds, Boolean.FALSE);
    }

    private String writeOpndRecords(Set<List<OpndSpec>> opnds, Boolean simple) {
        Iterator<List<OpndSpec>> hsiter = opnds.iterator();
        while (hsiter.hasNext()) {
            List<OpndSpec> opndVec = hsiter.next();
            traceTitle("    Operand with id = "
                    + opndVec.get(0).getId());
            for (int i = 0; i < opndVec.size(); i++) {
                OpndSpec os = opndVec.get(i);
                String sOpndId = os.getId();
                StringBuilder sb = new StringBuilder();
                List<Integer> children = os.getChildren();
                assert (!simple || (simple && children.isEmpty()));
                for (int j = 0; j < children.size(); j++) {
                    int child = ((Integer) children.get(j)).intValue();
                    if (j > 0) {
                        sb.append(PM_ALT_FIELD_DELIM);
                    }
                    sb.append(opndVec.get(child).getId());
                }
                String sArgs = sb.toString();
                traceTitle("      Item " + i);
                traceLine("      id       = " + sOpndId);
                traceLine("      type     = " + os.getType());
                traceLine("      origName = " + os.getOrigName());
                traceLine("      function = " + os.isFunction());
                traceLine("      subgraph = " + os.isSubgraph());
                traceLine("      compl    = " + os.isComplement());
                traceLine("      parent   = " + os.getParent());
                if (!simple) {
                    traceLine("      origId   = " + os.getOrigId());
                    traceLine("      args     = " + sArgs);
                }

                Attributes attrs = new BasicAttributes(true);
                attrs.put("objectClass", sOperandClass);
                attrs.put("pmId", sOpndId);
                attrs.put("pmType", os.getType());
                attrs.put("pmIsFunction", (os.isFunction() ? "TRUE" : "FALSE"));
                attrs.put("pmIsSubgraph", (os.isSubgraph() ? "TRUE" : "FALSE"));
                attrs.put("pmIsComplement", (os.isComplement() ? "TRUE"
                        : "FALSE"));
                attrs.put("pmOriginalName", os.getOrigName());
                if (!simple) {
                    attrs.put("pmOriginalId", os.getOrigId());
                    if (sArgs != null && sArgs.length() > 0) {
                        attrs.put("pmArgs", sArgs);
                    }
                }
                String sOpndDn = "CN=" + sOpndId + "," + sRuleContainerDN;
                try {
                    ctx.bind(sOpndDn, null, attrs);
                } catch (Exception e) {
                    e.printStackTrace();
                    return "Unable to create AD Operand " + os.getOrigName();
                }
            }
        }
        return null;
    }

    private void traceTitle(String title) {
        System.out.println();
        System.out.println(title);
    }

    private void traceLine(String line) {
        System.out.println("  " + line);
    }

    // The command parameters are: constraint name, operation, oattr name, oattr
    // id.
    // Note that the oattr name and id are prefixed with '!' if they designate
    // the complement of a container.
    // The constraint must exist. All other params may be null, but:
    //
    // If the operation is not null, it must be registered for the constraint.
    // If the oattr name or id is non-null, it must be registered for the
    // constraint and they must be consistent.
    private Packet deleteDeny(String sSessId, String sDenyName, String sOp,
                              String sOattrName, String sOattrId) {
        // Check permissions...

        String sDenyId = getEntityId(sDenyName, PM_DENY);
        if (sDenyId == null) {
            return failurePacket("No such deny: " + sDenyName);
        }

        return deleteDenyInternal(sDenyId, sOp, sOattrName, sOattrId);
    }

    private Packet deleteDenyInternal(String sDenyId, String sOp,
                                      String sOattrName, String sOattrId) {
        ModificationItem[] mods = new ModificationItem[1];

        // First some checks.
        if (sOp != null && !denyHasOp(sDenyId, sOp)) {
            return failurePacket("Inconsistency: the deny constraint has no such operation!");
        }

        String sId = null;
        boolean isComplement = false;
        if (sOattrName != null) {
            if (sOattrName.startsWith("!")) {
                isComplement = true;
                sOattrName = sOattrName.substring(1);
            }

            sId = getEntityId(sOattrName, PM_NODE_OATTR);
            if (sId == null) {
                return failurePacket("Inconsistency: no such object attribute!");
            }
            if (sOattrId != null) {
                if (sOattrId.startsWith("!")) {
                    sOattrId = sOattrId.substring(1);
                }
                if (!sOattrId.equals(sId)) {
                    return failurePacket("Inconsistency: the object attribute name is not consistent with its id!");
                }
            }

            if (isComplement) {
                sOattrId = "!" + sId;
            } else {
                sOattrId = sId;
            }
        }

        // If neither op nor container, delete the deny constraint.
        if (sOp == null && sOattrId == null) {
            try {
                ctx.destroySubcontext("CN=" + sDenyId + "," + sDenyContainerDN);
            } catch (Exception e) {
                if (debugFlag) {
                    e.printStackTrace();
                }
                return failurePacket("Error while deleting the deny constraint "
                        + sDenyId + ": " + e.getMessage());
            }
            return successPacket();
        }
        if (sOp != null) {
            // Delete the operation from the deny constraint.
            mods = new ModificationItem[1];
            mods[0] = new ModificationItem(DirContext.REMOVE_ATTRIBUTE,
                    new BasicAttribute("pmOp", sOp));
            try {
                ctx.modifyAttributes("CN=" + sDenyId + "," + sDenyContainerDN,
                        mods);
            } catch (Exception e) {
                if (debugFlag) {
                    e.printStackTrace();
                }
                return failurePacket("Error while deleting operation " + sOp
                        + ": " + e.getMessage());
            }
        }

        if (sOattrId != null) {
            // Delete the container from the deny constraint.
            mods = new ModificationItem[1];
            mods[0] = new ModificationItem(DirContext.REMOVE_ATTRIBUTE,
                    new BasicAttribute("pmAttr", sOattrId));
            try {
                ctx.modifyAttributes("CN=" + sDenyId + "," + sDenyContainerDN,
                        mods);
            } catch (Exception e) {
                if (debugFlag) {
                    e.printStackTrace();
                }
                return failurePacket("Error while deleting container: "
                        + e.getMessage());
            }
        }
        return successPacket();
    }

    // Returns the id of a similar deny.
    private String getSimilarDeny(String sDenyType, String sOrigName,
                                  String sOrigId, boolean bInters, HashSet<ActOpnd> hsOpnd2,
                                  HashSet<ActOpnd> hsOpnd3) {

        // The op set of an existing deny.
        HashSet<String> hsCrtOps = new HashSet<String>();

        // The op set of the deny we want to add.
        HashSet<String> hsOps = new HashSet<String>();
        Iterator<ActOpnd> iter = hsOpnd2.iterator();
        while (iter.hasNext()) {
            String sOp = iter.next().getName();
            hsOps.add(sOp);
        }

        // The container set of an existing deny.
        HashSet<String> hsCrtConts = new HashSet<String>();

        // The container set of the deny we want to add.
        HashSet<String> hsConts = new HashSet<String>();
        iter = hsOpnd3.iterator();
        while (iter.hasNext()) {
            ActOpnd opnd = iter.next();
            String sContId;
            if (opnd.isComplement()) {
                sContId = "!" + opnd.getId();
            } else {
                sContId = opnd.getId();
            }
            hsConts.add(sContId);
        }
        try {
            // Walk thru all denies.
            NamingEnumeration<?> denies;
            SearchControls constraints = new SearchControls();
            constraints.setSearchScope(SearchControls.ONELEVEL_SCOPE);
            constraints.setReturningAttributes(new String[]{"pmId", "pmName",
                    "pmType", "pmOriginalId", "pmIsIntersection", "pmOp",
                    "pmAttr"});
            denies = ctx.search(sDenyContainerDN, "(objectClass=*)",
                    constraints);
            while (denies != null && denies.hasMore()) {
                SearchResult sr = (SearchResult) denies.next();

                // Get the id of the current deny constraint.
                String sCrtDenyId = (String) sr.getAttributes().get("pmId").get();

                // Check the types.
                String sCrtDenyType = (String) sr.getAttributes().get("pmType").get();
                System.out.println("Compare " + sDenyType + " to "
                        + sCrtDenyType);
                if (!sCrtDenyType.equalsIgnoreCase(sDenyType)) {
                    continue;
                }
                // Check if both are intersections or both unions.
                boolean bCrtInters = ((String) sr.getAttributes().get("pmIsIntersection").get()).equalsIgnoreCase("TRUE");
                System.out.println("Compare " + bInters + " to " + bCrtInters);
                if (bCrtInters != bInters) {
                    continue;
                }
                // Check the user or attribute id.
                String sCrtId = (String) sr.getAttributes().get("pmOriginalId").get();
                System.out.println("Compare " + sOrigId + " to " + sCrtId);
                if (!sOrigId.equalsIgnoreCase(sCrtId)) {
                    continue;
                }
                // Check the operations.
                hsCrtOps.clear();
                Attribute attr = sr.getAttributes().get("pmOp");
                if (attr != null) {
                    for (NamingEnumeration<?> enumer = attr.getAll(); enumer.hasMore(); ) {
                        hsCrtOps.add((String) enumer.next());
                    }
                }
                printSet(hsOps, PM_PERM, "Compare operations");
                printSet(hsCrtOps, PM_PERM, "with crt. operations");
                if (!hsOps.containsAll(hsCrtOps)) {
                    continue;
                }
                if (!hsCrtOps.containsAll(hsOps)) {
                    continue;
                }

                // Check the containers.
                hsCrtConts.clear();
                attr = sr.getAttributes().get("pmAttr");
                if (attr != null) {
                    for (NamingEnumeration<?> enumer = attr.getAll(); enumer.hasMore(); ) {
                        hsCrtConts.add((String) enumer.next());
                    }
                }
                printSet(hsConts, PM_PERM, "Compare containers");
                printSet(hsCrtConts, PM_PERM, "with crt. containers");
                if (!hsConts.containsAll(hsCrtConts)) {
                    continue;
                }
                if (!hsCrtConts.containsAll(hsConts)) {
                    continue;
                }
                return sCrtDenyId;
            }
            return null;
        } catch (Exception e) {
            if (debugFlag) {
                e.printStackTrace();
            }
            return null;
        }
    }

    // The command parameters are: constraint name, type, user or uattr name,
    // user or uattr id, an operation, an oattr name, oattr id, and a boolean
    // denoting whether the denied operations apply to the intersection or to
    // the union of the object attributes.
    //
    // The deny type can be: PM_DENY_USER_ID, PM_DENY_INTRA_SESSION, or
    // PM_DENY_ACROSS_SESSIONS.
    // The constraint name must be non-null. All others may be null, with
    // the following restrictions:
    //
    // If the constraint does not exist, this API will try to create it. In this
    // case, the type and the user or uattr name cannot be null. The user or
    // uattr id, if non-null, must match the user or uattr name.
    // If the constraint already exists, this API will try to add an operation
    // or/and an object container (attribute), whichever is non-null.
    // In this case, the type, the user or uattr name, and the user or uattr id,
    // if non-null, must match the ones registered with the constraint.
    //
    // A container name (sOattrName) may start with an "!" to denote the
    // complement of that container.
    private Packet addDeny(String sSessId, String sDenyName, String sDenyType,
                           String sDenyToName, String sDenyToId, String sOp,
                           String sOattrName, String sOattrId, String sIsInters) {
        // Check permissions.
        // ...

        return addDenyInternal(sDenyName, sDenyType, sDenyToName, sDenyToId,
                sOp, sOattrName, sOattrId, sIsInters.equalsIgnoreCase("yes"));
    }

    private Packet addDenyInternal(String sDenyName, String sDenyType,
                                   String sDenyToName, String sDenyToId, String sOp,
                                   String sOattrName, String sOattrId, boolean bInters) {
        System.out.println("addDenyInternal(");
        System.out.println("                deny name = " + sDenyName);
        System.out.println("                deny type = " + sDenyType);
        System.out.println("                denyto name = " + sDenyToName);
        System.out.println("                denyto id = " + sDenyToId);
        System.out.println("                deny op = " + sOp);
        System.out.println("                deny oa name = " + sOattrName);
        System.out.println("                deny oa id = " + sOattrId);
        System.out.println("                deny inters = " + bInters);
        System.out.println("                )");

        ModificationItem[] mods = new ModificationItem[1];
        Packet result;

        // First check whether the deny exists.
        String sDenyId = getEntityId(sDenyName, PM_DENY);
        if (sDenyId != null) {
            // A deny constraint with that name already exists.
            // Do a series of checks.
            result =  getDenySimpleInfo(sDenyId);
            // The information returned by getDenySimpleInfo has the following
            // format:
            // item 0: <deny name>:<deny id>
            // item 1: <deny type>:<denyto name>:<denyto id>:<is intersection>
            if (result.hasError()) {
                return result;
            }
            String sLine = result.getStringValue(1);
            String[] pieces = sLine.split(PM_FIELD_DELIM);

            if (sDenyType != null && !sDenyType.equals(pieces[0])) {
                return failurePacket("In deny, the type does not match its registered type!");
            }

            if (sDenyToName != null && !sDenyToName.equals(pieces[1])) {
                return failurePacket("In deny, the session/process/user/attribute name does not match the registered name!");
            }

            if (sDenyToId != null && !sDenyToId.equals(pieces[2])) {
                return failurePacket("In deny, the session/process/user/attribute id does not match the registered id!");
            }

        } else { // New constraint.
            // A series of checks.
            if (sDenyType == null
                    || (!sDenyType.equalsIgnoreCase(PM_DENY_USER_ID)
                    && !sDenyType.equalsIgnoreCase(PM_DENY_USER_SET)
                    && !sDenyType.equalsIgnoreCase(PM_DENY_SESSION)
                    && !sDenyType.equalsIgnoreCase(PM_DENY_PROCESS)
                    && !sDenyType.equalsIgnoreCase(PM_DENY_INTRA_SESSION) && !sDenyType.equalsIgnoreCase(PM_DENY_ACROSS_SESSIONS))) {
                return failurePacket("Null or invalid deny type!");
            }
            if (sDenyToName == null) {
                return failurePacket("Please select a session, process, user or user attribute name!");
            }

            String sId;
            if (sDenyType.equals(PM_DENY_SESSION)) {
                sId = getEntityId(sDenyToName, PM_SESSION);
            } else if (sDenyType.equals(PM_DENY_PROCESS)) {
                sId = sDenyToName;
            } else if (sDenyType.equals(PM_DENY_USER_ID)) {
                sId = getEntityId(sDenyToName, PM_NODE_USER);
            } else {
                sId = getEntityId(sDenyToName, PM_NODE_UATTR);
            }

            if (sDenyToId != null && !sDenyToId.equals(sId)) {
                return failurePacket("In deny, the session/process/user/user attribute id does not match the registered id!");
            }

            // Anyway, set the session, user or attr id:
            sDenyToId = sId;
        }

        // Now add the constraint if new.
        if (sDenyId == null) {
            Attributes attrs = new BasicAttributes(true);
            RandomGUID myGUID = new RandomGUID();
            sDenyId = myGUID.toStringNoDashes();
            attrs.put("objectClass", sDenyClass);
            attrs.put("pmId", sDenyId);
            attrs.put("pmName", sDenyName);
            attrs.put("pmType", sDenyType);
            attrs.put("pmOriginalId", sDenyToId);
            attrs.put("pmIsIntersection", (bInters ? "TRUE" : "FALSE"));

            String sDenyDn = "CN=" + sDenyId + "," + sDenyContainerDN;
            try {
                ctx.bind(sDenyDn, null, attrs);
            } catch (Exception e) {
                e.printStackTrace();
                return failurePacket("Unable to create Deny constraint \""
                        + sDenyName + "\"");
            }
            // If the operation is present, add it to the deny constraint.
            if (sOp != null && sOp.length() > 0) {
                mods[0] = new ModificationItem(DirContext.ADD_ATTRIBUTE,
                        new BasicAttribute("pmOp", sOp));
                try {
                    ctx.modifyAttributes(sDenyDn, mods);
                } catch (Exception e) {
                    e.printStackTrace();
                    return failurePacket("Unable to add operation \"" + sOp
                            + "\": " + e.getMessage());
                }
            }
            // If the container is present, add it to the deny constraint.
            if (sOattrId != null && sOattrId.length() > 0) {
                if (sOattrName.startsWith("!")) {
                    System.out.println("Complementary container!");
                    sOattrId = "!" + sOattrId;
                }
                mods[0] = new ModificationItem(DirContext.ADD_ATTRIBUTE,
                        new BasicAttribute("pmAttr", sOattrId));
                try {
                    ctx.modifyAttributes(sDenyDn, mods);
                } catch (Exception e) {
                    e.printStackTrace();
                    return failurePacket("Unable to add container \""
                            + sOattrName + "\": " + e.getMessage());
                }
            }
        } else {
            // Deny exists, try to add the operation and/or container, which
            // cannot be
            // duplicate or both null.
            if ((sOp == null || sOp.length() == 0)
                    && (sOattrId == null || sOattrId.length() == 0)) {
                return failurePacket("Please select an operation and/or a container!");
            }

            if (sOp != null) {
                if (denyHasOp(sDenyId, sOp)) {
                    return failurePacket("Duplicate operation " + sOp
                            + " in deny constraint!");
                }
                // Add the operation.
                mods[0] = new ModificationItem(DirContext.ADD_ATTRIBUTE,
                        new BasicAttribute("pmOp", sOp));
                try {
                    ctx.modifyAttributes("CN=" + sDenyId + ","
                            + sDenyContainerDN, mods);
                } catch (Exception e) {
                    e.printStackTrace();
                    return failurePacket("Unable to add operation \"" + sOp
                            + "\"; " + e.getMessage());
                }
            }
            if (sOattrId != null) {
                if (denyHasOattr(sDenyId, sOattrId)) {
                    return failurePacket("Duplicate container " + sOattrName
                            + " in deny constraint!");
                }
                if (sOattrName.startsWith("!")) {
                    sOattrId = "!" + sOattrId;
                }
                // Add the container.
                mods[0] = new ModificationItem(DirContext.ADD_ATTRIBUTE,
                        new BasicAttribute("pmAttr", sOattrId));
                try {
                    ctx.modifyAttributes("CN=" + sDenyId + ","
                            + sDenyContainerDN, mods);
                } catch (Exception e) {
                    e.printStackTrace();
                    return failurePacket("Unable to add container \""
                            + sOattrName + "\"; " + e.getMessage());
                }
            }
        }
        result = new Packet();
        try {
            result.addItem(ItemType.RESPONSE_TEXT, sDenyName + PM_FIELD_DELIM
                    + sDenyId);
        } catch (Exception e) {
            e.printStackTrace();
            return failurePacket("Exception when building the result packet");
        }
        return result;
    }

    // The information returned by getDenySimpleInfo has the following format:
    // item 0: <deny name>:<deny id>
    // item 1: <deny type>:<user or attribute name>:<user or attribute id>:<is
    // intersection>
    private Packet getDenySimpleInfo(String sDenyId) {
        Packet result = new Packet();
        Attributes attrs;
        String sId, sName;

        try {
            attrs = ctx.getAttributes("CN=" + sDenyId + "," + sDenyContainerDN);

            // First insert the constraint name and id.
            sName = (String) attrs.get("pmName").get();
            result.addItem(ItemType.RESPONSE_TEXT, sName + PM_FIELD_DELIM
                    + sDenyId);

            // Now the deny type and the session/process/user/attr name and id:
            String sType = (String) attrs.get("pmType").get();
            sId = (String) attrs.get("pmOriginalId").get();
            if (sType.equals(PM_DENY_USER_ID)) {
                sName = getEntityName(sId, PM_NODE_USER);
            } else if (sType.equals(PM_DENY_SESSION)) {
                sName = getEntityName(sId, PM_SESSION);
            } else if (sType.equals(PM_DENY_PROCESS)) {
                sName = sId;
            } else {
                sName = getEntityName(sId, PM_NODE_UATTR);
            }
            String sInters = (((String) attrs.get("pmIsIntersection").get()).equalsIgnoreCase("TRUE") ? "yes" : "no");
            result.addItem(ItemType.RESPONSE_TEXT, sType + PM_FIELD_DELIM
                    + sName + PM_FIELD_DELIM + sId + PM_FIELD_DELIM + sInters);
        } catch (Exception e) {
            if (debugFlag) {
                e.printStackTrace();
            }
            return failurePacket("Exception in getDenySimpleInfo: "
                    + e.getMessage());
        }
        return result;
    }

    // The information returned by getTemplateInfo has the following format:
    // item 0: <tpl name>:<tpl id>
    // item 1: <cont 1 id>:...:<cont n id>
    // item 2: <key1>:...:<keyn>
    private Packet getTemplateInfo(String sSessId, String sTplId) {
        Packet result = new Packet();
        Attributes attrs;
        String sName;
        Attribute attr;

        try {
            attrs = ctx.getAttributes("CN=" + sTplId + ","
                    + sTemplateContainerDN);

            // First insert the template name and id.
            sName = (String) attrs.get("pmName").get();
            result.addItem(ItemType.RESPONSE_TEXT, sName + PM_FIELD_DELIM
                    + sTplId);

            // Now the container ids.
            attr = attrs.get("pmComponents");
            result.addItem(ItemType.RESPONSE_TEXT, (String) attr.get());

            // Now the keys (their names).
            attr = attrs.get("pmKey");
            if (attr == null) {
                result.addItem(ItemType.RESPONSE_TEXT, "");
            } else {
                boolean first = true;
                StringBuffer sb = new StringBuffer();
                for (NamingEnumeration<?> attrEnum = attr.getAll(); attrEnum.hasMore(); ) {
                    String sKey = (String) attrEnum.next();
                    if (first) {
                        sb.append(sKey);
                        first = false;
                    } else {
                        sb.append(PM_FIELD_DELIM + sKey);
                    }
                }
                result.addItem(ItemType.RESPONSE_TEXT, sb.toString());
            }
            return result;
        } catch (Exception e) {
            e.printStackTrace();
            return failurePacket("Exception in getTemplateInfo(): "
                    + e.getMessage());
        }
    }

    // The information returned by getDenyInfo has the following format:
    // item 0: <deny name>:<deny id>
    // item 1: <deny type>:<user or attribute name>:<user or attribute id>:<is
    // intersection>
    // item 2: <opcount>
    // items 3 through 3 + opcount - 1: <operation>
    // item 3 + opcount: <contcount>
    // item 3 + opcount + 1 through 3 + opcount + 1 + contcount - 1: <container
    // name>:<container id>
    // Note that the container name is prefixed with "!" for complements.
    private Packet getDenyInfo(String sSessId, String sDenyId) {
        Packet result = new Packet();
        Attributes attrs;
        String sId, sName;
        Attribute attr;

        try {
            attrs = ctx.getAttributes("CN=" + sDenyId + "," + sDenyContainerDN);

            // First insert the constraint name and id.
            sName = (String) attrs.get("pmName").get();
            result.addItem(ItemType.RESPONSE_TEXT, sName + PM_FIELD_DELIM
                    + sDenyId);

            // Now the deny type and the session, user, or attribute name and
            // id.
            String sType = (String) attrs.get("pmType").get();
            sId = (String) attrs.get("pmOriginalId").get();
            if (sType.equals(PM_DENY_SESSION)) {
                sName = getEntityName(sId, PM_SESSION);
            } else if (sType.equals(PM_DENY_PROCESS)) {
                sName = sId;
            } else if (sType.equals(PM_DENY_USER_ID)) {
                sName = getEntityName(sId, PM_NODE_USER);
            } else {
                sName = getEntityName(sId, PM_NODE_UATTR);
            }

            if (sName == null) {
                return failurePacket("No entity of type " + sType + " and id "
                        + sId);
            }

            String sInters = (((String) attrs.get("pmIsIntersection").get()).equalsIgnoreCase("TRUE") ? "yes" : "no");
            result.addItem(ItemType.RESPONSE_TEXT, sType + PM_FIELD_DELIM
                    + sName + PM_FIELD_DELIM + sId + PM_FIELD_DELIM + sInters);

            // Now the operations, one per item, prefixed by their number.
            attr = attrs.get("pmOp");
            if (attr == null) {
                result.addItem(ItemType.RESPONSE_TEXT, String.valueOf(0));
            } else {
                result.addItem(ItemType.RESPONSE_TEXT,
                        String.valueOf(attr.size()));
                for (NamingEnumeration<?> attrEnum = attr.getAll(); attrEnum.hasMore(); ) {
                    result.addItem(ItemType.RESPONSE_TEXT,
                            (String) attrEnum.next());
                }
            }

            // Now the containers, one per item, prefixed by their number.
            attr = attrs.get("pmAttr");
            if (attr == null) {
                result.addItem(ItemType.RESPONSE_TEXT, String.valueOf(0));
            } else {
                result.addItem(ItemType.RESPONSE_TEXT,
                        String.valueOf(attr.size()));
                for (NamingEnumeration<?> attrEnum = attr.getAll(); attrEnum.hasMore(); ) {
                    sId = (String) attrEnum.next();
                    String sCleanId;
                    if (sId.startsWith("!")) {
                        sCleanId = sId.substring(1);
                    } else {
                        sCleanId = sId;
                    }
                    sName = getEntityName(sCleanId, PM_NODE_OATTR);
                    if (sName == null) {
                        return failurePacket("No object attribute with id = "
                                + sCleanId);
                    }

                    if (sId.startsWith("!")) {
                        sName = "!" + sName;
                    }
                    result.addItem(ItemType.RESPONSE_TEXT, sName
                            + PM_FIELD_DELIM + sId);
                }
            }
        } catch (Exception e) {
            e.printStackTrace();
            return failurePacket("Exception in getDenyInfo(): "
                    + e.getMessage());
        }
        return result;
    }

    private Packet getDenies(String sSessId) {
        Packet result = new Packet();
        NamingEnumeration<?> denies;

        try {
            SearchControls constraints = new SearchControls();
            constraints.setSearchScope(SearchControls.ONELEVEL_SCOPE);
            constraints.setReturningAttributes(new String[]{"pmId", "pmName"});
            denies = ctx.search(sDenyContainerDN, "(objectClass=*)",
                    constraints);
            while (denies != null && denies.hasMore()) {
                SearchResult sr = (SearchResult) denies.next();
                String sDenyName = (String) sr.getAttributes().get("pmName").get();
                String sDenyId = (String) sr.getAttributes().get("pmId").get();
                result.addItem(ItemType.RESPONSE_TEXT, sDenyName
                        + PM_FIELD_DELIM + sDenyId);
            }
            return result;
        } catch (Exception e) {
            if (debugFlag) {
                e.printStackTrace();
            }
            return failurePacket("Exception in getDenies(): " + e.getMessage());
        }
    }

    private Packet testGetDeniedPerms(String sCrtSessId, String sObjName) {
        String sObjId = getEntityId(sObjName, PM_OBJ);
        if (sObjId == null) {
            return failurePacket("No such object " + sObjName + "!");
        }
        String sOattrId = getAssocOattr(sObjId);
        if (sOattrId == null) {
            return failurePacket("Inconsistency: no associated object attribute!");
        }
        HashSet<String> deniedOps;
        try {
            deniedOps = getDeniedPerms(sCrtSessId, null, sOattrId,
                    PM_NODE_OATTR);
        } catch (Exception e) {
            e.printStackTrace();
            deniedOps = new HashSet<String>();
        }
        printSet(deniedOps, PM_PERM, "Denied permissions are:");
        return setToPacket(deniedOps);
    }

    // Compute and return the permissions denied to the user/process/session.
    // Parameters:
    // sCrtSessId: the id of the current session. The user can be retrieved.
    // sCrtProcId: the id of the current process. Not used if null.
    // sEntId, sEntType: the id and type of the entity on which we compute
    // the denied permissions.
    //
    private HashSet<String> getDeniedPerms(String sCrtSessId,
                                           String sCrtProcId, String sEntId, String sEntType) throws Exception {
        System.out.println("%%%%% getDeniedPerms(" + sEntId + ", " + sEntType
                + ") i.e., for " + getEntityName(sEntId, sEntType));

        HashSet<String> deniedOps = new HashSet<String>();

        // For entities other than object attributes, return an empty set of
        // denied ops.
        if (!sEntType.equalsIgnoreCase(PM_NODE_OATTR)) {
            return deniedOps;
        }

        // Get the user of the current session.
        String sUserId = getSessionUserId(sCrtSessId);

        // The user's active attributes across all his sessions.
        HashSet<String> activesAcrossSessions = null;
        // The user's active attributes in the current session.
        HashSet<String> activesInCrtSession = null;

        // Walk thru all denies.
        NamingEnumeration<?> denies;
        SearchControls constraints = new SearchControls();
        constraints.setSearchScope(SearchControls.ONELEVEL_SCOPE);
        constraints.setReturningAttributes(new String[]{"pmId", "pmName",
                "pmType", "pmOriginalId", "pmIsIntersection", "pmOp",
                "pmAttr"});
        denies = ctx.search(sDenyContainerDN, "(objectClass=*)", constraints);

        while (denies != null && denies.hasMore()) {
            SearchResult sr = (SearchResult) denies.next();
            String sDenyType = (String) sr.getAttributes().get("pmType").get();
            String sDenyId = (String) sr.getAttributes().get("pmId").get();
            boolean bIntersection = ((String) sr.getAttributes().get("pmIsIntersection").get()).equalsIgnoreCase("TRUE");

            System.out.println("Found deny constraint " + sDenyId + " of type "
                    + sDenyType + " intersection=" + bIntersection);

            // Regardless of the type of the deny constraint, find out whether
            // the entity (an object attribute) is in the constraint's container
            // set.
            Attribute attr = sr.getAttributes().get("pmAttr");
            if (!entityIsInDenyList(sEntId, sEntType, attr, bIntersection)) {
                System.out.println("Entity " + getEntityName(sEntId, sEntType)
                        + " is NOT in " + sDenyId);
                continue;
            }
            System.out.println("Object " + getEntityName(sEntId, sEntType)
                    + " is in " + sDenyId);

            // If the deny constraint is of type session (PM_DENY_SESSION),
            // check whether the session id in the constraint matches this
            // session id
            // (the session trying to access a resource) and
            // skip the deny if not.
            // Else if the deny constraint is of type user id (PM_DENY_USER_ID),
            // check that the userid in the constraint matches sUserId, and
            // skip the deny if not.
            // Else if the deny constraint is of type attribute intrasession
            // (PM_DENY_INTRA_SESSION), check that the attribute in the
            // constraint
            // is active for sUserId in the current session.
            // Else (i.e., the deny constraint is of type
            // PM_DENY_ACROSS_SESSIONS),
            // check that the attribute in the constraint is active in any
            // session of the user.
            String sDenyToId = (String) sr.getAttributes().get("pmOriginalId").get();
            if (sDenyType.equalsIgnoreCase(PM_DENY_SESSION)) {
                if (!sCrtSessId.equals(sDenyToId)) {
                    System.out.println("Session "
                            + getEntityName(sCrtSessId, PM_SESSION)
                            + " is NOT in " + sDenyId);
                    continue;
                } else {
                    System.out.println("Session "
                            + getEntityName(sCrtSessId, PM_SESSION) + " is in "
                            + sDenyId);
                }
            } else if (sDenyType.equalsIgnoreCase(PM_DENY_PROCESS)) {
                if (sCrtProcId == null || !sCrtProcId.equals(sDenyToId)) {
                    System.out.println("Process " + sCrtProcId + " is NOT in "
                            + sDenyId);
                    continue;
                } else {
                    System.out.println("Process " + sCrtProcId + " is in "
                            + sDenyId);
                }
            } else if (sDenyType.equalsIgnoreCase(PM_DENY_USER_ID)) {
                if (!sUserId.equals(sDenyToId)) {
                    System.out.println("User "
                            + getEntityName(sUserId, PM_NODE_USER)
                            + " is NOT in " + sDenyId);
                    continue;
                } else {
                    System.out.println("User "
                            + getEntityName(sUserId, PM_NODE_USER) + " is in "
                            + sDenyId);
                }
            } else if (sDenyType.equalsIgnoreCase(PM_DENY_ACROSS_SESSIONS)) {
                if (activesAcrossSessions == null) {
                    activesAcrossSessions = getUserActiveAttrs(sUserId);
                }
                if (!activesAcrossSessions.contains(sDenyToId)) {
                    System.out.println("User "
                            + getEntityName(sUserId, PM_NODE_USER)
                            + " does not have active attr "
                            + getEntityName(sDenyToId, PM_NODE_UATTR));
                    continue;
                } else {
                    System.out.println("User "
                            + getEntityName(sUserId, PM_NODE_USER)
                            + " has active attr "
                            + getEntityName(sDenyToId, PM_NODE_UATTR));
                }
            } else {// PM_DENY_INTRA_SESSION
                if (activesInCrtSession == null) {
                    activesInCrtSession = getSessionActiveAttrSet(sCrtSessId);
                }
                if (!activesInCrtSession.contains(sDenyToId)) {
                    System.out.println("User "
                            + getEntityName(sUserId, PM_NODE_USER)
                            + " does not have active attr "
                            + getEntityName(sDenyToId, PM_NODE_UATTR));
                    continue;
                } else {
                    System.out.println("User "
                            + getEntityName(sUserId, PM_NODE_USER)
                            + " has active attr "
                            + getEntityName(sDenyToId, PM_NODE_UATTR));
                }
            }

            // Regardless of the type of the deny constraint, add the
            // constraint's
            // operations to the set deniedOps.
            attr = sr.getAttributes().get("pmOp");
            if (attr == null) {
                continue;
            }
            try {
                for (NamingEnumeration<?> attrEnum = attr.getAll(); attrEnum.hasMore(); ) {
                    String sOp = (String) attrEnum.next();
                    if (!deniedOps.contains(sOp)) {
                        deniedOps.add(sOp);
                    }
                }
            } catch (Exception e) {
                if (debugFlag) {
                    e.printStackTrace();
                }
            }
        }
        printSet(deniedOps, PM_PERM, "Operations denied for user "
                + getEntityName(sUserId, PM_NODE_USER) + " and entity "
                + getEntityName(sEntId, sEntType));
        return deniedOps;
    }

    // sEntId and sEntType identify an object attribute.
    // Parameter attr contains the "pmAttr" attributes of a deny constraint
    // and represents a set of object containers (i.e., object attributes).
    // The function checks whether the object attribute is contained in the
    // union or the intersection of the containers, depending on the value
    // of the bInters (false or true). Note that some containers may have
    // their id prefixed with the "!" symbol, which means to check whether
    // the object attribute is NOT in that container.
    private boolean entityIsInDenyList(String sEntId, String sEntType,
                                       Attribute attr, boolean bInters) {
        if (attr == null) {
            System.out.println("No object attributes in the constraint!");
            return false;
        }
        System.out.println("....ObjIsInDenyList");
        try {
            if (bInters) {
                // Do the intersection
                System.out.println("......Do intersection");
                for (NamingEnumeration<?> attrEnum = attr.getAll(); attrEnum.hasMore(); ) {
                    String sId = (String) attrEnum.next();
                    if (sId.startsWith("!")) {
                        sId = sId.substring(1);
                        System.out.println("........Processing container C("
                                + getEntityName(sId, PM_NODE_OATTR) + ")");
                        if (attrIsAscendant(sEntId, sId, PM_NODE_OATTR)) {
                            System.out.println("..........Obj is ascendant of container, return false");
                            return false;
                        } else {
                            System.out.println("..........Obj is not ascendant of container");
                        }
                    } else {
                        System.out.println("........Processing container "
                                + getEntityName(sId, PM_NODE_OATTR));
                        if (!attrIsAscendant(sEntId, sId, PM_NODE_OATTR)) {
                            System.out.println("..........Obj is not ascendant of container, return false");
                            return false;
                        } else {
                            System.out.println("..........Obj is ascendant of container");
                        }
                    }
                }
                return true;
            } else {
                // Do the union.
                for (NamingEnumeration<?> attrEnum = attr.getAll(); attrEnum.hasMore(); ) {
                    String sId = (String) attrEnum.next();
                    if (sId.startsWith("!")) {
                        sId = sId.substring(1);
                        System.out.println("........Processing container C("
                                + getEntityName(sId, PM_NODE_OATTR) + ")");
                        if (!attrIsAscendant(sEntId, sId, PM_NODE_OATTR)) {
                            System.out.println("..........Obj is not ascendant of container, return true");
                            return true;
                        } else {
                            System.out.println("..........Obj is ascendant of container");
                        }
                    } else {
                        System.out.println("........Processing container "
                                + getEntityName(sId, PM_NODE_OATTR));
                        if (attrIsAscendant(sEntId, sId, PM_NODE_OATTR)) {
                            System.out.println("..........Obj is ascendant of container, return true");
                            return true;
                        } else {
                            System.out.println("..........Obj is not ascendant of container");
                        }
                    }
                }
                return false;
            }
        } catch (Exception e) {
            if (debugFlag) {
                e.printStackTrace();
            }
            return false;
        }
    }

    private Packet isTimeToRefresh(String sClientId, String sSessId,
                                   String sClientTimestamp) {
        Date dateEngine, dateClient;
        Packet result = new Packet();

        try {
            dateEngine = dfUpdate.parse(sLastUpdateTimestamp);
            dateClient = dfUpdate.parse(sClientTimestamp);
            if (dateEngine.compareTo(dateClient) <= 0) {
                result.addItem(ItemType.RESPONSE_TEXT, "no");
            } else {
                result.addItem(ItemType.RESPONSE_TEXT, "yes");
            }
        } catch (Exception e) {
            if (debugFlag) {
                e.printStackTrace();
            }
            return failurePacket("Exception in engine's isTimeToRefresh: "
                    + e.getMessage());
        }
        return result;
    }

    private Packet getHostRepository(String sSessId) {
        String sHost = getSessionHostName(sSessId);
        if (sHost == null) {
            return failurePacket("No such session or host!");
        }
        String sReposit = getHostRepositoryInternal(sHost);
        if (sReposit == null) {
            return failurePacket("No repository for host " + sHost + "!");
        }
        Packet res = new Packet();
        try {
            res.addItem(ItemType.RESPONSE_TEXT, sReposit);
        } catch (Exception e) {
            e.printStackTrace();
            return failurePacket("Exception when building the result packet");
        }
        return res;
    }

    // Get host's repository path. This is the physical home of newly created
    // objects.
    private String getHostRepositoryInternal(String sHostName) {
        NamingEnumeration<?> entities;
        try {
            SearchControls constraints = new SearchControls();
            constraints.setSearchScope(SearchControls.ONELEVEL_SCOPE);
            constraints.setReturningAttributes(new String[]{"pmId", "pmPath"});
            entities = ctx.search(sHostContainerDN, "(pmName=" + sHostName
                    + ")", constraints);
            if (entities == null || !entities.hasMore()) {
                return null;
            }
            SearchResult sr = (SearchResult) entities.next();
            Attributes attrs = sr.getAttributes();
            return (String) (attrs.get("pmPath").get());
        } catch (Exception e) {
            e.printStackTrace();
            return null;
        }
    }

    /**
     * @return a list of all of the pm applications installed in the system
     */
    private Packet getInstalledApps(String sHost) {
        NamingEnumeration<SearchResult> users;
        Packet resp = new Packet();
        try {
            SearchControls constraints = new SearchControls();
            constraints.setSearchScope(SearchControls.ONELEVEL_SCOPE);
            constraints.setReturningAttributes(new String[]{"pmId"});
            users = ctx.search(sOsConfigContainerDN, "(&(pmId=*)(pmHost=" + sHost + "))", constraints);
            System.out.println("Searching for apps");
            if (users == null || !users.hasMore()) {
                return resp;
            }
            while (users.hasMore()) {
                SearchResult result = users.next();
                Attribute attr = result.getAttributes().get("pmId");
                if (attr == null) {
                    return resp;
                }
                System.out.println("Adding installed item " + attr.get());
                resp.addItem(ItemType.RESPONSE_TEXT, (String) attr.get());
            }
        } catch (Exception e) {
            if (debugFlag) {
                e.printStackTrace();
            }
        }
        return resp;

    }

    // Get the paths of applications installed on a host. The result should
    // contain the admin tool path in item 0 and the rtf editor path in item 1
    // if they are installed, otherwise the empty strings.
    private Packet getHostAppPaths(String sClientId, String sSessId,
                                   String sHost, String appName) {
        NamingEnumeration<?> configs;
        Packet res = new Packet();

        // Look for a OS Config record for the given host.
        try {
            SearchControls constraints = new SearchControls();
            constraints.setSearchScope(SearchControls.ONELEVEL_SCOPE);
            constraints.setReturningAttributes(new String[]{"pmId",
                    "pmAppPath", "pmAppPrefix", "pmAppMainClass"});
            configs = ctx.search(sOsConfigContainerDN, "(&(pmid=" + appName
                    + ")(pmHost=" + sHost + "))", constraints);
            if (configs == null || !configs.hasMore()) {
                return res;
            }
            SearchResult sr = (SearchResult) configs.next();
            Attribute attr = sr.getAttributes().get("pmAppPath");
            if (attr == null) {
                res.addItem(ItemType.RESPONSE_TEXT, "");
            } else {
                res.addItem(ItemType.RESPONSE_TEXT, (String) attr.get());
            }
            attr = sr.getAttributes().get("pmAppPrefix");
            if (attr == null) {
                res.addItem(ItemType.RESPONSE_TEXT, "");
            } else {
                res.addItem(ItemType.RESPONSE_TEXT, (String) attr.get());
            }
            attr = sr.getAttributes().get("pmAppMainClass");
            if (attr == null) {
                res.addItem(ItemType.RESPONSE_TEXT, "");
            } else {
                res.addItem(ItemType.RESPONSE_TEXT, (String) attr.get());
            }
            return res;
        } catch (Exception e) {
            if (debugFlag) {
                e.printStackTrace();
            }
            return failurePacket("Exception while looking for the OS configuration on "
                    + sHost);
        }
    }

    // Get the app paths for all hosts, one host per item.
    // An item should contain:
    // <admin tool path>|
    // <rtf editor path>|
    // <wkf app path>|
    // <egrant app path>|
    // <exporter path>|
    // <openoffice path>|
    // <msoffice path>|
    // <med rec editor path>|
    // <acct rec editor path>|
    // <host>.
    // It's essential to have the <host> NOT EMPTY and LAST.
    private Packet getAppPaths(String sClientId, String sSessId) {
        Packet result = new Packet();
        NamingEnumeration<?> paths;

        try {
            SearchControls constraints = new SearchControls();
            constraints.setSearchScope(SearchControls.ONELEVEL_SCOPE);
            constraints.setReturningAttributes(new String[]{"pmHost",
                    "pmAtoolPath", "pmRtfedPath", "pmWkfPath", "pmEmlPath",
                    "pmExpPath", "pmLauncherPath", "pmMsofficePath",
                    "pmMedrecPath", "pmAcctrecPath", "pmWorkflowOld"});
            paths = ctx.search(sOsConfigContainerDN, "(objectClass=*)",
                    constraints);

            while (paths != null && paths.hasMore()) {
                SearchResult sr = (SearchResult) paths.next();
                StringBuffer sb = new StringBuffer();

                Attribute attr = sr.getAttributes().get("pmAtoolPath");
                if (attr != null) {
                    sb.append((String) attr.get());
                }
                sb.append(PM_ALT_FIELD_DELIM);
                attr = sr.getAttributes().get("pmRtfedPath");
                if (attr != null) {
                    sb.append((String) attr.get());
                }
                sb.append(PM_ALT_FIELD_DELIM);
                attr = sr.getAttributes().get("pmWkfPath");
                if (attr != null) {
                    sb.append((String) attr.get());
                }
                sb.append(PM_ALT_FIELD_DELIM);
                attr = sr.getAttributes().get("pmEmlPath");
                if (attr != null) {
                    sb.append((String) attr.get());
                }
                sb.append(PM_ALT_FIELD_DELIM);
                attr = sr.getAttributes().get("pmExpPath");
                if (attr != null) {
                    sb.append((String) attr.get());
                }
                sb.append(PM_ALT_FIELD_DELIM);
                attr = sr.getAttributes().get("pmLauncherPath");
                if (attr != null) {
                    sb.append((String) attr.get());
                }
                sb.append(PM_ALT_FIELD_DELIM);
                attr = sr.getAttributes().get("pmMsofficePath");
                if (attr != null) {
                    sb.append((String) attr.get());
                }
                sb.append(PM_ALT_FIELD_DELIM);
                attr = sr.getAttributes().get("pmMedrecPath");
                if (attr != null) {
                    sb.append((String) attr.get());
                }
                sb.append(PM_ALT_FIELD_DELIM);
                attr = sr.getAttributes().get("pmAcctrecPath");
                if (attr != null) {
                    sb.append((String) attr.get());
                }
                sb.append(PM_ALT_FIELD_DELIM);
                attr = sr.getAttributes().get("pmWorkflowOld");
                if(attr !=null){
                	sb.append((String) attr.get());
                }
                sb.append(PM_ALT_FIELD_DELIM);

                sb.append((String) sr.getAttributes().get("pmHost").get());
                result.addItem(ItemType.RESPONSE_TEXT, sb.toString());
                System.out.println(sb.toString());
            }
            return result;
        } catch (CommunicationException e) {
            if (debugFlag) {
                e.printStackTrace();
            }
            return failurePacket("AD connection error");
        } catch (Exception e) {
            if (debugFlag) {
                e.printStackTrace();
            }
            return failurePacket("Exception: " + e.getMessage());
        }
    }

    private Packet addHostApp(String sSessId,
                              String sHost, String appName, String appPath,
                              String mainClassName, String appPrefix) {
        //Check for existing application with the same id and host combination.
        //If exists, remove the old entry.
        //Add a new entry to the directory.
        NamingEnumeration<SearchResult> matchingApps;
        try {
            SearchControls constraints = new SearchControls();
            constraints.setSearchScope(SearchControls.ONELEVEL_SCOPE);
            constraints.setReturningAttributes(new String[]{"cn", "pmId"});
            String searchString = String.format("(&(pmHost=%s)(pmId=%s))", sHost, appName);
            matchingApps = ctx.search(sOsConfigContainerDN, searchString, constraints);
            while (matchingApps != null && matchingApps.hasMore()) {
                SearchResult sr = matchingApps.next();
                String sId = sr.getAttributes().get("cn").get().toString();
                String deleteMe = String.format("CN=%s,%s", sId, sOsConfigContainerDN);
                ctx.destroySubcontext(deleteMe);
            }

            Attributes attrs = new BasicAttributes(true);
            RandomGUID myGUID = new RandomGUID();
            String sId = myGUID.toStringNoDashes();

            attrs.put("objectClass", sOsConfigClass);
            if (appName == null) {
                return failurePacket("Exception in installHostApp: no appname specified.");
            }
            attrs.put("pmId", appName);
            attrs.put("pmHost", sHost);
            if (appPath != null && !appPath.trim().isEmpty()) {
                attrs.put("pmAppPath", appPath);
            }
            if (mainClassName != null && !mainClassName.trim().isEmpty()) {
                attrs.put("pmAppMainClass", mainClassName);
            }
            if (appPrefix != null && !appPrefix.trim().isEmpty()) {
                attrs.put("pmAppPrefix", appPrefix);
            }
            String basePath = sOsConfigContainerDN;
            String objectAddress = String.format("CN=%s,%s", sId, basePath);
            ctx.bind(objectAddress, null, attrs);
            return successPacket();
        } catch (Exception e) {
            if (debugFlag) {
                e.printStackTrace();
            }
            return failurePacket("Exception in engine's installHostApp for "
                    + sHost);
        }

    }

    // Set the paths of applications installed on a host.
    private Packet setHostAppPaths(String sSessId, String sHost,
                                   String sAtoolPath, String sRtfedPath, String sWkfPath,
                                   String sEmlPath, String sExpPath, String sLauncherPath,
                                   String sMsofficePath, String sMedrecPath, String sAcctrecPath 
                                   ,String soldWkfPath) {
        // First delete all records for host.
        NamingEnumeration<?> configs;

        // Look for a OS Config record for the given host.
        try {
            SearchControls constraints = new SearchControls();
            constraints.setSearchScope(SearchControls.ONELEVEL_SCOPE);
            constraints.setReturningAttributes(new String[]{"pmId"});
            configs = ctx.search(sOsConfigContainerDN,
                    "(pmHost=" + sHost + ")", constraints);
            // Delete all records for the given host.
            while (configs != null && configs.hasMore()) {
                SearchResult sr = (SearchResult) configs.next();
                String sId = (String) sr.getAttributes().get("pmId").get();
                ctx.destroySubcontext("CN=" + sId + "," + sOsConfigContainerDN);
            }

            // Add a new record for the given host.
            Attributes attrs = new BasicAttributes(true);
            RandomGUID myGUID = new RandomGUID();
            String sId = myGUID.toStringNoDashes();
            attrs.put("objectClass", sOsConfigClass);
            attrs.put("pmId", sId);
            attrs.put("pmHost", sHost);
            if (sAtoolPath != null && sAtoolPath.length() > 0) {
                attrs.put("pmAtoolPath", sAtoolPath);
            }
            if (sRtfedPath != null && sRtfedPath.length() > 0) {
                attrs.put("pmRtfedPath", sRtfedPath);
            }
            if (sWkfPath != null && sWkfPath.length() > 0) {
                attrs.put("pmWkfPath", sWkfPath);
            }
            if (soldWkfPath != null && soldWkfPath.length() > 0) {
            	attrs.put("pmWorkflowOld", soldWkfPath);
            }
            if (sEmlPath != null && sEmlPath.length() > 0) {
                attrs.put("pmEmlPath", sEmlPath);
            }
            if (sExpPath != null && sExpPath.length() > 0) {
                attrs.put("pmExpPath", sExpPath);
            }
            if (sLauncherPath != null && sLauncherPath.length() > 0) {
                attrs.put("pmLauncherPath", sLauncherPath);
            }
            if (sMsofficePath != null && sMsofficePath.length() > 0) {
                attrs.put("pmMsofficePath", sMsofficePath);
            }
            if (sMedrecPath != null && sMedrecPath.length() > 0) {
                attrs.put("pmMedrecPath", sMedrecPath);
            }
            if (sAcctrecPath != null && sAcctrecPath.length() > 0) {
                attrs.put("pmAcctrecPath", sAcctrecPath);
            }
            ctx.bind("CN=" + sId + "," + sOsConfigContainerDN, null, attrs);
            return successPacket();
        } catch (Exception e) {
            if (debugFlag) {
                e.printStackTrace();
            }
            return failurePacket("Exception in engine's setAppPaths for "
                    + sHost);
        }
    }

    // Get the paths of the key and trust stores for a user on a host.
    // They are returned in items 0 and 1 of the result.
    private Packet getKStorePaths(String sClientId, String sSessId) {
        NamingEnumeration<?> configs;
        Packet res = new Packet();
        String sUserId = getSessionUserId(sSessId);
        String sHost = getSessionHostName(sSessId);

        // Look for a User Config record for the given host.
        try {
            SearchControls constraints = new SearchControls();
            constraints.setSearchScope(SearchControls.ONELEVEL_SCOPE);
            constraints.setReturningAttributes(new String[]{"pmId",
                    "pmKsPath", "pmTsPath"});
            configs = ctx.search(sUserConfigContainerDN, "(&(pmHost=" + sHost
                    + ")(pmUserId=" + sUserId + "))", constraints);
            if (configs == null || !configs.hasMore()) {
                return res;
            }
            SearchResult sr = (SearchResult) configs.next();
            Attribute attr = sr.getAttributes().get("pmKsPath");
            if (attr == null) {
                res.addItem(ItemType.RESPONSE_TEXT, "");
            } else {
                res.addItem(ItemType.RESPONSE_TEXT, (String) attr.get());
            }
            attr = sr.getAttributes().get("pmTsPath");
            if (attr == null) {
                res.addItem(ItemType.RESPONSE_TEXT, "");
            } else {
                res.addItem(ItemType.RESPONSE_TEXT, (String) attr.get());
            }
            return res;
        } catch (Exception e) {
            if (debugFlag) {
                e.printStackTrace();
            }
            return failurePacket("Exception while looking for the session configuration on "
                    + sHost);
        }
    }

    private Packet getAllKStorePaths(String sClientId, String sSessId) {
        NamingEnumeration<?> configs;
        Packet result = new Packet();

        // Look for a User Config record for the given host.
        try {
            SearchControls constraints = new SearchControls();
            constraints.setSearchScope(SearchControls.ONELEVEL_SCOPE);
            constraints.setReturningAttributes(new String[]{"pmHost",
                    "pmUserId", "pmKsPath", "pmTsPath"});
            configs = ctx.search(sUserConfigContainerDN, "(objectClass=*)",
                    constraints);
            while (configs != null && configs.hasMore()) {
                SearchResult sr = (SearchResult) configs.next();
                StringBuffer sb = new StringBuffer();
                Attribute attr = sr.getAttributes().get("pmKsPath");
                if (attr != null) {
                    sb.append((String) attr.get());
                }
                sb.append(PM_ALT_FIELD_DELIM);
                attr = sr.getAttributes().get("pmTsPath");
                if (attr != null) {
                    sb.append((String) attr.get());
                }
                sb.append(PM_ALT_FIELD_DELIM);
                sb.append((String) sr.getAttributes().get("pmHost").get());
                sb.append(PM_ALT_FIELD_DELIM);
                String sUserId = (String) sr.getAttributes().get("pmUserId").get();
                String sUserName = getEntityName(sUserId, PM_NODE_USER);
                if (sUserName == null) {
                    continue;
                }
                sb.append(sUserName);
                result.addItem(ItemType.RESPONSE_TEXT, sb.toString());
                System.out.println(sb.toString());
            }
            return result;
        } catch (Exception e) {
            if (debugFlag) {
                e.printStackTrace();
            }
            return failurePacket("Exception while looking for the keystore paths");
        }
    }

    // Set the paths of the key and trust stores for a user on a host.
    private Packet setKStorePaths(String sSessId, String sUserId, String sHost,
                                  String sKsPath, String sTsPath) {
        // First delete all records for user and host.
        NamingEnumeration<?> configs;

        // Find and delete the user config records for the given host and user.
        try {
            SearchControls constraints = new SearchControls();
            constraints.setSearchScope(SearchControls.ONELEVEL_SCOPE);
            constraints.setReturningAttributes(new String[]{"pmId",
                    "pmAtoolPath", "pmRtfedPath"});
            configs = ctx.search(sUserConfigContainerDN, "(&(pmHost=" + sHost
                    + ")(pmUserId=" + sUserId + "))", constraints);
            while (configs != null && configs.hasMore()) {
                SearchResult sr = (SearchResult) configs.next();
                String sId = (String) sr.getAttributes().get("pmId").get();
                ctx.destroySubcontext("CN=" + sId + ","
                        + sUserConfigContainerDN);
            }

            // Add a new record for the given host and user.
            Attributes attrs = new BasicAttributes(true);
            RandomGUID myGUID = new RandomGUID();
            String sId = myGUID.toStringNoDashes();
            attrs.put("objectClass", sUserConfigClass);
            attrs.put("pmId", sId);
            attrs.put("pmUserId", sUserId);
            attrs.put("pmHost", sHost);
            if (sKsPath != null && sKsPath.length() > 0) {
                attrs.put("pmKsPath", sKsPath);
            }
            if (sTsPath != null && sTsPath.length() > 0) {
                attrs.put("pmTsPath", sTsPath);
            }
            ctx.bind("CN=" + sId + "," + sUserConfigContainerDN, null, attrs);
            return successPacket();
        } catch (Exception e) {
            if (debugFlag) {
                e.printStackTrace();
            }
            return failurePacket("Exception in engine's setAppPaths for "
                    + sHost);
        }
    }

    // The items in cmdPacket contain:
    // item 0: cmd code "importConfiguration".
    // item 1: <session id>
    // item 2,3...: the script.
    private Packet importConfiguration(String sSessId, Packet cmdPacket) {
        Packet res;
        Vector<String> delayedLines = new Vector<String>();

        for (int i = 2; i < cmdPacket.size(); i++) {
            String sLine = cmdPacket.getStringValue(i);
            if (sLine.length() <= 0
                    || sLine.startsWith(PM_IMPORT_COMMENT_START)) {
                continue;
            }

            res =  interpretCmd(sSessId, sLine);
            if (res == null) {
                return failurePacket("Null result returned from command "
                        + sLine);
            }
            if (res.hasError()) {
                delayedLines.addElement(sLine);
                continue;
            }
        }
        for (int i = 0; i < delayedLines.size(); i++) {
            String sLine = delayedLines.get(i);
            res =  interpretCmd(sSessId, sLine);
            if (res == null) {
                return failurePacket("Null result returned from command "
                        + sLine);
            }
            if (res.hasError()) {
                return res;
            }
        }
        return successPacket();
    }

    private Packet interpretCmd(String sSessId, String sCmd) {
        String[] pieces = sCmd.split(PM_ALT_DELIM_PATTERN);
        String sOpCode = pieces[0];
        String sPrimType = pieces[1];

        // Dispatch command according to its code and primary operand type.
        if (sOpCode.equals("add")) {
            if (sPrimType.equals(PM_OBJ_CLASS)) {
                return cmdAddObjClass(sSessId, sCmd);
            } else if (sPrimType.equals(PM_OP)) {
                return cmdAddOp(sSessId, sCmd);
            } else if (sPrimType.equals(PM_NODE_OPSET)) {
                return cmdAddOpset(sSessId, sCmd);
            } else if (sPrimType.equals(PM_NODE_POL)) {
                return cmdAddPc(sSessId, sCmd);
            } else if (sPrimType.equals(PM_NODE_UATTR)) {
                return cmdAddUattr(sSessId, sCmd);
            } else if (sPrimType.equals(PM_NODE_USER)) {
                return cmdAddUser(sSessId, sCmd);
            } else if (sPrimType.equals(PM_EMAIL_ACCT)) {
                return cmdAddEmail(sSessId, sCmd);
            } else if (sPrimType.equals(PM_NODE_OATTR)) {
                return cmdAddOattr(sSessId, sCmd);
            } else if (sPrimType.equals(PM_COMPL_OATTR)) {
                return cmdAddComplOattr(sSessId, sCmd);
            } else if (sPrimType.equals(PM_OBJ)) {
                return cmdAddObj(sSessId, sCmd);
            } else if (sPrimType.equals(PM_ASET)) {
                return cmdAddAset(sSessId, sCmd);
            } else if (sPrimType.equals(PM_SAC)) {
                return cmdAddSac(sSessId, sCmd);
            } else if (sPrimType.equals(PM_APP_PATH)) {
                return cmdAddApplication(sSessId, sCmd);
            } else if (sPrimType.equals(PM_KS_PATH)) {
                return cmdAddKStores(sSessId, sCmd);
            } else if (sPrimType.equals(PM_PROP)) {
                return cmdAddProp(sSessId, sCmd);
            } else if (sPrimType.equals(PM_DENY)) {
                return cmdAddDeny(sSessId, sCmd);
            } else if (sPrimType.equals(PM_TASK)) {
                return cmdAddTask(sSessId, sCmd);
            } else if (sPrimType.equals(PM_CAP)) {
                return cmdAddCap(sSessId, sCmd);
            } else if (sPrimType.equals(PM_SCON)) {
                return cmdAddScon(sSessId, sCmd);
            } else if (sPrimType.equals(PM_TEMPLATE)) {
                return cmdAddTpl(sSessId, sCmd);
            } else if (sPrimType.equals(PM_KEY)) {
                return cmdAddKey(sSessId, sCmd);
            } else if (sPrimType.equals(PM_COMPONENTS)) {
                return cmdAddComps(sSessId, sCmd);
            }
        } else if (sOpCode.equals("asg")) {
            return assign(sSessId, sCmd);
        }
        return failurePacket("Invalid command code and/or primary operand type: "
                + sCmd);
    }

    // Process:
    // add|comps|<components>|b|<record name>
    // <components> is a list of object names separated by ":".
    // <record name> is the name of a record (formerly a composite object).
    // All - the record and the components - must already exist.
    private Packet cmdAddComps(String sSessId, String sCmd) {
        String[] pieces = sCmd.split(PM_ALT_DELIM_PATTERN);
        String sComps = pieces[2];
        if (sComps == null || sComps.length() <= 0) {
            return successPacket();
        }
        String sRecId = getEntityId(pieces[4], PM_NODE_OATTR);
        if (sRecId == null) {
            return failurePacket("No such record " + pieces[4]);
        }

        boolean first = true;
        StringBuilder sb = new StringBuilder();
        String[] splinters = sComps.split(PM_FIELD_DELIM);
        for (String splinter : splinters) {
            String sOattrId = getEntityId(splinter, PM_NODE_OATTR);
            if (sOattrId == null) {
                return failurePacket("No such object (attribute) "
                        + splinter);
            }
            if (first) {
                first = false;
                sb.append(sOattrId);
            } else {
                sb.append(PM_FIELD_DELIM).append(sOattrId);
            }
        }

        ModificationItem[] mods = new ModificationItem[1];
        mods[0] = new ModificationItem(DirContext.ADD_ATTRIBUTE,
                new BasicAttribute("pmComponents", sb.toString()));
        try {
            ctx.modifyAttributes("CN=" + sRecId + "," + sObjAttrContainerDN,
                    mods);
            return successPacket();
        } catch (Exception e) {
            e.printStackTrace();
            return failurePacket("Couldn't add the components to object "
                    + pieces[4]);
        }
    }

    // Process:
    // add|tpl|<tpl name>|conts|<containers>
    // add|tpl|<tpl name>|b|<record name>
    //
    // <containers> is a list of container names separated by ":".
    // First command creates a template.
    // The second command adds an existing template to an existing object.
    private Packet cmdAddTpl(String sSessId, String sCmd) {
        String[] pieces = sCmd.split(PM_ALT_DELIM_PATTERN);
        String sTplName = pieces[2];
        String sType = pieces[3];
        if (sType.equals(PM_CONTAINERS)) {
            String containers = pieces[4];
            String[] splinters = containers.split(PM_FIELD_DELIM);
            boolean first = true;
            StringBuffer sb = new StringBuffer();
            for (int i = 0; i < splinters.length; i++) {
                if (first) {
                    first = false;
                    sb.append(getEntityId(splinters[i], PM_NODE_OATTR));
                } else {
                    sb.append(PM_FIELD_DELIM
                            + getEntityId(splinters[i], PM_NODE_OATTR));
                }
            }
            return addTemplate(sSessId, sTplName, sb.toString(), null);
        } else if (sType.equals(PM_NODE_OATTR)) {
            String sRecId = getEntityId(pieces[4], PM_NODE_OATTR);
            if (sRecId == null) {
                return failurePacket("No such object attribute (record) "
                        + pieces[4]);
            }
            String sTplId = getEntityId(sTplName, PM_TEMPLATE);
            if (sTplId == null) {
                return failurePacket("No such template " + sTplName);
            }

            ModificationItem[] mods = new ModificationItem[1];
            mods[0] = new ModificationItem(DirContext.ADD_ATTRIBUTE,
                    new BasicAttribute("pmTemplateId", sTplId));
            try {
                ctx.modifyAttributes(
                        "CN=" + sRecId + "," + sObjAttrContainerDN, mods);
                return successPacket();
            } catch (Exception e) {
                e.printStackTrace();
                return failurePacket("Couldn't add the template " + sTplName
                        + " to object attribute (record) " + pieces[4]);
            }
        } else {
            return failurePacket("Wrong type in cmdAddTpl(): " + sType);
        }
    }

    // add|key|<key>|tpl|<tpl name>
    // add|key|<key>|b|<record name>
    private Packet cmdAddKey(String sSessId, String sCmd) {
        String[] pieces = sCmd.split(PM_ALT_DELIM_PATTERN);
        String sKey = pieces[2];
        String sType = pieces[3];
        if (sType.equals(PM_TEMPLATE)) {
            String sTplId = getEntityId(pieces[4], PM_TEMPLATE);
            if (sTplId == null) {
                return failurePacket("No template " + pieces[4]);
            }
            return addTemplateKey(sSessId, sTplId, sKey);
        } else if (sType.equals(PM_NODE_OATTR)) {
            String sRecId = getEntityId(pieces[4], PM_NODE_OATTR);
            if (sRecId == null) {
                return failurePacket("No object attribute (record) "
                        + pieces[4]);
            }
            return addRecordKey(sSessId, sRecId, sKey);
        } else {
            return failurePacket("Trying to add a key to entity of unknown type "
                    + sType);
        }
    }

    // Process add|sc|<scon name>|<k>
    private Packet cmdAddScon(String sSessId, String sCmd) {
        String[] pieces = sCmd.split(PM_ALT_DELIM_PATTERN);
        String sSconName = pieces[2];
        String sK = pieces[3];
        return addScon(sSessId, sSconName, sK, null);
    }

    // Process add|cap|<op name>|<obj name>|<pc name>|tk|<task name>
    private Packet cmdAddCap(String sSessId, String sCmd) {
        String[] pieces = sCmd.split(PM_ALT_DELIM_PATTERN);
        String sOpName = pieces[2];
        String sObjName = pieces[3];
        String sPcName = pieces[4];
        String sTaskName = pieces[6];

        return addTask(sSessId, sTaskName, sOpName, sObjName, sPcName);
    }

    // Process:
    // add|tk|<task name>
    // add|tk|<task name>|sc|<scon name>
    private Packet cmdAddTask(String sSessId, String sCmd) {
        String[] pieces = sCmd.split(PM_ALT_DELIM_PATTERN);
        String sTaskName = pieces[2];
        if (pieces.length >= 5) {
            // Add an existing task to a scon.
            String sId = getEntityId(sTaskName, PM_TASK);
            if (sId == null) {
                return failurePacket("No such task " + sTaskName);
            }
            return addScon(sSessId, pieces[4], null, sTaskName);
        }
        return addTask(sSessId, sTaskName, null, null, null);
    }

    // Note that adding a session or process deny via a script makes no sense.
    // Process add|deny|<deny name>|<deny type>|<user or attr>|<user or attr
    // name>|<is intersection>
    // where:
    // <deny type> ::=
    // PM_DENY_USER_ID|PM_DENY_INTRA_SESSION|PM_DENY_ACROSS_SESSIONS
    // <user or attr> ::= u|a
    // <is intersection> ::= yes|no
    private Packet cmdAddDeny(String sSessId, String sCmd) {
        String[] pieces = sCmd.split(PM_ALT_DELIM_PATTERN);
        String sDenyName = pieces[2];
        String sDenyType = pieces[3];
        String sNameType = pieces[4];
        String sName = pieces[5];
        String sIsInters = pieces[6];
        String sId = getEntityId(sName, sNameType);
        if (sId == null) {
            return failurePacket("No entity " + sName + " of type " + sNameType);
        }
        return addDenyInternal(sDenyName, sDenyType, sName, null, null, null,
                null, sIsInters.equalsIgnoreCase("yes"));
    }

    // Process add|prop|<property>|{a|b|p|v}|<attribute or policy or value>
    private Packet cmdAddProp(String sSessId, String sCmd) {
        String[] pieces = sCmd.split(PM_ALT_DELIM_PATTERN);
        String sProp = pieces[2];
        String sType = pieces[3];
        String sName = pieces[4];
        if (sType.equals(PM_VALUE)) {
            return setProperty(null, sProp, sName);
        }
        String sId = getEntityId(sName, sType);
        if (sId == null) {
            return failurePacket("No entity " + sName + " of type " + sType);
        }
        return addPropInternal(sId, sType, sProp);
    }

    // Process add|ks|<key store path>|<trust store path>|h|<host>|u|<user>
    private Packet cmdAddKStores(String sSessId, String sCmd) {
        String[] pieces = sCmd.split(PM_ALT_DELIM_PATTERN);
        String sKsPath = pieces[2];
        String sTsPath = pieces[3];
        String sHost = pieces[5];
        String sUser = pieces[7];
        String sUserId = getEntityId(sUser, PM_NODE_USER);
        return setKStorePaths(sSessId, sUserId, sHost, sKsPath, sTsPath);
    }

    // Process add|app|<admin tool path>|<editor path>|<workflow path>|
    // <email path>|<exporter path>|<launcher path>|<msoffice path>|
    // <medrec path>|<acctrec path>|h|<host>
    /*private Packet cmdAddApps(String sSessId, String sCmd) {
    String[] pieces = sCmd.split(PM_ALT_DELIM_PATTERN);
    String sAtoolPath = pieces[2];
    String sRtfedPath = pieces[3];
    String sWkfPath = pieces[4];
    String sEmlPath = pieces[5];
    String sExpPath = pieces[6];
    String sLauncherPath = pieces[7];
    String sMsofficePath = pieces[8];
    String sMedrecPath = pieces[9];
    String sAcctrecPath = pieces[10];
    String sHost = pieces[12];
    return setHostAppPaths(sSessId, sHost, sAtoolPath, sRtfedPath,
    sWkfPath, sEmlPath, sExpPath, sLauncherPath, sMsofficePath,
    sMedrecPath, sAcctrecPath);
    }*/
    private Packet cmdAddApplication(String sSessId, String sCmd) {
        String[] pieces = sCmd.split(PM_ALT_DELIM_PATTERN);
        String appName = pieces[2];
        String appPath = pieces[3];
        String appMainClass = pieces[4];
        String appPrefix = pieces[5];
        String sHost = pieces[6];
        return addHostApp(sSessId, sHost, appName, appPath, appMainClass, appPrefix);
    }

    // Process add|PM_SAC|<sac name>|<sac type>
    // <sac type> ::= PM_DENY_INTRA_SESSION|PM_DENY_ACROSS_SESSIONS
    private Packet cmdAddSac(String sClientId, String sCmd) {
        String[] pieces = sCmd.split(PM_ALT_DELIM_PATTERN);
        String sSac = pieces[2];
        String sType = pieces[3];
        return addSacAndAset(sClientId, sSac, sType, null, null);
    }

    // Process:
    // add|as|<attribute set>
    // add|as|<attribute set>|sa|<sac>
    private Packet cmdAddAset(String sClientId, String sCmd) {
        String[] pieces = sCmd.split(PM_ALT_DELIM_PATTERN);
        String sAset = pieces[2];
        if (pieces.length >= 5) {
            // Add an existing aset to a sac.
            String sId = getEntityId(sAset, PM_ASET);
            if (sId == null) {
                return failurePacket("No entity " + sAset + " of class "
                        + PM_ASET);
            }
            return addSacAndAset(sClientId, pieces[4], null, sId, sAset);
        }
        return addAsetAndAttr(sClientId, sAset, null, null);
    }

    // Process add|ob|<object>|<class>|<inh>|<host or orig name>|<path or
    // ignored>|p|<policy class>
    // add|ob|<object>|<class>|<inh>|<host or orig name>|<path or
    // ignored>|c|<connector>
    // add|ob|<object>|<class>|<inh>|<host or orig name>|<path or
    // ignored>|b|<object attribute>
    // <inh> is "yes" or "no".
    // <class> is File, Directory, User, User attribute, Object, Object
    // attribute,
    // Policy class, Connector, Operation set, or a custom class name.
    private Packet cmdAddObj(String sClientId, String sCmd) {
        String[] pieces = sCmd.split(PM_ALT_DELIM_PATTERN);
        String sObj = pieces[2];
        String sClass = pieces[3];
        String sInh = pieces[4];
        String sHost = pieces[5];
        String sPath = pieces[6];
        String sToType = pieces[7];
        String sToName = pieces[8];
        String sToId = getEntityId(sToName, sToType);
        String sOrigId = null;
        String sOrigName = null;

        if (sToId == null) {
            return failurePacket("No entity " + sToName + " of type " + sToType);
        }
        if (sClass.equals(PM_CLASS_USER_NAME)
                || sClass.equals(PM_CLASS_UATTR_NAME)
                || sClass.equals(PM_CLASS_OBJ_NAME)
                || sClass.equals(PM_CLASS_OATTR_NAME)
                || sClass.equals(PM_CLASS_POL_NAME)
                || sClass.equals(PM_CLASS_CONN_NAME)
                || sClass.equals(PM_CLASS_OPSET_NAME)) {
            sOrigName = sHost;
            sOrigId = getEntityId(sOrigName, classToType(sClass));
            if (sOrigId == null) {
                return failurePacket("No entity " + sHost + " of class "
                        + sClass);
            }
        }
        try {
            return addObjectInternal(sObj, null, null, sObj, sObj, sToId,
                    sToType, sClass, null, sHost, sPath, sOrigName, sOrigId,
                    (sInh.equalsIgnoreCase("yes")), null, null, null, null,
                    null, null, null);
        } catch (Exception e) {
            if (debugFlag) {
                e.printStackTrace();
            }
            return failurePacket("Exception while adding object: "
                    + e.getMessage());
        }
    }

    // Process add|b|<object attribute>|c|<connector>
    // add|b|<object attribute>|p|<policy class>
    // add|b|<object attribute>|b|<object attribute>
    // add|b|<object attribute>|deny|<deny constraint>
    private Packet cmdAddOattr(String sClientId, String sCmd) {
        String[] pieces = sCmd.split(PM_ALT_DELIM_PATTERN);
        String sOattr = pieces[2];
        String sToType = pieces[3];
        String sToName = pieces[4];
        String sToId = getEntityId(sToName, sToType);
        if (sToId == null) {
            return failurePacket("No entity " + sToName + " of type " + sToType);
        }

        // Note that in the case of adding the object attribute to a deny, the
        // object attribute must already exist!
        if (sToType.equalsIgnoreCase(PM_DENY)) {
            String sOattrId = getEntityId(sOattr, PM_NODE_OATTR);
            if (sOattrId == null) {
                return failurePacket("No object attribute " + sOattr);
            }
            return addDenyInternal(sToName, null, null, null, null, sOattr,
                    sOattrId, false);
        } else {
            return addOattrInternal(sOattr, null, sOattr, sOattr, sToId,
                    sToType, null, null);
        }
    }

    // Process add|cb|<object attribute>|deny|<deny constraint>,
    // i.e., the complement of an object attribute.
    private Packet cmdAddComplOattr(String sClientId, String sCmd) {
        String[] pieces = sCmd.split(PM_ALT_DELIM_PATTERN);
        String sToType = pieces[3];
        String sToName = pieces[4];
        if (!sToType.equalsIgnoreCase(PM_DENY)) {
            return failurePacket("Entity " + sToName
                    + " is not a deny constraint!");
        }
        String sOattrId = getEntityId(pieces[2], PM_NODE_OATTR);
        if (sOattrId == null) {
            return failurePacket("No object attribute " + pieces[2]);
        }
        String sOattr = "!" + pieces[2];
        return addDenyInternal(sToName, null, null, null, null, sOattr,
                sOattrId, false);
    }

    // Process add|eml|<coming from>|<email addr>|<pop server>|<smtp server>|
    // <acct name>|<password>|u|<user name>
    private Packet cmdAddEmail(String sClientId, String sCmd) {
        String[] pieces = sCmd.split(PM_ALT_DELIM_PATTERN);
        String sToType = pieces[8];// must be a user
        String sToName = pieces[9];
        String sToId = getEntityId(sToName, sToType);
        if (sToId == null) {
            return failurePacket("No entity " + sToName + " of type " + sToType);
        }
        return addEmailAcctInternal(sToName, pieces[2], pieces[3], pieces[4],
                pieces[5], pieces[6], pieces[7]);
    }

    // Process add|u|<user>|fn|<full name>|c|<connector>
    // add|u|<user>|fn|<full name>|a|<user attribute>
    private Packet cmdAddUser(String sClientId, String sCmd) {
        String[] pieces = sCmd.split(PM_ALT_DELIM_PATTERN);
        String sUser = pieces[2];
        String sFull = pieces[4];
        String sToType = pieces[5];
        String sToName = pieces[6];
        String sToId = getEntityId(sToName, sToType);
        if (sToId == null) {
            return failurePacket("No entity " + sToName + " of type " + sToType);
        }
        return addUserInternal(sUser, null, sFull, sUser, sUser, sToId, sToType);
    }

    // Process add|a|<user attribute>|c|<connector>
    // add|a|<user attribute>|p|<policy class>
    // add|a|<user attribute>|a|<user attribute>
    // add|a|<user attribute>|u|<user>
    // add|a|<user attribute>|as|<attribute set>
    private Packet cmdAddUattr(String sSessId, String sCmd) {
        String[] pieces = sCmd.split(PM_ALT_DELIM_PATTERN);
        String sUattr = pieces[2];
        String sToType = pieces[3];
        String sToName = pieces[4];
        String sToId = getEntityId(sToName, sToType);
        if (sToId == null) {
            return failurePacket("No entity " + sToName + " of type " + sToType);
        }
        if (sToType.equals(PM_ASET)) {
            // We have to add an attribute to an attribute set.
            // The attribute must exist.
            String sUattrId = getEntityId(sUattr, PM_NODE_UATTR);
            if (sUattrId == null) {
                return failurePacket("No entity " + sUattr + " of type "
                        + PM_NODE_UATTR);
            }
            return addAsetAndAttr(sSessId, sToName, sUattrId, sUattr);
        }
        return addUattrInternal(sUattr, sUattr, sUattr, sToId, sToType, null);
    }

    // Process add|p|<policy class>|c|<connector>
    private Packet cmdAddPc(String sClientId, String sCmd) {
        String[] pieces = sCmd.split(PM_ALT_DELIM_PATTERN);
        String sPol = pieces[2];
        return addPcInternal(sPol, null, sPol, sPol, null);
    }

    // Process add|s|<operation set>|oc|<object class>|a|<user attribute>,
    // add|s|<operation set>|oc|<object class>|b|<object attribute>, and
    // add|s|<operation set>|oc|<object class>|c|<connector>.
    @SuppressWarnings("unused")
    private Packet cmdAddOpset(String sClientId, String sCmd) {
        String[] pieces = sCmd.split(PM_ALT_DELIM_PATTERN);
        String sOpset = pieces[2];
        String sClass = pieces[4];// ignored
        String sToType = pieces[5];
        String sToName = pieces[6];
        String sToId = getEntityId(sToName, sToType);
        if (sToId == null) {
            return failurePacket("No entity " + sToName + " of type " + sToType);
        }
        if (sToType.equalsIgnoreCase(PM_NODE_UATTR)) {
            return addOpsetAndOpInternal(sOpset, null, sOpset, sOpset, null,
                    sToId, sToType, null, null);
        } else if (sToType.equalsIgnoreCase(PM_NODE_OATTR)
                || sToType.equalsIgnoreCase(PM_NODE_CONN)) {
            return addOpsetAndOpInternal(sOpset, null, sOpset, sOpset, null,
                    null, null, sToId, sToType);
        } else {
            return failurePacket("Incorrect base type in command " + sCmd);
        }
    }

    // Process add|oc|<object class>
    private Packet cmdAddObjClass(String sClientId, String sCmd) {
        String[] pieces = sCmd.split(PM_ALT_DELIM_PATTERN);
        String sClass = pieces[2];
        if (sClass == null || sClass.length() == 0) {
            return failurePacket("Invalid or null object class name");
        }
        return addObjClassAndOp(sClientId, sClass, sClass, sClass, null);
    }

    // Process add|op|<operation>|oc|<object class>
    // add|op|<operation>|s|<operation set>
    // add|op|<operation>|deny|<deny constraint>
    private Packet cmdAddOp(String sClientId, String sCmd) {
        String[] pieces = sCmd.split(PM_ALT_DELIM_PATTERN);
        String sOp = pieces[2];
        String sToType = pieces[3];
        String sToName = pieces[4];
        if (sToType.equals(PM_OBJ_CLASS)) {
            return addObjClassAndOp(sClientId, sToName, sToName, sToName, sOp);
        } else if (sToType.equals(PM_NODE_OPSET)) {
            return addOpsetAndOpInternal(sToName, null, null, null, sOp, null,
                    null, null, null);
        } else if (sToType.equals(PM_DENY)) {
            return addDenyInternal(sToName, null, null, null, sOp, null, null,
                    false);
        }
        return failurePacket("Not yet implemented");
    }

    // Process assignments:
    // asg|u|<user>|a|<user attribute>
    //
    // asg|a|<user attribute>|a|<user attribute>
    // asg|a|<user attribute>|p|<policy class>
    // asg|a|<user attribute>|s|<operation set>
    //
    // asg|b|<object attribute>|b|<object attribute>
    // asg|b|<object attribute>|p|<policy class>
    //
    // asg|s|<operation set>|b|<object attribute>
    private Packet assign(String sClientId, String sCmd) {
        String[] pieces = sCmd.split(PM_ALT_DELIM_PATTERN);
        String sType = pieces[1];
        String sName = pieces[2];
        String sToType = pieces[3];
        String sToName = pieces[4];
        String sId = getEntityId(sName, sType);
        if (sId == null) {
            return failurePacket("No entity " + sName + " of type " + sType);
        }
        String sToId = getEntityId(sToName, sToType);
        if (sToId == null) {
            return failurePacket("No entity " + sToName + " of type " + sToType);
        }
        return assignInternal(sId, sType, sToId, sToType);
    }

    /**
	 * @uml.property  name="savedRecords"
	 * @uml.associationEnd  multiplicity="(0 -1)" elementType="java.lang.String"
	 */
    HashSet<String> savedRecords = null;

    private Packet export(String sClientId, String sSessId) {
        if (savedRecords == null) {
            savedRecords = new HashSet<String>();
        }
        savedRecords.clear();

        HashSet<String> visitedSet = new HashSet<String>();
        ArrayList<QueueElement> queue = new ArrayList<QueueElement>();
        QueueElement qe, crtQe;
        String sId = null;
        Packet result = new Packet();
        Packet ar, ar2;

        // Export the object classes.
        try {
            ar =  getObjClasses(sClientId);
            if (ar == null) {
                return failurePacket("Null result to getObjClasses");
            }
            for (int i = 0; i < ar.size(); i++) {
                String sClass = ar.getStringValue(i);

                // Exclude the predefined classes.
                if (sClass.equals(PM_CLASS_FILE_NAME)
                        || sClass.equals(PM_CLASS_DIR_NAME)
                        || sClass.equals(PM_CLASS_USER_NAME)
                        || sClass.equals(PM_CLASS_UATTR_NAME)
                        || sClass.equals(PM_CLASS_OBJ_NAME)
                        || sClass.equals(PM_CLASS_OATTR_NAME)
                        || sClass.equals(PM_CLASS_POL_NAME)
                        || sClass.equals(PM_CLASS_CONN_NAME)
                        || sClass.equals(PM_CLASS_OPSET_NAME)
                        || sClass.equals(PM_CLASS_CLASS_NAME)
                        || sClass.equals(PM_CLASS_ANY_NAME)) {
                    continue;
                }

                result.addItem(ItemType.RESPONSE_TEXT, "add"
                        + PM_ALT_FIELD_DELIM + PM_OBJ_CLASS
                        + PM_ALT_FIELD_DELIM + sClass);
                ar2 =  getObjClassOps(sClientId, sClass);
                for (int j = 0; j < ar2.size() - 1; j++) {
                    String sOp = ar2.getStringValue(j);
                    result.addItem(ItemType.RESPONSE_TEXT, "add"
                            + PM_ALT_FIELD_DELIM + PM_OP + PM_ALT_FIELD_DELIM
                            + sOp + PM_ALT_FIELD_DELIM + PM_OBJ_CLASS
                            + PM_ALT_FIELD_DELIM + sClass);
                }
            }
        } catch (Exception e) {
            if (debugFlag) {
                e.printStackTrace();
            }
            return failurePacket("Exception in getObjClasses or getObjClassOps: "
                    + e.getMessage());
        }

        // Export the main PM graph.

        // Start by inserting the connector in the queue.
        crtQe = new QueueElement(PM_NODE_CONN, PM_CONNECTOR_ID, 0);
        queue.add(crtQe);

        try {
            while (!queue.isEmpty()) {
                // Extract the next node from the queue.
                crtQe = queue.remove(0);

                if (debugFlag) {
                    System.out.println("Out of queue: "
                            + getEntityName(crtQe.getId(), crtQe.getType())
                            + " type " + crtQe.getType());
                }
                // Examine its type.
                if (crtQe.getType().equalsIgnoreCase(PM_NODE_CONN)) {
                    // The current node is a CONNECTOR NODE.

                    // Process the policy classes assigned to the connector
                    // node.
                    Attribute attr = getFromPolicies(crtQe);
                    if (attr != null) {
                        for (NamingEnumeration<?> attrEnum = attr.getAll(); attrEnum.hasMore(); ) {
                            sId = (String) attrEnum.next();
                            String sName = getEntityName(sId, PM_NODE_POL);

                            // Don't list the "admin" policy class, but insert
                            // it into the queue.
                            if (!visitedSet.contains(sId)) {
                                qe = new QueueElement(PM_NODE_POL, sId, 0);
                                queue.add(qe);
                                if (sName.equals(PM_ADMIN_NAME)) {
                                    continue;
                                }
                                exportPc(result, sId);
                                visitedSet.add(sId);
                            } else {
                                result.addItem(ItemType.RESPONSE_TEXT, "asg"
                                        + PM_ALT_FIELD_DELIM + PM_NODE_POL
                                        + PM_ALT_FIELD_DELIM + sName
                                        + PM_ALT_FIELD_DELIM + PM_NODE_CONN
                                        + PM_ALT_FIELD_DELIM
                                        + PM_CONNECTOR_NAME);
                            }
                        }
                    }

                    // Process the user attributes assigned to the connector
                    // node.
                    attr = getFromUserAttrs(crtQe);
                    if (attr != null) {
                        for (NamingEnumeration<?> attrEnum = attr.getAll(); attrEnum.hasMore(); ) {
                            sId = (String) attrEnum.next();
                            if (!visitedSet.contains(sId)) {
                                qe = new QueueElement(PM_NODE_UATTR, sId, 0);
                                queue.add(qe);
                                exportUattr(result, sId, PM_NODE_CONN,
                                        PM_CONNECTOR_NAME);
                                visitedSet.add(sId);
                            } else {
                                result.addItem(
                                        ItemType.RESPONSE_TEXT,
                                        "asg"
                                                + PM_ALT_FIELD_DELIM
                                                + PM_NODE_UATTR
                                                + PM_ALT_FIELD_DELIM
                                                + getEntityName(sId,
                                                PM_NODE_UATTR)
                                                + PM_ALT_FIELD_DELIM
                                                + PM_NODE_CONN
                                                + PM_ALT_FIELD_DELIM
                                                + PM_CONNECTOR_NAME);
                            }
                        }
                    }

                    // Process the users assigned to the connector node.
                    attr = getFromUsers(crtQe);
                    if (attr != null) {
                        for (NamingEnumeration<?> attrEnum = attr.getAll(); attrEnum.hasMore(); ) {
                            sId = (String) attrEnum.next();
                            if (!visitedSet.contains(sId)) {
                                qe = new QueueElement(PM_NODE_USER, sId, 0);
                                queue.add(qe);
                                exportUser(result, sId, PM_NODE_CONN,
                                        PM_CONNECTOR_NAME);
                                visitedSet.add(sId);
                            } else {
                                result.addItem(
                                        ItemType.RESPONSE_TEXT,
                                        "asg"
                                                + PM_ALT_FIELD_DELIM
                                                + PM_NODE_USER
                                                + PM_ALT_FIELD_DELIM
                                                + getEntityName(sId,
                                                PM_NODE_USER)
                                                + PM_ALT_FIELD_DELIM
                                                + PM_NODE_CONN
                                                + PM_ALT_FIELD_DELIM
                                                + PM_CONNECTOR_NAME);
                            }
                        }
                    }

                    // Process the object attributes assigned to the connector
                    // node.
                    attr = getFromObjAttrs(crtQe);
                    if (attr != null) {
                        for (NamingEnumeration<?> attrEnum = attr.getAll(); attrEnum.hasMore(); ) {
                            sId = (String) attrEnum.next();
                            if (!visitedSet.contains(sId)) {
                                qe = new QueueElement(PM_NODE_OATTR, sId, 0);
                                queue.add(qe);
                                exportOattr(result, sId, PM_NODE_CONN,
                                        PM_CONNECTOR_NAME);
                                visitedSet.add(sId);
                            } else {
                                result.addItem(
                                        ItemType.RESPONSE_TEXT,
                                        "asg"
                                                + PM_ALT_FIELD_DELIM
                                                + PM_NODE_OATTR
                                                + PM_ALT_FIELD_DELIM
                                                + getEntityName(sId,
                                                PM_NODE_OATTR)
                                                + PM_ALT_FIELD_DELIM
                                                + PM_NODE_CONN
                                                + PM_ALT_FIELD_DELIM
                                                + PM_CONNECTOR_NAME);
                            }
                        }
                    }

                    // Process the operation sets assigned to the connector
                    // node.
                    attr = getFromOpsets(crtQe);
                    if (attr != null) {
                        for (NamingEnumeration<?> attrEnum = attr.getAll(); attrEnum.hasMore(); ) {
                            sId = (String) attrEnum.next();
                            String sName = getEntityName(sId, PM_NODE_OPSET);

                            if (!visitedSet.contains(sId)) {
                                qe = new QueueElement(PM_NODE_OPSET, sId, 0);
                                queue.add(qe);

                                // Get its class.
                                String sClass = "Ignored";
                                result.addItem(ItemType.RESPONSE_TEXT, "add"
                                        + PM_ALT_FIELD_DELIM + PM_NODE_OPSET
                                        + PM_ALT_FIELD_DELIM + sName
                                        + PM_ALT_FIELD_DELIM + PM_OBJ_CLASS
                                        + PM_ALT_FIELD_DELIM + sClass
                                        + PM_ALT_FIELD_DELIM + PM_NODE_CONN
                                        + PM_ALT_FIELD_DELIM
                                        + PM_CONNECTOR_NAME);
                                visitedSet.add(sId);

                                // Get its operations.
                                ar =  getOpsetOps(sClientId, sName);
                                if (ar == null) {
                                    return failurePacket("Null result from getOpsetOps");
                                }
                                for (int i = 0; i < ar.size(); i++) {
                                    String sOp = ar.getStringValue(i);
                                    result.addItem(ItemType.RESPONSE_TEXT,
                                            "add" + PM_ALT_FIELD_DELIM + PM_OP
                                                    + PM_ALT_FIELD_DELIM + sOp
                                                    + PM_ALT_FIELD_DELIM
                                                    + PM_NODE_OPSET
                                                    + PM_ALT_FIELD_DELIM
                                                    + sName);
                                }
                            } else {
                                result.addItem(ItemType.RESPONSE_TEXT, "asg"
                                        + PM_ALT_FIELD_DELIM + PM_NODE_OPSET
                                        + PM_ALT_FIELD_DELIM + sName
                                        + PM_ALT_FIELD_DELIM + PM_NODE_CONN
                                        + PM_ALT_FIELD_DELIM
                                        + PM_CONNECTOR_NAME);
                            }
                        }
                    }
                } else if (crtQe.getType().equalsIgnoreCase(PM_NODE_POL)) {

                    // The current node is a POLICY CLASS node.
                    String sCrtName = getEntityName(crtQe.getId(),
                            crtQe.getType());

                    // Process the user attributes assigned to the policy class.
                    Attribute attr = getFromUserAttrs(crtQe);
                    if (attr != null) {
                        for (NamingEnumeration<?> attrEnum = attr.getAll(); attrEnum.hasMore(); ) {
                            sId = (String) attrEnum.next();
                            String sName = getEntityName(sId, PM_NODE_UATTR);

                            // The "superAdmin" attribute has special treatment:
                            // Do not generate "add superAdmin" to any entity.
                            // Generate "asg superAdmin" to any pc such that
                            // superAdmin-->pc
                            // and pc != admin.
                            // Insert superAdmin into the queue.
                            if (sName.equals(PM_SUPER_ADMIN_NAME)) {
                                if (!visitedSet.contains(sId)) {
                                    qe = new QueueElement(PM_NODE_UATTR, sId, 0);
                                    queue.add(qe);
                                    visitedSet.add(sId);
                                }
                                if (!sCrtName.equals(PM_ADMIN_NAME)) {
                                    result.addItem(ItemType.RESPONSE_TEXT,
                                            "asg" + PM_ALT_FIELD_DELIM
                                                    + PM_NODE_UATTR
                                                    + PM_ALT_FIELD_DELIM
                                                    + sName
                                                    + PM_ALT_FIELD_DELIM
                                                    + PM_NODE_POL
                                                    + PM_ALT_FIELD_DELIM
                                                    + sCrtName);
                                }
                            } else {
                                if (!visitedSet.contains(sId)) {
                                    qe = new QueueElement(PM_NODE_UATTR, sId, 0);
                                    queue.add(qe);
                                    exportUattr(result, sId, PM_NODE_POL,
                                            sCrtName);
                                    visitedSet.add(sId);
                                } else {
                                    result.addItem(ItemType.RESPONSE_TEXT,
                                            "asg" + PM_ALT_FIELD_DELIM
                                                    + PM_NODE_UATTR
                                                    + PM_ALT_FIELD_DELIM
                                                    + sName
                                                    + PM_ALT_FIELD_DELIM
                                                    + PM_NODE_POL
                                                    + PM_ALT_FIELD_DELIM
                                                    + sCrtName);
                                }
                            }
                        }
                    }

                    // Process the object attributes assigned to the policy
                    // class.
                    attr = getFromObjAttrs(crtQe);
                    if (attr != null) {
                        for (NamingEnumeration<?> attrEnum = attr.getAll(); attrEnum.hasMore(); ) {
                            sId = (String) attrEnum.next();
                            String sName = getEntityName(sId, PM_NODE_OATTR);

                            // The "everything" object (attribute) has a special
                            // treatment.
                            // Do not generate "add everything" to any entity.
                            // Generate "asg everything" to the right entities
                            // except the "admin" pc.
                            // Insert "everything" into the queue.
                            if (sName.equals(PM_EVERYTHING_NAME)) {
                                if (!visitedSet.contains(sId)) {
                                    qe = new QueueElement(PM_NODE_OATTR, sId, 0);
                                    queue.add(qe);
                                    visitedSet.add(sId);
                                }
                                if (!sCrtName.equals(PM_ADMIN_NAME)) {
                                    result.addItem(ItemType.RESPONSE_TEXT,
                                            "asg" + PM_ALT_FIELD_DELIM
                                                    + PM_NODE_OATTR
                                                    + PM_ALT_FIELD_DELIM
                                                    + sName
                                                    + PM_ALT_FIELD_DELIM
                                                    + PM_NODE_POL
                                                    + PM_ALT_FIELD_DELIM
                                                    + sCrtName);
                                }
                            } else {
                                if (!visitedSet.contains(sId)) {
                                    qe = new QueueElement(PM_NODE_OATTR, sId, 0);
                                    queue.add(qe);
                                    exportOattr(result, sId, PM_NODE_POL,
                                            sCrtName);
                                    visitedSet.add(sId);
                                } else {
                                    result.addItem(ItemType.RESPONSE_TEXT,
                                            "asg" + PM_ALT_FIELD_DELIM
                                                    + PM_NODE_OATTR
                                                    + PM_ALT_FIELD_DELIM
                                                    + sName
                                                    + PM_ALT_FIELD_DELIM
                                                    + PM_NODE_POL
                                                    + PM_ALT_FIELD_DELIM
                                                    + sCrtName);
                                }
                            }
                        }
                    }

                } else if (crtQe.getType().equalsIgnoreCase(PM_NODE_UATTR)) {

                    // The current node is a USER ATTRIBUTE node.
                    String sCrtName = getEntityName(crtQe.getId(),
                            crtQe.getType());

                    // Process the users assigned to this user attribute.
                    Attribute attr = getFromUsers(crtQe);
                    if (attr != null) {
                        for (NamingEnumeration<?> attrEnum = attr.getAll(); attrEnum.hasMore(); ) {
                            sId = (String) attrEnum.next();
                            String sName = getEntityName(sId, PM_NODE_USER);

                            // The "super" user has a special treatment.
                            // Do not generate "add super" to any entity.
                            // Generate "asg super" to the correct entities
                            // except the
                            // "superAdmin" user attribute.
                            // Insert "super" into the queue.
                            if (sName.equals(PM_SUPER_NAME)) {
                                if (!visitedSet.contains(sId)) {
                                    qe = new QueueElement(PM_NODE_USER, sId, 0);
                                    queue.add(qe);
                                    visitedSet.add(sId);
                                }
                                if (!sCrtName.equals(PM_SUPER_ADMIN_NAME)) {
                                    result.addItem(ItemType.RESPONSE_TEXT,
                                            "asg" + PM_ALT_FIELD_DELIM
                                                    + PM_NODE_USER
                                                    + PM_ALT_FIELD_DELIM
                                                    + sName
                                                    + PM_ALT_FIELD_DELIM
                                                    + PM_NODE_UATTR
                                                    + PM_ALT_FIELD_DELIM
                                                    + sCrtName);
                                }
                            } else {
                                if (!visitedSet.contains(sId)) {
                                    qe = new QueueElement(PM_NODE_USER, sId, 0);
                                    queue.add(qe);
                                    exportUser(result, sId, PM_NODE_UATTR,
                                            sCrtName);
                                    visitedSet.add(sId);
                                } else {
                                    result.addItem(ItemType.RESPONSE_TEXT,
                                            "asg" + PM_ALT_FIELD_DELIM
                                                    + PM_NODE_USER
                                                    + PM_ALT_FIELD_DELIM
                                                    + sName
                                                    + PM_ALT_FIELD_DELIM
                                                    + PM_NODE_UATTR
                                                    + PM_ALT_FIELD_DELIM
                                                    + sCrtName);
                                }
                            }
                        }
                    }

                    // Process the user attributes assigned to this user
                    // attribute.
                    attr = getFromAttrs(crtQe);
                    if (attr != null) {
                        for (NamingEnumeration<?> attrEnum = attr.getAll(); attrEnum.hasMore(); ) {
                            sId = (String) attrEnum.next();
                            if (!visitedSet.contains(sId)) {
                                qe = new QueueElement(PM_NODE_UATTR, sId,
                                        crtQe.getLevel() + 1);
                                queue.add(qe);
                                exportUattr(result, sId, PM_NODE_UATTR,
                                        sCrtName);
                                visitedSet.add(sId);
                            } else {
                                result.addItem(
                                        ItemType.RESPONSE_TEXT,
                                        "asg"
                                                + PM_ALT_FIELD_DELIM
                                                + PM_NODE_UATTR
                                                + PM_ALT_FIELD_DELIM
                                                + getEntityName(sId,
                                                PM_NODE_UATTR)
                                                + PM_ALT_FIELD_DELIM
                                                + PM_NODE_UATTR
                                                + PM_ALT_FIELD_DELIM + sCrtName);
                            }
                        }
                    }

                    // Process the operation sets assigned to this user
                    // attribute.
                    attr = getToOpsets(crtQe);
                    if (attr != null) {
                        for (NamingEnumeration<?> attrEnum = attr.getAll(); attrEnum.hasMore(); ) {
                            sId = (String) attrEnum.next();
                            String sName = getEntityName(sId, PM_NODE_OPSET);

                            // The "all ops" operation set has a special
                            // treatment.
                            // Do not generate "add allops" to any entity.
                            // Generate "asg entity to allops" for the right
                            // entities except the
                            // "superAdmin" user attribute.
                            // Insert "allops" into the queue.
                            if (sName.equals(PM_ALL_OPS_NAME)) {
                                if (!visitedSet.contains(sId)) {
                                    qe = new QueueElement(PM_NODE_OPSET, sId, 0);
                                    queue.add(qe);
                                    visitedSet.add(sId);
                                }
                                if (!sCrtName.equals(PM_SUPER_ADMIN_NAME)) {
                                    result.addItem(ItemType.RESPONSE_TEXT,
                                            "asg" + PM_ALT_FIELD_DELIM
                                                    + PM_NODE_UATTR
                                                    + PM_ALT_FIELD_DELIM
                                                    + sCrtName
                                                    + PM_ALT_FIELD_DELIM
                                                    + PM_NODE_OPSET
                                                    + PM_ALT_FIELD_DELIM
                                                    + sName);
                                }
                            } else {
                                if (!visitedSet.contains(sId)) {
                                    qe = new QueueElement(PM_NODE_OPSET, sId, 0);
                                    queue.add(qe);
                                    // Get its class.
                                    String sClass = "Ignored";
                                    String sOpsetName = getEntityName(sId,
                                            PM_NODE_OPSET);
                                    result.addItem(ItemType.RESPONSE_TEXT,
                                            "add" + PM_ALT_FIELD_DELIM
                                                    + PM_NODE_OPSET
                                                    + PM_ALT_FIELD_DELIM
                                                    + sOpsetName
                                                    + PM_ALT_FIELD_DELIM
                                                    + PM_OBJ_CLASS
                                                    + PM_ALT_FIELD_DELIM
                                                    + sClass
                                                    + PM_ALT_FIELD_DELIM
                                                    + PM_NODE_UATTR
                                                    + PM_ALT_FIELD_DELIM
                                                    + sCrtName);
                                    visitedSet.add(sId);

                                    // Get its operations.
                                    ar =  getOpsetOps(sClientId, sName);
                                    if (ar == null) {
                                        return failurePacket("Null result from getOpsetOps");
                                    }
                                    for (int i = 0; i < ar.size(); i++) {
                                        String sOp = ar.getStringValue(i);
                                        result.addItem(ItemType.RESPONSE_TEXT,
                                                "add" + PM_ALT_FIELD_DELIM
                                                        + PM_OP
                                                        + PM_ALT_FIELD_DELIM
                                                        + sOp
                                                        + PM_ALT_FIELD_DELIM
                                                        + PM_NODE_OPSET
                                                        + PM_ALT_FIELD_DELIM
                                                        + sName);
                                    }
                                } else {
                                    result.addItem(ItemType.RESPONSE_TEXT,
                                            "asg" + PM_ALT_FIELD_DELIM
                                                    + PM_NODE_UATTR
                                                    + PM_ALT_FIELD_DELIM
                                                    + sCrtName
                                                    + PM_ALT_FIELD_DELIM
                                                    + PM_NODE_OPSET
                                                    + PM_ALT_FIELD_DELIM
                                                    + sName);
                                }
                            }
                        }
                    }

                } else if (crtQe.getType().equalsIgnoreCase(PM_NODE_OATTR)) {

                    // The current node is an OBJECT ATTRIBUTE node.
                    String sCrtName = getEntityName(crtQe.getId(),
                            crtQe.getType());

                    // Process the object attributes assigned to this object
                    // attribute.
                    Attribute attr = getFromAttrs(crtQe);
                    if (attr != null) {
                        for (NamingEnumeration<?> attrEnum = attr.getAll(); attrEnum.hasMore(); ) {
                            sId = (String) attrEnum.next();
                            if (!visitedSet.contains(sId)) {
                                qe = new QueueElement(PM_NODE_OATTR, sId, 0);
                                queue.add(qe);
                                exportOattr(result, sId, PM_NODE_OATTR,
                                        sCrtName);
                                visitedSet.add(sId);
                            } else {
                                result.addItem(
                                        ItemType.RESPONSE_TEXT,
                                        "asg"
                                                + PM_ALT_FIELD_DELIM
                                                + PM_NODE_OATTR
                                                + PM_ALT_FIELD_DELIM
                                                + getEntityName(sId,
                                                PM_NODE_OATTR)
                                                + PM_ALT_FIELD_DELIM
                                                + PM_NODE_OATTR
                                                + PM_ALT_FIELD_DELIM + sCrtName);
                            }
                        }
                    }

                    // Process the operation sets assigned to this object
                    // attribute.
                    attr = getFromOpsets(crtQe);
                    if (attr != null) {
                        for (NamingEnumeration<?> attrEnum = attr.getAll(); attrEnum.hasMore(); ) {
                            sId = (String) attrEnum.next();
                            String sName = getEntityName(sId, PM_NODE_OPSET);

                            // The "all ops" operation set has a special
                            // treatment.
                            // Do not generate "add allops" to any entity.
                            // Generate "asg allops" to the right entities
                            // except the
                            // "everything" user attribute.
                            // Insert "allops" into the queue.
                            if (sName.equals(PM_ALL_OPS_NAME)) {
                                if (!visitedSet.contains(sId)) {
                                    qe = new QueueElement(PM_NODE_OPSET, sId, 0);
                                    queue.add(qe);
                                    visitedSet.add(sId);
                                }
                                if (!sCrtName.equals(PM_EVERYTHING_NAME)) {
                                    result.addItem(ItemType.RESPONSE_TEXT,
                                            "asg" + PM_ALT_FIELD_DELIM
                                                    + PM_NODE_OPSET
                                                    + PM_ALT_FIELD_DELIM
                                                    + sName
                                                    + PM_ALT_FIELD_DELIM
                                                    + PM_NODE_OATTR
                                                    + PM_ALT_FIELD_DELIM
                                                    + sCrtName);
                                }
                            } else {
                                if (!visitedSet.contains(sId)) {
                                    qe = new QueueElement(PM_NODE_OPSET, sId, 0);
                                    queue.add(qe);
                                    // Get its class.
                                    String sClass = "Ignored";
                                    result.addItem(ItemType.RESPONSE_TEXT,
                                            "add" + PM_ALT_FIELD_DELIM
                                                    + PM_NODE_OPSET
                                                    + PM_ALT_FIELD_DELIM
                                                    + sName
                                                    + PM_ALT_FIELD_DELIM
                                                    + PM_OBJ_CLASS
                                                    + PM_ALT_FIELD_DELIM
                                                    + sClass
                                                    + PM_ALT_FIELD_DELIM
                                                    + PM_NODE_OATTR
                                                    + PM_ALT_FIELD_DELIM
                                                    + sCrtName);
                                    visitedSet.add(sId);

                                    // Get its operations.
                                    ar =  getOpsetOps(sClientId, sName);
                                    if (ar == null) {
                                        return failurePacket("Null result from getOpsetOps");
                                    }
                                    for (int i = 0; i < ar.size(); i++) {
                                        String sOp = ar.getStringValue(i);
                                        result.addItem(ItemType.RESPONSE_TEXT,
                                                "add" + PM_ALT_FIELD_DELIM
                                                        + PM_OP
                                                        + PM_ALT_FIELD_DELIM
                                                        + sOp
                                                        + PM_ALT_FIELD_DELIM
                                                        + PM_NODE_OPSET
                                                        + PM_ALT_FIELD_DELIM
                                                        + sName);
                                    }
                                } else {
                                    result.addItem(ItemType.RESPONSE_TEXT,
                                            "asg" + PM_ALT_FIELD_DELIM
                                                    + PM_NODE_OPSET
                                                    + PM_ALT_FIELD_DELIM
                                                    + sName
                                                    + PM_ALT_FIELD_DELIM
                                                    + PM_NODE_OATTR
                                                    + PM_ALT_FIELD_DELIM
                                                    + sCrtName);
                                }
                            }
                        }
                    }
                }
            }
        } catch (Exception e) {
            if (debugFlag) {
                e.printStackTrace();
            }
            return failurePacket("Exception in export: " + e.getMessage());
        }

        // Export the attribute sets.
        ar =  getAsets(sClientId);
        if (ar == null) {
            return failurePacket("Null result from getAsets");
        }
        if (ar.hasError()) {
            return ar;
        }
        for (int i = 0; i < ar.size(); i++) {
            String sLine = ar.getStringValue(i);
            String[] pieces = sLine.split(PM_FIELD_DELIM);
            try {
                result.addItem(ItemType.RESPONSE_TEXT, "add"
                        + PM_ALT_FIELD_DELIM + PM_ASET + PM_ALT_FIELD_DELIM
                        + pieces[0]);
            } catch (Exception e) {
                e.printStackTrace();
                return failurePacket("Exception when building result packet");
            }
            ar2 =  getAsetInfo(sClientId, pieces[1]);
            // ar2 contains the attributes starting with item 2.
            // One attribute per item, name:id.
            for (int j = 2; j < ar2.size(); j++) {
                String sAttr = ar2.getStringValue(j);
                String[] fields = sAttr.split(PM_FIELD_DELIM);
                try {
                    result.addItem(ItemType.RESPONSE_TEXT, "add"
                            + PM_ALT_FIELD_DELIM + PM_NODE_UATTR
                            + PM_ALT_FIELD_DELIM + fields[0]
                            + PM_ALT_FIELD_DELIM + PM_ASET + PM_ALT_FIELD_DELIM
                            + pieces[0]);
                } catch (Exception e) {
                    e.printStackTrace();
                    return failurePacket("Exception when building result packet");
                }
            }
        }

        // Export sacs.
        ar =  getSacs(sClientId);
        if (ar == null) {
            return failurePacket("Null result from getSacs");
        }
        if (ar.hasError()) {
            return ar;
        }
        for (int i = 0; i < ar.size(); i++) {
            String sLine = ar.getStringValue(i);
            // Each item returned by getSacs() contains <sac name>:<sac id>:<sac
            // type>.
            String[] pieces = sLine.split(PM_FIELD_DELIM);
            try {
                result.addItem(ItemType.RESPONSE_TEXT, "add"
                        + PM_ALT_FIELD_DELIM + PM_SAC + PM_ALT_FIELD_DELIM
                        + pieces[0] + PM_ALT_FIELD_DELIM + pieces[2]);
            } catch (Exception e) {
                e.printStackTrace();
                return failurePacket("Exception when building result packet");
            }

            ar2 =  getSacInfo(sClientId, pieces[1]);
            // ar2 contain the attribute sets starting with item 1.
            // One attribute set per item, name:id.
            for (int j = 1; j < ar2.size(); j++) {
                String sAset = ar2.getStringValue(j);
                String[] fields = sAset.split(PM_FIELD_DELIM);
                try {
                    result.addItem(ItemType.RESPONSE_TEXT, "add"
                            + PM_ALT_FIELD_DELIM + PM_ASET + PM_ALT_FIELD_DELIM
                            + fields[0] + PM_ALT_FIELD_DELIM + PM_SAC
                            + PM_ALT_FIELD_DELIM + pieces[0]);
                } catch (Exception e) {
                    e.printStackTrace();
                    return failurePacket("Exception when building result packet");
                }
            }
        }

        // Export the applications.
        ar =  getAppPaths(sClientId, sSessId);
        if (ar == null) {
            return failurePacket("Null result from getAppPaths");
        }
        if (ar.hasError()) {
            return ar;
        }
        for (int i = 0; i < ar.size(); i++) {
            String sLine = ar.getStringValue(i);

            try {
                // An item of the result contains:
                // <admin tool path>|<editor path>|<wkf path>|<email path>|
                // <exporter path>|<openoffice path>|<msoffice path>|
                // <mr editor>|<acct editor>|<host>.
                // At least the host is not empty.
                String[] pieces = sLine.split(PM_ALT_DELIM_PATTERN);
                System.out.println("got " + pieces.length + " pieces");

                // pieces[0]=admin tool path,
                // pieces[1]=editor path,
                // pieces[2]=wkf path,
                // pieces[3]=email path,
                // pieces[4]=exporter path,
                // pieces[5]=openoffice path,
                // pieces[6]=msoffice path,
                // pieces[7]=mr editor path,
                // pieces[8]=acct editor path,
                // pieces[9]=host.
                result.addItem(ItemType.RESPONSE_TEXT, "add"
                        + PM_ALT_FIELD_DELIM + PM_APP_PATH + PM_ALT_FIELD_DELIM
                        + pieces[0] + PM_ALT_FIELD_DELIM + pieces[1]
                        + PM_ALT_FIELD_DELIM + pieces[2] + PM_ALT_FIELD_DELIM
                        + pieces[3] + PM_ALT_FIELD_DELIM + pieces[4]
                        + PM_ALT_FIELD_DELIM + pieces[5] + PM_ALT_FIELD_DELIM
                        + pieces[6] + PM_ALT_FIELD_DELIM + pieces[7]
                        + PM_ALT_FIELD_DELIM + pieces[8] + PM_ALT_FIELD_DELIM
                        + pieces[9] + PM_ALT_FIELD_DELIM 
                        + PM_HOST + PM_ALT_FIELD_DELIM + pieces[10]);
            } catch (Exception ee) {
                ee.printStackTrace();
                return failurePacket("Exception while exporting application paths: "
                        + ee.getMessage());
            }
        }

        // Export the keystore paths.
        ar =  getAllKStorePaths(sClientId, sSessId);
        if (ar == null) {
            return failurePacket("Null result from getAllKStorePaths");
        }
        if (ar.hasError()) {
            return ar;
        }
        for (int i = 0; i < ar.size(); i++) {
            String sLine = ar.getStringValue(i);

            try {
                // An item of the result contains: <key store path>|<trust store
                // path>|<host>|<user>.
                // At least the host and the user names are not empty.
                String[] pieces = sLine.split(PM_ALT_DELIM_PATTERN);
                System.out.println("got " + pieces.length + " pieces");

                result.addItem(ItemType.RESPONSE_TEXT, "add"
                        + PM_ALT_FIELD_DELIM + PM_KS_PATH + PM_ALT_FIELD_DELIM
                        + pieces[0] + PM_ALT_FIELD_DELIM + pieces[1]
                        + PM_ALT_FIELD_DELIM + PM_HOST + PM_ALT_FIELD_DELIM
                        + pieces[2] + PM_ALT_FIELD_DELIM + PM_NODE_USER
                        + PM_ALT_FIELD_DELIM + pieces[3]);
            } catch (Exception ee) {
                ee.printStackTrace();
                return failurePacket("Exception while exporting key store paths: "
                        + ee.getMessage());
            }
        }

        // Export denies.
        ar =  getDenies(sSessId);
        if (ar == null) {
            return failurePacket("Null result from getDenies");
        }
        if (ar.hasError()) {
            return ar;
        }
        for (int i = 0; i < ar.size(); i++) {
            String sLine = ar.getStringValue(i);
            String[] pieces = sLine.split(PM_FIELD_DELIM);
            // pieces[0] is the deny name, pieces[1] is the deny id.
            String sDenyName = pieces[0];
            String sDenyId = pieces[1];
            ar2 =  getDenyInfo(sSessId, sDenyId);

            // The deny may have been for a session that does not exist anymore,
            // skip it.
            if (ar2.hasError()) {
                continue;
            }

            // The information returned by getDenyInfo has the following format:
            // item 0: <deny name>:<deny id>
            // item 1: <deny type>:<user or attribute name>:<user or attribute
            // id>:<is intersection>
            // item 2: <operation count, opcount>
            // items 3 through 3 + opcount - 1: <operation>
            // item 3 + opcount: <container count, contcount>
            // item 3 + opcount + 1 through 3 + opcount + 1 + contcount - 1:
            // <container name>:<container id>
            sLine = ar2.getStringValue(1);
            System.out.println("Deny type, name, id, is intersection: " + sLine);
            pieces = sLine.split(PM_FIELD_DELIM);
            String sDenyType = pieces[0];
            String sUserOrAttrName = pieces[1];
            String sIsInters = pieces[3];
            String sNameType = (sDenyType.equalsIgnoreCase(PM_DENY_USER_ID) ? PM_NODE_USER
                    : PM_NODE_UATTR);

            // Write cmd to create deny with name, type, user or attribute name,
            // and whether is an intersection or union of containers.
            try {
                result.addItem(ItemType.RESPONSE_TEXT, "add"
                        + PM_ALT_FIELD_DELIM + PM_DENY + PM_ALT_FIELD_DELIM
                        + sDenyName + PM_ALT_FIELD_DELIM + sDenyType
                        + PM_ALT_FIELD_DELIM + sNameType + PM_ALT_FIELD_DELIM
                        + sUserOrAttrName + PM_ALT_FIELD_DELIM + sIsInters);
            } catch (Exception e) {
                e.printStackTrace();
                return failurePacket("Exception when building result packet");
            }

            // Write cmd to add denied operations.
            int opCount = Integer.valueOf(ar2.getStringValue(2)).intValue();
            for (int j = 3; j < 3 + opCount; j++) {
                String sOp = ar2.getStringValue(j);
                try {
                    result.addItem(ItemType.RESPONSE_TEXT, "add"
                            + PM_ALT_FIELD_DELIM + PM_OP + PM_ALT_FIELD_DELIM
                            + sOp + PM_ALT_FIELD_DELIM + PM_DENY
                            + PM_ALT_FIELD_DELIM + sDenyName);
                } catch (Exception e) {
                    e.printStackTrace();
                    return failurePacket("Exception when building result packet");
                }
            }
            // Write cmd to add denied containers.
            int contCount = Integer.valueOf(ar2.getStringValue(3 + opCount)).intValue();
            for (int j = 4 + opCount; j < 4 + opCount + contCount; j++) {
                sLine = ar2.getStringValue(j);
                System.out.println("cont name, cont id: " + sLine);
                pieces = sLine.split(PM_FIELD_DELIM);
                // pieces[0] is the container name, possibly prefixed with the
                // symbol '!'
                // indicating complement.
                String sCont;
                String sContType;
                if (pieces[0].startsWith("!")) {
                    sCont = pieces[0].substring(1);
                    sContType = PM_COMPL_OATTR;
                } else {
                    sCont = pieces[0];
                    sContType = PM_NODE_OATTR;
                }
                try {
                    result.addItem(ItemType.RESPONSE_TEXT, "add"
                            + PM_ALT_FIELD_DELIM + sContType
                            + PM_ALT_FIELD_DELIM + sCont + PM_ALT_FIELD_DELIM
                            + PM_DENY + PM_ALT_FIELD_DELIM + sDenyName);
                } catch (Exception e) {
                    e.printStackTrace();
                    return failurePacket("Exception when building result packet");
                }
            }
        }

        // Export the tasks.
        ar =  getTasks(sClientId);
        if (ar == null) {
            return failurePacket("Null result from getTasks");
        }
        if (ar.hasError()) {
            return ar;
        }

        for (int i = 0; i < ar.size(); i++) {
            String sLine = ar.getStringValue(i);
            System.out.println("Task " + sLine);
            String[] pieces = sLine.split(PM_FIELD_DELIM);
            try {
                result.addItem(ItemType.RESPONSE_TEXT, "add"
                        + PM_ALT_FIELD_DELIM + PM_TASK + PM_ALT_FIELD_DELIM
                        + pieces[0]);
            } catch (Exception e) {
                e.printStackTrace();
                return failurePacket("Exception when building result packet");
            }
            ar2 =  getTaskInfo(sClientId, pieces[1]);
            // ar2 contains the task's capabilities starting with item 1,
            // One capability per item, <op>,<obj name>:<obj id>,<pc name>:<pc
            // id>.
            for (int j = 1; j < ar2.size(); j++) {
                String sCap = ar2.getStringValue(j);
                System.out.println("Capability " + sCap);

                String[] fields = sCap.split(PM_LIST_MEMBER_SEP);
                String[] objPieces = fields[1].split(PM_FIELD_DELIM);
                String[] pcPieces = fields[2].split(PM_FIELD_DELIM);
                try {
                    result.addItem(ItemType.RESPONSE_TEXT, "add"
                            + PM_ALT_FIELD_DELIM + PM_CAP + PM_ALT_FIELD_DELIM
                            + fields[0] + PM_ALT_FIELD_DELIM + objPieces[0]
                            + PM_ALT_FIELD_DELIM + pcPieces[0]
                            + PM_ALT_FIELD_DELIM + PM_TASK + PM_ALT_FIELD_DELIM
                            + pieces[0]);
                } catch (Exception e) {
                    e.printStackTrace();
                    return failurePacket("Exception when building result packet");
                }
            }
        }

        // Export the static constraints.
        ar =  getScons(sClientId);
        if (ar == null) {
            return failurePacket("Null result from getScons");
        }
        if (ar.hasError()) {
            return ar;
        }

        for (int i = 0; i < ar.size(); i++) {
            String sLine = ar.getStringValue(i);
            System.out.println("Scon " + sLine);
            String[] pieces = sLine.split(PM_FIELD_DELIM);
            ar2 =  getSconInfo(sClientId, pieces[1]);
            if (ar2.hasError()) {
                return ar2;
            }

            // ar2 contains the scon's k (item 1) and tasks (starting with item
            // 2).
            String sK = ar2.getStringValue(1);
            System.out.println("  k " + sK);
            try {
                result.addItem(ItemType.RESPONSE_TEXT, "add"
                        + PM_ALT_FIELD_DELIM + PM_SCON + PM_ALT_FIELD_DELIM
                        + pieces[0] + PM_ALT_FIELD_DELIM + sK);
            } catch (Exception e) {
                e.printStackTrace();
                return failurePacket("Exception when building result packet");
            }

            for (int j = 2; j < ar2.size(); j++) {
                String sTask = ar2.getStringValue(j);
                System.out.println("  task " + sTask);
                // Each item contains: <task name>:<task id>.
                String[] taskPieces = sTask.split(PM_FIELD_DELIM);
                try {
                    result.addItem(ItemType.RESPONSE_TEXT, "add"
                            + PM_ALT_FIELD_DELIM + PM_TASK + PM_ALT_FIELD_DELIM
                            + taskPieces[0] + PM_ALT_FIELD_DELIM + PM_SCON
                            + PM_ALT_FIELD_DELIM + pieces[0]);
                } catch (Exception e) {
                    e.printStackTrace();
                    return failurePacket("Exception when building result packet");
                }
            }
        }

        // Export the record templates.
        exportTemplates(result);

        // The records (some object containers) were exported as all other
        // objects attributes,
        // but incompletely. Now we export their templates, containers and keys.
        // The record ids
        // were saved in savedRecords (the ids were those of the associated
        // oattrs).
        exportRecordProperties(result);

        // Export the properties (from the Property Container).
        exportProperties(result);

        return result;
    }

    private void exportProperties(Packet result) {
        Packet props =  getProperties(null);
        if (props == null || props.size() <= 0) {
            return;
        }
        if (props.hasError()) {
            return;
        }

        try {
            for (int i = 0; i < props.size(); i++) {
                String sLine = props.getStringValue(i);
                String[] pieces = sLine.split(PM_PROP_DELIM);
                result.addItem(ItemType.RESPONSE_TEXT, "add"
                        + PM_ALT_FIELD_DELIM + PM_PROP + PM_ALT_FIELD_DELIM
                        + pieces[0] + PM_ALT_FIELD_DELIM + PM_VALUE
                        + PM_ALT_FIELD_DELIM + pieces[1]);
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    private Packet testExportRecords() {
        if (savedRecords == null) {
            savedRecords = new HashSet<String>();
        } else {
            savedRecords.clear();
        }

        Packet ar =  getRecords(null, null, null);
        for (int i = 0; i < ar.size() - 1; i++) {
            String sLine = ar.getStringValue(i);
            String[] pieces = sLine.split(PM_FIELD_DELIM);
            savedRecords.add(pieces[1]);
        }

        Packet result = new Packet();
        exportTemplates(result);
        exportRecordProperties(result);

        return result;
    }

    private void exportRecordProperties(Packet result) {
        Iterator<String> setiter = savedRecords.iterator();
        try {
            while (setiter.hasNext()) {
                String sCompoId = setiter.next();
                System.out.println("Exporting record with id " + sCompoId);
                Packet info =  getRecordInfo(null, sCompoId);
                if (info.hasError()) {
                    System.out.println("Error in getRecordInfo called from exportRecordProperties:");
                    System.out.println(info.getErrorMessage());
                    continue;
                }

                // Item 0: <name>:<id>
                // Item 1: <template name>:<template id>
                // Item 2: <comp count>
                // Items 3 to 3 + <comp count> - 1: <comp name>:<comp id>
                // Item 3 + <comp count>: <key count>
                // Items 3 + <comp count> + 1 to 3 + <comp count> + 1 + <key
                // count> - 1: <key name>=<key value>
                // The <comp id> is the id of the object attribute associated
                // with a
                // component object.
                String sLine = info.getStringValue(0);
                String[] pieces = sLine.split(PM_FIELD_DELIM);
                String sRecName = pieces[0];

                // Get the object's template and generate the add template
                // command.
                sLine = info.getStringValue(1);
                pieces = sLine.split(PM_FIELD_DELIM);
                result.addItem(ItemType.RESPONSE_TEXT, "add"
                        + PM_ALT_FIELD_DELIM + PM_TEMPLATE + PM_ALT_FIELD_DELIM
                        + pieces[0] + PM_ALT_FIELD_DELIM + PM_NODE_OATTR
                        + PM_ALT_FIELD_DELIM + sRecName);

                // Get the object's components and generate the add components
                // command.
                sLine = info.getStringValue(2);
                int nComp = Integer.valueOf(sLine).intValue();
                StringBuffer sb = new StringBuffer();
                boolean first = true;
                for (int i = 0; i < nComp; i++) {
                    sLine = info.getStringValue(3 + i);
                    pieces = sLine.split(PM_FIELD_DELIM);
                    if (first) {
                        first = false;
                        sb.append(pieces[0]);
                    } else {
                        sb.append(PM_FIELD_DELIM + pieces[0]);
                    }
                }
                result.addItem(ItemType.RESPONSE_TEXT, "add"
                        + PM_ALT_FIELD_DELIM + PM_COMPONENTS
                        + PM_ALT_FIELD_DELIM + sb.toString()
                        + PM_ALT_FIELD_DELIM + PM_NODE_OATTR
                        + PM_ALT_FIELD_DELIM + sRecName);

                // Get the object's keys and generate the add key commands.
                sLine = info.getStringValue(3 + nComp);
                int nKeys = Integer.valueOf(sLine).intValue();
                for (int i = 0; i < nKeys; i++) {
                    sLine = info.getStringValue(4 + nComp + i);
                    result.addItem(ItemType.RESPONSE_TEXT, "add"
                            + PM_ALT_FIELD_DELIM + PM_KEY + PM_ALT_FIELD_DELIM
                            + sLine + PM_ALT_FIELD_DELIM + PM_NODE_OATTR
                            + PM_ALT_FIELD_DELIM + sRecName);
                }
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    private void exportTemplates(Packet result) {
        Packet templates =  getTemplates(null);
        if (templates == null || templates.size() <= 0) {
            return;
        }
        if (templates.hasError()) {
            return;
        }

        try {
            for (int i = 0; i < templates.size(); i++) {
                String sLine = templates.getStringValue(i);
                String[] pieces = sLine.split(PM_FIELD_DELIM);
                Packet tplInfo =  getTemplateInfo(null, pieces[1]);

                tplInfo.print(true, "Template info for " + pieces[0]);

                // item 0: <tpl name>:<tpl id>
                // item 1: <cont 1 id>:...:<cont n id>
                // item 2: <key1>:...:<keyn>
                String sContainers = tplInfo.getStringValue(1);
                String[] splinters = sContainers.split(PM_FIELD_DELIM);
                boolean first = true;
                StringBuffer sb = new StringBuffer();
                for (int j = 0; j < splinters.length; j++) {
                    String sContName = getEntityName(splinters[j],
                            PM_NODE_OATTR);
                    if (first) {
                        first = false;
                        sb.append(sContName);
                    } else {
                        sb.append(PM_FIELD_DELIM + sContName);
                    }
                }
                result.addItem(ItemType.RESPONSE_TEXT, "add"
                        + PM_ALT_FIELD_DELIM + PM_TEMPLATE + PM_ALT_FIELD_DELIM
                        + pieces[0] + PM_ALT_FIELD_DELIM + PM_CONTAINERS
                        + PM_ALT_FIELD_DELIM + sb.toString());
                if (tplInfo.size() >= 3) {
                    String sKeys = tplInfo.getStringValue(2);
                    splinters = sKeys.split(PM_FIELD_DELIM);
                    for (int j = 0; j < splinters.length; j++) {
                        result.addItem(ItemType.RESPONSE_TEXT, "add"
                                + PM_ALT_FIELD_DELIM + PM_KEY
                                + PM_ALT_FIELD_DELIM + splinters[j]
                                + PM_ALT_FIELD_DELIM + PM_TEMPLATE
                                + PM_ALT_FIELD_DELIM + pieces[0]);
                    }
                }
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    private void exportOattr(Packet result, String sId, String sBaseType,
                             String sBaseName) {
        String sName = getEntityName(sId, PM_NODE_OATTR);

        String sVobjId = getAssocObj(sId);
        try {
            if (sVobjId == null) {
                // This is an object attribute not associated with an object.
                result.addItem(ItemType.RESPONSE_TEXT, "add"
                        + PM_ALT_FIELD_DELIM + PM_NODE_OATTR
                        + PM_ALT_FIELD_DELIM + sName + PM_ALT_FIELD_DELIM
                        + sBaseType + PM_ALT_FIELD_DELIM + sBaseName);
            } else {
                // This is an object attribute associated with an object.
                // Export the object.
                Packet ar =  getObjInfo(sVobjId);
                String sLine = ar.getStringValue(0);

                // sLine may contain:
                // name|id|class|inh|host|path, or
                // name|id|class|inh|orig name|orig id, or
                // name|id|class|inh.
                String[] pieces = sLine.split(PM_ALT_DELIM_PATTERN);
                String sClass = pieces[2];

                // If the object's class is Clipboard, don't export it.
                if (sClass.equalsIgnoreCase(PM_CLASS_CLIPBOARD_NAME)) {
                    return;
                }

                StringBuffer sb = new StringBuffer();
                sb.append("add" + PM_ALT_FIELD_DELIM + PM_OBJ
                        + PM_ALT_FIELD_DELIM + pieces[0] + PM_ALT_FIELD_DELIM
                        + pieces[2] + PM_ALT_FIELD_DELIM + pieces[3]);
                if (pieces.length <= 4) {
                    sb.append(PM_ALT_FIELD_DELIM + PM_ALT_FIELD_DELIM);
                } else {
                    sb.append(PM_ALT_FIELD_DELIM + pieces[4]
                            + PM_ALT_FIELD_DELIM + pieces[5]);
                }
                sb.append(PM_ALT_FIELD_DELIM + sBaseType + PM_ALT_FIELD_DELIM
                        + sBaseName);
                result.addItem(ItemType.RESPONSE_TEXT, sb.toString());
            }

            // If the object attribute is a record (container), save it to add
            // template,
            // components, and keys later.
            if (isRecord(sId)) {
                savedRecords.add(sId);
            }

            // Export its properties.
            HashSet<String> props = getProps(sId, PM_NODE_OATTR);
            Iterator<String> iter = props.iterator();
            while (iter.hasNext()) {
                result.addItem(ItemType.RESPONSE_TEXT, "add"
                        + PM_ALT_FIELD_DELIM + PM_PROP + PM_ALT_FIELD_DELIM
                        + iter.next() + PM_ALT_FIELD_DELIM + PM_NODE_OATTR
                        + PM_ALT_FIELD_DELIM + sName);
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    private void exportPc(Packet result, String sId) {
        String sName = getEntityName(sId, PM_NODE_POL);

        try {
            result.addItem(ItemType.RESPONSE_TEXT, "add" + PM_ALT_FIELD_DELIM
                    + PM_NODE_POL + PM_ALT_FIELD_DELIM + sName
                    + PM_ALT_FIELD_DELIM + PM_NODE_CONN + PM_ALT_FIELD_DELIM
                    + PM_CONNECTOR_NAME);

            // Export its properties.
            HashSet<String> props = getProps(sId, PM_NODE_POL);
            Iterator<String> iter = props.iterator();
            while (iter.hasNext()) {
                result.addItem(ItemType.RESPONSE_TEXT, "add"
                        + PM_ALT_FIELD_DELIM + PM_PROP + PM_ALT_FIELD_DELIM
                        + iter.next() + PM_ALT_FIELD_DELIM + PM_NODE_POL
                        + PM_ALT_FIELD_DELIM + sName);
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    private void exportUser(Packet result, String sId, String sBaseType,
                            String sBaseName) {
        String sName = getEntityName(sId, PM_NODE_USER);
        String sFull = getUserFullName(sId);
        try {
            result.addItem(ItemType.RESPONSE_TEXT, "add" + PM_ALT_FIELD_DELIM
                    + PM_NODE_USER + PM_ALT_FIELD_DELIM + sName
                    + PM_ALT_FIELD_DELIM + PM_FULL_NAME + PM_ALT_FIELD_DELIM
                    + sFull + PM_ALT_FIELD_DELIM + sBaseType
                    + PM_ALT_FIELD_DELIM + sBaseName);

            // Export its email account info.
            Packet emlInfo =  getEmailAcct(null, sName);
            if (emlInfo == null || emlInfo.size() < 6 || emlInfo.hasError()) {
                return;
            }
            String sComingFrom = emlInfo.getStringValue(1);
            String sEmailAddr = emlInfo.getStringValue(2);
            String sPopServer = emlInfo.getStringValue(3);
            String sSmtpServer = emlInfo.getStringValue(4);
            String sAcctName = emlInfo.getStringValue(5);
            String sPassword = sName;

            result.addItem(ItemType.RESPONSE_TEXT, "add" + PM_ALT_FIELD_DELIM
                    + PM_EMAIL_ACCT + PM_ALT_FIELD_DELIM + sComingFrom
                    + PM_ALT_FIELD_DELIM + sEmailAddr + PM_ALT_FIELD_DELIM
                    + sPopServer + PM_ALT_FIELD_DELIM + sSmtpServer
                    + PM_ALT_FIELD_DELIM + sAcctName + PM_ALT_FIELD_DELIM
                    + sPassword + PM_ALT_FIELD_DELIM + PM_NODE_USER
                    + PM_ALT_FIELD_DELIM + sName);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    private void exportUattr(Packet result, String sId, String sBaseType,
                             String sBaseName) {
        String sName = getEntityName(sId, PM_NODE_UATTR);
        try {

            result.addItem(ItemType.RESPONSE_TEXT, "add" + PM_ALT_FIELD_DELIM
                    + PM_NODE_UATTR + PM_ALT_FIELD_DELIM + sName
                    + PM_ALT_FIELD_DELIM + sBaseType + PM_ALT_FIELD_DELIM
                    + sBaseName);

            // Export its properties.
            HashSet<String> props = getProps(sId, PM_NODE_UATTR);
            Iterator<String> iter = props.iterator();
            while (iter.hasNext()) {
                result.addItem(ItemType.RESPONSE_TEXT, "add"
                        + PM_ALT_FIELD_DELIM + PM_PROP + PM_ALT_FIELD_DELIM
                        + iter.next() + PM_ALT_FIELD_DELIM + PM_NODE_UATTR
                        + PM_ALT_FIELD_DELIM + sName);
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    private Packet testSynchro(String sClientId) throws Exception {
        System.out.println("Starting work in testSynchro");
        for (long i = 0; i < 5000000000l; i++) ;
        return successPacket("TestSynchro terminated");
    }

    private void printSetOfSets(HashSet<HashSet<String>> hs, String caption) {
        if (caption != null && caption.length() > 0) {
            System.out.println(caption);
        }
        Iterator<HashSet<String>> hsiter = hs.iterator();

        System.out.println("{");
        while (hsiter.hasNext()) {
            HashSet<String> set = hsiter.next();
            System.out.print(" ");
            printSet(set, PM_NODE_UATTR, null);
        }
        System.out.println("}");
    }

    private void printSet(Set<String> hs, String sType, String caption) {
        if (caption != null && caption.length() > 0) {
            System.out.println(caption);
        }
        Iterator<String> hsiter = hs.iterator();

        System.out.print("{");
        boolean firstTime = true;
        while (hsiter.hasNext()) {
            String sId = hsiter.next();
            if (sType.equalsIgnoreCase(PM_PERM)) {
                if (firstTime) {
                    System.out.print(sId);
                    firstTime = false;
                } else {
                    System.out.print(", " + sId);
                }
            } else {
                String sName = getEntityName(sId, sType);
                if (firstTime) {
                    System.out.print(sName);
                    firstTime = false;
                } else {
                    System.out.print(", " + sName);
                }
            }
        }
        System.out.println("}");
    }

    private void printVector(Vector<String> v, String sType, String caption) {
        System.out.println("-------" + caption + "-------");

        System.out.println("{");
        for (int i = 0; i < v.size(); i++) {
            String sId = v.elementAt(i);
            String sName = getEntityName(sId, sType);
            System.out.println("    " + sName + ":" + sId + ",");
        }
        System.out.println("}");
    }

    // Whether the string sY can be added to the HashSet set without
    // conflict with the SAC constraint sac
    // (sac is only one of the SAC constraints!).
    private boolean canAddTo(String sY, HashSet<String> set,
                             HashSet<HashSet<String>> sac) {
        Iterator<String> setiter = set.iterator();
        while (setiter.hasNext()) {
            String sX = setiter.next();
            if (elementsConflict(sY, sX, sac)) {
                return false;
            }
        }
        return true;
    }

    // Whether x and y are each in a different set of sac.
    private boolean elementsConflict(String sX, String sY,
                                     HashSet<HashSet<String>> sac) {
        int ix = 0;
        int iy = 0;
        int i = 0;
        Iterator<HashSet<String>> saciter = sac.iterator();
        while (saciter.hasNext()) {
            i++;
            HashSet<?> saci = saciter.next();
            if (saci.contains(sX)) {
                ix = i;
            }
            if (saci.contains(sY)) {
                iy = i;
            }
        }
        return (ix > 0 && iy > 0 && ix != iy);
    }

    private void addSetToResult(HashSet<String> set,
                                HashSet<HashSet<String>> result) {
        HashSet<String> member = null;
        Iterator<HashSet<String>> resiter = result.iterator();
        boolean replace = false;

        while (resiter.hasNext()) {
            member = resiter.next();
            if (member.containsAll(set)) {
                return;
            }
            if (set.containsAll(member)) {
                replace = true;
                break;
            }
        }
        if (replace) {
            result.remove(member);
        }
        result.add(set);
    }

    /*
     * private void printMaximalSubsets(HashSet maxSubs) { Iterator maxiter =
     * maxSubs.iterator(); while (maxiter.hasNext()) { HashSet subset =
     * (HashSet)maxiter.next(); Iterator subiter = subset.iterator(); boolean
     * first = true; String sLine = ""; while (subiter.hasNext()) { String sId =
     * (String)subiter.next(); String sName = getNameOfEntityWithIdAndType(sId, PM_NODE_UATTR);
     * if (first) { first = false; sLine = sName; } else { sLine = sLine + "," +
     * sName; } } System.out.println("{" + sLine + "}"); } }
     */
    private void printMaximalSubsets(HashSet<HashSet<String>> maxSubs) {
        Iterator<HashSet<String>> maxiter = maxSubs.iterator();
        while (maxiter.hasNext()) {
            HashSet<String> subset = maxiter.next();
            printSet(subset, PM_NODE_UATTR, null);
        }
    }

    private Packet getMaximalSubsets(String sClientId, String sAsetId) {
        HashSet<String> hsAttrs = asetToSet(sAsetId);
        HashSet<HashSet<String>> res = getMaximalSubsetsInternal(hsAttrs);

        Packet result = new Packet();

        // Each element of res is a subset we were looking for.
        Iterator<HashSet<String>> resiter = res.iterator();
        while (resiter.hasNext()) {
            HashSet<?> subset = resiter.next();
            Iterator<?> subiter = subset.iterator();
            boolean first = true;
            String sLine = "";
            while (subiter.hasNext()) {
                String sId = (String) subiter.next();
                String sName = getEntityName(sId, PM_NODE_UATTR);
                if (first) {
                    first = false;
                    sLine = sName;
                } else {
                    sLine = sLine + "," + sName;
                }
            }
            try {
                // result.addItem(ItemType.RESPONSE_TEXT, setToString(subset));
                result.addItem(ItemType.RESPONSE_TEXT, sLine);
            } catch (Exception e) {
                e.printStackTrace();
                return failurePacket("Exception when building the result packet");
            }
        }
        return result;
    }

    // Returns the maximal (with respect to SAC) activable attribute subsets of
    // a set.
    // The argument is the id of a user attribute set.
    private HashSet<HashSet<String>> getMaximalSubsetsInternal(
            HashSet<String> hsAttrs) {
        HashSet<HashSet<String>> temp, result;

        // Both temp and result are sets of sets. Eventually, the elements of
        // temp
        // will be the subsets we're looking for. We start with the argument set
        // as the only element of temp. At each iteration we try to split it
        // in non-conflicting subsets.
        temp = new HashSet<HashSet<String>>();
        temp.add(hsAttrs);

        // Init result with the empty set.
        result = new HashSet<HashSet<String>>();

        // For each SAC
        Vector<String> sacs = getSacs();
        for (int saci = 0; saci < sacs.size(); saci++) {
            // Build the HashSet for the sac.
            String sSacId = sacs.elementAt(saci);
            Vector<String> sacasets = getSacAsets(sSacId);
            HashSet<HashSet<String>> sac = new HashSet<HashSet<String>>();
            for (int aseti = 0; aseti < sacasets.size(); aseti++) {
                String sId = sacasets.get(aseti);
                HashSet<String> set = asetToSet(sId);
                sac.add(set);
            }

            System.out.println("New step with a new SAC");
            printSetOfSets(sac, "SAC");

            printSetOfSets(temp, "Temp");

            // For each set "tosplit" in temp
            Iterator<HashSet<String>> tempiter = temp.iterator();
            while (tempiter.hasNext()) {
                HashSet<String> toSplit = tempiter.next();

                printSet(toSplit, PM_NODE_UATTR, "toSplit");

                // bCommon indicates whether toSplit has common elements with
                // any of the attribute sets in SACi. Initially is false.
                boolean bCommon = false;
                // For each attribute set uasi in SACi
                Iterator<HashSet<String>> saciter = sac.iterator();
                while (saciter.hasNext()) {
                    HashSet<String> uasi = saciter.next();
                    // Compute seti = intersection(uasi, tosplit).
                    HashSet<String> seti = new HashSet<String>(uasi);
                    seti.retainAll(toSplit);
                    printSet(seti, PM_NODE_UATTR, "iset = tosplit int uasi");
                    // If seti is not empty
                    if (!seti.isEmpty()) {
                        bCommon = true;
                        // Loop through the toSplit's elements. If an element
                        // can be added
                        // to seti without conflict with the current SAC, add it
                        // there.
                        Iterator<String> tosplititer = toSplit.iterator();
                        while (tosplititer.hasNext()) {
                            String sYId = tosplititer.next();
                            if (canAddTo(sYId, seti, sac)) {
                                seti.add(sYId);
                            }
                        }
                        // Add seti to the "result".
                        // If seti is included in a set already in result, do
                        // nothing.
                        // If seti includes a set already in result, replace
                        // that set
                        // with seti.
                        // Otherwise, add seti to result.
                        addSetToResult(seti, result);
                    }
                }
                // If no set in sac had any common element with toSplit, add
                // toSplit to result.
                if (!bCommon) {
                    addSetToResult(toSplit, result);
                }
            }
            printSetOfSets(result, "result");

            // Prepare for a new step that uses the next sac: transfer result to
            // temp.
            temp.clear();
            temp = result;
            result = new HashSet<HashSet<String>>();
        }
        return temp;
    }

    // An attribute set to HashSet.
    private HashSet<String> asetToSet(String sAsetId) {
        Attributes attrs;
        Attribute attr;
        HashSet<String> hs = new HashSet<String>();
        try {
            attrs = ctx.getAttributes("CN=" + sAsetId + ","
                    + sAttrSetContainerDN);
            attr = attrs.get("pmAttr");
            if (attr != null) {
                for (NamingEnumeration<?> enumer = attr.getAll(); enumer.hasMore(); ) {
                    String sAttrId = (String) enumer.next();
                    hs.add(sAttrId);
                }
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
        return hs;
    }

    // Request permissions on the OATTR (in general associated to a virtual
    // object)
    // in a given session.
    // Returns all the permissions - old and newly acquired.
    // The oattr is identified by its name.
    //
    // Notes.
    // 1. Although sObjName in general identifies an object, it can be the name
    // of any object attribute, not necessarily associated with a virtual
    // object.
    // 2. Part or all of requested permissions may already be available.
    private Packet requestPerms(String sClientId, String sSessId,
                                String sObjName, String sReqPerms) {
        // Find the graph node with the name and type.
        String sTgtOaId = getEntityId(sObjName, PM_NODE_OATTR);
        if (sTgtOaId == null) {
            return failurePacket("No object (attribute) " + sObjName);
        }

        return setToPacket(requestPermsInternal2(sSessId, sTgtOaId, sReqPerms));
    }

    // Tries to activate attributes that grant the session the user-requested
    // permissions on the (virtual) object identified here through its
    // associated object attribute.
    // sTgtOaId is the identifier of the target object attribute. It should
    // be associated with the object, but actually can be any object attribute.
    /*private Set<String> requestPermsNoSacInternal(String sClientId,
   String sSessId, String sTgtOaId, String sReqPerms) {
   NamingEnumeration<?> objs;
   Vector<String> activeAttrs;
   Vector<String> policyClasses;
   Vector<String> opsets;
   Vector<String> oattrs;

   String sPcId;
   String sOpsId;
   String sOaId;

   Set<String> reqops = stringToSet(sReqPerms);
   Set<String> crtperms = getPermsInternal(sSessId, sTgtOaId);
   Set<String> newreqops = new HashSet<String>(reqops.size());
   newreqops.addAll(reqops);

   // Subtract the current permissions (the session already has) from the
   // requested operations.
   if (crtperms.contains(PM_ANY_ANY)) {
   newreqops.clear();
   } else {
   newreqops.removeAll(crtperms);
   }

   System.out.println("------Req perms: " + setToString(reqops));
   System.out.println("------Crt perms: " + setToString(crtperms));
   System.out.println("------New req perms: " + setToString(newreqops));

   // If the client requested no permissions beyond those it already has,
   // return all current permissions as granted.
   // if (newreqops.isEmpty()) return setToPacket(reqops);
   if (newreqops.isEmpty()) {
   return crtperms;
   }

   // Get the session's user, active attributes, and policy classes.
   String sUserId = getSessionUserId(sSessId);
   activeAttrs = getSessionActiveAttrs(sSessId);
   policyClasses = getPolicyClasses();

   // Create a hashtable ht. A ht entry has a policy class as key, and a
   // HashMap as value. The HashMap has a user attribute as key and a
   // HashSet of permissions (operations) as value.
   // Only policy classes that contain the object appear as keys in ht.
   // The user attribute must be within the policy class. The permissions
   // are those that become available to the subject when the attribute
   // is activated.
   Map<String, Map<String, Set<String>>> ht = new Hashtable<String, Map<String, Set<String>>>();

   // For each policy class pc
   for (int pc = 0; pc < policyClasses.size(); pc++) {
   sPcId = policyClasses.elementAt(pc);
   // If (!(o ->+ pc)) continue.
   if (!attrIsAscendantToPolicy(sTgtOaId, PM_NODE_OATTR, sPcId)) {
   continue;
   }
   // The object is in this policy class. Note that at this time
   // ht has no entry for pc. Add an entry [pc, empty] to ht.
   addHtEntry(sPcId, (String) null, (String) null, ht);
   System.out.println("ht <--- new empty entry for pc = "
   + getNameOfEntityWithIdAndType(sPcId, PM_NODE_POL));
   Map<String, Set<String>> pcmap = ht.get(sPcId);

   // For each user attribute ua such that u ->+ ua and ua ->+ pc and
   // ua NOT active:
   HashSet<String> authattrs = getUserDescendantsInternal(sUserId);
   Iterator<String> uaiter = authattrs.iterator();
   while (uaiter.hasNext()) {
   String sUaId = uaiter.next();
   System.out.println("  Examine ua = "
   + getNameOfEntityWithIdAndType(sUaId, PM_NODE_UATTR));
   if (!attrIsAscendantToPolicy(sUaId, PM_NODE_UATTR, sPcId)) {
   System.out
   .println("             not in policy class - rejected");
   continue;
   }

    * if (activeAttrs.contains(sUaId)) {
    * System.out.println("             already active - rejected");
    * continue; }

   // Add [ua,empty] to the hashmap for pc.
   System.out.println("  ht[" + getNameOfEntityWithIdAndType(sPcId, PM_NODE_POL)
   + "] <--- new empty entry for ua = "
   + getNameOfEntityWithIdAndType(sUaId, PM_NODE_UATTR));
   addHtEntry(sPcId, sUaId, (String) null, ht);

   // For each opset ops such that ua->ops
   opsets = getToOpsets(sUaId);
   for (int ops = 0; ops < opsets.size(); ops++) {
   sOpsId = opsets.elementAt(ops);

   // If the opset ops does not contribute any operation
   // towards newreqops,
   // then continue with the next op set.
   // First get all ops' operations.
   Set<String> contrib = new HashSet<String>();
   addOpsetToSet(sOpsId, contrib);

   printSet(contrib, PM_PERM, "Brut contribution of opset "
   + getNameOfEntityWithIdAndType(sOpsId, PM_NODE_OPSET));

   // Then retain only those included in the requested ops.
   if (contrib.contains(PM_ANY_ANY)) {
   contrib = newreqops;
   } else if (newreqops.contains(PM_ANY_ANY)) {
   // contrib remains unchanged by intersection.
   } else {
   contrib.retainAll(newreqops);
   }
   if (contrib.isEmpty()) {
   continue;
   }

   // For each oa such that ops -> oa
   oattrs = getToAttrs(sOpsId);
   for (int oa = 0; oa < oattrs.size(); oa++) {
   sOaId = oattrs.elementAt(oa);
   // If !(oa ->+ pc) continue.
   if (!attrIsAscendantToPolicy(sOaId, PM_NODE_OATTR,
   sPcId)) {
   continue;
   }
   // If !(o ->* oa) continue
   if (!attrIsAscendant(sTgtOaId, sOaId, PM_NODE_OATTR)) {
   continue;
   }
   // Add ua's partial contribution (for this ops) to the
   // HashMap entry
   // for ua in the hashtable entry for pc.

   System.out.println("    ht["
   + getNameOfEntityWithIdAndType(sPcId, PM_NODE_POL) + "]["
   + getNameOfEntityWithIdAndType(sUaId, PM_NODE_UATTR)
   + "] <--- its contribution:");
   printSet(contrib, PM_PERM, "Contribution of "
   + getNameOfEntityWithIdAndType(sUaId, PM_NODE_UATTR));
   addHtEntry(sPcId, sUaId, contrib, ht);
   }
   }
   HashSet<?> set = (HashSet<?>) pcmap.get(sUaId);
   if (set.isEmpty()) {
   pcmap.remove(sUaId);
   }
   }
   // If the entry for pc has an empty HashMap, return the permissions
   // we already have.
   if (pcmap.isEmpty()) {
   return crtperms;
   }
   }
   // Now ht has entries [pc, {[ua1,set1],...,[uan,setn]}], meaning that
   // the subject will get seti permissions if uai gets activated within
   // pc.
   // Note that seti contains only new, requested permissions. By
   // activating
   // uai, the subject might acquire other permissions beyond seti.
   printHtWithPcKeys(ht);

   // Compute the attainable permissions - i.e., if each attribute in ht
   // were
   // activated. That means to compute the union of seti for each entry
   // in ht, then to intersect the unions.
   HashSet<String> attainable = new HashSet<String>();
   HashSet<String> unionset = new HashSet<String>();
   boolean firstTime = true;
   Iterator<Map<String, Set<String>>> htiter = ht.values().iterator();
   while (htiter.hasNext()) {
   Map<String, Set<String>> map = htiter.next();
   Iterator<Set<String>> mapiter = map.values().iterator();
   unionset.clear();
   while (mapiter.hasNext()) {
   unionset.addAll(mapiter.next());
   }
   if (firstTime) {
   firstTime = false;
   attainable = (HashSet<String>) unionset.clone();
   } else {
   attainable.retainAll(unionset);
   }
   }

   System.out.println("------ The attainable permissions are: "
   + setToString(attainable));

   // If no new permissions can be acquired, return the old one we had:
   if (attainable.isEmpty()) {
   return crtperms;
   }

   // The set of user attributes to activate, initially empty.
   HashSet<String> toActivate = new HashSet<String>();

   // For each pc entry in the ht, try to activate attributes from the
   // entry
   // so that the "attainable" permissions are acquired within that pc.
   // Some of the attributes in that pc MAY ALREADY BE ACTIVE.
   // Some of the attributes in that pc may already be marked to activate
   // during processing of another pc.
   htiter = ht.values().iterator();
   while (htiter.hasNext()) {
   // For each entry in ht, which is a HashMap:
   Map<String, Set<String>> entrymap = htiter.next();
   // Initially all the entries in the HashMap are selectable,...
   @SuppressWarnings("unchecked")
   Map<String, Set<String>> selectable = (Map<String, Set<String>>) ((HashMap<String, Set<String>>) entrymap)
   .clone();
   // ...no permissions are attained so far,...
   Set acquired = new HashSet<Object>();
   // ...and all attainable permissions still remain to be attained.
   HashSet<String> remaining = (HashSet<String>) attainable.clone();

   // Some attribute could already be active.
   // Some other attributes could have already been marked for
   // activation during processing of other entries. Compute
   // their share of permissions.
   Iterator<?> mapiter = entrymap.keySet().iterator();
   while (mapiter.hasNext()) {
   String sUaId = (String) mapiter.next();
   if (!activeAttrs.contains(sUaId) && !toActivate.contains(sUaId)) {
   continue;
   }

   // This attribute is already active or was already marked to be
   // activated
   // in another entry. Update the sets accordingly.
   Collection<?> set = (HashSet<?>) entrymap.get(sUaId);
   acquired.addAll(set);
   remaining.removeAll(set);
   selectable.remove(sUaId);
   }

   // Continue to select other attributes for activation until all
   // attainable permissions are acquired.
   while (!remaining.isEmpty()) {
   // Select next user attribute to activate from this pc entry.
   String sUaId = selectBestNoSac(selectable, remaining);
   // Add ua to the set to activate.
   toActivate.add(sUaId);
   // Update the sets.
   HashSet<?> set = (HashSet<?>) selectable.get(sUaId);
   acquired.addAll(set);
   remaining.removeAll(set);
   selectable.remove(sUaId);
   }
   }

   // Activate the attributes in toActivate.
   activateAttributesInternal(sSessId, toActivate);
   // The newly activated attributes might produce new permissions in
   // addition
   // to the requested ones. Recompute and return current permissions.
   // crtperms.addAll(attainable);
   crtperms = getPermsInternal(sSessId, sTgtOaId);
   return crtperms;
   }
    */
    // RequestPermsInternal2() finds and activates the attributes
    // that grant the session the requested permissions on an object.
    // Note that this method is similar to requestPermsInternal(),
    // but it also considers across-session SACs.
    // The requestPermsInternal only considers intra-session SACs.
    // Note: sTgtOaId can be any object attribute, doesn't have to be
    // the oa associated to an object.
    private HashSet<String> requestPermsInternal2(String sSessId,
                                                  String sTgtOaId, String sReqPerms) {
        //NamingEnumeration<?> objs;
        Vector<String> policyClasses;
        Vector<String> opsets;
        Vector<String> oattrs;
        //HashSet<?> objects;

        String sPcId;
        //String sAaId;
        String sOpsId;
        String sOaId;

        System.out.println("***requestPermsInternal on OATTR "
                + getEntityName(sTgtOaId, PM_NODE_OATTR) + "***");

        HashSet<String> reqops = stringToSet(sReqPerms);
        HashSet<String> crtperms = getPermsInternal(sSessId, sTgtOaId);
        HashSet<String> newreqops = new HashSet<String>(reqops);

        // Subtract the current permissions (the session already has) from the
        // requested operations.
        if (crtperms.contains(PM_ANY_ANY)) {
            newreqops.clear();
        } else {
            newreqops.removeAll(crtperms);
        }

        System.out.println("*Req perms: " + setToString(reqops));
        System.out.println("*Crt perms: " + setToString(crtperms));
        System.out.println("*New req perms: " + setToString(newreqops));

        // If the client requested no permissions beyond those it already has,
        // return all current permissions as granted.
        // if (newreqops.isEmpty()) return setToPacket(reqops);
        if (newreqops.isEmpty()) {
            return crtperms;
        }

        // Get the session's user, active attributes, and policy classes.
        String sUserId = getSessionUserId(sSessId);
        policyClasses = getPolicyClasses();

        // Create a hashtable ht. A ht entry has a policy class as key, and a
        // HashMap as value. The HashMap has a user attribute as key and a
        // HashSet of permissions (operations) as value.
        // Only policy classes that contain the object appear as keys in ht.
        // The user attribute must be within the policy class. The permissions
        // are those that become available to the subject when the attribute
        // is activated.
        Map<String, Map<String, Set<String>>> ht = new Hashtable<String, Map<String, Set<String>>>();
        // The attributes inserted in ht.
        HashSet<String> htAttrs = new HashSet<String>();

        // For each policy class pc
        for (int pc = 0; pc < policyClasses.size(); pc++) {
            sPcId = policyClasses.elementAt(pc);
            // If (!(o ->+ pc)) continue.
            if (!attrIsAscendantToPolicy(sTgtOaId, PM_NODE_OATTR, sPcId)) {
                continue;
            }
            // The object is in this policy class. Note that at this time
            // ht has no entry for pc. Add an entry [pc, empty] to ht.
            addHtEntry(sPcId, (String) null, (String) null, ht);
            System.out.println("*ht <--- new empty entry for pc = "
                    + getEntityName(sPcId, PM_NODE_POL));
            Map<String, Set<String>> pcmap = ht.get(sPcId);

            // For each user attribute ua such that u ->+ ua and ua ->+ pc and
            // ua NOT active:
            HashSet<String> authattrs = getUserDescendantsInternal(sUserId);
            Iterator<String> uaiter = authattrs.iterator();
            while (uaiter.hasNext()) {
                String sUaId = uaiter.next();
                System.out.println("*  Examine ua = "
                        + getEntityName(sUaId, PM_NODE_UATTR));
                if (!attrIsAscendantToPolicy(sUaId, PM_NODE_UATTR, sPcId)) {
                    System.out.println("*             is NOT in "
                            + getEntityName(sPcId, PM_NODE_POL));
                    continue;
                }
                System.out.println("*             is in "
                        + getEntityName(sPcId, PM_NODE_POL));

                // Add [ua,empty] to the hashmap for pc.
                System.out.println("*  ht[" + getEntityName(sPcId, PM_NODE_POL)
                        + "] <--- new empty entry for ua = "
                        + getEntityName(sUaId, PM_NODE_UATTR));
                addHtEntry(sPcId, sUaId, (String) null, ht);

                // For each opset ops such that ua->ops
                opsets = getToOpsets(sUaId);
                for (int ops = 0; ops < opsets.size(); ops++) {
                    sOpsId = opsets.elementAt(ops);

                    // If the ops does not contribute any operation towards
                    // newreqops,
                    // then continue with the next op set.
                    // First get all ops' operations.
                    HashSet<String> contrib = new HashSet<String>();
                    addOpsetToSet(sOpsId, contrib);

                    printSet(contrib, PM_PERM, "Brut contribution of opset "
                            + getEntityName(sOpsId, PM_NODE_OPSET));

                    // Then retain only those included in the requested ops.
                    if (contrib.contains(PM_ANY_ANY)) {
                        contrib = new HashSet<String>(newreqops);
                    } else if (newreqops.contains(PM_ANY_ANY)) {
                        // Intersection leaves contrib unchanged.
                    } else {
                        contrib.retainAll(newreqops);
                    }
                    if (contrib.isEmpty()) {
                        continue;
                    }

                    // For each oa such that ops -> oa
                    oattrs = getToAttrs(sOpsId);
                    for (int oa = 0; oa < oattrs.size(); oa++) {
                        sOaId = oattrs.elementAt(oa);
                        // If !(oa ->+ pc) continue.
                        if (!attrIsAscendantToPolicy(sOaId, PM_NODE_OATTR,
                                sPcId)) {
                            continue;
                        }
                        // If !(o ->* oa) continue
                        if (!attrIsAscendant(sTgtOaId, sOaId, PM_NODE_OATTR)) {
                            continue;
                        }
                        // Add ua's partial contribution (for this ops) to the
                        // HashMap entry
                        // for ua in the hashtable entry for pc.

                        System.out.println("*    ht["
                                + getEntityName(sPcId, PM_NODE_POL) + "]["
                                + getEntityName(sUaId, PM_NODE_UATTR)
                                + "] <--- its contribution:");
                        printSet(contrib, PM_PERM, "Contribution of "
                                + getEntityName(sUaId, PM_NODE_UATTR));
                        addHtEntry(sPcId, sUaId, contrib, ht);
                    }
                }
                HashSet<?> set = (HashSet<?>) pcmap.get(sUaId);
                if (set.isEmpty()) {
                    pcmap.remove(sUaId);
                } else {
                    htAttrs.add(sUaId);
                }
            }
            // If the entry for pc has an empty HashMap, return the permissions
            // we already have.
            if (pcmap.isEmpty()) {
                return crtperms;
            }
        }

        // Now ht has entries [pc, {[ua1,set1],...,[uan,setn]}], meaning that
        // the subject will get seti permissions if uai gets activated within
        // pc.
        // Note that seti contains only new, requested permissions. By
        // activating
        // uai, the subject might acquire other permissions in addition to seti.
        System.out.println("*HashTable ht contents:");
        printHtWithPcKeys(ht);

        // Session's active attributes.
        HashSet<String> sessActiveAttrs = getSessionActiveAttrSet(sSessId);
        printSet(sessActiveAttrs, PM_NODE_UATTR,
                "Set of session active attributes");

        // User's active attributes (in all his sessions).
        HashSet<String> userActiveAttrs = getUserActiveAttrs(sUserId);
        printSet(userActiveAttrs, PM_NODE_UATTR,
                "Set of user active attributes");

        // All attributes in across-sessions SACs.
        HashSet<String> acrossSessSacAttrs = getAcrossSessSacAttrs();
        printSet(acrossSessSacAttrs, PM_NODE_UATTR,
                "Set of across session sacs attributes");

        // Compute user's active attributes that are in across-sessions sacs.
        HashSet<String> acrossSessSacActiveAttrs = new HashSet<String>(
                userActiveAttrs);
        acrossSessSacActiveAttrs.retainAll(acrossSessSacAttrs);
        printSet(acrossSessSacActiveAttrs, PM_NODE_UATTR,
                "Set of across session sacs active attributes");

        // Compute the union.
        HashSet<String> sessAndHtAttrs = new HashSet<String>(sessActiveAttrs);
        sessAndHtAttrs.addAll(htAttrs);

        // Prepare the set of activable attributes.
        HashSet<String> activableAttrs = new HashSet<String>(sessAndHtAttrs);
        printSet(activableAttrs, PM_NODE_UATTR,
                "Set of activable attributes (from sesion and ht)");

        // Add the attributes that are active in other sessions of this user and
        // specified in across-sessions sacs.
        activableAttrs.addAll(acrossSessSacActiveAttrs);
        printSet(activableAttrs, PM_NODE_UATTR,
                "Set of activable attributes (with active across-session sacs added)");

        // Compute all maximal subsets of activable with no SAC conflict:
        HashSet<HashSet<String>> maxActSets = getMaximalSubsetsInternal(activableAttrs);
        System.out.println("*Found the maximal subsets:");
        printMaximalSubsets(maxActSets);

        // Each element of maxActSets is a subset of activableAttrs with no
        // SAC conflict, but if we add any other attribute to it we get a
        // conflict.
        // Because the attributes already active for the session cannot be made
        // inactive, they should be contained in any set of attributes we
        // consider for activation. Hence we discard the elements of maxActSets
        // that do not include the attributes already active.
        // Include the other sessions' active attributes that are in across
        // sessions
        // SACs in "attributes already active".
        // whenever you modify the elements of the HashSet, make a copy of the
        // HashSet.
        Iterator<HashSet<String>> maxiter = maxActSets.iterator();
        HashSet<HashSet<String>> newMaxActSets = new HashSet<HashSet<String>>();
        while (maxiter.hasNext()) {
            HashSet<String> actSet = maxiter.next();
            if (!actSet.containsAll(sessActiveAttrs)
                    || !actSet.containsAll(acrossSessSacActiveAttrs)) {
                System.out.println("Discard the following maximal subset (does not contain the active attrs):");
                printSet(actSet, PM_NODE_UATTR, null);
                // Don't copy actSet to the new maxActSet.
            } else {
                // Retain from actSet only the attributes that are active in the
                // current session or those inserted through ht. Insert actSet
                // into the new maxActSet.
                actSet.retainAll(sessAndHtAttrs);
                newMaxActSets.add(actSet);
            }
        }

        System.out.println("*The maximal subsets after discarding those that don't contain the active attrs:");
        printMaximalSubsets(newMaxActSets);

        // If after discarding the maximal subsets that do not include
        // the active attributes there is no maximal subset left,
        // return the current perms:
        if (newMaxActSets.isEmpty()) {
            System.out.println("All maximal subsets have been removed. Returning the crt permissions!");
            return crtperms;
        }

        // For each maximal subset s of activable attributes compute the set of
        // new requested permissions that can be acquired from the attributes
        // of that subset, denoted attainable(s):
        // For each entry in ht, we'll compute the union
        // of the operation sets in that entry, but only of those corresponding
        // to ua's from the maximal subset. Then we'll intersect those unions.
        // Store the pairs [s, attainable(s)] in a HashMap for later processing.
        HashMap<HashSet<String>, HashSet<String>> subAttain = new HashMap<HashSet<String>, HashSet<String>>();
        try {
            // For each maximal subset s
            Iterator<HashSet<String>> maxiter2 = newMaxActSets.iterator();
            while (maxiter2.hasNext()) {
                HashSet<String> actSet = maxiter2.next();

                // Compute attainable permissions for actSet (called s in
                // description).
                HashSet<String> attainableS = new HashSet<String>(); // attainable(s)
                // in
                // description.
                HashSet<String> attainableSPc = new HashSet<String>(); // attainable(s,pc)
                // in
                // description.
                boolean firstTime = true;
                boolean bPcContribIsEmpty = false;
                Iterator<Map<String, Set<String>>> htiter = ht.values().iterator();
                // For each entry (we use the values) in ht:
                while (htiter.hasNext()) {
                    Map<String, Set<String>> map = htiter.next();
                    // Prepare to do the union for this ht entry. Use only map
                    // entries
                    // [ua,set] with ua in s.
                    attainableSPc.clear();
                    Iterator<String> mapiter = map.keySet().iterator();// The key is
                    // a
                    // ua.
                    while (mapiter.hasNext()) {
                        String sId = (String) mapiter.next();
                        if (actSet.contains(sId)) {
                            Set<String> hs = map.get(sId);
                            if (hs.contains(PM_ANY_ANY)) {
                                attainableSPc = new HashSet<String>();
                                attainableSPc.add(PM_ANY_ANY);
                            } else if (attainableSPc.contains(PM_ANY_ANY)) {
                                // The union operation leaves attainable
                                // unchanged.
                            } else {
                                attainableSPc.addAll(map.get(sId));
                            }
                        }
                    }
                    printSet(attainableSPc, PM_PERM,
                            "*Attainable union for pc entry");

                    // If this pc entry does not yield any permissions for set
                    // s,
                    // we can skip the rest of ht entries and discard s.
                    if (attainableSPc.isEmpty()) {
                        bPcContribIsEmpty = true;
                        break;
                    }

                    // We got some permissions for s and this pc. If this pc is
                    // the first
                    // for this s, store them in attainableS. Otherwise
                    // intersect them
                    // with the crt attainableS.
                    if (firstTime) {
                        firstTime = false;
                        attainableS = new HashSet<String>(attainableSPc);
                    } else {
                        if (attainableS.contains(PM_ANY_ANY)) {
                            attainableS = new HashSet<String>(attainableSPc);
                        } else if (attainableSPc.contains(PM_ANY_ANY)) {
                            // The intersection operation leaves attainableS
                            // unchanged.
                        } else {
                            attainableS.retainAll(attainableSPc);
                        }
                    }
                } // for each ht entry

                // At this point there are three cases:
                // 1. We broke out from the loop on ht entries because a ht
                // entry had
                // no attainable permissions, fact signaled by bPcContribIsEmpty
                // = true.
                // 2. The loop ended normally with an empty intersection.
                // 3. The loop ended normally with a non-empty intersection.
                // In cases 1 and 2, discard the maximal subset s and continue
                // with the
                // next one. In case 3, store s and its attainableS in a HashMap
                // for
                // later use.
                if (bPcContribIsEmpty || attainableS.isEmpty()) {
                    System.out.println("*Discard the following maximal subset (no attainable perms):");
                    printSet(actSet, PM_NODE_UATTR, null);
                    maxiter2.remove();
                } else {
                    // Store s as key and attainable as value in the HashMap
                    // "subAttain"
                    // for later processing.
                    System.out.println("*The following maximal subset:");
                    printSet(actSet, PM_NODE_UATTR, "");
                    System.out.println("*    has attainable perms:");
                    printSet(attainableS, PM_PERM, "");
                    subAttain.put(actSet, attainableS);
                }
            } // for each s
        } catch (Exception e) {
            e.printStackTrace();
            return crtperms;
        }
        System.out.println("*The maximal subsets after discarding those without attainable perms:");
        printMaximalSubsets(newMaxActSets);

        // maxActSets may be empty after discarding some s.
        if (newMaxActSets.isEmpty()) {
            return crtperms;
        }
        // The following was added when removing modified elements from the
        // hashset didn't work.
        // if (subAttain.isEmpty()) return crtperms;

        // Right now, for each maximal set of activable attributes s we have the
        // set of its attainable permissions. This info is in the HashMap
        // subAttain = {[s, attainable(s)]}.
        // Note that attainable(s) contains only new requested permissions.
        // Next step is to select an s. In this implementation, we select an s
        // with maximum number of attainable permissions.
        // To do: find that s during the preceding loop.
        Iterator<HashSet<String>> attainiter = subAttain.keySet().iterator();// The
        // key
        // is
        // an
        // s.
        int max = 0; // max number of permissions til now.
        HashSet<String> sm = null;
        HashSet<String> attainableSM = null;
        while (attainiter.hasNext()) {
            HashSet<String> s = attainiter.next();
            HashSet<String> attain = subAttain.get(s);
            if (attain.size() > max) {
                max = attain.size();
                sm = s;
                attainableSM = attain;
            }
        }

        printSet(sm, PM_NODE_UATTR, "*We selected the maximal subset:");
        printSet(attainableSM, PM_PERM, "*    with the attainable perms:");

        // Next step is to mark for activation the attributes of each ht entry
        // WHICH ALSO ARE IN sm. Same algorithm as in no sac case. Remember that
        // some of the attributes in the ht entry MAY ALREADY BE ACTIVE, and
        // some of the attributes may have already been marked during processing
        // of another entry.

        // The set of attributes marked for activation is initially empty.
        HashSet<String> markedAttrs = new HashSet<String>();
        Iterator<Map<String, Set<String>>> htiter = ht.values().iterator();

        System.out.println("*Start attribute marking");
        while (htiter.hasNext()) {
            // For each entry in ht, which is a HashMap:
            System.out.println("*For a ht entry");
            Map<String, Set<String>> entrymap = htiter.next();
            // Initially all the entries in entrymap with keys (i.e., ua)
            // in sm are selectable. Note that this condition will be
            // enforced in selectBest().
            HashMap<String, Set<String>> selectable = new HashMap<String, Set<String>>(entrymap);
            // ...no permissions are attained so far,...
            HashSet<String> acquired = new HashSet<String>();
            // ...and all attainable permissions still remain to be attained.
            HashSet<String> remaining = new HashSet<String>(attainableSM);
            printSet(remaining, PM_PERM, "*   The initial remaining set is");

            // Some attributes could already be active.
            // Some other attributes could have already been marked for
            // activation during processing of other entries. Compute
            // their share of permissions.
            Iterator<String> mapiter = entrymap.keySet().iterator();
            while (mapiter.hasNext()) {
                String sUaId = mapiter.next();
                if (!sessActiveAttrs.contains(sUaId)
                        && !markedAttrs.contains(sUaId)) {
                    continue;
                }

                // This attribute is already active or was already marked to be
                // activated
                // in another entry. Update the sets accordingly.
                System.out.println("*   User attribute "
                        + getEntityName(sUaId, PM_NODE_UATTR)
                        + " is already active or marked.");
                Set<String> set = entrymap.get(sUaId);
                printSet(set, PM_PERM, "*      Its share is:");
                if (set.contains(PM_ANY_ANY)) {
                    acquired = new HashSet<String>();
                    acquired.add(PM_ANY_ANY);
                } else if (acquired.contains(PM_ANY_ANY)) {
                } else {
                    acquired.addAll(set);
                }
                if (set.contains(PM_ANY_ANY)) {
                    remaining.clear();
                } else if (remaining.contains(PM_ANY_ANY)) {
                } else {
                    remaining.removeAll(set);
                }
                printSet(remaining, PM_PERM, "*      After it, remaining is:");
                selectable.remove(sUaId);
            }

            // Continue to select other attributes for activation until all
            // attainable permissions are acquired.
            System.out.println("*   Start attribute selection");
            while (!remaining.isEmpty()) {
                // Select next user attribute to activate from this pc entry.
                String sUaId = selectBest(selectable, remaining, sm);

                System.out.println("*   User attribute "
                        + getEntityName(sUaId, PM_NODE_UATTR)
                        + " was selected in selectBest");
                // Add ua to the set to activate.
                markedAttrs.add(sUaId);
                // Update the sets.
                Set<String> set = selectable.get(sUaId);

                printSet(set, PM_PERM, "*      Its share is:");

                if (set.contains(PM_ANY_ANY)) {
                    acquired = new HashSet<String>();
                    acquired.add(PM_ANY_ANY);
                } else if (acquired.contains(PM_ANY_ANY)) {
                } else {
                    acquired.addAll(set);
                }
                if (set.contains(PM_ANY_ANY)) {
                    remaining.clear();
                } else if (remaining.contains(PM_ANY_ANY)) {
                } else {
                    remaining.removeAll(set);
                }
                printSet(remaining, PM_PERM, "*      After it, remaining is:");
                selectable.remove(sUaId);
            }
        }

        // Activate the marked attributes.
        activateAttributesInternal(sSessId, markedAttrs);
        // The newly activated attributes might produce new permissions in
        // addition
        // to the requested ones. Recompute and return current permissions.
        // crtperms.addAll(attainable);
        crtperms = getPermsInternal(sSessId, sTgtOaId);
        return crtperms;

    }

    // Determines whether opening an object o in a session s would prevent
    // other open object in that session from being saved, and whether creating
    // a new session would help.
    private Packet wouldOpenPreventSave(String sSessId, String sObjName,
                                        String sReqPerms) {
        Packet resNo = new Packet();
        Packet resYes = new Packet();
        try {
            resNo.addItem(ItemType.RESPONSE_TEXT, "no");
            resYes.addItem(ItemType.RESPONSE_TEXT, "yes");
        } catch (Exception e) {
            e.printStackTrace();
            return failurePacket("Exception when building the \"No\" packet");
        }

        //Packet res = new Packet();
        //NamingEnumeration<?> objs;
        Vector<String> policyClasses;
        Vector<String> opsets;
        Vector<String> oattrs;
        //HashSet<?> objects;

        String sPcId;
        //String sAaId;
        String sOpsId;
        String sOaId;

        String sTgtOaId = getEntityId(sObjName, PM_NODE_OATTR);
        if (sTgtOaId == null) {
            return failurePacket("No object (attribute) " + sObjName);
        }

        // Get the set of the session's active attributes.
        // Maybe we need to consider the active attributes across all the user's
        // sessions?
        HashSet<String> sessActiveAttrs = getSessionActiveAttrSet(sSessId);
        printSet(sessActiveAttrs, PM_NODE_UATTR,
                "Set of session active attributes");

        // If this set is empty, return false - this is like a new session.
        if (sessActiveAttrs.isEmpty()) {
            System.out.println("The set of active attributes is empty, returning no");
            return resNo;
        }

        // Get the set of the session's open objects - as a set of names.
        HashSet<String> sessOpenObjs = getSessionOpenObjs(sSessId);
        printSet(sessOpenObjs, PM_PERM, "Set of session open objects");

        // If this set is empty, return false - no danger of not being able to
        // save these objects.
        if (sessOpenObjs.isEmpty()) {
            System.out.println("The set of open objects is empty, returning no");
            return resNo;
        }

        // The rest is borrowed from requestPerms, with the goal of finding the
        // set
        // of attributes that need to be activated in order to open the given
        // object
        // with the set of given permissions.

        HashSet<String> reqops = stringToSet(sReqPerms);
        HashSet<String> crtperms = getPermsInternal(sSessId, sTgtOaId);
        HashSet<String> newreqops = new HashSet<String>(reqops);

        // Subtract the current permissions (the session already has) from the
        // requested operations.
        if (crtperms.contains(PM_ANY_ANY)) {
            newreqops.clear();
        } else {
            newreqops.removeAll(crtperms);
        }

        System.out.println("*Req perms: " + setToString(reqops));
        System.out.println("*Crt perms: " + setToString(crtperms));
        System.out.println("*New req perms: " + setToString(newreqops));

        // If the client requested no permissions beyond those it already has,
        // return all current permissions as granted.
        // if (newreqops.isEmpty()) return setToPacket(reqops);
        if (newreqops.isEmpty()) {
            System.out.println("Session already has the requested permissions on the given object, returning no");
            return resNo;
        }

        // Get the session's user, active attributes, and policy classes.
        String sUserId = getSessionUserId(sSessId);
        policyClasses = getPolicyClasses();

        // Create a hashtable ht. A ht entry has a policy class as key, and a
        // HashMap as value. The HashMap has a user attribute as key and a
        // HashSet of permissions (operations) as value.
        // Only policy classes that contain the object appear as keys in ht.
        // The user attribute must be within the policy class. The permissions
        // are those that become available to the subject when the attribute
        // is activated.
        Map<String, Map<String, Set<String>>> ht = new Hashtable<String, Map<String, Set<String>>>();
        // The attributes inserted in ht.
        HashSet<String> htAttrs = new HashSet<String>();

        // For each policy class pc
        for (int pc = 0; pc < policyClasses.size(); pc++) {
            sPcId = policyClasses.elementAt(pc);
            // If (!(o ->+ pc)) continue.
            if (!attrIsAscendantToPolicy(sTgtOaId, PM_NODE_OATTR, sPcId)) {
                continue;
            }
            // The object is in this policy class. Note that at this time
            // ht has no entry for pc. Add an entry [pc, empty] to ht.
            addHtEntry(sPcId, null, (String) null, ht);
            System.out.println("*ht <--- new empty entry for pc = "
                    + getEntityName(sPcId, PM_NODE_POL));
            Map<String, Set<String>> pcmap = ht.get(sPcId);

            // For each user attribute ua such that u ->+ ua and ua ->+ pc and
            // ua NOT active:
            HashSet<String> authattrs = getUserDescendantsInternal(sUserId);
            Iterator<String> uaiter = authattrs.iterator();
            while (uaiter.hasNext()) {
                String sUaId = uaiter.next();
                System.out.println("*  Examine ua = "
                        + getEntityName(sUaId, PM_NODE_UATTR));
                if (!attrIsAscendantToPolicy(sUaId, PM_NODE_UATTR, sPcId)) {
                    System.out.println("*             is NOT in "
                            + getEntityName(sPcId, PM_NODE_POL));
                    continue;
                }
                System.out.println("*             is in "
                        + getEntityName(sPcId, PM_NODE_POL));

                // Add [ua,empty] to the hashmap for pc.
                System.out.println("*  ht[" + getEntityName(sPcId, PM_NODE_POL)
                        + "] <--- new empty entry for ua = "
                        + getEntityName(sUaId, PM_NODE_UATTR));
                addHtEntry(sPcId, sUaId, (String) null, ht);

                // For each opset ops such that ua->ops
                opsets = getToOpsets(sUaId);
                for (int ops = 0; ops < opsets.size(); ops++) {
                    sOpsId = opsets.elementAt(ops);

                    // If the ops does not contribute any operation towards
                    // newreqops,
                    // then continue with the next op set.
                    // First get all ops' operations.
                    HashSet<String> contrib = new HashSet<String>();
                    addOpsetToSet(sOpsId, contrib);

                    printSet(contrib, PM_PERM, "Brut contribution of opset "
                            + getEntityName(sOpsId, PM_NODE_OPSET));

                    // Then retain only those included in the requested ops.
                    if (contrib.contains(PM_ANY_ANY)) {
                        contrib = new HashSet<String>(newreqops);
                    } else if (newreqops.contains(PM_ANY_ANY)) {
                        // Intersection leaves contrib unchanged.
                    } else {
                        contrib.retainAll(newreqops);
                    }
                    if (contrib.isEmpty()) {
                        continue;
                    }

                    // For each oa such that ops -> oa
                    oattrs = getToAttrs(sOpsId);
                    for (int oa = 0; oa < oattrs.size(); oa++) {
                        sOaId = oattrs.elementAt(oa);
                        // If !(oa ->+ pc) continue.
                        if (!attrIsAscendantToPolicy(sOaId, PM_NODE_OATTR,
                                sPcId)) {
                            continue;
                        }
                        // If !(o ->* oa) continue
                        if (!attrIsAscendant(sTgtOaId, sOaId, PM_NODE_OATTR)) {
                            continue;
                        }
                        // Add ua's partial contribution (for this ops) to the
                        // HashMap entry
                        // for ua in the hashtable entry for pc.

                        System.out.println("*    ht["
                                + getEntityName(sPcId, PM_NODE_POL) + "]["
                                + getEntityName(sUaId, PM_NODE_UATTR)
                                + "] <--- its contribution:");
                        printSet(contrib, PM_PERM, "Contribution of "
                                + getEntityName(sUaId, PM_NODE_UATTR));
                        addHtEntry(sPcId, sUaId, contrib, ht);
                    }
                }
                HashSet<?> set = (HashSet<?>) pcmap.get(sUaId);
                if (set.isEmpty()) {
                    pcmap.remove(sUaId);
                } else {
                    htAttrs.add(sUaId);
                }
            }
            // If the entry for pc has an empty HashMap, return the permissions
            // we already have.
            if (pcmap.isEmpty()) {
                System.out.println("The entry for pc has an empty HashMap, returning no");
                return resNo;
            }
        }

        // Now ht has entries [pc, {[ua1,set1],...,[uan,setn]}], meaning that
        // the subject will get seti permissions if uai gets activated within
        // pc.
        // Note that seti contains only new, requested permissions. By
        // activating
        // uai, the subject might acquire other permissions in addition to seti.
        System.out.println("*HashTable ht contents:");
        printHtWithPcKeys(ht);

        // User's active attributes (in all his sessions).
        HashSet<String> userActiveAttrs = getUserActiveAttrs(sUserId);
        printSet(userActiveAttrs, PM_NODE_UATTR,
                "Set of user active attributes");

        // All attributes in across-sessions SACs.
        HashSet<String> acrossSessSacAttrs = getAcrossSessSacAttrs();
        printSet(acrossSessSacAttrs, PM_NODE_UATTR,
                "Set of across session sacs attributes");

        // Compute user's active attributes that are in across-sessions sacs.
        HashSet<String> acrossSessSacActiveAttrs = new HashSet<String>(
                userActiveAttrs);
        acrossSessSacActiveAttrs.retainAll(acrossSessSacAttrs);
        printSet(acrossSessSacActiveAttrs, PM_NODE_UATTR,
                "Set of across session sacs active attributes");

        // Compute the union.
        HashSet<String> sessAndHtAttrs = new HashSet<String>(sessActiveAttrs);
        sessAndHtAttrs.addAll(htAttrs);

        // Prepare the set of activable attributes.
        HashSet<String> activableAttrs = new HashSet<String>(sessAndHtAttrs);
        printSet(activableAttrs, PM_NODE_UATTR,
                "Set of activable attributes (from sesion and ht)");

        // Add the attributes that are active in other sessions of this user and
        // specified in across-sessions sacs.
        activableAttrs.addAll(acrossSessSacActiveAttrs);
        printSet(activableAttrs, PM_NODE_UATTR,
                "Set of activable attributes (with active across-session sacs added)");

        // Compute all maximal subsets of activable with no SAC conflict:
        HashSet<HashSet<String>> maxActSets = getMaximalSubsetsInternal(activableAttrs);
        System.out.println("*Found the maximal subsets:");
        printMaximalSubsets(maxActSets);

        // Each element of maxActSets is a subset of activableAttrs with no
        // SAC conflict, but if we add any other attribute to it we get a
        // conflict.
        // Because the attributes already active for the session cannot be made
        // inactive, they should be contained in any set of attributes we
        // consider for activation. Hence we discard the elements of maxActSets
        // that do not include the attributes already active.
        // Include the other sessions' active attributes that are in across
        // sessions
        // SACs in "attributes already active".
        // whenever you modify the elements of the HashSet, make a copy of the
        // HashSet.
        Iterator<HashSet<String>> maxiter = maxActSets.iterator();
        HashSet<HashSet<String>> newMaxActSets = new HashSet<HashSet<String>>();
        while (maxiter.hasNext()) {
            HashSet<String> actSet = maxiter.next();
            if (!actSet.containsAll(sessActiveAttrs)
                    || !actSet.containsAll(acrossSessSacActiveAttrs)) {
                System.out.println("Discard the following maximal subset (does not contain the active attrs):");
                printSet(actSet, PM_NODE_UATTR, null);
                // Don't copy actSet to the new maxActSet.
            } else {
                // Retain from actSet only the attributes that are active in the
                // current session or those inserted through ht. Insert actSet
                // into the new maxActSet.
                actSet.retainAll(sessAndHtAttrs);
                newMaxActSets.add(actSet);
            }
        }

        System.out.println("*The maximal subsets after discarding those that don't contain the active attrs:");
        printMaximalSubsets(newMaxActSets);

        // If after discarding the maximal subsets that do not include
        // the active attributes there is no maximal subset left,
        // return the current perms:
        if (newMaxActSets.isEmpty()) {
            System.out.println("All maximal subsets have been removed, returning no!");
            return resNo;
        }

        // For each maximal subset s of activable attributes compute the set of
        // new requested permissions that can be acquired from the attributes
        // of that subset, denoted attainable(s):
        // For each entry in ht, we'll compute the union
        // of the operation sets in that entry, but only of those corresponding
        // to ua's from the maximal subset. Then we'll intersect those unions.
        // Store the pairs [s, attainable(s)] in a HashMap for later processing.
        HashMap<HashSet<String>, HashSet<String>> subAttain = new HashMap<HashSet<String>, HashSet<String>>();
        try {
            // For each maximal subset s
            Iterator<HashSet<String>> maxiter2 = newMaxActSets.iterator();
            while (maxiter2.hasNext()) {
                HashSet<String> actSet = maxiter2.next();

                // Compute attainable permissions for actSet (called s in
                // description).
                HashSet<String> attainableS = new HashSet<String>(); // attainable(s)
                // in
                // description.
                HashSet<String> attainableSPc = new HashSet<String>(); // attainable(s,pc)
                // in
                // description.
                boolean firstTime = true;
                boolean bPcContribIsEmpty = false;
                Iterator<Map<String, Set<String>>> htiter = ht.values().iterator();
                // For each entry (we use the values) in ht:
                while (htiter.hasNext()) {
                    Map<String, Set<String>> map = htiter.next();
                    // Prepare to do the union for this ht entry. Use only map
                    // entries
                    // [ua,set] with ua in s.
                    attainableSPc.clear();
                    Iterator<String> mapiter = map.keySet().iterator();// The key is
                    // a
                    // ua.
                    while (mapiter.hasNext()) {
                        String sId = mapiter.next();
                        if (actSet.contains(sId)) {
                            Set<String> hs = map.get(sId);
                            if (hs.contains(PM_ANY_ANY)) {
                                attainableSPc = new HashSet<String>();
                                attainableSPc.add(PM_ANY_ANY);
                            } else if (attainableSPc.contains(PM_ANY_ANY)) {
                                // The union operation leaves attainable
                                // unchanged.
                            } else {
                                attainableSPc.addAll(map.get(sId));
                            }
                        }
                    }
                    printSet(attainableSPc, PM_PERM,
                            "*Attainable union for pc entry");

                    // If this pc entry does not yield any permissions for set
                    // s,
                    // we can skip the rest of ht entries and discard s.
                    if (attainableSPc.isEmpty()) {
                        bPcContribIsEmpty = true;
                        break;
                    }

                    // We got some permissions for s and this pc. If this pc is
                    // the first
                    // for this s, store them in attainableS. Otherwise
                    // intersect them
                    // with the crt attainableS.
                    if (firstTime) {
                        firstTime = false;
                        attainableS = new HashSet<String>(attainableSPc);
                    } else {
                        if (attainableS.contains(PM_ANY_ANY)) {
                            attainableS = new HashSet<String>(attainableSPc);
                        } else if (attainableSPc.contains(PM_ANY_ANY)) {
                            // The intersection operation leaves attainableS
                            // unchanged.
                        } else {
                            attainableS.retainAll(attainableSPc);
                        }
                    }
                } // for each ht entry

                // At this point there are three cases:
                // 1. We broke out from the loop on ht entries because a ht
                // entry had
                // no attainable permissions, fact signaled by bPcContribIsEmpty
                // = true.
                // 2. The loop ended normally with an empty intersection.
                // 3. The loop ended normally with a non-empty intersection.
                // In cases 1 and 2, discard the maximal subset s and continue
                // with the
                // next one. In case 3, store s and its attainableS in a HashMap
                // for
                // later use.
                if (bPcContribIsEmpty || attainableS.isEmpty()) {
                    System.out.println("*Discard the following maximal subset (no attainable perms):");
                    printSet(actSet, PM_NODE_UATTR, null);
                    maxiter2.remove();
                } else {
                    // Store s as key and attainable as value in the HashMap
                    // "subAttain"
                    // for later processing.
                    System.out.println("*The following maximal subset:");
                    printSet(actSet, PM_NODE_UATTR, "");
                    System.out.println("*    has attainable perms:");
                    printSet(attainableS, PM_PERM, "");
                    subAttain.put(actSet, attainableS);
                }
            } // for each s
        } catch (Exception e) {
            e.printStackTrace();
            System.out.println("Exception, returning no!");
            return resNo;
        }
        System.out.println("*The maximal subsets after discarding those without attainable perms:");
        printMaximalSubsets(newMaxActSets);

        // maxActSets may be empty after discarding some s.
        if (newMaxActSets.isEmpty()) {
            System.out.println("newMaxActSets is empty, returning no");
            return resNo;
        }

        // The following was added when removing modified elements from the
        // hashset didn't work.
        // if (subAttain.isEmpty()) return crtperms;

        // Right now, for each maximal set of activable attributes s we have the
        // set of its attainable permissions. This info is in the HashMap
        // subAttain = {[s, attainable(s)]}.
        // Note that attainable(s) contains only new requested permissions.
        // Next step is to select an s. In this implementation, we select an s
        // with maximum number of attainable permissions.
        // To do: find that s during the preceding loop.
        Iterator<HashSet<String>> attainiter = subAttain.keySet().iterator();// The
        // key
        // is
        // an
        // s.
        int max = 0; // max number of permissions til now.
        HashSet<String> sm = null;
        HashSet<String> attainableSM = null;
        while (attainiter.hasNext()) {
            HashSet<String> s = attainiter.next();
            HashSet<String> attain = subAttain.get(s);
            if (attain.size() > max) {
                max = attain.size();
                sm = s;
                attainableSM = attain;
            }
        }

        printSet(sm, PM_NODE_UATTR, "*We selected the maximal subset:");
        printSet(attainableSM, PM_PERM, "*    with the attainable perms:");

        // Next step is to mark for activation the attributes of each ht entry
        // WHICH ALSO ARE IN sm. Same algorithm as in no sac case. Remember that
        // some of the attributes in the ht entry MAY ALREADY BE ACTIVE, and
        // some of the attributes may have already been marked during processing
        // of another entry.

        // The set of attributes marked for activation is initially empty.
        HashSet<String> markedAttrs = new HashSet<String>();
        Iterator<Map<String, Set<String>>> htiter = ht.values().iterator();

        System.out.println("*Start attribute marking");
        while (htiter.hasNext()) {
            // For each entry in ht, which is a HashMap:
            System.out.println("*For a ht entry");
            HashMap<String, Set<String>> entrymap = (HashMap<String, Set<String>>) htiter.next();
            // Initially all the entries in entrymap with keys (i.e., ua)
            // in sm are selectable. Note that this condition will be
            // enforced in selectBest().
            HashMap<String, Set<String>> selectable = new HashMap<String, Set<String>>(entrymap);
            // ...no permissions are attained so far,...
            HashSet<String> acquired = new HashSet<String>();
            // ...and all attainable permissions still remain to be attained.
            HashSet<String> remaining = new HashSet<String>(attainableSM);
            printSet(remaining, PM_PERM, "*   The initial remaining set is");

            // Some attributes could already be active.
            // Some other attributes could have already been marked for
            // activation during processing of other entries. Compute
            // their share of permissions.
            Iterator<String> mapiter = entrymap.keySet().iterator();
            while (mapiter.hasNext()) {
                String sUaId = mapiter.next();
                if (!sessActiveAttrs.contains(sUaId)
                        && !markedAttrs.contains(sUaId)) {
                    continue;
                }

                // This attribute is already active or was already marked to be
                // activated
                // in another entry. Update the sets accordingly.
                System.out.println("*   User attribute "
                        + getEntityName(sUaId, PM_NODE_UATTR)
                        + " is already active or marked.");
                Set<String> set = entrymap.get(sUaId);
                printSet(set, PM_PERM, "*      Its share is:");
                if (set.contains(PM_ANY_ANY)) {
                    acquired = new HashSet<String>();
                    acquired.add(PM_ANY_ANY);
                } else if (acquired.contains(PM_ANY_ANY)) {
                } else {
                    acquired.addAll(set);
                }
                if (set.contains(PM_ANY_ANY)) {
                    remaining.clear();
                } else if (remaining.contains(PM_ANY_ANY)) {
                } else {
                    remaining.removeAll(set);
                }
                printSet(remaining, PM_PERM, "*      After it, remaining is:");
                selectable.remove(sUaId);
            }

            // Continue to select other attributes for activation until all
            // attainable permissions are acquired.
            System.out.println("*   Start attribute selection");
            while (!remaining.isEmpty()) {
                // Select next user attribute to activate from this pc entry.
                String sUaId = selectBest(selectable, remaining, sm);

                System.out.println("*   User attribute "
                        + getEntityName(sUaId, PM_NODE_UATTR)
                        + " was selected in selectBest");
                // Add ua to the set to activate.
                markedAttrs.add(sUaId);
                // Update the sets.
                Set<String> set = selectable.get(sUaId);

                printSet(set, PM_PERM, "*      Its share is:");

                if (set.contains(PM_ANY_ANY)) {
                    acquired = new HashSet<String>();
                    acquired.add(PM_ANY_ANY);
                } else if (acquired.contains(PM_ANY_ANY)) {
                } else {
                    acquired.addAll(set);
                }
                if (set.contains(PM_ANY_ANY)) {
                    remaining.clear();
                } else if (remaining.contains(PM_ANY_ANY)) {
                } else {
                    remaining.removeAll(set);
                }
                printSet(remaining, PM_PERM, "*      After it, remaining is:");
                selectable.remove(sUaId);
            }
        }

        // Remove the attributes already active.
        markedAttrs.removeAll(sessActiveAttrs);

        if (markedAttrs.isEmpty()) {
            System.out.println("The diff between the attribute sets is empty, returning no");
            return resNo;
        }

        // For each attribute to be activated
        Iterator<String> markedIter = markedAttrs.iterator();
        while (markedIter.hasNext()) {
            String sUaId = markedIter.next();
            System.out.println("wouldOpenPreventSave: For attr "
                    + getEntityName(sUaId, PM_NODE_UATTR));
            // For each deny of this attribute and of intra-session type
            NamingEnumeration<?> denies;
            try {
                SearchControls constraints = new SearchControls();
                constraints.setSearchScope(SearchControls.ONELEVEL_SCOPE);
                constraints.setReturningAttributes(new String[]{"pmId",
                        "pmName", "pmIsIntersection", "pmAttr", "pmOp"});
                denies = ctx.search(sDenyContainerDN, "(&(pmOriginalId="
                        + sUaId + ")(pmType=intra session))", constraints);
                while (denies != null && denies.hasMore()) {
                    SearchResult sr = (SearchResult) denies.next();
                    String sDenyName = (String) sr.getAttributes().get("pmName").get();
                    System.out.println("                        For deny "
                            + sDenyName);
                    /*String sDenyId = (String) sr.getAttributes().get("pmId")
                    .get();*/
                    boolean bIsInters = ((String) sr.getAttributes().get("pmIsIntersection").get()).equalsIgnoreCase("TRUE");
                    Attribute containerattr = sr.getAttributes().get("pmAttr");

                    // See whether the opset for this deny contains
                    // "File write".
                    Attribute opattr = sr.getAttributes().get("pmOp");
                    if (opattr != null) {
                        for (NamingEnumeration<?> enumer = opattr.getAll(); enumer.hasMore(); ) {
                            String sOp = (String) enumer.next();
                            System.out.println("                          Found op "
                                    + sOp);
                            if (!sOp.equalsIgnoreCase("File write")) {
                                continue;
                            }

                            // So one of the denied operations is "File write".
                            // Now we have to find an open object in the session
                            // that's
                            // in the deny's container set.
                            Iterator<String> sooiter = sessOpenObjs.iterator();
                            while (sooiter.hasNext()) {
                                String sOpenObj = sooiter.next();
                                String sOOAssocId = getEntityId(sOpenObj,
                                        PM_NODE_OATTR);
                                System.out.println("                            For open obj "
                                        + sOpenObj
                                        + " and assoc oattr id "
                                        + sOOAssocId);
                                // We have to consider intersection/union and
                                // container complements.
                                if (entityIsInDenyList(sOOAssocId,
                                        PM_NODE_OATTR, containerattr, bIsInters)) {
                                    System.out.println("                              Found it in the deny set");
                                    return resYes;
                                }
                            }
                        }
                    }
                }
            } catch (Exception e) {
                e.printStackTrace();
            }
        }

        System.out.println("End of loop, returning no");
        return resNo;
    }

    // RequestPermsInternal() finds and activates the attributes
    // that grant the session the requested permissions on an object.
    // It only considers intra-session SACs. For a version that
    // also considers across-sessions SACs, see requestPermsInternal2().
    // sTgtOaId is the identifier of the target object attribute.
    // Note: Actually sTgtOaId can be any object attribute.
    /*private HashSet<String> requestPermsInternal(String sSessId,
   String sTgtOaId, String sReqPerms) {
   //NamingEnumeration<?> objs;
   HashSet<String> activeAttrs;
   Vector<String> policyClasses;
   Vector<String> opsets;
   Vector<String> oattrs;
   //HashSet<?> objects;

   String sPcId;
   //String sAaId;
   String sOpsId;
   String sOaId;

   System.out.println("***requestPermsInternal on OATTR "
   + getNameOfEntityWithIdAndType(sTgtOaId, PM_NODE_OATTR) + "***");

   HashSet<String> reqops = stringToSet(sReqPerms);
   HashSet<String> crtperms = getPermsInternal(sSessId, sTgtOaId);
   HashSet<String> newreqops = new HashSet<String>(reqops);

   // Subtract the current permissions (the session already has) from the
   // requested operations.
   if (crtperms.contains(PM_ANY_ANY)) {
   newreqops.clear();
   } else {
   newreqops.removeAll(crtperms);
   }

   System.out.println("*Req perms: " + setToString(reqops));
   System.out.println("*Crt perms: " + setToString(crtperms));
   System.out.println("*New req perms: " + setToString(newreqops));

   // If the client requested no permissions beyond those it already has,
   // return all current permissions as granted.
   // if (newreqops.isEmpty()) return setToPacket(reqops);
   if (newreqops.isEmpty()) {
   return crtperms;
   }

   // Get the session's user, active attributes, and policy classes.
   String sUserId = getSessionUserId(sSessId);
   activeAttrs = getSessionActiveAttrSet(sSessId);
   policyClasses = getPolicyClasses();

   // Prepare the set of activable attributes, which will contain the
   // active attributes for the given session, and all attributes
   // inserted in ht below.
   HashSet<String> activableAttrs = new HashSet<String>(activeAttrs);

   // Create a hashtable ht. A ht entry has a policy class as key, and a
   // HashMap as value. The HashMap has a user attribute as key and a
   // HashSet of permissions (operations) as value.
   // Only policy classes that contain the object appear as keys in ht.
   // The user attribute must be within the policy class. The permissions
   // are those that become available to the subject when the attribute
   // is activated.
   Hashtable<String, Map<String, Set<String>>> ht = new Hashtable<String, Map<String, Set<String>>>();

   // For each policy class pc
   for (int pc = 0; pc < policyClasses.size(); pc++) {
   sPcId = policyClasses.elementAt(pc);
   // If (!(o ->+ pc)) continue.
   if (!attrIsAscendantToPolicy(sTgtOaId, PM_NODE_OATTR, sPcId)) {
   continue;
   }
   // The object is in this policy class. Note that at this time
   // ht has no entry for pc. Add an entry [pc, empty] to ht.
   addHtEntry(sPcId, null, (String) null, ht);
   System.out.println("*ht <--- new empty entry for pc = "
   + getNameOfEntityWithIdAndType(sPcId, PM_NODE_POL));
   Map<String, Set<String>> pcmap = ht.get(sPcId);

   // For each user attribute ua such that u ->+ ua and ua ->+ pc and
   // ua NOT active:
   HashSet<String> authattrs = getUserDescendantsInternal(sUserId);
   Iterator<String> uaiter = authattrs.iterator();
   while (uaiter.hasNext()) {
   String sUaId = uaiter.next();
   System.out.println("*  Examine ua = "
   + getNameOfEntityWithIdAndType(sUaId, PM_NODE_UATTR));
   if (!attrIsAscendantToPolicy(sUaId, PM_NODE_UATTR, sPcId)) {
   System.out.println("*             is NOT in "
   + getNameOfEntityWithIdAndType(sPcId, PM_NODE_POL));
   continue;
   }
   System.out.println("*             is in "
   + getNameOfEntityWithIdAndType(sPcId, PM_NODE_POL));

   // Add [ua,empty] to the hashmap for pc.
   System.out.println("*  ht[" + getNameOfEntityWithIdAndType(sPcId, PM_NODE_POL)
   + "] <--- new empty entry for ua = "
   + getNameOfEntityWithIdAndType(sUaId, PM_NODE_UATTR));
   addHtEntry(sPcId, sUaId, (String) null, ht);

   // For each opset ops such that ua->ops
   opsets = getToOpsets(sUaId);
   for (int ops = 0; ops < opsets.size(); ops++) {
   sOpsId = opsets.elementAt(ops);

   // If the ops does not contribute any operation towards
   // newreqops,
   // then continue with the next op set.
   // First get all ops' operations.
   HashSet<String> contrib = new HashSet<String>();
   addOpsetToSet(sOpsId, contrib);

   printSet(contrib, PM_PERM, "Brut contribution of opset "
   + getNameOfEntityWithIdAndType(sOpsId, PM_NODE_OPSET));

   // Then retain only those included in the requested ops.
   if (contrib.contains(PM_ANY_ANY)) {
   contrib = new HashSet<String>(newreqops);
   } else if (newreqops.contains(PM_ANY_ANY)) {
   // Intersection leaves contrib unchanged.
   } else {
   contrib.retainAll(newreqops);
   }
   if (contrib.isEmpty()) {
   continue;
   }

   // For each oa such that ops -> oa
   oattrs = getToAttrs(sOpsId);
   for (int oa = 0; oa < oattrs.size(); oa++) {
   sOaId = oattrs.elementAt(oa);
   // If !(oa ->+ pc) continue.
   if (!attrIsAscendantToPolicy(sOaId, PM_NODE_OATTR,
   sPcId)) {
   continue;
   }
   // If !(o ->* oa) continue
   if (!attrIsAscendant(sTgtOaId, sOaId, PM_NODE_OATTR)) {
   continue;
   }
   // Add ua's partial contribution (for this ops) to the
   // HashMap entry
   // for ua in the hashtable entry for pc.

   System.out.println("*    ht["
   + getNameOfEntityWithIdAndType(sPcId, PM_NODE_POL) + "]["
   + getNameOfEntityWithIdAndType(sUaId, PM_NODE_UATTR)
   + "] <--- its contribution:");
   printSet(contrib, PM_PERM, "Contribution of "
   + getNameOfEntityWithIdAndType(sUaId, PM_NODE_UATTR));
   addHtEntry(sPcId, sUaId, contrib, ht);
   }
   }
   HashSet<?> set = (HashSet<?>) pcmap.get(sUaId);
   if (set.isEmpty()) {
   pcmap.remove(sUaId);
   } else {
   activableAttrs.add(sUaId);
   }
   }
   // If the entry for pc has an empty HashMap, return the permissions
   // we already have.
   if (pcmap.isEmpty()) {
   return crtperms;
   }
   }

   // Now ht has entries [pc, {[ua1,set1],...,[uan,setn]}], meaning that
   // the subject will get seti permissions if uai gets activated within
   // pc.
   // Note that seti contains only new, requested permissions. By
   // activating
   // uai, the subject might acquire other permissions in addition to seti.
   System.out.println("*HashTable ht contents:");
   printHtWithPcKeys(ht);

   // The set activable contains the set of active and activable attributes
   // for the given session. Some of its members may be in SAC conflict.
   printSet(activableAttrs, PM_NODE_UATTR, "Set of activable attributes");

   // Compute all maximal subsets of activable with no SAC conflict:
   HashSet<HashSet<String>> maxActSets = getMaximalSubsetsInternal(activableAttrs);
   System.out.println("*Found the maximal subsets:");
   printMaximalSubsets(maxActSets);

   // Each element of maxActSets is a subset of activableAttrs with no
   // SAC conflict, but if we add any other attribute to it we get a
   // conflict.
   // Because the attributes already active for the session cannot be made
   // inactive, they should be contained in any set of attributes we
   // consider for activation. Hence we discard the elements of maxActSets
   // that do not include the attributes already active.
   Iterator<HashSet<String>> maxiter = maxActSets.iterator();
   while (maxiter.hasNext()) {
   HashSet<?> actSet = maxiter.next();
   if (!actSet.containsAll(activeAttrs)) {
   maxiter.remove();
   }
   }

   // If after discarding the maximal subsets that do not include
   // the active attributes there is no maximal subset left,
   // return the current perms:
   if (maxActSets.isEmpty()) {
   System.out
   .println("*None of the maximal subsets contains the active attributes.");
   System.out.println("*Returning the current permissions");
   return crtperms;
   }
   System.out
   .println("*The maximal subsets after discarding those that don't contain the active attrs:");
   printMaximalSubsets(maxActSets);

   // For each maximal subset s of activable attributes compute the set of
   // new requested permissions that can be acquired from the attributes
   // of that subset, denoted attainable(s):
   // For each entry in ht, we'll compute the union
   // of the operation sets in that entry, but only of those corresponding
   // to ua's from the maximal subset. Then we'll intersect those unions.
   // Store the pairs [s, attainable(s)] in a HashMap for later processing.
   HashMap<HashSet<String>, HashSet<String>> subAttain = new HashMap<HashSet<String>, HashSet<String>>();
   maxiter = maxActSets.iterator();
   // For each maximal subset s
   while (maxiter.hasNext()) {
   HashSet<String> s = maxiter.next();

   // Compute attainable permissions for s.
   HashSet<String> attainableS = new HashSet<String>(); // attainable(s)
   // in
   // description.
   HashSet<String> attainableSPc = new HashSet<String>(); // attainable(s,pc)
   // in
   // description.
   boolean firstTime = true;
   boolean bPcContribIsEmpty = false;
   Iterator<Map<String, Set<String>>> htiter = ht.values().iterator();
   // For each entry (we use the values) in ht:
   while (htiter.hasNext()) {
   Map<String, Set<String>> map = htiter.next();
   // Prepare to do the union for this ht entry. Use only map
   // entries
   // [ua,set] with ua in s.
   attainableSPc.clear();
   Iterator<String> mapiter = map.keySet().iterator();// The key is a
   // ua.
   while (mapiter.hasNext()) {
   String sId = mapiter.next();
   if (s.contains(sId)) {
   Set<String> hs = map.get(sId);
   if (hs.contains(PM_ANY_ANY)) {
   attainableSPc = new HashSet<String>();
   attainableSPc.add(PM_ANY_ANY);
   } else if (attainableSPc.contains(PM_ANY_ANY)) {
   // The union operation leaves attainable unchanged.
   } else {
   attainableSPc
   .addAll(map.get(sId));
   }
   }
   }

   printSet(attainableSPc, PM_PERM,
   "*Attainable union for pc entry");

   // If this pc entry does not yield any permissions for set s,
   // we can skip the rest of ht entries and discard s.
   if (attainableSPc.isEmpty()) {
   bPcContribIsEmpty = true;
   break;
   }
   // We got some permissions for s and this pc. If this pc is the
   // first
   // for this s, store them in attainableS. Otherwise intersect
   // them
   // with the crt attainableS.
   if (firstTime) {
   firstTime = false;
   attainableS = new HashSet<String>(attainableSPc);
   } else {
   if (attainableS.contains(PM_ANY_ANY)) {
   attainableS = new HashSet<String>(attainableSPc);
   } else if (attainableSPc.contains(PM_ANY_ANY)) {
   // The intersection operation leaves attainableS
   // unchanged.
   } else {
   attainableS.retainAll(attainableSPc);
   }
   }
   } // for each ht entry

   // At this point there are three cases:
   // 1. We broke out from the loop on ht entries because a ht entry
   // had
   // no attainable permissions, fact signaled by bPcContribIsEmpty =
   // true.
   // 2. The loop ended normally with an empty intersection.
   // 3. The loop ended normally with a non-empty intersection.
   // In cases 1 and 2, discard the maximal subset s and continue with
   // the
   // next one. In case 3, store s and its attainableS in a HashMap for
   // later use.
   if (bPcContribIsEmpty || attainableS.isEmpty()) {
   System.out
   .println("*The following maximal subset was discarded (no attainable perms):");
   printSet(s, PM_NODE_UATTR, null);
   maxiter.remove();
   continue;
   }

   // Store s as key and attainable as value in the HashMap "subAttain"
   // for later processing.
   System.out.println("*The following maximal subset:");
   printSet(s, PM_NODE_UATTR, "");
   System.out.println("*    has attainable perms:");
   printSet(attainableS, PM_PERM, "");
   subAttain.put(s, attainableS);
   } // for each s

   // maxActSets may be empty after discarding some s.
   if (maxActSets.isEmpty()) {
   return crtperms;
   }

   // Right now, for each maximal set of activable attributes s we have the
   // set of its attainable permissions. This info is in the HashMap
   // subAttain = {[s, attainable(s)]}.
   // Note that attainable(s) contains only new requested permissions.
   // Next step is to select an s. In this implementation, we select an s
   // with maximum number of attainable permissions.
   // To do: find that s during the preceding loop.
   Iterator<HashSet<String>> attainiter = subAttain.keySet().iterator();// The
   // key
   // is
   // an
   // s.
   int max = 0; // max number of permissions til now.
   HashSet<String> sm = null;
   HashSet<String> attainableSM = null;
   while (attainiter.hasNext()) {
   HashSet<String> s = attainiter.next();
   HashSet<String> attain = subAttain.get(s);
   if (attain.size() > max) {
   max = attain.size();
   sm = s;
   attainableSM = attain;
   }
   }

   printSet(sm, PM_NODE_UATTR, "*We selected the maximal subset:");
   printSet(attainableSM, PM_PERM, "*    with the attainable perms:");

   // Next step is to mark for activation the attributes of each ht entry
   // WHICH ALSO ARE IN sm. Same algorithm as in no sac case. Remember that
   // some of the attributes in the ht entry MAY ALREADY BE ACTIVE, and
   // some of the attributes may have already been marked during processing
   // of another entry.

   // The set of attributes marked for activation is initially empty.
   HashSet<String> markedAttrs = new HashSet<String>();
   Iterator<Map<String, Set<String>>> htiter = ht.values().iterator();

   System.out.println("*Start attribute marking");
   while (htiter.hasNext()) {
   // For each entry in ht, which is a HashMap:
   System.out.println("*For a ht entry");
   HashMap<String, Set<String>> entrymap = (HashMap<String, Set<String>>) htiter
   .next();
   // Initially all the entries in entrymap with keys (i.e., ua)
   // in sm are selectable. Note that this condition will be
   // enforced in selectBest().
   HashMap<String, Set<String>> selectable = new HashMap<String, Set<String>>(entrymap);
   // ...no permissions are attained so far,...
   HashSet<String> acquired = new HashSet<String>();
   // ...and all attainable permissions still remain to be attained.
   HashSet<String> remaining = new HashSet<String>(attainableSM);
   printSet(remaining, PM_PERM, "*   The initial remaining set is");

   // Some attributes could already be active.
   // Some other attributes could have already been marked for
   // activation during processing of other entries. Compute
   // their share of permissions.
   Iterator<String> mapiter = entrymap.keySet().iterator();
   while (mapiter.hasNext()) {
   String sUaId = mapiter.next();
   if (!activeAttrs.contains(sUaId)
   && !markedAttrs.contains(sUaId)) {
   continue;
   }

   // This attribute is already active or was already marked to be
   // activated
   // in another entry. Update the sets accordingly.
   System.out.println("*   User attribute "
   + getNameOfEntityWithIdAndType(sUaId, PM_NODE_UATTR)
   + " is already active or marked.");
   Set<String> set = entrymap.get(sUaId);
   printSet(set, PM_PERM, "*      Its share is:");
   if (set.contains(PM_ANY_ANY)) {
   acquired = new HashSet<String>();
   acquired.add(PM_ANY_ANY);
   } else if (acquired.contains(PM_ANY_ANY)) {
   } else {
   acquired.addAll(set);
   }
   if (set.contains(PM_ANY_ANY)) {
   remaining.clear();
   } else if (remaining.contains(PM_ANY_ANY)) {
   } else {
   remaining.removeAll(set);
   }
   printSet(remaining, PM_PERM, "*      After it, remaining is:");
   selectable.remove(sUaId);
   }

   // Continue to select other attributes for activation until all
   // attainable permissions are acquired.
   System.out.println("*   Start attribute selection");
   while (!remaining.isEmpty()) {
   // Select next user attribute to activate from this pc entry.
   String sUaId = selectBest(selectable, remaining, sm);

   System.out.println("*   User attribute "
   + getNameOfEntityWithIdAndType(sUaId, PM_NODE_UATTR)
   + " was selected in selectBest");
   // Add ua to the set to activate.
   markedAttrs.add(sUaId);
   // Update the sets.
   Set<String> set = selectable.get(sUaId);

   printSet(set, PM_PERM, "*      Its share is:");

   if (set.contains(PM_ANY_ANY)) {
   acquired = new HashSet<String>();
   acquired.add(PM_ANY_ANY);
   } else if (acquired.contains(PM_ANY_ANY)) {
   } else {
   acquired.addAll(set);
   }
   if (set.contains(PM_ANY_ANY)) {
   remaining.clear();
   } else if (remaining.contains(PM_ANY_ANY)) {
   } else {
   remaining.removeAll(set);
   }
   printSet(remaining, PM_PERM, "*      After it, remaining is:");
   selectable.remove(sUaId);
   }
   }

   // Activate the attributes in toActivate.
   activateAttributesInternal(sSessId, markedAttrs);
   // The newly activated attributes might produce new permissions in
   // addition
   // to the requested ones. Recompute and return current permissions.
   // crtperms.addAll(attainable);
   crtperms = getPermsInternal(sSessId, sTgtOaId);
   return crtperms;
   }
    */
    // The selectable argument is a partial entry in the Hashtable
    // used in requestPerms(). From it we have to chose an attribute to
    // activate. The remaining argument is a set containing the
    // permissions requested but still not attained.
    /*private String selectBestNoSac(Map<?, ?> selectable,
    HashSet<String> remaining) {
    // Walk through selectable's entries.
    // Select that key (ua) which contributes the maximum number of perms.
    int maxContrib = 0;
    String sSelectedUa = null;

    Iterator<?> mapiter = selectable.keySet().iterator();
    while (mapiter.hasNext()) {
    String sUa = (String) mapiter.next();
    HashSet<?> set = (HashSet<?>) ((HashSet<?>) selectable.get(sUa))
    .clone();
    set.retainAll(remaining);
    if (set.size() > maxContrib) {
    maxContrib = set.size();
    sSelectedUa = sUa;
    }
    }
    return sSelectedUa;
    }*/
    private String selectBest(HashMap<String, Set<String>> selectable,
                              HashSet<String> remaining, HashSet<String> sm) {
        // Walk through selectable's entries whose keys ARE ALSO IN sm.
        // Select that key (i.e., ua) which contributes the maximum number of
        // perms.
        int maxContrib = 0;
        String sSelectedUa = null;
        System.out.println("*    *Begin selectBest");
        printSet(remaining, PM_PERM, "*    *with remaining set:");
        Iterator<String> mapiter = selectable.keySet().iterator();
        while (mapiter.hasNext()) {
            String sUa = (String) mapiter.next();
            if (!sm.contains(sUa)) {
                continue;
            }
            HashSet<String> set = new HashSet<String>(selectable.get(sUa));
            printSet(set, PM_PERM, "*    *selectBest: attribute "
                    + getEntityName(sUa, PM_NODE_UATTR) + " has contrib:");
            if (set.contains(PM_ANY_ANY)) {
                set = new HashSet<String>(remaining);
            } else if (remaining.contains(PM_ANY_ANY)) {
            } else {
                set.retainAll(remaining);
            }
            if (set.size() > maxContrib) {
                maxContrib = set.size();
                sSelectedUa = sUa;
            }
        }
        System.out.println("*    *End selectBest");
        return sSelectedUa;
    }

    // For an object identified by its name (the name may be assumed to be
    // an OATTR associated with the object), find the properties: class of the
    // object (File, Directory, User, User attribute, etc.),
    // original name and id of the PM entity if the object is a PM entity,
    // the host and path if the object is a File or Directory,
    // whether it represents a subgraph of the PM graph (if the object
    // is a PM entity), and the permissions of the crt. session's processes.
    // Return value: a Packet with:
    // Item 0: <name>|<id>|<class>|<inh>|<host or orig name>|<path or orig id>
    // Item 1: <permission>
    // Item 2: <permission>
    // ...
    // The name and id are those of the virtual object. The original name and id
    // are those of the original PM entity represented by the virtual object.
    // The host and path are those of the File or Directory represented by the
    // virtual object.
    private Packet refMediation(String sCrtSessId, String sObjName) {
        String sObjId = getEntityId(sObjName, PM_OBJ);
        if (sObjId == null) {
            return failurePacket("No object of name " + sObjName);
        }

        Packet res =  getObjInfo(sObjId);
        if (res.hasError()) {
            return res;
        }

        // Find the id of the associated object attribute, then the permissions.
        String sOattrId = getEntityId(sObjName, PM_NODE_OATTR);
        if (sOattrId == null) {
            return failurePacket("The object " + sObjName
                    + " has no associated attribute!");
        }
        HashSet<String> grantedPerms = getPermsInternal(sCrtSessId, sOattrId);
        if (grantedPerms == null) {
            return failurePacket("The engine returned a null set of granted permissions!");
        }

        HashSet<String> deniedPerms;
        try {
            deniedPerms = getDeniedPerms(sCrtSessId, null, sOattrId,
                    PM_NODE_OATTR);
        } catch (Exception e) {
            if (debugFlag) {
                e.printStackTrace();
            }
            return failurePacket("Exception while computing denied permissions: "
                    + e.getMessage());
        }
        grantedPerms.removeAll(deniedPerms);

        // Add the permissions to the resulting packet.
        try {
            Iterator<String> iter = grantedPerms.iterator();
            while (iter.hasNext()) {
                res.addItem(ItemType.RESPONSE_TEXT, iter.next());
            }
        } catch (Exception e) {
            e.printStackTrace();
            return failurePacket("Exception when building the result packet");
        }

        return res;
    }

    //
    // GetPermittedOps computes the operations that are permitted
    // to a session/process on a given object. In doing that, it
    // considers all attributes of the process/session user as being
    // active.
    // Let p be a process for user u in a session sess.
    //
    // Process p in session sess is permitted operation op on object o
    // iff (u, op, o) is a permission and (op, o) is not denied
    // for user u or session sess or process p.
    //
    // For the definition of permissions (u, op, o), see the docs.
    //
    // Parameters:
    // sCrtSessId: the id of the session.
    // sCrtProcId: the id of the process.
    // sObjName: the name of the object.
    //
    // Return:
    // An error packet or a packet that contains the following items:
    // Item 0: <name>|<id>|<class>|<inh>|<host or orig name>|<path or orig id>
    // Item 1: <operation permitted>
    // Item 2: <operation permitted>
    // ...
    //
    private Packet getPermittedOps(String sCrtSessId, String sCrtProcId,
                                   String sObjName) {
        String sObjId = getEntityId(sObjName, PM_OBJ);
        if (sObjId == null) {
            return failurePacket("No object of name " + sObjName);
        }

        Packet res =  getObjInfo(sObjId);
        if (res.hasError()) {
            return res;
        }

        // Find the id of the associated object attribute, then the permissions.
        String sOattrId = getEntityId(sObjName, PM_NODE_OATTR);
        if (sOattrId == null) {
            return failurePacket("The object " + sObjName
                    + " has no associated attribute!");
        }
        HashSet<String> grantedPerms = getPermittedOpsInternal(sCrtSessId,
                sOattrId);
        if (grantedPerms == null) {
            return failurePacket("The engine returned a null set of granted permissions!");
        }

        HashSet<String> deniedPerms;
        try {
            deniedPerms = getDeniedPerms(sCrtSessId, sCrtProcId, sOattrId,
                    PM_NODE_OATTR);
        } catch (Exception e) {
            if (debugFlag) {
                e.printStackTrace();
            }
            return failurePacket("Exception while computing denied permissions: "
                    + e.getMessage());
        }
        grantedPerms.removeAll(deniedPerms);

        // Add the permissions to the resulting packet.
        try {
            Iterator<String> iter = grantedPerms.iterator();
            while (iter.hasNext()) {
                res.addItem(ItemType.RESPONSE_TEXT, iter.next());
            }
        } catch (Exception e) {
            e.printStackTrace();
            return failurePacket("Exception when building the result packet");
        }

        return res;
    }

    // Return some object properties, like if it's an email message, sent by
    // whom,
    // when, subject.
    private Packet getObjEmailProps(String sCrtSessId, String sObjName) {
        // sObjName must be the name of an object.
        String sObjId = getEntityId(sObjName, PM_OBJ);
        if (sObjId == null) {
            return failurePacket("Selected entity, " + sObjName
                    + ", is not an object!");
        }

        try {
            Attributes objattrs = ctx.getAttributes("CN=" + sObjId + ","
                    + sVirtualObjContainerDN);
            String sClass = (String) objattrs.get("pmObjClass").get();
            if (!sClass.equals(PM_CLASS_FILE_NAME)) {
                return failurePacket("Selected object is not an email message!");
            }
            String sPath = (String) objattrs.get("pmPath").get();
            if (!sPath.endsWith(".eml")) {
                return failurePacket("Selected object is not an email message!");
            }
            Attribute attr = objattrs.get("pmEmlSender");
            if (attr == null) {
                return failurePacket("No email properties set!");
            }

            Packet res = new Packet();
            res.addItem(ItemType.RESPONSE_TEXT, (String) attr.get());
            res.addItem(ItemType.RESPONSE_TEXT,
                    (String) objattrs.get("pmEmlRecip").get());
            res.addItem(ItemType.RESPONSE_TEXT,
                    (String) objattrs.get("pmTimestamp").get());
            res.addItem(ItemType.RESPONSE_TEXT,
                    (String) objattrs.get("pmEmlSubject").get());
            attr = objattrs.get("pmEmlAttached");
            if (attr != null) {
                for (NamingEnumeration<?> enumer = attr.getAll(); enumer.hasMore(); ) {
                    res.addItem(ItemType.RESPONSE_TEXT, (String) enumer.next());
                }
            }
            return res;
        } catch (Exception e) {
            e.printStackTrace();
            return failurePacket("Exception while extracting properties; "
                    + e.getMessage());
        }
    }

    // For return value, see the refMediation() function.
    private Packet getVosIdProperties(String sCrtSessId, String sVosPresType,
                                      String sVosId) {
        Attributes attrs;
        try {
            if (sVosPresType.equalsIgnoreCase(PM_VOS_PRES_ADMIN)) {
                attrs = ctx.getAttributes("CN=" + sVosId + ","
                        + sAdminVosNodeContainerDN);
            } else {
                attrs = ctx.getAttributes("CN=" + sVosId + ","
                        + sVosNodeContainerDN);
            }
            String sSessId = (String) attrs.get("pmSessId").get();
            if (!sSessId.equalsIgnoreCase(sCrtSessId)) {
                return failurePacket("Inconsistency: The node you selected does not appear in the current session!");
            }
            String sOrigId = (String) attrs.get("pmOriginalId").get();
            String sType = null;
            if (sVosPresType.equalsIgnoreCase(PM_VOS_PRES_ADMIN)) {
                sType = (String) attrs.get("pmType").get();
            } else {
                String s = (String) attrs.get("pmIsObj").get();
                sType = s.equalsIgnoreCase("TRUE") ? PM_NODE_ASSOC
                        : PM_NODE_OATTR;
            }
            if (sType.equalsIgnoreCase(PM_NODE_ASSOC)) {
                // Let's find the virtual object.
                String sObjId = getAssocObj(sOrigId);
                if (sObjId == null) {
                    return failurePacket("Inconsistency: The node you selected has no associated object!");
                }
                // Extract the properties from the virtual object.
                return getObjInfo(sObjId);
            } else {
                attrs = ctx.getAttributes("CN=" + sOrigId + ","
                        + sObjAttrContainerDN);
                Attribute attr = attrs.get("pmTemplateId");
                if (attr == null) {
                    return failurePacket("The selected node is not an object or a record!");
                }
                String sTemplateId = (String) attr.get();
                String sTemplateName = getEntityName(sTemplateId, PM_TEMPLATE);
                if (sTemplateName == null) {
                    return failurePacket("Inconsistency: no template with id "
                            + sTemplateId);
                }
                String sName = getEntityName(sOrigId, PM_NODE_OATTR);
                Packet res = new Packet();
                res.addItem(ItemType.RESPONSE_TEXT, sName + PM_ALT_FIELD_DELIM
                        + sOrigId + PM_ALT_FIELD_DELIM + PM_CLASS_RECORD_NAME
                        + PM_ALT_FIELD_DELIM + "no" + PM_ALT_FIELD_DELIM
                        + sTemplateName);
                return res;
            }

        } catch (Exception e) {
            if (debugFlag) {
                e.printStackTrace();
            }
            return failurePacket("Error while getting VOS node properties: "
                    + e.getMessage());
        }
    }

    // Find the object id from an object id, or an oattr id, or an object name.
    String getObjId(String sObj) {
        //String sObjId = null;

        // First try as if sObj were an oattr id. Return the assoc object.
        String sObjName = getEntityName(sObj, PM_NODE_OATTR);
        if (sObjName != null) {
            return getAssocObj(sObj);
        }

        // Argument is not an oattr id. Try as if it were an object id.
        sObjName = getEntityName(sObj, PM_OBJ);
        if (sObjName != null) {
            return sObj;
        }

        // The argument is not an object id. Try as if it were an object name.
        return getEntityId(sObj, PM_OBJ);
    }

    private Packet getObjProperties(String sObjOrObjAttribute) {
        System.out.println("Calling getObjProperties(" + sObjOrObjAttribute + ")");
        String sObjId = getObjId(sObjOrObjAttribute);
        System.out.println("Actual sObjId is " + sObjId);
        Attributes virattrs;
        Packet result = new Packet();
        try {
            virattrs = ctx.getAttributes("CN=" + sObjId + ","
                    + sVirtualObjContainerDN);
            String sName = (String) virattrs.get("pmName").get();
            String sOattrId = (String) virattrs.get("pmAssocAttr").get();
            String sClass = (String) virattrs.get("pmObjClass").get();
            String sIncludes = (String) virattrs.get("pmIncludesAscendants").get();
            sIncludes = (sIncludes.equals("TRUE") ? "yes" : "no");
            if (sClass.equals(PM_CLASS_UATTR_NAME) ||
                    sClass.equals(PM_CLASS_OATTR_NAME) ||
                    sClass.equals(PM_CLASS_POL_NAME)) {
                HashSet props = getProps(sObjId, sClass);
                if (props != null) {
                    StringBuilder propsBuilder = new StringBuilder();
                    for (Object obj : props) {
                        propsBuilder.append(obj);
                        propsBuilder.append(PM_ALT_FIELD_DELIM);
                    }
                    String propsString = propsBuilder.toString();
                    result.addItem(ItemType.RESPONSE_TEXT, propsString);
                }
            }

        } catch (NamingException ne) {
            ne.printStackTrace(System.out);
        } catch (PacketException pe) {
            pe.printStackTrace(System.out);
        }
        return result;

    }

    // This method should work when sObj is the name or id of an object or of
    // the
    // oattr associated with an object.
    // Returns:
    // For File/Dir: <name>|<oattr id>|<class>|<inh>|<host>|<path>
    // For PM entity: <name>|<oattr id>|<class>|<inh>|<orig name>|<orig id>
    // For Composite: <name>|<oattr id>|<class>|<inh>.
    private Packet getObjInfo(String sObj) {
        System.out.println("Calling getObjInfo(" + sObj + ")" + " and the obj String: " + sObj + "\n");
        String sObjId = getObjId(sObj);
        System.out.println("Actual sObjId is " + sObjId);

        Attributes virattrs;
        Packet result = new Packet();
        try {
            virattrs = ctx.getAttributes("CN=" + sObjId + ","
                    + sVirtualObjContainerDN);
            String sName = (String) virattrs.get("pmName").get();
            String sOattrId = (String) virattrs.get("pmAssocAttr").get();
            String sClass = (String) virattrs.get("pmObjClass").get();
            String sIncludes = (String) virattrs.get("pmIncludesAscendants").get();
            sIncludes = (sIncludes.equals("TRUE") ? "yes" : "no");
            if (sClass.equals(PM_CLASS_FILE_NAME)
                    || sClass.equals(PM_CLASS_DIR_NAME)) {
                String sHost = (String) virattrs.get("pmHost").get();
                String sPath = (String) virattrs.get("pmPath").get();
                result.addItem(ItemType.RESPONSE_TEXT, sName
                        + PM_ALT_FIELD_DELIM + sOattrId + PM_ALT_FIELD_DELIM
                        + sClass + PM_ALT_FIELD_DELIM + sIncludes
                        + PM_ALT_FIELD_DELIM + sHost + PM_ALT_FIELD_DELIM
                        + sPath);
            } else if (sClass.equals(PM_CLASS_USER_NAME)
                    || sClass.equals(PM_CLASS_UATTR_NAME)
                    || sClass.equals(PM_CLASS_OBJ_NAME)
                    || sClass.equals(PM_CLASS_OATTR_NAME)
                    || sClass.equals(PM_CLASS_POL_NAME)
                    || sClass.equals(PM_CLASS_CONN_NAME)
                    || sClass.equals(PM_CLASS_OPSET_NAME)) {

                String sOrigName = (String) virattrs.get("pmOriginalName").get();
                String sOrigId = (String) virattrs.get("pmOriginalId").get();
                result.addItem(ItemType.RESPONSE_TEXT, sName
                        + PM_ALT_FIELD_DELIM + sOattrId + PM_ALT_FIELD_DELIM
                        + sClass + PM_ALT_FIELD_DELIM + sIncludes
                        + PM_ALT_FIELD_DELIM + sOrigName + PM_ALT_FIELD_DELIM
                        + sOrigId);

            } else {
                result.addItem(ItemType.RESPONSE_TEXT, sName
                        + PM_ALT_FIELD_DELIM + sOattrId + PM_ALT_FIELD_DELIM
                        + sClass + PM_ALT_FIELD_DELIM + sIncludes);
            }
            return result;
        } catch (Exception e) {
            if (debugFlag) {
                e.printStackTrace();
            }
            return failurePacket("Exception in getObjInfo(): " + e.getMessage());
        }
    }

    private Packet getUserDescendants(String sClientId, String sUserId) {
        return setToPacket(getUserDescendantsInternal(sUserId));
    }

    // Engine command. Used in reference mediation performed in OSSimulator.
    // sObjId is the id of a virtual object.
    private Packet getPerms(String sCrtSessId, String sSessId, String sObjId) {
        String sAssocOaId = getAssocOattr(sObjId);
        if (sAssocOaId == null) {
            return failurePacket("Your object has no associated attribute!");
        }
        return setToPacket(getPermsInternal(sSessId, sAssocOaId));
    }

    // Get the current permissions on an object attribute. It is assumed that
    // the
    // object attribute is associated to a virtual object, but in reality it
    // could
    // be any oattr.
    // This function is called from requestPermsInternal(),
    // requestPermsNoSacInternal(), refMediation(), getPerms().
    private HashSet<String> getPermsInternal(String sSessId, String sTgtOaId) /*
     * throws
     * Exception
     */ {
        //NamingEnumeration<?> objs;

        Vector<String> activeAttrs;
        Vector<String> policyClasses;
        Vector<String> opsets;
        Vector<String> oattrs;
        //HashSet<?> objects;

        String sPcId;
        String sAaId;
        String sOpsId;
        String sOaId;

        // Get the session's active attributes and the policy classes (as
        // Vectors).
        activeAttrs = getSessionActiveAttrs(sSessId);
        policyClasses = getPolicyClasses();

        // Create an empty HashMap.
        HashMap<String, HashSet<String>> hm = new HashMap<String, HashSet<String>>();

        // For each policy class pc
        for (int pc = 0; pc < policyClasses.size(); pc++) {
            sPcId = policyClasses.elementAt(pc);
            System.out.println("For pc = " + getEntityName(sPcId, PM_NODE_POL));
            // If (o is not in policy class pc) continue.
            if (!attrIsAscendantToPolicy(sTgtOaId, PM_NODE_OATTR, sPcId)) {
                System.out.println("  Oattr "
                        + getEntityName(sTgtOaId, PM_NODE_OATTR)
                        + " is not in " + getEntityName(sPcId, PM_NODE_POL));
                continue;
            }
            System.out.println("  Oattr "
                    + getEntityName(sTgtOaId, PM_NODE_OATTR) + " is in "
                    + getEntityName(sPcId, PM_NODE_POL));

            // The object is in this policy class. Note that at this time
            // hm has no entry for pc. Add an entry [pc, empty] to hm.
            System.out.println("  Create entry hm["
                    + getEntityName(sPcId, PM_NODE_POL) + "]");
            addHmEntry(sPcId, null, hm);

            // For each active attribute
            for (int aa = 0; aa < activeAttrs.size(); aa++) {
                sAaId = activeAttrs.elementAt(aa);
                System.out.println("  For each active attr "
                        + getEntityName(sAaId, PM_NODE_UATTR));
                // If !(aa ->+ pc) continue.
                if (!attrIsAscendantToPolicy(sAaId, PM_NODE_UATTR, sPcId)) {
                    System.out.println("    "
                            + getEntityName(sAaId, PM_NODE_UATTR)
                            + " is not in pc = "
                            + getEntityName(sPcId, PM_NODE_POL));
                    continue;
                }
                System.out.println("    " + getEntityName(sAaId, PM_NODE_UATTR)
                        + " is in pc = " + getEntityName(sPcId, PM_NODE_POL));

                // For each opset such that aa -> opset
                opsets = getToOpsets(sAaId);
                for (int ops = 0; ops < opsets.size(); ops++) {
                    sOpsId = opsets.elementAt(ops);

                    // For each oa such that opset -> oa
                    oattrs = getToAttrs(sOpsId);
                    for (int oa = 0; oa < oattrs.size(); oa++) {
                        sOaId = oattrs.elementAt(oa);
                        // If !(oa ->+ pc) continue.
                        if (!attrIsAscendantToPolicy(sOaId, PM_NODE_OATTR,
                                sPcId)) {
                            continue;
                        }
                        // If !(o ->* oa) continue
                        if (!attrIsAscendant(sTgtOaId, sOaId, PM_NODE_OATTR)) {
                            continue;
                        }
                        // Add [pc, ops] to the hashmap.
                        System.out.println("    Added "
                                + getEntityName(sOpsId, PM_NODE_OPSET)
                                + " to entry pc = "
                                + getEntityName(sPcId, PM_NODE_POL));
                        addHmEntry(sPcId, sOpsId, hm);
                    }
                }
            }
        }
        // Intersect the permissions in each entry of the HashMap.
        Iterator<HashSet<String>> iter = hm.values().iterator();
        boolean firstTime = true;
        HashSet<String> resultSet = new HashSet<String>();
        HashSet<String> crtSet;
        while (iter.hasNext()) {
            if (firstTime) {
                firstTime = false;
                resultSet = iter.next();
            } else {
                crtSet = iter.next();
                if (crtSet.contains(PM_ANY_ANY)) {
                } else if (resultSet.contains(PM_ANY_ANY)) {
                    resultSet = crtSet;
                } else {
                    resultSet.retainAll(crtSet);
                }
            }
        }
        return resultSet;
    }

    // Get the current permissions on an object attribute. It is assumed that
    // the
    // object attribute is associated to a virtual object, but in reality it
    // could
    // be any oattr.
    // This function is called from getPermittedOps(). It works as
    // if all the user's attributes were active.
    private HashSet<String> getPermittedOpsInternal(String sSessId,
                                                    String sTgtOaId) /* throws Exception */ {
        //NamingEnumeration<?> objs;

        Vector<String> activeAttrs;
        Vector<String> policyClasses;
        Vector<String> opsets;
        Vector<String> oattrs;
        //HashSet<?> objects;

        String sPcId;
        String sAaId;
        String sOpsId;
        String sOaId;

        // Get the session's active attributes and the policy classes (as
        // Vectors).
        String sUserId = getSessionUserId(sSessId);
        activeAttrs = getUserDescendantsInternalVector(sUserId);
        policyClasses = getPolicyClasses();

        // Create an empty HashMap.
        HashMap<String, HashSet<String>> hm = new HashMap<String, HashSet<String>>();

        // For each policy class pc
        for (int pc = 0; pc < policyClasses.size(); pc++) {
            sPcId = policyClasses.elementAt(pc);
            System.out.println("For pc = " + getEntityName(sPcId, PM_NODE_POL));
            // If (o is not in policy class pc) continue.
            if (!attrIsAscendantToPolicy(sTgtOaId, PM_NODE_OATTR, sPcId)) {
                System.out.println("  Oattr "
                        + getEntityName(sTgtOaId, PM_NODE_OATTR)
                        + " is not in " + getEntityName(sPcId, PM_NODE_POL));
                continue;
            }
            System.out.println("  Oattr "
                    + getEntityName(sTgtOaId, PM_NODE_OATTR) + " is in "
                    + getEntityName(sPcId, PM_NODE_POL));

            // The object is in this policy class. Note that at this time
            // hm has no entry for pc. Add an entry [pc, empty] to hm.
            System.out.println("  Create entry hm["
                    + getEntityName(sPcId, PM_NODE_POL) + "]");
            addHmEntry(sPcId, null, hm);

            // For each active attribute
            for (int aa = 0; aa < activeAttrs.size(); aa++) {
                sAaId = activeAttrs.elementAt(aa);
                System.out.println("  For each active attr "
                        + getEntityName(sAaId, PM_NODE_UATTR));
                // If !(aa ->+ pc) continue.
                if (!attrIsAscendantToPolicy(sAaId, PM_NODE_UATTR, sPcId)) {
                    System.out.println("    "
                            + getEntityName(sAaId, PM_NODE_UATTR)
                            + " is not in pc = "
                            + getEntityName(sPcId, PM_NODE_POL));
                    continue;
                }
                System.out.println("    " + getEntityName(sAaId, PM_NODE_UATTR)
                        + " is in pc = " + getEntityName(sPcId, PM_NODE_POL));

                // For each opset such that aa -> opset
                opsets = getToOpsets(sAaId);
                for (int ops = 0; ops < opsets.size(); ops++) {
                    sOpsId = opsets.elementAt(ops);

                    // For each oa such that opset -> oa
                    oattrs = getToAttrs(sOpsId);
                    for (int oa = 0; oa < oattrs.size(); oa++) {
                        sOaId = oattrs.elementAt(oa);
                        // If !(oa ->+ pc) continue.
                        if (!attrIsAscendantToPolicy(sOaId, PM_NODE_OATTR,
                                sPcId)) {
                            continue;
                        }
                        // If !(o ->* oa) continue
                        if (!attrIsAscendant(sTgtOaId, sOaId, PM_NODE_OATTR)) {
                            continue;
                        }
                        // Add [pc, ops] to the hashmap.
                        System.out.println("    Added "
                                + getEntityName(sOpsId, PM_NODE_OPSET)
                                + " to entry pc = "
                                + getEntityName(sPcId, PM_NODE_POL));
                        addHmEntry(sPcId, sOpsId, hm);
                    }
                }
            }
        }
        // Intersect the permissions in each entry of the HashMap.
        Iterator<HashSet<String>> iter = hm.values().iterator();
        boolean firstTime = true;
        HashSet<String> resultSet = new HashSet<String>();
        HashSet<String> crtSet = null;
        while (iter.hasNext()) {
            if (firstTime) {
                firstTime = false;
                resultSet = iter.next();
            } else {
                crtSet = iter.next();
                if (crtSet.contains(PM_ANY_ANY)) {
                } else if (resultSet.contains(PM_ANY_ANY)) {
                    resultSet = crtSet;
                } else {
                    resultSet.retainAll(crtSet);
                }
            }
        }
        return resultSet;
    }

    // A null sOpsId means an empty set of operations.
    private void addHmEntry(String sPcId, String sOpsId,
                            HashMap<String, HashSet<String>> hm) {
        HashSet<String> set;

        if (hm.containsKey(sPcId)) {
            set = hm.get(sPcId);
            addOpsetToSet(sOpsId, set);
        } else {
            set = new HashSet<String>();
            addOpsetToSet(sOpsId, set);
            hm.put(sPcId, set);
        }
    }

    // The command getPermittedOpsOnEntity is just for debugging.
    // It may be called from the admin tool.
    /*private Packet getPermittedOpsOnEntity(String sSessId, String sTargetId,
    String sTargetType) {
    return setToPacket(getPermittedOpsOnEntityInternal(sSessId, null,
    sTargetId, sTargetType));
    }*/
    // The command getPermittedOpsOnEntityInternal returns the set
    // of admin operations permitted to all processes
    // in a given session on a given target. The target is a PM entity
    // (like an object attribute, a policy class, etc.), which is
    // identified by its id and type. To find the admin operations
    // permitted to a process on this target, first we must find
    // the objects that represent the target. Then we have to find
    // the admin operations that are permitted on each representative
    // in each policy class, etc.
    // An object x represents the target t if:
    // - x.pmOriginalId = t.id and x.inh = no; or:
    // - x.pmOriginalId != null and x.inh = yes and t is in x.ascendants.
    private HashSet<String> getPermittedOpsOnEntityInternal(String sCrtSessId,
                                                            String sProcId, String sTgtId, String sTgtType) {
        HashSet<String> prSet = new HashSet<String>();
        String sObjId;

        if (sTgtType.equalsIgnoreCase(PM_NODE_ASSOC)) {
            sTgtType = PM_NODE_OATTR;
        }

        System.out.println("***********getPermittedOpsOnEntityInternal "
                + getEntityName(sTgtId, sTgtType));

        // Search PmVirtualObjContainer for objects x as in the above comment:
        NamingEnumeration<?> objects;
        try {
            SearchControls constraints = new SearchControls();
            constraints.setSearchScope(SearchControls.ONELEVEL_SCOPE);
            constraints.setReturningAttributes(new String[]{"pmId",
                    "pmOriginalId", "pmObjClass", "pmIncludesAscendants"});
            objects = ctx.search(sVirtualObjContainerDN, "(objectClass=*)",
                    constraints);
            while (objects != null && objects.hasMore()) {
                SearchResult sr = (SearchResult) objects.next();
                sObjId = (String) sr.getAttributes().get("pmId").get();
                Attribute attr = sr.getAttributes().get("pmOriginalId");
                if (attr == null) {
                    continue;
                }
                String sSomeEntityId = (String) attr.get();
                String sInh = (String) sr.getAttributes().get("pmIncludesAscendants").get();
                String sSomeEntityClass = (String) sr.getAttributes().get("pmObjClass").get();
                if (sSomeEntityId.equalsIgnoreCase(sTgtId)) {
                    prSet.add(sObjId);
                    System.out.println("Added virtual obj id " + sObjId);
                } else if (sInh.equalsIgnoreCase("true")
                        && isContained(sTgtId, sTgtType, sSomeEntityId,
                        classToType(sSomeEntityClass))) {
                    prSet.add(sObjId);
                    System.out.println("Added virtual obj id " + sObjId);
                }
            }
        } catch (Exception e) {
            if (debugFlag) {
                e.printStackTrace();
            }
        }

        printSet(prSet, PM_OBJ,
                "Set of virtual objects representing the entity "
                        + getEntityName(sTgtId, sTgtType));

        // If no virtual objects are mapped to the target entity,
        // return empty list of permissions.
        if (prSet.isEmpty()) {
            return new HashSet<String>();
        }

        // The computed operations permitted on the given entity.
        HashSet<String> computedOps = new HashSet<String>();

        // Find the denied operations on the target entity.
        HashSet<String> deniedOps;
        try {
            deniedOps = getDeniedPerms(sCrtSessId, sProcId, sTgtId, sTgtType);
        } catch (Exception e) {
            if (debugFlag) {
                e.printStackTrace();
            }
            return computedOps;
        }

        // Prepare for iteration through the objects that represent
        // the given entity (which were collected in prSet.
        Iterator<String> setiter = prSet.iterator();
        //String sUserId = getSessionUserId(sCrtSessId);

        // For each representative object
        while (setiter.hasNext()) {
            sObjId = setiter.next();
            System.out.println("---For the rep object " + sObjId + ","
                    + getEntityName(sObjId, PM_OBJ));

            // Get the oattr associated with the representative object.
            String sAssocOaId = getAssocOattr(sObjId);
            if (sAssocOaId == null) {
                continue;
            }

            // Get the permitted ops on the associated oattr:
            computedOps.addAll(getPermittedOpsInternal(sCrtSessId, sAssocOaId));
        }

        // Remove the denied operations:
        computedOps.removeAll(deniedOps);
        return computedOps;
    }

    // Request permissions on a PM entity. The entity is given by its id and
    // type.
    // Calls requestPermsOnPmEntityInternal() on the PM entity, which is
    // supposed
    // to be called from within the engine, to test whether the subject
    // is allowed to perform administrative operations on that entity.
    //
    // No longer used. PM works as if all a user's attributes were
    // active. Instead, PM calls getPermittedOpsOnEntity or
    // getPermittedOpsOnEntityInternal.
    //
    private Packet requestPermsOnPmEntity(String sSessId, String sTgtId,
                                          String sTgtClass, String sReqPerms) {
        return setToPacket(requestPermsOnPmEntityInternal(sSessId, sTgtId,
                sTgtClass, sReqPerms));
    }

    // The target object is a PM entity given by its id and type.
    // First step is to find a (virtual) object that represents the target.
    // Note that the virtual object can specify the target explicitly by its
    // original id in the "pmOriginalId" attribute, or implicitly by
    // a subgraph that contains the target.
    //
    // No longer used. PM works as if all a user's attributes were
    // active. Instead, PM calls getPermittedOpsOnEntity or
    // getPermittedOpsOnEntityInternal.
    //
    private HashSet<String> requestPermsOnPmEntityInternal(String sCrtSessId,
                                                           String sTgtId, String sTgtType, String sReqPerms) {
        // Search PmVirtualObjContainer for objects that either have:
        // pmOriginalId = sTgtObjId, or
        // pmOriginalId = someEntityId and sTgtObjId is an ascendant of
        // someEntityId.
        HashSet<String> prSet = new HashSet<String>();
        String sObjId;

        if (sTgtType.equalsIgnoreCase(PM_NODE_ASSOC)) {
            sTgtType = PM_NODE_OATTR;
        }

        System.out.println("***********requestPermsOnPmEntityInternal "
                + getEntityName(sTgtId, sTgtType) + " " + sReqPerms);

        // Search PmVirtualObjContainer for objects x such that:
        // x represents a PM entity and
        // ((x.id = target.id) or (x.inh = true and target is in x.ascendants)).
        // x represents an entity if its pmOriginalId is not null.
        NamingEnumeration<?> objects;
        try {
            SearchControls constraints = new SearchControls();
            constraints.setSearchScope(SearchControls.ONELEVEL_SCOPE);
            constraints.setReturningAttributes(new String[]{"pmId",
                    "pmOriginalId", "pmObjClass", "pmIncludesAscendants"});
            objects = ctx.search(sVirtualObjContainerDN, "(objectClass=*)",
                    constraints);
            while (objects != null && objects.hasMore()) {
                SearchResult sr = (SearchResult) objects.next();
                sObjId = (String) sr.getAttributes().get("pmId").get();
                Attribute attr = sr.getAttributes().get("pmOriginalId");
                if (attr == null) {
                    continue;
                }
                String sSomeEntityId = (String) attr.get();
                String sInh = (String) sr.getAttributes().get("pmIncludesAscendants").get();
                String sSomeEntityClass = (String) sr.getAttributes().get("pmObjClass").get();
                if (sSomeEntityId.equalsIgnoreCase(sTgtId)) {
                    prSet.add(sObjId);
                    System.out.println("Added virtual obj id " + sObjId);
                } else if (sInh.equalsIgnoreCase("true")
                        && isContained(sTgtId, sTgtType, sSomeEntityId,
                        classToType(sSomeEntityClass))) {
                    prSet.add(sObjId);
                    System.out.println("Added virtual obj id " + sObjId);
                }
            }
        } catch (Exception e) {
            if (debugFlag) {
                e.printStackTrace();
            }
        }

        printSet(prSet, PM_OBJ,
                "Set of virtual objects representing the entity "
                        + getEntityName(sTgtId, sTgtType));

        // If no virtual objects are mapped to the target entity,
        // return empty list of permissions.
        if (prSet.isEmpty()) {
            return new HashSet<String>();
        }

        HashSet<String> reqPerms = stringToSet(sReqPerms);
        HashSet<String> receivedPerms = new HashSet<String>();

        // For each virtual object that represents the entity
        Iterator<String> setiter = prSet.iterator();
//		String sUserId = getSessionUserId(sCrtSessId);
        HashSet<String> deniedPerms;
        // Find the denied permissions on the target entity.
        try {
            deniedPerms = getDeniedPerms(sCrtSessId, null, sTgtId, sTgtType);
        } catch (Exception e) {
            if (debugFlag) {
                e.printStackTrace();
            }
            return receivedPerms;
        }

        while (setiter.hasNext()) {
            sObjId = setiter.next();
            System.out.println("---Virtual object selected is " + sObjId + ","
                    + getEntityName(sObjId, PM_OBJ));
            // Request the permissions ON THE OBJECT ATTRIBUTE ASSOCIATED
            // with the virtual object.
            String sAssocOaId = getAssocOattr(sObjId);
            if (sAssocOaId == null) {
                continue;
            }
            HashSet<String> perms = requestPermsInternal2(sCrtSessId,
                    sAssocOaId, sReqPerms);

            perms.removeAll(deniedPerms);

            if (perms.contains("*") || perms.containsAll(reqPerms)) {
                return perms;
            }
            receivedPerms.addAll(perms);
            if (receivedPerms.containsAll(reqPerms)) {
                return receivedPerms;
            }
        }

        return receivedPerms;
    }

    // The target object is a PM entity given by its id and class.
    // First step is to find a (virtual) object that represents the target.
    // Note that the object may specify the target explicitly by its
    // original id in the "pmOriginalId" attribute, or implicitly by
    // a subgraph that contains the target.
    /*private HashSet<String> requestPermsOnPmEntityInternal2(String sCrtSessId,
    String sTgtId, String sTgtClass, String sReqPerms) {
    // Search PmVirtualObjContainer for objects that either have:
    // pmOriginalId = sTgtObjId, or
    // pmOriginalId = someEntityId and sTgtObjId is an ascendant of
    // someEntityId.
    HashSet<String> prSet = new HashSet<String>();
    String sObjId;

    if (sTgtClass.equalsIgnoreCase(PM_NODE_ASSOC)) {
    sTgtClass = PM_NODE_OATTR;
    }

    System.out.println("***requestPermsOnPmEntity "
    + getNameOfEntityWithIdAndType(sTgtId, sTgtClass) + "***");

    // Search PmVirtualObjContainer for objects x such that:
    // x is a PM entity and
    // ((x.id = target.id) or (x.inh = true and target is in x.ascendants)).
    NamingEnumeration<?> objects;
    try {
    SearchControls constraints = new SearchControls();
    constraints.setSearchScope(SearchControls.ONELEVEL_SCOPE);
    constraints.setReturningAttributes(new String[] { "pmId",
    "pmOriginalId", "pmObjClass", "pmIncludesAscendants" });
    objects = ctx.search(sVirtualObjContainerDN, "(objectClass=*)",
    constraints);
    while (objects != null && objects.hasMore()) {
    SearchResult sr = (SearchResult) objects.next();
    sObjId = (String) sr.getAttributes().get("pmId").get();
    Attribute attr = sr.getAttributes().get("pmOriginalId");
    if (attr == null) {
    continue;
    }
    String sSomeEntityId = (String) attr.get();
    String sInh = (String) sr.getAttributes()
    .get("pmIncludesAscendants").get();
    String sSomeEntityClass = (String) sr.getAttributes()
    .get("pmObjClass").get();
    if (sSomeEntityId.equalsIgnoreCase(sTgtId)) {
    prSet.add(sObjId);
    System.out.println("Added virtual obj id " + sObjId);
    } else if (sInh.equalsIgnoreCase("true")
    && isContained(sTgtId, sTgtClass, sSomeEntityId,
    classToType(sSomeEntityClass))) {
    prSet.add(sObjId);
    System.out.println("Added virtual obj id " + sObjId);
    }
    }
    } catch (Exception e) {
    if (debugFlag) {
    e.printStackTrace();
    }
    }

    printSet(prSet, PM_OBJ,
    "Set of virtual objects representing the entity "
    + getNameOfEntityWithIdAndType(sTgtId, sTgtClass));

    // If no virtual objects are mapped to the target entity,
    // return empty list of permissions.
    if (prSet.isEmpty()) {
    return new HashSet<String>();
    }

    // Select the first virtual object in the set.
    Iterator<String> setiter = prSet.iterator();
    if (!setiter.hasNext()) {
    return new HashSet<String>();
    }
    sObjId = setiter.next();

    System.out.println("Virtual object selected is " + sObjId + ","
    + getNameOfEntityWithIdAndType(sObjId, PM_OBJ));

    // Request the permissions ON THE OBJECT ATTRIBUTE ASSOCIATED
    // with the virtual object, not on the virtual object itself:
    String sAssocOaId = getAssocOattr(sObjId);
    if (sAssocOaId == null) {
    return new HashSet<String>();
    }
    return requestPermsInternal(sCrtSessId, sAssocOaId, sReqPerms);
    }*/
    // Translates PM entity classes to types, e.g., User --> u, User attribute
    // --> a.
    private String classToType(String sClass) {
        if (sClass.equalsIgnoreCase(PM_CLASS_USER_NAME)) {
            return PM_NODE_USER;
        } else if (sClass.equalsIgnoreCase(PM_CLASS_UATTR_NAME)) {
            return PM_NODE_UATTR;
        } else if (sClass.equalsIgnoreCase(PM_CLASS_OBJ_NAME)) {
            return PM_OBJ;
        } else if (sClass.equalsIgnoreCase(PM_CLASS_OATTR_NAME)) {
            return PM_NODE_OATTR;
        } else if (sClass.equalsIgnoreCase(PM_CLASS_POL_NAME)) {
            return PM_NODE_POL;
        } else if (sClass.equalsIgnoreCase(PM_CLASS_OPSET_NAME)) {
            return PM_NODE_OPSET;
        } else if (sClass.equalsIgnoreCase(PM_CLASS_CONN_NAME)) {
            return PM_NODE_CONN;
        } else if (sClass.equalsIgnoreCase(PM_CLASS_FILE_NAME)) {
            return PM_OBJ;
        } else if (sClass.equalsIgnoreCase(PM_CLASS_DIR_NAME)) {
            return PM_OBJ;
        } else {
            return null;
        }
    }

    // Translates types to PM entity classes, e.g., u --> User.
    private String typeToClass(String sType) {
        if (sType.equalsIgnoreCase(PM_NODE_USER)) {
            return PM_CLASS_USER_NAME;
        } else if (sType.equalsIgnoreCase(PM_NODE_UATTR)) {
            return PM_CLASS_UATTR_NAME;
        } else if (sType.equalsIgnoreCase(PM_OBJ)) {
            return PM_CLASS_OBJ_NAME;
        } else if (sType.equalsIgnoreCase(PM_NODE_OATTR)) {
            return PM_CLASS_OATTR_NAME;
        } else if (sType.equalsIgnoreCase(PM_NODE_ASSOC)) {
            return PM_CLASS_OATTR_NAME;
        } else if (sType.equalsIgnoreCase(PM_NODE_POL)) {
            return PM_CLASS_POL_NAME;
        } else if (sType.equalsIgnoreCase(PM_NODE_OPSET)) {
            return PM_CLASS_OPSET_NAME;
        } else if (sType.equalsIgnoreCase(PM_NODE_CONN)) {
            return PM_CLASS_CONN_NAME;
        } else {
            return null;
        }
    }

    private Packet testIsContained(String sId1, String sClass1, String sId2,
                                   String sClass2) {
        Packet result = new Packet();
        System.out.println("Test isContained " + sId1 + ":" + sClass1 + ", "
                + sId2 + ":" + sClass2);
        try {
            result.addItem(ItemType.RESPONSE_TEXT,
                    (isContained(sId1, sClass1, sId2, sClass2) ? "true"
                            : "false"));
            return result;
        } catch (Exception e) {
            e.printStackTrace();
            return failurePacket("Exception when building the result packet");
        }
    }

    // The types are abbrevs used in the engine (u, a, ob, b, p, s, c).
    private boolean isContained(String sId1, String sType1, String sId2,
                                String sType2) {
        if (sType1.equalsIgnoreCase(PM_NODE_USER)) {
            return (sType2.equalsIgnoreCase(PM_NODE_UATTR) && userIsAscendant(
                    sId1, sId2))
                    || (sType2.equalsIgnoreCase(PM_NODE_POL) && userIsAscendantToPolicy(
                    sId1, sId2))
                    || (sType2.equalsIgnoreCase(PM_NODE_CONN));
        }

        if (sType1.equalsIgnoreCase(PM_NODE_UATTR)) {
            return (sType2.equalsIgnoreCase(PM_NODE_UATTR) && attrIsAscendant(
                    sId1, sId2, PM_NODE_UATTR))
                    || (sType2.equalsIgnoreCase(PM_NODE_POL) && attrIsAscendantToPolicy(
                    sId1, PM_NODE_UATTR, sId2))
                    || (sType2.equalsIgnoreCase(PM_NODE_CONN));
        }

        if (sType1.equalsIgnoreCase(PM_NODE_OATTR)
                || sType1.equalsIgnoreCase(PM_NODE_ASSOC)) {
            return (sType2.equalsIgnoreCase(PM_NODE_OATTR) && attrIsAscendant(
                    sId1, sId2, PM_NODE_OATTR))
                    || (sType2.equalsIgnoreCase(PM_NODE_POL) && attrIsAscendantToPolicy(
                    sId1, PM_NODE_OATTR, sId2))
                    || (sType2.equalsIgnoreCase(PM_NODE_CONN));
        }

        if (sType1.equalsIgnoreCase(PM_OBJ)) {
            // We have a virtual object. To assess containment, look at its
            // associated object attribute.
            String sAssoc1 = getAssocOattr(sId1);
            if (sAssoc1 == null) {
                return false;
            }
            return (sType2.equalsIgnoreCase(PM_NODE_OATTR) && attrIsAscendant(
                    sAssoc1, sId2, PM_NODE_OATTR))
                    || (sType2.equalsIgnoreCase(PM_NODE_POL) && attrIsAscendantToPolicy(
                    sAssoc1, PM_NODE_OATTR, sId2))
                    || (sType2.equalsIgnoreCase(PM_NODE_CONN));
        }

        if (sType1.equalsIgnoreCase(PM_NODE_POL)) {
            return (sType2.equalsIgnoreCase(PM_NODE_CONN));
        }

        if (sType1.equalsIgnoreCase(PM_NODE_OPSET)) {
            return (opsetIsAscendant(sId1, sId2, sType2));
        }

        return false;
    }

    private boolean opsetIsAscendant(String sId1, String sId2, String sType2) {
        Attributes attrs;
        Attribute attr;

        if (sType2.equalsIgnoreCase(PM_NODE_CONN)) {
            return true;
        }

        try {
            attrs = ctx.getAttributes("CN=" + sId1 + "," + sOpsetContainerDN);
            attr = attrs.get("pmToAttr");
            if (attr == null) {
                return false;
            }
            for (NamingEnumeration<?> attrEnum = attr.getAll(); attrEnum.hasMore(); ) {
                String sId = (String) attrEnum.next();
                if (sType2.equalsIgnoreCase(PM_NODE_OATTR)) {
                    if (attrIsAscendant(sId, sId2, sType2)) {
                        return true;
                    }
                } else if (sType2.equalsIgnoreCase(PM_NODE_POL)) {
                    if (attrIsAscendantToPolicy(sId, PM_NODE_OATTR, sId2)) {
                        return true;
                    }
                }
            }
            return false;
        } catch (Exception e) {
            if (debugFlag) {
                e.printStackTrace();
            }
            return false;
        }
    }

    // Returns the list of objects created or deleted since the last update
    // of the given session. If the last client update time is null, send all
    // objects.
    // Engine command. Not used to date.
    private Packet updateProtObjs(String sClientId, String sSessId,
                                  String sClientLastTimestamp) {
        // If the last update timestamp is null, get all PM objects on that
        // host.
        if (sClientLastTimestamp == null) {
            try {
                return getProtObjs(sClientId, sSessId);
            } catch (Exception e) {
                if (debugFlag) {
                    e.printStackTrace();
                }
                return failurePacket(e.getMessage());
            }
        } else {
            // The client has a non-null last update timestamp.

            // If the last engine update is null (i.e., no engine update since
            // launch),
            // or the engine last update time <= client last update time, send
            // an empty list.
            // Else send all relevant objects, for now (later modify to send
            // only updates).
            boolean sendEmpty = false;
            if (sLastUpdateTimestamp == null) {
                sendEmpty = true;
            } else {
                Date dateEngine, dateClient;
                try {
                    dateEngine = dfUpdate.parse(sLastUpdateTimestamp);
                    dateClient = dfUpdate.parse(sClientLastTimestamp);
                    if (dateEngine.compareTo(dateClient) <= 0) {
                        sendEmpty = true;
                    }
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            if (sendEmpty) {
                Packet res = new Packet();
                try {
                    res.addItem(ItemType.RESPONSE_TEXT, "tsp"
                            + PM_ALT_FIELD_DELIM + dfUpdate.format(new Date()));
                    return res;
                } catch (Exception e) {
                    e.printStackTrace();
                    return failurePacket("Exception when building the result packet");
                }
            } else {
                try {
                    return getProtObjs(sClientId, sSessId);
                } catch (Exception e) {
                    if (debugFlag) {
                        e.printStackTrace();
                    }
                    return failurePacket(e.getMessage());
                }
            }
        }
    }

    // Get all PM-protected objects relevant to a session (i.e., all objects
    // on the session's host that are registered with the pm AND contained
    // in a policy class). For each such object compute the session subject's
    // permissions on them. The result is:
    // timestamp_record (object_record)*
    // The timestamp record has the format:
    // tsp|timestamp
    // where the timestamp looks like that:
    // May 26, 2005 2:38:39 PM EDT
    // and shows the server's local time.
    // The object record has the format:
    // add|obj_path|obj_id|permissions
    // where the path is the object's absolute path, and the permissions are
    // comma-separated. For example:
    // add|E:\Work\F1|E0244E048CB49B6C9C500FE0CC48770E|read,write
    private Packet getProtObjs(String sClientId, String sSessId)
            throws Exception {
        Packet result = new Packet();
        NamingEnumeration<?> objs;

        Vector<String> activeAttrs;
        Vector<String> policyClasses;
        Vector<String> opsets;
        Vector<String> oattrs;
        //HashSet<?> objects;

        Map<String, Map<String, Set<String>>> ht = new Hashtable<String, Map<String, Set<String>>>();

        String sPcId;
        String sAaId;
        String sOpsId;
        String sOaId;
        String sObjId;
        String sAssocId;

        // First get the session's user and host.
        //String sUserId = getSessionUserId(sSessId);
        String sHostName = getSessionHostName(sSessId);

        // Find the objects on this host.
        try {
            SearchControls constraints = new SearchControls();
            constraints.setSearchScope(SearchControls.ONELEVEL_SCOPE);
            constraints.setReturningAttributes(new String[]{"pmId",
                    "pmInstance", "pmAssocAttr"});
            objs = ctx.search(sVirtualObjContainerDN, "(pmHost=" + sHostName
                    + ")", constraints);
        } catch (CommunicationException e) {
            if (debugFlag) {
                e.printStackTrace();
            }
            return failurePacket("AD connection error");
        } catch (Exception e) {
            if (debugFlag) {
                e.printStackTrace();
            }
            return failurePacket("Exception: " + e.getMessage());
        }

        // Prepare the return.
        // Reserve the first record for the timestamp.
        try {
            result.addItem(ItemType.RESPONSE_TEXT, "tsp" + PM_ALT_FIELD_DELIM
                    + dfUpdate.format(new Date()));
        } catch (Exception e) {
            e.printStackTrace();
            return failurePacket("Exception when building the result packet");
        }
        activeAttrs = getSessionActiveAttrs(sSessId);
        policyClasses = getPolicyClasses();

        // For each object on host
        while (objs != null && objs.hasMore()) {
            SearchResult sr = (SearchResult) objs.next();
            sObjId = (String) sr.getAttributes().get("pmId").get();
            sAssocId = (String) sr.getAttributes().get("pmAssocAttr").get();

            // For each pc in policy classes (remember that only objects
            // contained
            // in a policy class are pm-protected).
            for (int pc = 0; pc < policyClasses.size(); pc++) {
                sPcId = policyClasses.elementAt(pc);
                // If (o is not in policy class pc) continue.
                if (!attrIsAscendantToPolicy(sAssocId, PM_NODE_OATTR, sPcId)) {
                    continue;
                }
                // The object is in this policy class. Add an entry [o, {[pc,
                // empty]}]
                // to Hashtable ht.
                addHtEntry(sObjId, sPcId, (String) null, ht);

                // For each active attribute
                for (int aa = 0; aa < activeAttrs.size(); aa++) {
                    sAaId = activeAttrs.elementAt(aa);
                    // If !(aa ->+ pc) continue.
                    if (!attrIsAscendantToPolicy(sAaId, PM_NODE_UATTR, sPcId)) {
                        continue;
                    }

                    // For each opset such that aa -> opset
                    opsets = getToOpsets(sAaId);
                    for (int ops = 0; ops < opsets.size(); ops++) {
                        sOpsId = opsets.elementAt(ops);

                        // For each oa such that opset -> oa
                        oattrs = getToAttrs(sOpsId);
                        for (int oa = 0; oa < oattrs.size(); oa++) {
                            sOaId = oattrs.elementAt(oa);
                            // If !(oa ->+ pc) continue.
                            if (!attrIsAscendantToPolicy(sOaId, PM_NODE_OATTR,
                                    sPcId)) {
                                continue;
                            }
                            // If !(o ->* oa) continue
                            if (!attrIsAscendant(sAssocId, sOaId, PM_NODE_OATTR)) {
                                continue;
                            }
                            System.out.println("triple o = " + sObjId
                                    + ", pc = " + sPcId + ", ops = " + sOpsId);
                            // Add [o, [pc, ops]] to the hashtable.
                            addHtEntry(sObjId, sPcId, sOpsId, ht);
                        }
                    }
                }
            }
        }
        // Ht has entries [objid, hashmap[pcid, hashset[operation]]]. For
        // example:
        // [o, {[rbac, {r,w,a}], [mls, {r,f}]}]. If the hashmap for o has only
        // one entry,
        // those are the permissions. If there are multiple entries, they must
        // be
        // intersected. In the above example, the permissions for o are {r}.
        for (Iterator<String> enumer = ht.keySet().iterator(); enumer.hasNext(); ) {
            sObjId = enumer.next();
            sAssocId = getAssocOattr(sObjId);
            Map<String, Set<String>> map = ht.get(sObjId);

            Iterator<Set<String>> iter = map.values().iterator();
            boolean firstTime = true;
            Set<String> set1 = null, set2 = null;
            while (iter.hasNext()) {
                if (firstTime) {
                    firstTime = false;
                    set1 = iter.next();
                } else {
                    set2 = iter.next();
                    Iterator<String> iter1 = set1.iterator();
                    while (iter1.hasNext()) {
                        String sOp = iter1.next();
                        if (!set2.contains(sOp)) {
                            iter1.remove();
                        }
                    }
                }
            }
            // Now set1 contains the intersection of opsets for object o
            // (inters.
            // relative to policy classes).
            // Create an entry for the object in the result.
            try {
                result.addItem(ItemType.RESPONSE_TEXT, "add"
                        + PM_ALT_FIELD_DELIM + getObjPath(sObjId)
                        + PM_ALT_FIELD_DELIM + sObjId + PM_ALT_FIELD_DELIM
                        + setToString(set1));
            } catch (Exception e) {
                e.printStackTrace();
                return failurePacket("Exception when building the result packet");
            }
        }
        return result;
    }

    // Test whether (op, o) is one of the session's capabilities.
    private Packet sessionHasCap(String sClientId, String sOp, String sObjId,
                                 String sSessId) throws Exception {
        String sPcId;
        String sAaId;
        //String sOpsId;
        String sOaId;

        Vector<String> activeAttrs;
        Vector<String> policyClasses;

        // Indicates whether the object is within at least a policy class.
        boolean objectInPc = false;
        // Indicates whether the capability was found in the union - see the
        // article.
        boolean foundInUnion;

        // First get some information about the session: the user, host,
        // active attributes, policy classes.
        String sUserId = getSessionUserId(sSessId);
        String sHostName = getSessionHostName(sSessId);
        System.out.println("User = " + sUserId + ", host = " + sHostName);
        activeAttrs = getSessionActiveAttrs(sSessId);
        policyClasses = getPolicyClasses();

        // For each pc in the policy classes
        for (int pc = 0; pc < policyClasses.size(); pc++) {
            sPcId = policyClasses.elementAt(pc);
            // Find the associated object attribute of object o.
            sOaId = getAssocOattr(sObjId);
            if (sOaId == null) {
                return failurePacket("Database inconsistency: object has no associated attribute");
            }
            // If object o (actually the associated attribute) does not pertain
            // to
            // this policy class, continue with the next one.
            if (!attrIsAscendantToPolicy(sOaId, PM_NODE_OATTR, sPcId)) {
                continue;
            }
            // Set a flag to indicate that the object was found in at least a
            // policy class.
            objectInPc = true;
            // Prepare for searching the capability in the union.
            foundInUnion = false;
            // For each aa in the session's active attributes
            for (int aa = 0; aa < activeAttrs.size(); aa++) {
                sAaId = activeAttrs.elementAt(aa);
                // If aa is in this policy class
                if (attrIsAscendantToPolicy(sAaId, PM_NODE_UATTR, sPcId)) {
                    // and (op, o) is in caps(aa)
                    if (attrHasCap(sOp, sOaId, sPcId, sAaId)) {
                        foundInUnion = true;
                        // It's enough to find (op, o) in the caps of one active
                        // attribute.
                        break;
                    }
                }
            }
            if (!foundInUnion) {
                return failurePacket("No");
            }
        }
        if (objectInPc) {
            return successPacket();
        }
        return failurePacket("No");
    }

    // Test whether (op, o) is in the caps for an active attribute in a policy
    // class.
    // Note that instead of the object o we use the associated object attribute.
    private boolean attrHasCap(String sOp, String sAssocOaId, String sPcId,
                               String sAaId) {
        Vector<String> opsets;
        Vector<String> oattrs;
        String sOpsId;
        String sOaId;

        // For each opset such that aa -> opset
        opsets = getToOpsets(sAaId);
        for (int ops = 0; ops < opsets.size(); ops++) {
            sOpsId = opsets.elementAt(ops);

            // Don't check the opset class any more.
            // String sOpsClass = getOpsetClassName(sOpsId);
            // String sObjClass = getAssocObjClassName(sAssocOaId);
            // if (!sOpsClass.equalsIgnoreCase(sObjClass)) continue;

            // If the operation is not in the opset, continue with next opset.
            if (!opsetContainsOp(sOpsId, sOp)) {
                continue;
            }
            // For each oa such that opset->oa
            oattrs = getToAttrs(sOpsId);
            for (int oa = 0; oa < oattrs.size(); oa++) {
                sOaId = oattrs.elementAt(oa);
                // If (o ->* oa && oa ->+ pc) return true
                if (attrIsAscendant(sAssocOaId, sOaId, PM_NODE_OATTR)
                        && attrIsAscendantToPolicy(sOaId, PM_NODE_OATTR, sPcId)) {
                    return true;
                }
            }
        }
        return false;
    }

    private Packet setToPacket(HashSet<String> set) {
        if (set == null) {
            return null;
        }
        Packet p = new Packet();
        try {
            Iterator<String> iter = set.iterator();
            while (iter.hasNext()) {
                p.addItem(ItemType.RESPONSE_TEXT, iter.next());
            }
            return p;
        } catch (Exception e) {
            e.printStackTrace();
            return null;
        }
    }

    private String setToString(Set<String> set) {
        if (set == null) {
            return null;
        }
        StringBuffer sb = new StringBuffer();
        Iterator<String> iter = set.iterator();
        boolean firstTime = true;
        while (iter.hasNext()) {
            if (firstTime) {
                firstTime = false;
            } else {
                sb.append(",");
            }
            sb.append(iter.next());
        }
        return sb.toString();
    }

    private HashSet<String> stringToSet(String sArg) {
        HashSet<String> set = new HashSet<String>();
        if (sArg != null) {
            String[] pieces = sArg.split(",");
            for (int i = 0; i < pieces.length; i++) {
                String t = pieces[i].trim();
                if (t.length() > 0) {
                    set.add(t);
                }
            }
        }
        return set;
    }

    private void printHtWithPcKeys(Map<String, Map<String, Set<String>>> ht) {
        System.out.println("---------- Hashtable ----------");
        for (Iterator<String> keys = ht.keySet().iterator(); keys.hasNext(); ) {
            String sKey = keys.next();
            String sPc = getEntityName(sKey, PM_NODE_POL);
            System.out.println("For policy class " + sPc);

            Map<String, Set<String>> map = ht.get(sKey);
            Set<String> keyset = map.keySet();
            Iterator<String> iter = keyset.iterator();
            while (iter.hasNext()) {
                String sMapkey = (String) iter.next();
                String sUa = getEntityName(sMapkey, PM_NODE_UATTR);
                System.out.print("    Attr: " + sUa);
                System.out.println(" -> "
                        + setToString(map.get(sMapkey)));
            }
        }
    }

    // Add (to) an entry in a Hashtable, whose value is a HashMap, whose value
    // is a HashSet built out of HashSets.
    // sKey is a Hashtable key, and sSecKey is a HashMap key.
    // sKey cannot be null.
    // If sSecKey is null (possible only when sKey is new), add an empty
    // HashMap.
    private void addHtEntry(String sKey, String sSecKey, Set<String> setToAdd,
                            Map<String, Map<String, Set<String>>> ht) {
        Map<String, Set<String>> map;
        Set<String> set;

        if (ht.containsKey(sKey)) {
            map = ht.get(sKey);
            if (sSecKey == null) {
                return;
            }
            if (map.containsKey(sSecKey)) {
                set = map.get(sSecKey);
                set.addAll(setToAdd);
            } else {
                // Build a new entry in the HashMap.
                set = new HashSet<String>();
                set.addAll(setToAdd);
                map.put(sSecKey, set);
            }
        } else {
            // Add a new entry with key sKey, but first build the value.
            map = new HashMap<String, Set<String>>();
            if (sSecKey == null) {
                ht.put(sKey, map);
                return;
            }
            set = new HashSet<String>();
            set.addAll(setToAdd);
            map.put(sSecKey, set);
            ht.put(sKey, map);
        }
    }

    // Add (to) an entry in a Hashtable, whose value is a HashMap, whose value
    // is a HashSet built out of opsets.
    // sKey is a Hashtable key, and sSecKey is a HashMap key.
    // sKey cannot be null.
    // If sSecKey is null (possible only when sKey is new), add an empty
    // HashMap.
    // In addOpsetToSet(), a null sOpsId is interpreted as the empty set of
    // operations.
    private void addHtEntry(String sKey, String sSecKey, String sOpsId,
                            Map<String, Map<String, Set<String>>> ht) {
        Map<String, Set<String>> map;
        Set<String> set;

        if (ht.containsKey(sKey)) {
            map = ht.get(sKey);
            if (sSecKey == null) {
                return;
            }
            if (map.containsKey(sSecKey)) {
                set = map.get(sSecKey);
                addOpsetToSet(sOpsId, set);
            } else {
                // Build a new entry in the HashMap.
                set = new HashSet<String>();
                addOpsetToSet(sOpsId, set);
                map.put(sSecKey, set);
            }
        } else {
            // Add a new entry with key sKey, but first build the value.
            map = new HashMap<String, Set<String>>();
            if (sSecKey == null) {
                ht.put(sKey, map);
                return;
            }
            set = new HashSet<String>();
            addOpsetToSet(sOpsId, set);
            map.put(sSecKey, set);
            ht.put(sKey, map);
        }
    }

    // A null sOpsetId means an empty set of operations.
    private void addOpsetToSet(String sOpsetId, Set<String> set) {
        Attributes attrs;
        Attribute attr;
        if (sOpsetId == null) {
            return;
        }
        try {
            attrs = ctx.getAttributes("CN=" + sOpsetId + ","
                    + sOpsetContainerDN);
            attr = attrs.get("pmOp");
            if (attr != null) {
                for (NamingEnumeration<?> enumer = attr.getAll(); enumer.hasMore(); ) {
                    set.add((String) enumer.next());
                }
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    // Get session events since the last update and delete them from
    // the Events container.
    private Packet getSessionEvents(String sClientId) throws Exception {
        Packet result = new Packet();
        NamingEnumeration<?> events;

        try {
            SearchControls constraints = new SearchControls();
            constraints.setSearchScope(SearchControls.ONELEVEL_SCOPE);
            constraints.setReturningAttributes(new String[]{"pmId",
                    "pmEvent", "pmOriginalId"});
            events = ctx.search(sEventContainerDN, "(pmObjClass="
                    + sSessionClass + ")", constraints);
            while (events != null && events.hasMore()) {
                SearchResult sr = (SearchResult) events.next();
                String sEvent = (String) sr.getAttributes().get("pmEvent").get();
                String sSessId = (String) sr.getAttributes().get("pmOriginalId").get();
                String sEventId = (String) sr.getAttributes().get("pmId").get();

                ctx.destroySubcontext("CN=" + sEventId + ","
                        + sEventContainerDN);

                result.addItem(ItemType.RESPONSE_TEXT, sEvent + PM_FIELD_DELIM
                        + sSessId);
            }
            return result;
        } catch (CommunicationException e) {
            if (debugFlag) {
                e.printStackTrace();
            }
            return failurePacket("AD connection error");
        } catch (Exception e) {
            if (debugFlag) {
                e.printStackTrace();
            }
            return failurePacket("Exception: " + e.getMessage());
        }
    }

    private HashSet<String> getUserSessions(String sUserId) {
        NamingEnumeration<?> sessions;
        HashSet<String> sessSet = new HashSet<String>();
        try {
            SearchControls constraints = new SearchControls();
            constraints.setSearchScope(SearchControls.ONELEVEL_SCOPE);
            constraints.setReturningAttributes(new String[]{"pmId"});
            sessions = ctx.search(sSessionContainerDN, "(pmUserId=" + sUserId
                    + ")", constraints);
            while (sessions != null && sessions.hasMore()) {
                SearchResult sr = (SearchResult) sessions.next();
                String sSessId = (String) sr.getAttributes().get("pmId").get();
                sessSet.add(sSessId);
            }
        } catch (Exception e) {
            if (debugFlag) {
                e.printStackTrace();
            }
        }
        return sessSet;
    }

    // Get the user's active attribute across all his sessions.
    private HashSet<String> getUserActiveAttrs(String sUserId) {
        HashSet<String> actives = new HashSet<String>();
        HashSet<String> sessions;
        String sSessId;
        Attributes attrs;
        Attribute attr;
        String sId;

        sessions = getUserSessions(sUserId);
        try {
            Iterator<String> setiter = sessions.iterator();
            while (setiter.hasNext()) {
                sSessId = setiter.next();
                attrs = ctx.getAttributes("CN=" + sSessId + ","
                        + sSessionContainerDN);
                attr = attrs.get("pmAttr");
                if (attr != null) {
                    for (NamingEnumeration<?> enumer = attr.getAll(); enumer.hasMore(); ) {
                        sId = (String) enumer.next();
                        if (!actives.contains(sId)) {
                            actives.add(sId);
                        }
                    }
                }
            }
        } catch (Exception e) {
            if (debugFlag) {
                e.printStackTrace();
            }
        }
        return actives;
    }

    // Get a list of all sessions. Each entry in the list contains:
    // name:id.
    // As the last step, this function deletes the session create and delte
    // events
    // from the event container.
    private Packet getSessions(String sClientId) throws Exception {
        Packet result = new Packet();
        NamingEnumeration<?> ses;

        // Delete all session events.
        emptyContainer(sEventContainerDN, null);

        try {
            SearchControls constraints = new SearchControls();
            constraints.setSearchScope(SearchControls.ONELEVEL_SCOPE);
            constraints.setReturningAttributes(new String[]{"pmId", "pmName"});
            ses = ctx.search(sSessionContainerDN, "(objectClass=*)",
                    constraints);
            while (ses != null && ses.hasMore()) {
                SearchResult sr = (SearchResult) ses.next();
                String sName = (String) sr.getAttributes().get("pmName").get();
                String sId = (String) sr.getAttributes().get("pmId").get();
                result.addItem(ItemType.RESPONSE_TEXT, sName + PM_FIELD_DELIM
                        + sId);
            }
            return result;
        } catch (CommunicationException e) {
            if (debugFlag) {
                e.printStackTrace();
            }
            return failurePacket("AD connection error");
        } catch (Exception e) {
            if (debugFlag) {
                e.printStackTrace();
            }
            return failurePacket("Exception: " + e.getMessage());
        }
    }

    // The information returned by getSessionInfo has the following format:
    // item 0: <sess name>:<sess id>
    // item 1: <user name>:<user id>
    // item 2: <host name>:<host id>
    // items 3 through 3 + active_attr_count - 1: <attr name>:<attr id>
    private Packet getSessionInfo(String sClientId, String sSessId) {
        Packet result = new Packet();

        try {
            Attributes attrs = ctx.getAttributes("CN=" + sSessId + ","
                    + sSessionContainerDN);
            String sSessName = (String) attrs.get("pmName").get();
            String sUserId = (String) attrs.get("pmUserId").get();
            String sHostName = (String) attrs.get("pmHost").get();
            result.addItem(ItemType.RESPONSE_TEXT, sSessName + PM_FIELD_DELIM
                    + sSessId);
            result.addItem(ItemType.RESPONSE_TEXT,
                    getEntityName(sUserId, PM_NODE_USER) + PM_FIELD_DELIM
                            + sUserId);
            result.addItem(ItemType.RESPONSE_TEXT, sHostName + PM_FIELD_DELIM
                    + getEntityId(sHostName, PM_HOST));

            Attribute attr = attrs.get("pmAttr");
            if (attr != null) {
                for (NamingEnumeration<?> enumer = attr.getAll(); enumer.hasMore(); ) {
                    String sAttrId = (String) enumer.next();
                    String sAttrName = getEntityName(sAttrId, PM_NODE_UATTR);
                    if (sAttrName == null) {
                        return failurePacket("No such attribute " + sAttrId);
                    }
                    result.addItem(ItemType.RESPONSE_TEXT, sAttrName
                            + PM_FIELD_DELIM + sAttrId);
                }
            }
            return result;
        } catch (NameNotFoundException e) {
            if (debugFlag) {
                e.printStackTrace();
            }
            return failurePacket("No such session");
        } catch (Exception e) {
            if (debugFlag) {
                e.printStackTrace();
            }
            return failurePacket("Exception during getSessionInfo: "
                    + e.getMessage());
        }
    }

    private HashSet<String> getPolicyAttributesAssigned(String sPolId,
                                                        String sOattrId) {
        try {
            HashSet<String> hs = new HashSet<String>();
            Attributes attrs = ctx.getAttributes("CN=" + sOattrId + ","
                    + sObjAttrContainerDN);
            Attribute attr = attrs.get("pmToAttr");
            if (attr != null) {
                for (NamingEnumeration<?> enumer = attr.getAll(); enumer.hasMore(); ) {
                    String sId = (String) enumer.next();
                    if (attrIsAscendantToPolicy(sId, PM_NODE_OATTR, sPolId)) {
                        hs.add(sId);
                    }
                }
            }
            return hs;
        } catch (Exception e) {
            if (debugFlag) {
                e.printStackTrace();
            }
            return null;
        }
    }

    // Get the ids of the user attributes that are active in the specified
    // user session and specified policy class.
    private HashSet<String> getPolicyActiveAttributes(String sSessId,
                                                      String sPolId) {
        System.out.println("sess = " + sSessId + ", pol = " + sPolId);
        Attributes attrs;
        Attribute attr;
        String sId;// sName;
        HashSet<String> hs = new HashSet<String>();

        try {
            attrs = ctx.getAttributes("CN=" + sSessId + ","
                    + sSessionContainerDN);
            attr = attrs.get("pmAttr");
            if (attr != null) {
                for (NamingEnumeration<?> enumer = attr.getAll(); enumer.hasMore(); ) {
                    sId = (String) enumer.next();
                    if (attrIsAscendantToPolicy(sId, PM_NODE_UATTR, sPolId)) {
                        hs.add(sId);
                    }
                }
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
        return hs;
    }

    // Get the name:id of the session's active attributes.
    private Packet getActiveAttributes(String sClientId, String sSessId) {
        Attributes attrs;
        Attribute attr;
        String sId, sName;

        Packet res = new Packet();

        try {
            attrs = ctx.getAttributes("CN=" + sSessId + ","
                    + sSessionContainerDN);
            attr = attrs.get("pmAttr");
            if (attr != null) {
                for (NamingEnumeration<?> enumer = attr.getAll(); enumer.hasMore(); ) {
                    sId = (String) enumer.next();
                    sName = getEntityName(sId, PM_NODE_UATTR);
                    if (sName == null) {
                        return failurePacket("No such attribute " + sId);
                    }
                    res.addItem(ItemType.RESPONSE_TEXT, sName + PM_FIELD_DELIM
                            + sId);
                }
            }
            return res;
        } catch (NameNotFoundException e) {
            if (debugFlag) {
                e.printStackTrace();
            }
            return failurePacket("No such session");
        } catch (Exception e) {
            if (debugFlag) {
                e.printStackTrace();
            }
            return failurePacket("Error while obtaining the active attributes");
        }
    }

    private String getEntityName(String sId, String sType) {
        Attributes attrs;
        //Attribute attr;
        String sName;
        String sDn;
        if (sType.equalsIgnoreCase(PM_NODE_USER)) {
            sDn = "CN=" + sId + "," + sUserContainerDN;
        } else if (sType.equalsIgnoreCase(PM_NODE_UATTR)) {
            sDn = "CN=" + sId + "," + sUserAttrContainerDN;
        } else if (sType.equalsIgnoreCase(PM_NODE_OATTR)) {
            sDn = "CN=" + sId + "," + sObjAttrContainerDN;
        } else if (sType.equalsIgnoreCase(PM_NODE_ASSOC)) {
            sDn = "CN=" + sId + "," + sObjAttrContainerDN;
        } else if (sType.equalsIgnoreCase(PM_HOST)) {
            sDn = "CN=" + sId + "," + sHostContainerDN;
        } else if (sType.equalsIgnoreCase(PM_NODE_OPSET)) {
            sDn = "CN=" + sId + "," + sOpsetContainerDN;
        } else if (sType.equalsIgnoreCase(PM_OBJ_CLASS)) {
            sDn = "CN=" + sId + "," + sObjClassContainerDN;
        } else if (sType.equalsIgnoreCase(PM_OBJ)) {
            sDn = "CN=" + sId + "," + sVirtualObjContainerDN;
        } else if (sType.equalsIgnoreCase(PM_NODE_POL)) {
            sDn = "CN=" + sId + "," + sPolicyContainerDN;
        } else if (sType.equalsIgnoreCase(PM_NODE_CONN)) {
            sDn = "CN=" + sId + "," + sConnectorContainerDN;
        } else if (sType.equalsIgnoreCase(PM_ASET)) {
            sDn = "CN=" + sId + "," + sAttrSetContainerDN;
        } else if (sType.equalsIgnoreCase(PM_SAC)) {
            sDn = "CN=" + sId + "," + sSacContainerDN;
        } else if (sType.equalsIgnoreCase(PM_DENY)) {
            sDn = "CN=" + sId + "," + sDenyContainerDN;
        } else if (sType.equalsIgnoreCase(PM_TASK)) {
            sDn = "CN=" + sId + "," + sTaskContainerDN;
        } else if (sType.equalsIgnoreCase(PM_SCON)) {
            sDn = "CN=" + sId + "," + sSconContainerDN;
        } else if (sType.equalsIgnoreCase(PM_SCONA)) {
            sDn = "CN=" + sId + "," + sSconaContainerDN;
        } else if (sType.equalsIgnoreCase(PM_SCRIPT)) {
            sDn = "CN=" + sId + "," + sRuleContainerDN;
        } else if (sType.equalsIgnoreCase(PM_TEMPLATE)) {
            sDn = "CN=" + sId + "," + sTemplateContainerDN;
        } else if (sType.equalsIgnoreCase(PM_SESSION)) {
            sDn = "CN=" + sId + "," + sSessionContainerDN;
        } else if (sType.equalsIgnoreCase(PM_PROCESS)) {
            return sId;
        } else {
            return null;
        }
        try {
            attrs = ctx.getAttributes(sDn);
            if (attrs == null) {
                return null;
            }
            sName = (String) attrs.get("pmName").get();
        } catch (Exception e) {
            e.printStackTrace();
            return null;
        }
        return sName;
    }

    // Activate some attributes for a session. The attributes must be in the
    // session user's profile.
    private Packet activateAttributes(String sClientId, String sSessId,
                                      String[] pmAttrs) throws Exception {
        ModificationItem[] mods = new ModificationItem[1];
        // Find the session's user.
        String sUserId = getSessionUserId(sSessId);
        if (sUserId == null) {
            return failurePacket("No such session " + sSessId);
        }

        // See whether the user has each attribute we want to activate:
        boolean err = false;
        for (int i = 0; i < pmAttrs.length; i++) {
            if (!userIsAscendant(sUserId, pmAttrs[i])) {
                return failurePacket("Attribute " + pmAttrs[i]
                        + " not in user's profile");
            }

            // Try to activate the attributes one by one. If one is already
            // active,
            // continue with the others.
            mods[0] = new ModificationItem(DirContext.ADD_ATTRIBUTE,
                    new BasicAttribute("pmAttr", pmAttrs[i]));
            try {
                ctx.modifyAttributes("CN=" + sSessId + ","
                        + sSessionContainerDN, mods);
            } catch (Exception e) {
                e.printStackTrace();
                err = true;
            }
        }
        if (err) {
            return failurePacket("Some attributes are already active");
        }
        return successPacket("Attributes activated successfully");
    }

    private void activateAttributesInternal(String sSessId,
                                            HashSet<String> attrset) {
        ModificationItem[] mods = new ModificationItem[1];
        //boolean err = false;
        Iterator<String> iter = attrset.iterator();
        while (iter.hasNext()) {
            mods[0] = new ModificationItem(DirContext.ADD_ATTRIBUTE,
                    new BasicAttribute("pmAttr", iter.next()));
            try {
                ctx.modifyAttributes("CN=" + sSessId + ","
                        + sSessionContainerDN, mods);
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
    }

    private String getSessionHostName(String sSessId) {
        String sHost;

        System.out.println("Looking for session CN=" + sSessId + ","
                + sSessionContainerDN);

        try {
            Attributes attrs = ctx.getAttributes("CN=" + sSessId + ","
                    + sSessionContainerDN);
            Attribute attr = attrs.get("pmHost");
            sHost = (String) attr.get();
        } catch (Exception e) {
            if (debugFlag) {
                e.printStackTrace();
            }
            return null;
        }
        return sHost;
    }

    private Packet getSessionUser(String sSessId) {
        String sUserId = getSessionUserId(sSessId);
        if (sUserId == null) {
            return failurePacket("Couldn't find session or its user id");
        }
        String sUser = getEntityName(sUserId, PM_NODE_USER);
        if (sUser == null) {
            return failurePacket("Couldn't find session user");
        }
        Packet res = new Packet();
        try {
            res.addItem(ItemType.RESPONSE_TEXT, sUser);
            return res;
        } catch (Exception e) {
            e.printStackTrace();
            return failurePacket("Exception when building the result packet");
        }
    }

    private Packet getSessionName(String sSessId) {
        try {
            Attributes attrs = ctx.getAttributes("CN=" + sSessId + ","
                    + sSessionContainerDN);
            Attribute attr = attrs.get("pmName");
            String sName = (String) attr.get();
            Packet result = new Packet();
            result.addItem(ItemType.RESPONSE_TEXT, sName);
            return result;
        } catch (Exception e) {
            if (debugFlag) {
                e.printStackTrace();
            }
            return failurePacket("Exception in getSessionName: "
                    + e.getMessage());
        }
    }

    private String getSessionUserId(String sSessId) {
        String sUserId;

        try {
            Attributes attrs = ctx.getAttributes("CN=" + sSessId + ","
                    + sSessionContainerDN);
            Attribute attr = attrs.get("pmUserId");
            sUserId = (String) attr.get();
        } catch (Exception e) {
            if (debugFlag) {
                e.printStackTrace();
            }
            return null;
        }
        return sUserId;
    }

    private Vector<String> getSessionActiveAttrs(String sSessId) {
        Vector<String> v = new Vector<String>();
        try {
            Attributes attrs = ctx.getAttributes("CN=" + sSessId + ","
                    + sSessionContainerDN);
            Attribute attr = attrs.get("pmAttr");
            if (attr == null) {
                return v;
            }
            for (NamingEnumeration<?> enumer = attr.getAll(); enumer.hasMore(); ) {
                v.add((String) enumer.next());
            }
        } catch (Exception e) {
            if (debugFlag) {
                e.printStackTrace();
            }
        }
        return v;
    }

    // Returns the set of already open objects for the given session.
    // Note that they are returned as object names!
    private HashSet<String> getSessionOpenObjs(String sSessId) {
        HashSet<String> hs = new HashSet<String>();
        try {
            Attributes attrs = ctx.getAttributes("CN=" + sSessId + ","
                    + sSessionContainerDN);
            Attribute attr = attrs.get("pmOpenObj");
            if (attr == null) {
                return hs;
            }
            for (NamingEnumeration<?> enumer = attr.getAll(); enumer.hasMore(); ) {
                String sOO = (String) enumer.next();
                String[] pieces = sOO.split(PM_ALT_DELIM_PATTERN);
                hs.add(pieces[0]);
            }
        } catch (Exception e) {
            if (debugFlag) {
                e.printStackTrace();
            }
        }
        return hs;
    }

    private HashSet<String> getSessionActiveAttrSet(String sSessId) {
        HashSet<String> hs = new HashSet<String>();
        try {
            Attributes attrs = ctx.getAttributes("CN=" + sSessId + ","
                    + sSessionContainerDN);
            Attribute attr = attrs.get("pmAttr");
            if (attr == null) {
                return hs;
            }
            for (NamingEnumeration<?> enumer = attr.getAll(); enumer.hasMore(); ) {
                hs.add((String) enumer.next());
            }
        } catch (Exception e) {
            if (debugFlag) {
                e.printStackTrace();
            }
        }
        return hs;
    }

    private Vector<String> getSacAsets(String sSacId) {
        Vector<String> v = new Vector<String>();
        try {
            Attributes attrs = ctx.getAttributes("CN=" + sSacId + ","
                    + sSacContainerDN);
            Attribute attr = attrs.get("pmAttrSet");
            if (attr == null) {
                return v;
            }
            for (NamingEnumeration<?> enumer = attr.getAll(); enumer.hasMore(); ) {
                v.add((String) enumer.next());
            }
        } catch (Exception e) {
            if (debugFlag) {
                e.printStackTrace();
            }
        }
        return v;
    }

    private String getUserPass(String sId) {
        Attributes attrs;
        //Attribute attr;
        String sPass;

        try {
            attrs = ctx.getAttributes("CN=" + sId + "," + sUserContainerDN);
            if (attrs == null) {
                return null;
            }
            sPass = (String) attrs.get("pmPassword").get();
        } catch (Exception e) {
            e.printStackTrace();
            return null;
        }
        return sPass;
    }

    /**
	 * @uml.property  name="nextSessionNumber"
	 */
    int nextSessionNumber = 1;

    // The password is not encrypted in any way by PmSimul, but the
    // communication
    // client-server is secure.
    private Packet spawnSession(String sClientId, String sCrtSessId)
            throws Exception {
        String sUserId;
        String sUserName;
        String sHost;
        String sSessName;
        //String sSessid;
        Attributes attrs;

        try {
            attrs = ctx.getAttributes("CN=" + sCrtSessId + ","
                    + sSessionContainerDN);
            sUserId = (String) attrs.get("pmUserId").get();
            sHost = (String) attrs.get("pmHost").get();
        } catch (Exception e) {
            if (debugFlag) {
                e.printStackTrace();
            }
            return failurePacket("Exception in spawnSession: " + e.getMessage());
        }

        sUserName = getEntityName(sUserId, PM_NODE_USER);
        sSessName = sUserName + "@" + sHost + "-" + nextSessionNumber++;

        attrs = new BasicAttributes(true);
        RandomGUID myGUID = new RandomGUID();
        String sSessId = myGUID.toStringNoDashes();
        attrs.put("objectClass", sSessionClass);
        attrs.put("pmId", sSessId);
        attrs.put("pmName", sSessName);
        attrs.put("pmHost", sHost);
        attrs.put("pmUserId", sUserId);
        String sTimestamp = dfUpdate.format(new Date());
        attrs.put("pmTimestamp", sTimestamp);

        // Prepare the path and create the new session object.
        String sDn = "CN=" + sSessId + "," + sSessionContainerDN;
        try {
            ctx.bind(sDn, null, attrs);
        } catch (Exception e) {
            if (debugFlag) {
                e.printStackTrace();
            }
            return failurePacket("Could not spawn the session object");
        }

        // Create an event in PmEventContainer with:
        // pmObjClass = the class of the new session object, i.e.,
        // "pmClassSession";
        // pmOriginalId = the id of the new session object;
        // pmEvent = "create";
        // pmTimestamp = timestamp of the new session.
        // cn = "create" + "|" + the id of the new session object.
        myGUID = new RandomGUID();
        String sEventId = myGUID.toStringNoDashes();
        attrs = new BasicAttributes(true);
        attrs.put("objectClass", sEventClass); // Class of this object, which is
        // an event.
        attrs.put("pmObjClass", sSessionClass); // Class of the event's object,
        // which is a session.
        attrs.put("pmId", sEventId); // The id of the event.
        attrs.put("pmOriginalId", sSessId); // The id of the event's object,
        // which is the session id.
        attrs.put("pmEvent", PM_EVENT_CREATE); // The event - create.
        attrs.put("pmTimestamp", sTimestamp); // The event's timestamp.

        // Prepare the path for the new event object.
        sDn = "CN=" + sEventId + "," + sEventContainerDN;

        // If same event for the same object already exists, delete it.
        if (!deleteSimilarEvents(PM_EVENT_CREATE, sSessId)) {
            return failurePacket("Failed to delete similar events");
        }
        try {
            ctx.bind(sDn, null, attrs);
        } catch (Exception e) {
            if (debugFlag) {
                e.printStackTrace();
            }
            return failurePacket("Could not register the event \"Create session\"");
        }

        // Return the name and id of the new session.
        Packet res = new Packet();
        try {
            res.addItem(ItemType.RESPONSE_TEXT, sSessName);
            res.addItem(ItemType.RESPONSE_TEXT, sSessId);
            res.addItem(ItemType.RESPONSE_TEXT, sUserId);
        } catch (Exception e) {
            e.printStackTrace();
            return failurePacket("Exception when building the result packet");
        }
        return res;
    }

    // The password is not encrypted.
    private Packet createSession(String sClientId, String sName, String sHost,
                                 String sUser, String sPass) throws Exception {
        // An empty password arrives here as null.
        if (sPass == null) {
            sPass = "";
        }

        // Check that the host is registered with PM, but use the host name
        // in the session, as we do in the objects.
        String sHostId = getEntityId(sHost, PM_HOST);
        if (sHostId == null) {
            return failurePacket("No such host name!");
        }

        String sUserId = getEntityId(sUser, PM_NODE_USER);
        if (sUserId == null) {
            return failurePacket("Incorrect user name or password!");
        }

        // Get the hash from database, then the salt (first 24 hex digits = 12
        // bytes.
        String sStoredHash = getUserPass(sUserId);
        if (sStoredHash == null) {
            return failurePacket("Internal error - user has no password hash!");
        }
        String sSalt = sStoredHash.substring(0, 24);

        // Convert the salt from 24 hex digits to 12 bytes.
        byte[] salt = hexString2ByteArray(sSalt);

        // Get a message digest instance and hash the salt and the password.
        byte[] digest;
        try {
            MessageDigest md = MessageDigest.getInstance("MD5");
            md.update(salt);
            md.update(sPass.getBytes());
            sPass = null;
            digest = md.digest();
        } catch (Exception e) {
            e.printStackTrace();
            return failurePacket("Internal error while hashing the password");
        }
        String sComputedHash = sSalt + byteArray2HexString(digest);
        if (!sComputedHash.equalsIgnoreCase(sStoredHash)) {
            return failurePacket("Incorrect user name or password!");
        }

        // Get a name for session.
        sName = sUser + "@" + sHost + "-" + nextSessionNumber++;

        Attributes attrs = new BasicAttributes(true);
        RandomGUID myGUID = new RandomGUID();
        String sSessId = myGUID.toStringNoDashes();
        attrs.put("objectClass", sSessionClass);
        attrs.put("pmId", sSessId);
        attrs.put("pmName", sName);
        attrs.put("pmHost", sHost);
        attrs.put("pmUserId", sUserId);
        String sTimestamp = dfUpdate.format(new Date());
        attrs.put("pmTimestamp", sTimestamp);

        // Prepare the path and create the new session object.
        String sDn = "CN=" + sSessId + "," + sSessionContainerDN;
        try {
            ctx.bind(sDn, null, attrs);
        } catch (Exception e) {
            if (debugFlag) {
                e.printStackTrace();
            }
            return failurePacket("Could not create the session object");
        }

        // Create an event in PmEventContainer with:
        // pmObjClass = the class of the new session object, i.e.,
        // "pmClassSession";
        // pmOriginalId = the id of the new session object;
        // pmEvent = "create";
        // pmTimestamp = timestamp of the new session.
        // cn = "create" + "|" + the id of the new session object.
        myGUID = new RandomGUID();
        String sEventId = myGUID.toStringNoDashes();
        attrs = new BasicAttributes(true);
        attrs.put("objectClass", sEventClass); // Class of this object, which is
        // an event.
        attrs.put("pmObjClass", sSessionClass); // Class of the event's object,
        // which is a session.
        attrs.put("pmId", sEventId); // The id of the event.
        attrs.put("pmOriginalId", sSessId); // The id of the event's object,
        // which is the session id.
        attrs.put("pmEvent", PM_EVENT_CREATE); // The event - create.
        attrs.put("pmTimestamp", sTimestamp); // The event's timestamp.

        // Prepare the path for the new event object.
        sDn = "CN=" + sEventId + "," + sEventContainerDN;

        // If same event for the same object already exists, delete it.
        if (!deleteSimilarEvents(PM_EVENT_CREATE, sSessId)) {
            return failurePacket("Failed to delete similar events");
        }
        try {
            ctx.bind(sDn, null, attrs);
        } catch (Exception e) {
            if (debugFlag) {
                e.printStackTrace();
            }
            return failurePacket("Could not register the event \"Create session\"");
        }

        // Return the name and id of the new session to PmSimul.
        Packet res = new Packet();
        try {
            res.addItem(ItemType.RESPONSE_TEXT, sName);
            res.addItem(ItemType.RESPONSE_TEXT, sSessId);
            res.addItem(ItemType.RESPONSE_TEXT, sUserId);
        } catch (Exception e) {
            return failurePacket("Exception when building the result packet");
        }
        return res;
    }

    // Delete all events with pmEvent=sEvent on the the object pmOriginalId =
    // sObjId.
    private boolean deleteSimilarEvents(String sEvent, String sObjId) {
        NamingEnumeration<?> events;

        try {
            SearchControls constraints = new SearchControls();
            constraints.setSearchScope(SearchControls.ONELEVEL_SCOPE);
            constraints.setReturningAttributes(new String[]{"pmId"});
            events = ctx.search(sEventContainerDN, "(&(pmEvent=" + sEvent
                    + ")(pmOriginalId=" + sObjId + "))", constraints);
            while (events != null && events.hasMore()) {
                SearchResult sr = (SearchResult) events.next();
                String sEventId = (String) sr.getAttributes().get("pmId").get();
                ctx.destroySubcontext("CN=" + sEventId + ","
                        + sEventContainerDN);
            }
        } catch (Exception e) {
            if (debugFlag) {
                e.printStackTrace();
            }
            return false;
        }
        return true;
    }

    private Packet changePassword(String sClientId, String sUser,
                                  String sOldPass, String sNewPass, String sConPass) throws Exception {
        // Empty passwords arrive here as nulls.
        if (sOldPass == null) {
            sOldPass = "";
        }
        if (sNewPass == null) {
            sNewPass = "";
        }
        if (sConPass == null) {
            sConPass = "";
        }

        if (!sNewPass.equals(sConPass)) {
            return failurePacket("The new passwords you typed do not match!");
        }
        sConPass = null;

        String sUserId = getEntityId(sUser, PM_NODE_USER);
        if (sUserId == null) {
            return failurePacket("Incorrect user name or password!");
        }

        // Get the hash from database, then the salt (first 24 hex digits = 12
        // bytes.
        String sStoredHash = getUserPass(sUserId);
        if (sStoredHash == null) {
            return failurePacket("Internal error - user has no password hash");
        }
        String sSalt = sStoredHash.substring(0, 24);

        // Convert the salt from 24 hex digits to 12 bytes.
        byte[] salt = hexString2ByteArray(sSalt);

        // Get a message digest instance and hash the salt and the password.
        byte[] digest;
        try {
            MessageDigest md = MessageDigest.getInstance("MD5");
            md.update(salt);
            md.update(sOldPass.getBytes());
            sOldPass = null;
            digest = md.digest();
        } catch (Exception e) {
            e.printStackTrace();
            return failurePacket("Internal error while hashing the password!");
        }
        String sComputedHash = sSalt + byteArray2HexString(digest);
        if (!sComputedHash.equalsIgnoreCase(sStoredHash)) {
            return failurePacket("Incorrect user name or password!");
        }

        // Get a random 12-byte salt.
        SecureRandom random = new SecureRandom();
        salt = new byte[12];
        random.nextBytes(salt);

        // Digest the salt and the new password.
        try {
            MessageDigest md = MessageDigest.getInstance("MD5");
            md.update(salt);
            md.update(sNewPass.getBytes());
            sNewPass = null; // but they're not collected probably
            digest = md.digest();
        } catch (Exception e) {
            e.printStackTrace();
            return failurePacket("Error while hashing the password");
        }

        // Convert the hash to a string of hex digits.
        sComputedHash = byteArray2HexString(salt) + byteArray2HexString(digest);

        // Store the new hash as attribute "pmPassword" of the user.
        try {
            ModificationItem[] mods = new ModificationItem[1];
            mods[0] = new ModificationItem(DirContext.REPLACE_ATTRIBUTE,
                    new BasicAttribute("pmPassword", sComputedHash));
            ctx.modifyAttributes("CN=" + sUserId + "," + sUserContainerDN, mods);
        } catch (Exception e) {
            if (debugFlag) {
                e.printStackTrace();
            }
            return failurePacket("Failed to change password: " + e.getMessage());
        }
        return successPacket();
    }

    private boolean deleteSessionVosNodes(String sSessId) {
        NamingEnumeration<?> nodes;

        try {
            SearchControls constraints = new SearchControls();
            constraints.setSearchScope(SearchControls.ONELEVEL_SCOPE);
            constraints.setReturningAttributes(new String[]{"cn"});
            nodes = ctx.search(sVosNodeContainerDN, "(pmSessId=" + sSessId
                    + ")", constraints);
            while (nodes != null && nodes.hasMore()) {
                SearchResult sr = (SearchResult) nodes.next();
                String sCn = (String) sr.getAttributes().get("cn").get();
                ctx.destroySubcontext("CN=" + sCn + "," + sVosNodeContainerDN);
            }
        } catch (Exception e) {
            if (debugFlag) {
                e.printStackTrace();
            }
            return false;
        }
        return true;
    }

    private Packet deleteSession(String sClientId, String sSessId) {
        // First delete the session's VOS nodes.
        if (!deleteSessionVosNodes(sSessId)) {
            return failurePacket("Could not delete the session's VOS nodes");
        }
        try {
            ctx.destroySubcontext("CN=" + sSessId + "," + sSessionContainerDN);
        } catch (Exception e) {
            if (debugFlag) {
                e.printStackTrace();
            }
            return failurePacket("Could not delete session " + sSessId);
        }

        // Create an event in PmEventContainer with:
        // pmObjClass = the class of the session object, i.e., "pmClassSession";
        // pmId = the id of the session object;
        // pmEvent = "delete";
        // pmTimestamp = current timestamp.
        // cn = "delete" + "|" + the id of the session object.
        Attributes attrs = new BasicAttributes(true);
        RandomGUID myGUID = new RandomGUID();
        String sEventId = myGUID.toStringNoDashes();
        attrs.put("objectClass", sEventClass); // Class of this object, which is
        // an event.
        attrs.put("pmObjClass", sSessionClass); // Class of the event's object,
        // which is a session.
        attrs.put("pmId", sEventId); // The id of the event.
        attrs.put("pmOriginalId", sSessId); // The id of the event's object,
        // which is the session id.
        attrs.put("pmEvent", PM_EVENT_DELETE); // The event - delete.
        String sTimestamp = dfUpdate.format(new Date());
        attrs.put("pmTimestamp", sTimestamp); // The event's timestamp.

        // Prepare the path and create the new event object. If an event with
        // the
        // same name exists, delete it first.
        String sDn = "CN=" + sEventId + "," + sEventContainerDN;
        if (!deleteSimilarEvents(PM_EVENT_DELETE, sSessId)) {
            return failurePacket("Failed to delete similar events");
        }
        try {
            ctx.bind(sDn, null, attrs);
        } catch (Exception e) {
            if (debugFlag) {
                e.printStackTrace();
            }
            return failurePacket("Could not create the event \"Delete session\"");
        }
        return successPacket();
    }

    // Determine the admin view of the virtual object system for a given
    // session/user.
    private Packet computeAdminVos(String sClientId, String sUserId,
                                   String sSessId) {
        Vector<String> repOasInPc;

        String sUserName = getEntityName(sUserId, PM_NODE_USER);
        if (sUserName == null) {
            return failurePacket("No user with such id!");
        }

        System.out.println("Determining new VOS for user " + sUserName);

        // Get all policy classes:
        Vector<String> policyClasses = getPolicyClasses();

        // Get all user's attributes (ua such that u ->+ ua):
        HashSet<String> authAttrs = getUserDescendantsInternal(sUserId);

        // Init a HashMap whose entries will contain the AccRepOas(u, pc)
        // with pc as key.
        HashMap<String, Vector<String>> hm = new HashMap<String, Vector<String>>();

        // For each policy class pc:
        for (int pc = 0; pc < policyClasses.size(); pc++) {
            String sPcId = policyClasses.elementAt(pc);
            String sPcName = getEntityName(sPcId, PM_NODE_POL);

            // Init the vector for RepOasInPc(u, pc) and create the hm entry
            // for the current pc:
            repOasInPc = new Vector<String>();
            hm.put(sPcId, repOasInPc);

            // For each user attribute ua such that ua ->+ pc:
            Iterator<String> uaiter = authAttrs.iterator();
            while (uaiter.hasNext()) {
                String sUaId = uaiter.next();
                if (!attrIsAscendantToPolicy(sUaId, PM_NODE_UATTR, sPcId)) {
                    continue;
                }

                // For each ops such that ua->ops:
                Vector<String> opsets = getToOpsets(sUaId);
                for (int ops = 0; ops < opsets.size(); ops++) {
                    String sOpsId = opsets.elementAt(ops);

                    // For each oa such that ops -> oa
                    Vector<String> oattrs = getToAttrs(sOpsId);
                    for (int oa = 0; oa < oattrs.size(); oa++) {
                        String sOaId = oattrs.elementAt(oa);

                        // If oa does not have an associate object, skip it.
                        String sObjId = getAssocObj(sOaId);
                        if (sObjId == null) {
                            continue;
                        }

                        // If not (oa ->+ pc) skip this oa.
                        if (!attrIsAscendantToPolicy(sOaId, PM_NODE_OATTR,
                                sPcId)) {
                            continue;
                        }

                        // If the object sObjId does not represent a PM entity,
                        // skip this oa.
                        if (!objRepresentsAGraphEntity(sObjId)) {
                            continue;
                        }

                        // Add oa to repOasInPc, if not already there.
                        if (!repOasInPc.contains(sOaId)) {
                            repOasInPc.add(sOaId);
                        }
                    }
                }
            }
            // Now we have the RepOasInPc(u, pc) set. Let's print its elements:
            printVector(repOasInPc, PM_NODE_OATTR,
                    "Accessible object attributes in policy " + sPcName);
        }

        // Let's compute AccRepOas(u).
        HashSet<String> accRepOas = new HashSet<String>();

        // For each policy class pc:
        for (int pc = 0; pc < policyClasses.size(); pc++) {
            String sPcId = policyClasses.elementAt(pc);
            //String sPcName = getNameOfEntityWithIdAndType(sPcId, PM_NODE_POL);

            // Get the set RepOasInPc for the current pc.
            repOasInPc = hm.get(sPcId);

            // For each oa in RepOasInPc(u, pc)
            for (int i = 0; i < repOasInPc.size(); i++) {
                String sOaId = repOasInPc.elementAt(i);

                // If oa is accessible to user u, add oa to accRepOas.
                if (repOattrIsAccessible(sOaId, sPcId, hm)) {
                    if (!accRepOas.contains(sOaId)) {
                        accRepOas.add(sOaId);
                    }
                }
            }
        }

        printSet(accRepOas, PM_NODE_OATTR, "Accessible representative oattrs");

        // Let's compute the set PrincRepOas(u).
        HashSet<String> princRepOas = new HashSet<String>();

        Iterator<String> accIter = accRepOas.iterator();
        loopOas:
        while (accIter.hasNext()) {
            String sOaId = accIter.next();
            Iterator<String> princIter = princRepOas.iterator();
            while (princIter.hasNext()) {
                String sPrincId = princIter.next();
                if (viewIsIncludedInView(sOaId, sPrincId)) {
                    continue loopOas;
                }
            }
            princIter = princRepOas.iterator();
            while (princIter.hasNext()) {
                String sPrincId = princIter.next();
                if (viewIsIncludedInView(sPrincId, sOaId)) {
                    princIter.remove();
                }
            }
            princRepOas.add(sOaId);
        }

        printSet(princRepOas, PM_NODE_OATTR, "Principal representative oattrs");

        // Build the VOS graph.
        buildAdminVosGraph(princRepOas, sUserId, sUserName, sSessId);
        Packet result = new Packet();
        try {
            result.addItem(ItemType.RESPONSE_TEXT, dfUpdate.format(new Date()));
            return result;
        } catch (Exception e) {
            e.printStackTrace();
            return failurePacket("Exception when building the result packet");
        }
    }

    private void buildAdminVosGraph(HashSet<String> princRepOas,
                                    String sUserId, String sUserName, String sSessId) {
        try {
            // First delete all records for the session.
            deleteAdminVosRecords(sSessId);

            // Build the connector node.
            Attributes vosAttrs = new BasicAttributes(true);
            vosAttrs.put("objectClass", sAdminVosNodeClass);
            RandomGUID myGUID = new RandomGUID();
            String sConnNewId = myGUID.toStringNoDashes();
            vosAttrs.put("pmId", sConnNewId);
            vosAttrs.put("pmOriginalId", PM_CONNECTOR_ID);
            vosAttrs.put("pmName", PM_CONNECTOR_NAME);
            vosAttrs.put("pmType", PM_NODE_CONN);
            vosAttrs.put("pmSessId", sSessId);
            vosAttrs.put("pmUserId", sUserId);
            vosAttrs.put("pmUserName", sUserName);
            ctx.bind("CN=" + sConnNewId + "," + sAdminVosNodeContainerDN, null,
                    vosAttrs);

            // Prepare for walk through views defined by the principals.
            HashSet<String> visitedSet = new HashSet<String>();
            ArrayList<AdminVosQueueElement> queue = new ArrayList<AdminVosQueueElement>();
//			AdminVosQueueElement qe;
            AdminVosQueueElement crtQe;

            // For each principal in princRepOas
            Iterator<String> princIter = princRepOas.iterator();
            while (princIter.hasNext()) {
                String sPrincOaId = princIter.next();
                System.out.println("Generating the subgraph for principal \""
                        + getEntityName(sPrincOaId, PM_NODE_OATTR) + "\"");

                // Get information from the principal.
                // TO DO: Get this information in the previous steps and store
                // it in
                // the hash set princRepOas.
                String sObjId = getAssocObj(sPrincOaId);
                Attributes attrs = ctx.getAttributes("CN=" + sObjId + ","
                        + sVirtualObjContainerDN);
                Attribute attr = attrs.get("pmObjClass");
                String sPrincType = classToType((String) attr.get());
                attr = attrs.get("pmOriginalId");
                String sPrincId = (String) attr.get();
                String sPrincName = getEntityName(sPrincId, sPrincType);
                attr = attrs.get("pmIncludesAscendants");
                boolean bPrincAscs = ((String) attr.get()).equalsIgnoreCase("TRUE");
                if (sPrincType.equalsIgnoreCase(PM_NODE_OATTR)
                        && getAssocObj(sPrincId) != null) {
                    sPrincType = PM_NODE_ASSOC;
                }
                String sEntNewId = null;

                System.out.println("    Principal's type = " + sPrincType
                        + ", id = " + sPrincId + ", name = "
                        + getEntityName(sPrincId, sPrincType) + ", subgraph = "
                        + bPrincAscs);

                // Build the principal node.
                // If the principal is the connector, don't build the principal
                // (the connector is already built), but set sEntNewId to
                // sConnNewId
                // in order to be initialized.
                // Anyway, build the principal's ascendants.
                sEntNewId = sConnNewId;
                if (!sPrincId.equalsIgnoreCase(PM_CONNECTOR_ID)) {
                    vosAttrs = new BasicAttributes(true);
                    vosAttrs.put("objectClass", sAdminVosNodeClass);
                    myGUID = new RandomGUID();
                    sEntNewId = myGUID.toStringNoDashes();
                    vosAttrs.put("pmId", sEntNewId);
                    vosAttrs.put("pmOriginalId", sPrincId);
                    vosAttrs.put("pmName", sPrincName);
                    vosAttrs.put("pmType", sPrincType);
                    vosAttrs.put("pmSessId", sSessId);
                    vosAttrs.put("pmUserId", sUserId);
                    vosAttrs.put("pmUserName", sUserName);
                    ctx.bind(
                            "CN=" + sEntNewId + "," + sAdminVosNodeContainerDN,
                            null, vosAttrs);

                    // Link it to the connnector node.
                    if (!addAdminVosDoubleLink(sEntNewId, sConnNewId)) {
                        System.out.println("Error while linking principal "
                                + sPrincName + " to connector!");
                        return;
                    }
                }

                // If the principal defines a view limited to the pricipal node
                // itself,
                // continue with next principal. Otherwise, insert the principal
                // into
                // the queue.
                if (!bPrincAscs) {
                    continue;
                }
                crtQe = new AdminVosQueueElement(sPrincType, sPrincId,
                        sEntNewId);
                queue.add(crtQe);

                // Loop while queue is not empty.
                while (!queue.isEmpty()) {
                    // Extract first queue element:
                    crtQe = queue.remove(0);
                    String sCrtType = crtQe.getType();
                    String sCrtId = crtQe.getId();
                    String sCrtDescId = crtQe.getDesc();
                    String sCrtName = getEntityName(sCrtId, sCrtType);
                    if (debugFlag) {
                        System.out.println("Out of queue: " + sCrtName + "("
                                + sCrtId + ", " + sCrtType + "), "
                                + sCrtDescId);
                    }
                    // Get the direct ascendants of crtQe. They depend on crtQe
                    // type.
                    if (sCrtType.equalsIgnoreCase(PM_NODE_USER)) {
                        // do nothing, there are no ascendants.
                    } else if (sCrtType.equalsIgnoreCase(PM_NODE_UATTR)) {
                        // Direct ascendants could be user attributes...
                        attr = getFromAttrs(sCrtId, PM_NODE_UATTR);
                        doAdminVosDirAscs(attr, PM_NODE_UATTR, sCrtDescId,
                                sSessId, queue, visitedSet);

                        // ... or users.
                        attr = getFromUsers(sCrtId, PM_NODE_UATTR);
                        doAdminVosDirAscs(attr, PM_NODE_USER, sCrtDescId,
                                sSessId, queue, visitedSet);
                    } else if (sCrtType.equalsIgnoreCase(PM_NODE_POL)) {
                        // Direct ascendants could be user attributes...
                        attr = getFromUserAttrs(sCrtId, PM_NODE_POL);
                        doAdminVosDirAscs(attr, PM_NODE_UATTR, sCrtDescId,
                                sSessId, queue, visitedSet);
                        // ... or object attributes.
                        attr = getFromObjAttrs(sCrtId, PM_NODE_POL);
                        doAdminVosDirAscs(attr, PM_NODE_OATTR, sCrtDescId,
                                sSessId, queue, visitedSet);
                    } else if (sCrtType.equalsIgnoreCase(PM_NODE_OATTR)) {
                        // Direct ascendants could be object attributes.
                        attr = getFromAttrs(sCrtId, PM_NODE_OATTR);
                        doAdminVosDirAscs(attr, PM_NODE_OATTR, sCrtDescId,
                                sSessId, queue, visitedSet);
                    } else if (sCrtType.equalsIgnoreCase(PM_NODE_ASSOC)) {
                        // do nothing, an associated oattr does not have
                        // ascendants.
                    } else if (sCrtType.equalsIgnoreCase(PM_NODE_CONN)) {
                        attr = getFromPolicies(PM_CONNECTOR_ID, PM_NODE_CONN);
                        doAdminVosDirAscs(attr, PM_NODE_POL, sCrtDescId,
                                sSessId, queue, visitedSet);
                    }

                }// while queue not empty
            }

        } catch (Exception e) {
            e.printStackTrace();
        }

    }

    // Parameters:
    // attr: An Attribute containing the ids of the direct ascendants of a node.
    // sType: the type of those ascendants (PM_NODE_USER, etc.)
    // sVosBaseId: the VOS id of the base node.
    // sSessId: the session id.
    // queue and visited: we know them.
    // Note that the type for object attributes comes always as PM_NODE_OATTR,
    // event when the object attribute is associated to an object. In such a
    // case,
    // we need to put it correctly in the VOS as PM_NODE_ASSOC.
    private void doAdminVosDirAscs(Attribute attr, String sType,
                                   String sVosBaseId, String sSessId,
                                   ArrayList<AdminVosQueueElement> queue, HashSet<String> visited) {
        try {
            if (attr != null) {
                for (NamingEnumeration<?> attrEnum = attr.getAll(); attrEnum.hasMore(); ) {
                    String sTrueType = sType;
                    String sId = (String) attrEnum.next();
                    String sName = getEntityName(sId, sType);
                    String sNewId = null;

                    // If the current ascendant is an object attribute
                    // associated to an
                    // object, change its type to PM_NODE_ASSOC ("o").
                    if (sType.equalsIgnoreCase(PM_NODE_OATTR)
                            && getAssocObj(sId) != null) {
                        sTrueType = PM_NODE_ASSOC;
                    }

                    // Do not display objects that represent PM entities!
                    if (sTrueType.equals(PM_NODE_ASSOC)
                            && oattrRepresentsAnEntity(sId)) {
                        continue;
                    }

                    if (!visited.contains(sId)) {
                        visited.add(sId);
                        Attributes vosAttrs = new BasicAttributes(true);
                        vosAttrs.put("objectClass", sAdminVosNodeClass);
                        RandomGUID myGUID = new RandomGUID();
                        sNewId = myGUID.toStringNoDashes();
                        vosAttrs.put("pmId", sNewId);
                        vosAttrs.put("pmOriginalId", sId);
                        vosAttrs.put("pmName", sName);
                        vosAttrs.put("pmType", sTrueType);
                        vosAttrs.put("pmSessId", sSessId);
                        ctx.bind("CN=" + sNewId + ","
                                + sAdminVosNodeContainerDN, null, vosAttrs);

                        // Insert the new VOS node into the queue.
                        AdminVosQueueElement qe = new AdminVosQueueElement(
                                sTrueType, sId, sNewId);
                        queue.add(qe);
                    }

                    // Create double link new VOS node -> base VOS node. When
                    // the new VOS node
                    // was already visited, we don;t know its new id, so we must
                    // search for it
                    // based on the original id and the session id.
                    if (sNewId == null) {
                        sNewId = getAdminVosNodeId(sId, sSessId);
                    }
                    if (!addAdminVosDoubleLink(sNewId, sVosBaseId)) {
                        System.out.println("Error when linking VOS node "
                                + sName + " to its VOS base!");
                        return;
                    }
                }
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    private void addAdminVosNode(Packet graph, String sType, String sId)
            throws Exception {
        String sLabel = getAdminVosNodeName(sId);
        StringBuffer sb = new StringBuffer();
        sb.append(sType);
        sb.append(PM_FIELD_DELIM);
        sb.append(sId);
        sb.append(PM_FIELD_DELIM);
        sb.append(sLabel);
        graph.addItem(ItemType.RESPONSE_TEXT, sb.toString());
    }

    // For a given admin VOS node, return its direct ascendants.
    // sId is the new id of the VOS node.
    private Attribute getAdminVosNodeAscs(String sId) {
        try {
            Attributes attrs = ctx.getAttributes("CN=" + sId + ","
                    + sAdminVosNodeContainerDN);
            Attribute attr = attrs.get("pmAscNode");
            return attr;
        } catch (Exception e) {
            if (debugFlag) {
                e.printStackTrace();
            }
            return null;
        }
    }

    // For a given admin VOS node, return its direct descendants.
    // sId is the new id of the VOS node.
    private Attribute getAdminVosNodeDescs(String sId) {
        try {
            Attributes attrs = ctx.getAttributes("CN=" + sId + ","
                    + sAdminVosNodeContainerDN);
            Attribute attr = attrs.get("pmDescNode");
            return attr;
        } catch (Exception e) {
            if (debugFlag) {
                e.printStackTrace();
            }
            return null;
        }
    }

    // For a given admin VOS node, return its name.
    // sId is the new id of the VOS node.
    private String getAdminVosNodeName(String sId) {
        try {
            Attributes attrs = ctx.getAttributes("CN=" + sId + ","
                    + sAdminVosNodeContainerDN);
            return (String) attrs.get("pmName").get();
        } catch (Exception e) {
            if (debugFlag) {
                e.printStackTrace();
            }
            return null;
        }
    }

    // For a given admin VOS node, return its original id.
    // Parameter sId is the new id of the VOS node.
    private String getAdminVosNodeOrigId(String sId) {
        try {
            Attributes attrs = ctx.getAttributes("CN=" + sId + ","
                    + sAdminVosNodeContainerDN);
            return (String) attrs.get("pmOriginalId").get();
        } catch (Exception e) {
            if (debugFlag) {
                e.printStackTrace();
            }
            return null;
        }
    }

    // For a given VOS node, return its type.
    // sId is the new id of the VOS node.
    private String getAdminVosNodeType(String sId) {
        try {
            Attributes attrs = ctx.getAttributes("CN=" + sId + ","
                    + sAdminVosNodeContainerDN);
            return (String) attrs.get("pmType").get();
        } catch (Exception e) {
            if (debugFlag) {
                e.printStackTrace();
            }
            return null;
        }
    }

    // Given an admin VOS node's original id and the session id,
    // return the node's new id.
    private String getAdminVosNodeId(String sOrigId, String sSessId) {
        NamingEnumeration<?> nodes;

        try {
            SearchControls constraints = new SearchControls();
            constraints.setSearchScope(SearchControls.ONELEVEL_SCOPE);
            constraints.setReturningAttributes(new String[]{"pmId"});
            nodes = ctx.search(sAdminVosNodeContainerDN, "(&(pmOriginalId="
                    + sOrigId + ")(pmSessId=" + sSessId + "))", constraints);
        } catch (Exception e) {
            if (debugFlag) {
                e.printStackTrace();
            }
            return null;
        }
        try {
            if (nodes == null || !nodes.hasMore()) {
                return null;
            }
            SearchResult sr = (SearchResult) nodes.next();
            return (String) sr.getAttributes().get("pmId").get();
        } catch (Exception e) {
            if (debugFlag) {
                e.printStackTrace();
            }
            return null;
        }
    }

    private boolean addAdminVosDoubleLink(String sId1, String sId2) {
        ModificationItem[] mods = new ModificationItem[1];

        mods[0] = new ModificationItem(DirContext.ADD_ATTRIBUTE,
                new BasicAttribute("pmDescNode", sId2));
        try {
            ctx.modifyAttributes("CN=" + sId1 + "," + sAdminVosNodeContainerDN,
                    mods);
        } catch (Exception e) {
            if (debugFlag) {
                e.printStackTrace();
            }
            return false;
        }
        mods[0] = new ModificationItem(DirContext.ADD_ATTRIBUTE,
                new BasicAttribute("pmAscNode", sId1));
        try {
            ctx.modifyAttributes("CN=" + sId2 + "," + sAdminVosNodeContainerDN,
                    mods);
        } catch (Exception e) {
            if (debugFlag) {
                e.printStackTrace();
            }
            return false;
        }
        return true;
    }

    // sOa1 and sOa2 are object attributes associated to objects that
    // represent PM graph entities.
    private boolean viewIsIncludedInView(String sOa1, String sOa2) {
        try {
            // First find the entities.
            // Get type, id, and isSubgraph for first entity.
            String sObjId = getAssocObj(sOa1);
            if (sObjId == null) {
                System.out.println("viewIsIncludedInView: arg 1 is not associated to an object");
                return false;
            }
            Attributes attrs = ctx.getAttributes("CN=" + sObjId + ","
                    + sVirtualObjContainerDN);
            Attribute attr = attrs.get("pmObjClass");
            if (attr == null || attr.size() <= 0) {
                System.out.println("viewIsIncludedInView: pmObjClass for arg 1 is null or empty");
                return false;
            }
            String sEntType1 = classToType((String) attr.get());
            attr = attrs.get("pmOriginalId");
            if (attr == null || attr.size() <= 0) {
                System.out.println("viewIsIncludedInView: pmOriginalId for arg 1 is null or empty");
                return false;
            }
            String sEntId1 = (String) attr.get();
            attr = attrs.get("pmIncludesAscendants");
            if (attr == null || attr.size() <= 0) {
                System.out.println("viewIsIncludedInView: pmIncludesAscendants for arg 1 is null or empty");
                return false;
            }
            boolean bEntAscs1 = ((String) attr.get()).equalsIgnoreCase("TRUE");

            // Get type, id, and isSubgraph for second entity.
            sObjId = getAssocObj(sOa2);
            if (sObjId == null) {
                System.out.println("viewIsIncludedInView: arg 2 is not associated to an object");
                return false;
            }
            attrs = ctx.getAttributes("CN=" + sObjId + ","
                    + sVirtualObjContainerDN);
            attr = attrs.get("pmObjClass");
            if (attr == null || attr.size() <= 0) {
                System.out.println("viewIsIncludedInView: pmObjClass for arg 2 is null or empty");
                return false;
            }
            String sEntType2 = classToType((String) attr.get());
            attr = attrs.get("pmOriginalId");
            if (attr == null || attr.size() <= 0) {
                System.out.println("viewIsIncludedInView: pmOriginalId for arg 2 is null or empty");
                return false;
            }
            String sEntId2 = (String) attr.get();
            attr = attrs.get("pmIncludesAscendants");
            if (attr == null || attr.size() <= 0) {
                System.out.println("viewIsIncludedInView: pmIncludesAscendants for arg 2 is null or empty");
                return false;
            }
            boolean bEntAscs2 = ((String) attr.get()).equalsIgnoreCase("TRUE");

            if (bEntAscs2
                    && isContained(sEntId1, sEntType1, sEntId2, sEntType2)) {
                System.out.println("viewIsIncludedInView("
                        + getEntityName(sOa1, PM_NODE_OATTR) + ", "
                        + getEntityName(sOa2, PM_NODE_OATTR) + ") = true");
                return true;
            }
            if (sEntId1.equalsIgnoreCase(sEntId2) && !bEntAscs1 && !bEntAscs2) {
                System.out.println("viewIsIncludedInView("
                        + getEntityName(sOa1, PM_NODE_OATTR) + ", "
                        + getEntityName(sOa2, PM_NODE_OATTR) + ") = true");
                return true;
            }
            System.out.println("viewIsIncludedInView("
                    + getEntityName(sOa1, PM_NODE_OATTR) + ", "
                    + getEntityName(sOa2, PM_NODE_OATTR) + ") = false");
            return false;
        } catch (Exception e) {
            if (debugFlag) {
                e.printStackTrace();
            }
            return false;
        }
    }

    // The oa here is associated to an object that represents a graph entity.
    // It is sort of special, because it has opsets assigned to itself,
    // not to descendant oattrs.
    private boolean repOattrIsAccessible(String sOaId, String sPcId,
                                         HashMap<String, Vector<String>> hm) {
        // Try to find pc' != pc such that oa ->+ pc'. Use the hm keys to get
        // pc'.
        Set<String> keyset = hm.keySet();
        Iterator<String> iter = keyset.iterator();
        while (iter.hasNext()) {
            String sPcIdPrim = iter.next();
            if (sPcIdPrim.equals(sPcId)) {
                continue;
            }
            if (!attrIsAscendantToPolicy(sOaId, PM_NODE_OATTR, sPcIdPrim)) {
                continue;
            }
            // The vector MinAOA(u,pc'):
            Vector<String> v = hm.get(sPcIdPrim);
            // Looking for a oam' such that oa ->* oam'.
            // If we don't find one, then oa is not visible.
            boolean foundOaPrim = false;
            for (int i = 0; i < v.size(); i++) {
                String sOaIdPrim = v.elementAt(i);
                if (attrIsAscendant(sOaId, sOaIdPrim, PM_NODE_OATTR)) {
                    foundOaPrim = true;
                    break;
                }
            }
            if (!foundOaPrim) {
                return false;
            }
        }
        return true;
    }

    // sPresType is the presentation type: administrative or end-user.
    private Packet computeVos(String sClientId, String sPresType,
                              String sUserId, String sSessId) {
        if (sPresType.equalsIgnoreCase(PM_VOS_PRES_ADMIN)) {
            return computeAdminVos(sSessId, sUserId, sSessId);
        }
        String sUserName;
        Vector<String> policyClasses;
        Vector<String> opsets;
        Vector<String> oattrs;
        Vector<String> aoattrs; // accessible (to user) object attributes.
        String sPcId;
        String sPcName;
        String sOpsId;
        String sOaId;

        // Find user's name:
        sUserName = getEntityName(sUserId, PM_NODE_USER);
        if (sUserName == null) {
            return failurePacket("No user with such id");
        }

        // Get all policy classes:
        policyClasses = getPolicyClasses();

        // Get user's attributes (ua such that u ->+ ua):
        HashSet<String> authattrs = getUserDescendantsInternal(sUserId);

        // Init a HashMap whose entries will contain the MinAOA for various pcs.
        // The key of an entry is the pcId.
        // The value of an entry is a vector containing MinAOA(u,pc).
        HashMap<String, Vector<String>> hm = new HashMap<String, Vector<String>>();

        // For each policy class pc:
        for (int pc = 0; pc < policyClasses.size(); pc++) {
            sPcId = policyClasses.elementAt(pc);
            sPcName = getEntityName(sPcId, PM_NODE_POL);

            // Init new vector for MinAOA(u,pc) and create entry for crt. pc:
            Vector<String> minaoattrs = new Vector<String>();
            hm.put(sPcId, minaoattrs);

            // New vector for AOA(u,pc)
            aoattrs = new Vector<String>();

            // For each user attribute ua such that ua ->+ pc:
            Iterator<String> uaiter = authattrs.iterator();
            while (uaiter.hasNext()) {
                String sUaId = uaiter.next();
                if (!attrIsAscendantToPolicy(sUaId, PM_NODE_UATTR, sPcId)) {
                    continue;
                }

                // For each ops such that ua->ops:
                opsets = getToOpsets(sUaId);
                for (int ops = 0; ops < opsets.size(); ops++) {
                    sOpsId = opsets.elementAt(ops);

                    // For each oa such that ops -> oa
                    oattrs = getToAttrs(sOpsId);
                    for (int oa = 0; oa < oattrs.size(); oa++) {
                        sOaId = oattrs.elementAt(oa);

                        // Added (March 2006) to ignore the objects that
                        // represents PM entities.
                        if (ignoreOattrInVos(sOaId)) {
                            continue;
                        }

                        // Retain only oa such that oa ->+ pc:
                        if (!attrIsAscendantToPolicy(sOaId, PM_NODE_OATTR,
                                sPcId)) {
                            continue;
                        }
                        if (!aoattrs.contains(sOaId)) {
                            aoattrs.add(sOaId);
                        }
                    }
                }
            }
            // Now we have the AOA(u,pc) set. Let's print its elements:
            printVector(aoattrs, PM_NODE_OATTR,
                    "Accessible object attributes in policy " + sPcName);

            // For each oam in AOA(u,pc):
            boolean isMinimal;
            for (int oam = 0; oam < aoattrs.size(); oam++) {
                String sOaIdM = aoattrs.elementAt(oam);
                isMinimal = true;
                // For each oa in AOA(u,pc), oa != oam:
                for (int oa = 0; oa < aoattrs.size(); oa++) {
                    if (oa == oam) {
                        continue;
                    }
                    sOaId = aoattrs.elementAt(oa);
                    if (attrIsAscendant(sOaIdM, sOaId, PM_NODE_OATTR)) {
                        isMinimal = false;
                        break;
                    }
                }
                if (isMinimal) {
                    minaoattrs.add(sOaIdM);
                }
            }
        }

        // Now the hm entry with key = pc contains MinAOA(u,pc). Let's print
        // them.
        Set<String> keyset = hm.keySet();
        Iterator<String> iter = keyset.iterator();
        while (iter.hasNext()) {
            String key = iter.next();
            String sName = getEntityName(key, PM_NODE_POL);
            Vector<String> v = hm.get(key);
            printVector(v, PM_NODE_OATTR, "MinAOA(" + sName + ")");

            // It's incorrect to ignore empty policy classes at this stage!!!
            // if (v.isEmpty()) iter.remove();
        }

        // For testing only.
        // For each key=pc of hm
        // For each element minimal in pc
        // For each object attribute ascendant
        // Print whether it is visible.
        iter = keyset.iterator();
        HashSet<String> attrSet = new HashSet<String>();

        while (iter.hasNext()) {
            sPcId = iter.next();
            sPcName = getEntityName(sPcId, PM_NODE_POL);
            System.out.println("//For pc " + sPcName + ":");
            Vector<String> v = hm.get(sPcId);
            for (int i = 0; i < v.size(); i++) {
                String sOamId = (String) v.elementAt(i);
                String sOamName = getEntityName(sOamId, PM_NODE_OATTR);
                attrSet.clear();
                getAscAttrs(sOamId, PM_NODE_OATTR, attrSet);
                System.out.println("////For attr " + sOamName
                        + " and its ascendants:");
                Iterator<String> oamiter = attrSet.iterator();
                while (oamiter.hasNext()) {
                    sOaId = oamiter.next();
                    String sOaName = getEntityName(sOaId, PM_NODE_OATTR);
                    if (attrIsVisible(sOaId, sPcId, hm)) {
                        System.out.println("   ascendant " + sOaName
                                + " is visible.");
                    } else {
                        System.out.println("   ascendant " + sOaName
                                + " is NOT visible.");
                    }
                }
            }
        }

        // Build the VOS graph.
        buildVosGraph(hm, sUserId, sUserName, sSessId);
        Packet res = new Packet();
        try {
            res.addItem(ItemType.RESPONSE_TEXT, dfUpdate.format(new Date()));
        } catch (Exception e) {
            e.printStackTrace();
            return failurePacket("Exception when building the result packet");
        }
        return res;
    }

    private void deleteAdminVosRecords(String sSessId) throws Exception {
        NamingEnumeration<?> members;
        String sDn;

        SearchControls constraints = new SearchControls();
        constraints.setSearchScope(SearchControls.ONELEVEL_SCOPE);
        constraints.setReturningAttributes(null);
        members = ctx.search(sAdminVosNodeContainerDN, "(pmSessId=" + sSessId
                + ")", constraints);
        while (members != null && members.hasMore()) {
            sDn = ((SearchResult) members.next()).getName() + ","
                    + sAdminVosNodeContainerDN;

            ctx.destroySubcontext(sDn);
        }
    }

    private void deleteVosRecords(String sSessId) throws Exception {
        NamingEnumeration<?> members;
        String sDn;

        SearchControls constraints = new SearchControls();
        constraints.setSearchScope(SearchControls.ONELEVEL_SCOPE);
        constraints.setReturningAttributes(null);
        members = ctx.search(sVosNodeContainerDN, "(pmSessId=" + sSessId + ")",
                constraints);
        while (members != null && members.hasMore()) {
            sDn = ((SearchResult) members.next()).getName() + ","
                    + sVosNodeContainerDN;
            ctx.destroySubcontext(sDn);
        }
    }

    private void buildVosGraph(HashMap<String, Vector<String>> minAoa,
                               String sUserId, String sUserName, String sSessId) {
        Attributes attrs;
        String sConnNewId;
        String sPcNewId;
        String sOamNewId;
        String sOaNewId;

        // The id of the node used as direct descendant of a visible node.
        // It is not necessarily the true descendant of the visible node.
        // The visible portions of a branch may have invisible gaps between
        // them.

        try {
            // First delete all records for the session.
            deleteVosRecords(sSessId);

            // Build connector node.
            attrs = new BasicAttributes(true);
            attrs.put("objectClass", sVosNodeClass);
            RandomGUID myGUID = new RandomGUID();
            sConnNewId = myGUID.toStringNoDashes();
            attrs.put("pmId", sConnNewId);
            // attrs.put("pmId", PM_CONNECTOR_ID);
            attrs.put("pmOriginalId", PM_CONNECTOR_ID);
            attrs.put("pmOriginalName", PM_CONNECTOR_NAME);
            attrs.put("pmUserId", sUserId);
            attrs.put("pmUserName", sUserName);
            attrs.put("pmObjClass", sConnectorClass);
            attrs.put("pmIsObj", "FALSE");
            attrs.put("pmSessId", sSessId);
            ctx.bind("CN=" + sConnNewId + "," + sVosNodeContainerDN, null,
                    attrs);
            // System.out.println("***Built connector node " + PM_CONNECTOR_NAME
            // + "(" + sConnNewId + ")");

            // Build nodes for policy classes.
            HashSet<String> visitedSet = new HashSet<String>();
            ArrayList<VosQueueElement> queue = new ArrayList<VosQueueElement>();
            VosQueueElement qe, crtQe;

            Set<String> keyset = minAoa.keySet();
            Iterator<String> iter = keyset.iterator();
            // For each policy class pc:
            while (iter.hasNext()) {
                String sPcId = iter.next();
                String sPcName = getEntityName(sPcId, PM_NODE_POL);

                // Build the policy class node and the relation pc->pm:
                attrs = new BasicAttributes(true);
                attrs.put("objectClass", sVosNodeClass);
                myGUID = new RandomGUID();
                sPcNewId = myGUID.toStringNoDashes();
                attrs.put("pmId", sPcNewId);
                attrs.put("pmOriginalId", sPcId);
                attrs.put("pmOriginalName", sPcName);
                attrs.put("pmUserId", sUserId);
                attrs.put("pmUserName", sUserName);
                attrs.put("pmObjClass", sPolicyClass);
                attrs.put("pmIsObj", "FALSE");
                attrs.put("pmSessId", sSessId);
                ctx.bind("CN=" + sPcNewId + "," + sVosNodeContainerDN, null,
                        attrs);
                // System.out.println("***Built policy node " + sPcName + "(" +
                // sPcNewId + ")");

                if (!addVosDoubleLink(sPcNewId, sConnNewId)) {
                    System.out.println("Error when setting links policy class - connector");
                    return;
                }

                // Get the set MinAOA(u,pc):
                Vector<String> v = minAoa.get(sPcId);
                // For each oam in MinAOA(u,pc):
                for (int i = 0; i < v.size(); i++) {
                    String sOamId = (String) v.elementAt(i);
                    String sOamName = getEntityName(sOamId, PM_NODE_OATTR);

                    // If oam is visible:
                    if (attrIsVisible(sOamId, sPcId, minAoa)) {
                        // Note that even a minimal node may have been already
                        // visited.
                        if (!visitedSet.contains(sOamId)) {
                            // Put oam in the queue together with itself as
                            // descendant of its
                            // direct ascendants, because it is visible:
                            // Mark it as visited:
                            visitedSet.add(sOamId);

                            // Create node for oam:
                            attrs = new BasicAttributes(true);
                            attrs.put("objectClass", sVosNodeClass);
                            myGUID = new RandomGUID();
                            sOamNewId = myGUID.toStringNoDashes();
                            attrs.put("pmId", sOamNewId);
                            attrs.put("pmOriginalId", sOamId);
                            attrs.put("pmOriginalName", sOamName);
                            attrs.put("pmUserId", sUserId);
                            attrs.put("pmUserName", sUserName);
                            attrs.put("pmObjClass", sObjAttrClass);
                            if (hasAssocObj(sOamId)) {
                                attrs.put("pmIsObj", "TRUE");
                            } else {
                                attrs.put("pmIsObj", "FALSE");
                            }
                            attrs.put("pmSessId", sSessId);
                            ctx.bind("CN=" + sOamNewId + ","
                                    + sVosNodeContainerDN, null, attrs);
                            // System.out.println("***Built min attribute node "
                            // + sOamName + "(" + sOamNewId + ")");

                            // Add a record for oam in the queue:
                            crtQe = new VosQueueElement(sOamId, sOamNewId);
                            queue.add(crtQe);
                        }
                        // Create double link oam->pc (between new ids). I know
                        // pc's new id,
                        // but not oam's new id (unless it was just created
                        // before).
                        // So, search for it:
                        sOamNewId = getVosNodeId(sOamId, sSessId);
                        if (!addVosDoubleLink(sOamNewId, sPcNewId)) {
                            System.out.println("Error when setting links object attribute - policy class");
                            return;
                        }
                    } else { // oam is NOT visible:
                        if (!visitedSet.contains(sOamId)) {
                            // Put oam in the queue together with pc as
                            // descendant of its
                            // direct ascendants, because it is NOT visible:
                            crtQe = new VosQueueElement(sOamId, sPcNewId);
                            queue.add(crtQe);
                            // Mark it as visited:
                            visitedSet.add(sOamId);
                        }
                    }

                    // While queue is not empty
                    while (!queue.isEmpty()) {
                        // Extract first element {crtoa, crtdesc} from the
                        // queue:
                        crtQe = queue.remove(0);
                        String sCrtOaId = crtQe.getId();
                        String sCrtDescId = crtQe.getDesc();
                        String sCrtOaName = getEntityName(sCrtOaId,
                                PM_NODE_OATTR);

                        if (debugFlag) {
                            System.out.println("Out of queue: " + sCrtOaName
                                    + "(" + sCrtOaId + "), " + sCrtDescId);
                        }
                        // For each direct ascendant oa of crtoa:
                        Attribute attr = getFromAttrs(sCrtOaId, PM_NODE_OATTR);
                        if (attr != null) {
                            for (NamingEnumeration<?> attrEnum = attr.getAll(); attrEnum.hasMore(); ) {
                                String sOaId = (String) attrEnum.next();
                                String sOaName = getEntityName(sOaId,
                                        PM_NODE_OATTR);
                                // System.out.println("***Processing direct ascendant: "
                                // + sOaName + "(" + sOaId + ")");
                                // If oa is visible and NOT to be ignored in
                                // VOS:
                                if (attrIsVisible(sOaId, sPcId, minAoa)
                                        && !ignoreOattrInVos(sOaId)) {
                                    if (!visitedSet.contains(sOaId)) {
                                        visitedSet.add(sOaId);
                                        // Create node oa:
                                        attrs = new BasicAttributes(true);
                                        attrs.put("objectClass", sVosNodeClass);
                                        myGUID = new RandomGUID();
                                        sOaNewId = myGUID.toStringNoDashes();
                                        attrs.put("pmId", sOaNewId);
                                        attrs.put("pmOriginalId", sOaId);
                                        attrs.put("pmOriginalName", sOaName);
                                        attrs.put("pmUserId", sUserId);
                                        attrs.put("pmUserName", sUserName);
                                        attrs.put("pmObjClass", sObjAttrClass);
                                        if (hasAssocObj(sOaId)) {
                                            attrs.put("pmIsObj", "TRUE");
                                        } else {
                                            attrs.put("pmIsObj", "FALSE");
                                        }
                                        attrs.put("pmSessId", sSessId);
                                        ctx.bind("CN=" + sOaNewId + ","
                                                + sVosNodeContainerDN, null,
                                                attrs);
                                        // System.out.println("***Built attribute node "
                                        // + sOaName + "(" + sOaNewId + ")");

                                        // Because oa is visible, it will be
                                        // displayed, and its direct
                                        // ascendants will be pointing down to
                                        // it:
                                        qe = new VosQueueElement(sOaId,
                                                sOaNewId);
                                        queue.add(qe);
                                    }

                                    // Create double link oa->crtdesc (between
                                    // new ids). Crtdesc
                                    // is already a new id (it was obtained from
                                    // the queue).
                                    // But I don't know oa's new id (unless it
                                    // was just created before).
                                    // So, search for it:
                                    sOaNewId = getVosNodeId(sOaId, sSessId);
                                    if (!addVosDoubleLink(sOaNewId, sCrtDescId)) {
                                        System.out.println("Error when setting links object attribute - object attribute");
                                        return;
                                    }
                                } else {// oa is not visible.
                                    if (!visitedSet.contains(sOaId)) {
                                        // Because oa is not visible, its
                                        // ascendants
                                        // will be linked down to the crt. desc:
                                        qe = new VosQueueElement(sOaId,
                                                sCrtDescId);
                                        queue.add(qe);
                                        visitedSet.add(sOaId);
                                    }
                                }
                            }
                        }
                    }// while queue not empty
                }// for each oam
            }// for each pc
        } catch (Exception e) {
            if (debugFlag) {
                e.printStackTrace();
            }
            System.out.println("Error while building VOS graph");
            return;
        }
    }

    // Returns true = success.
    private boolean addVosDoubleLink(String sId1, String sId2) {
        ModificationItem[] mods = new ModificationItem[1];

        mods[0] = new ModificationItem(DirContext.ADD_ATTRIBUTE,
                new BasicAttribute("pmDescNode", sId2));
        try {
            ctx.modifyAttributes("CN=" + sId1 + "," + sVosNodeContainerDN, mods);
        } catch (Exception e) {
            if (debugFlag) {
                e.printStackTrace();
            }
            return false;
        }
        mods[0] = new ModificationItem(DirContext.ADD_ATTRIBUTE,
                new BasicAttribute("pmAscNode", sId1));
        try {
            ctx.modifyAttributes("CN=" + sId2 + "," + sVosNodeContainerDN, mods);
        } catch (Exception e) {
            if (debugFlag) {
                e.printStackTrace();
            }
            return false;
        }
        return true;
    }

    // Returns whether object attribute oa is visible by the user u for which
    // {MinAOA(u,pc)| pc in PC} has been computed.
    // Attribute oa is not arbitrary. There must be a policy class pc and an
    // object attribute oam in MinAOA(u,pc) such that oa ->* oam.
    // Attribute oa is visible by user u iff there is no pc' != pc such
    // that ((oa ->+ pc') and (there is no oam' in MinAOA(u,pc') with
    // oa->*oam')).
    // sOaId is the id of oa.
    // sPcId is the id of pc.
    // Each entry in hm has a pc as key and MinAOA(u,pc) (as a vector) as value.
    private boolean attrIsVisible(String sOaId, String sPcId,
                                  HashMap<String, Vector<String>> hm) {
        // Try to find pc' != pc such that oa ->+ pc'. Use the hm keys to get
        // pc'.
        Set<String> keyset = hm.keySet();
        Iterator<String> iter = keyset.iterator();
        while (iter.hasNext()) {
            String sPcIdPrim = iter.next();
            if (sPcIdPrim.equals(sPcId)) {
                continue;
            }
            if (!attrIsAscendantToPolicy(sOaId, PM_NODE_OATTR, sPcIdPrim)) {
                continue;
            }
            // The vector MinAOA(u,pc'):
            Vector<String> v = hm.get(sPcIdPrim);
            // Looking for a oam' such that oa ->* oam'.
            // If we don't find one, then oa is not visible.
            boolean foundOaPrim = false;
            for (int i = 0; i < v.size(); i++) {
                String sOaIdPrim = (String) v.elementAt(i);
                if (attrIsAscendant(sOaId, sOaIdPrim, PM_NODE_OATTR)) {
                    foundOaPrim = true;
                    break;
                }
            }
            if (!foundOaPrim) {
                return false;
            }
        }
        return true;
    }

    private Packet deleteHost(String sSessId, String sHostId) {
        try {
            ctx.destroySubcontext("CN=" + sHostId + "," + sHostContainerDN);
        } catch (Exception e) {
            if (debugFlag) {
                e.printStackTrace();
            }
            return failurePacket("Could not delete host with id " + sHostId);
        }
        return successPacket();
    }

    private Packet updateHost(String sSessId, String sHostId, String sHost,
                              String sRepo, String sIpa, String sDescr, String sPdc) {
        // Check permissions...

        // Test that the host id exists.
        String s = getEntityName(sHostId, PM_HOST);
        if (s == null) {
            return failurePacket("No host with id " + sHostId);
        }

        // Convert the boolean to upper case.
        sPdc = sPdc.toUpperCase();

        // Prepare the attributes to be updated.
        ModificationItem[] mods = new ModificationItem[5];

        System.out.println("pmName=" + sHost);
        System.out.println("pmPath=" + sRepo);
        System.out.println("pmIsDomController=" + sPdc);
        System.out.println("pmDescription=" + sDescr);
        System.out.println("pmIpAddress=" + sIpa);

        mods[0] = new ModificationItem(DirContext.REPLACE_ATTRIBUTE,
                new BasicAttribute("pmName", sHost));
        mods[1] = new ModificationItem(DirContext.REPLACE_ATTRIBUTE,
                new BasicAttribute("pmPath", sRepo));
        mods[2] = new ModificationItem(DirContext.REPLACE_ATTRIBUTE,
                new BasicAttribute("pmIsDomController", sPdc));
        mods[3] = new ModificationItem(DirContext.REPLACE_ATTRIBUTE,
                new BasicAttribute("pmDescription", sDescr));
        mods[4] = new ModificationItem(DirContext.REPLACE_ATTRIBUTE,
                new BasicAttribute("pmIpAddress", sIpa));
        try {
            ctx.modifyAttributes("CN=" + sHostId + "," + sHostContainerDN, mods);
        } catch (Exception e) {
            if (debugFlag) {
                e.printStackTrace();
            }
            return failurePacket("Couldn't update host with id " + sHostId);
        }
        Packet res = new Packet();
        try {
            res.addItem(ItemType.RESPONSE_TEXT, sHost + PM_FIELD_DELIM
                    + sHostId);
        } catch (Exception e) {
            e.printStackTrace();
            return failurePacket("Exception when updating the host: "
                    + e.getMessage());
        }
        return res;
    }

    private Packet addHost(String sSessId, String sHost, String sRepo,
                           String sReserved, String sIpa, String sDescr, String sPdc) {
        // Check permissions...

        // Test if duplicate name.
        if (entityNameExists(sHost, PM_HOST)) {
            return failurePacket("Duplicate host name!");
        }
        // Test whether the attributes are valid.
        if (sHost == null || sHost.length() == 0) {
            return failurePacket("Null host name!");
        }
        if (!hostNameIsValid(sHost)) {
            return failurePacket("Invalid host name!");
        }
        if (sRepo == null || sRepo.length() == 0) {
            return failurePacket("Null repository path!");
        }
        if (sDescr == null || sDescr.length() == 0) {
            return failurePacket("Null description!");
        }
        if (!sPdc.equalsIgnoreCase("true") && !sPdc.equalsIgnoreCase("false")) {
            return failurePacket("Non-boolean isPDController!");
        }

        // Prepare the attributes of the new host object.
        Attributes attrs = new BasicAttributes(true);
        RandomGUID myGUID = new RandomGUID();
        String sId = myGUID.toStringNoDashes();
        // Mandatory
        attrs.put("objectClass", sHostClass);
        attrs.put("pmId", sId);
        attrs.put("pmName", sHost);
        attrs.put("pmPath", sRepo);
        //attrs.put("pmCgiName", "Ignored.");
        attrs.put("pmDescription", sDescr);
        attrs.put("pmOtherInfo", "None.");
        //attrs.put("pmVirtualDir", "Ignored.");
        if (sIpa != null && sIpa.length() > 0) {
            attrs.put("pmIpAddress", sIpa);
        }
        attrs.put("pmIsDomController", sPdc.toUpperCase());

        // Create the record
        try {
            ctx.bind("CN=" + sId + "," + sHostContainerDN, null, attrs);
        } catch (InvalidNameException e) {
            if (debugFlag) {
                e.printStackTrace();
            }
            return failurePacket("Invalid name " + sHost);
        } catch (NameAlreadyBoundException e) {
            if (debugFlag) {
                e.printStackTrace();
            }
            return failurePacket("Duplicate name " + sHost);
        } catch (Exception e) {
            if (debugFlag) {
                e.printStackTrace();
            }
            return failurePacket("Probably invalid name " + sHost);
            // E.g.: "a/b" raises a NamingException with DIR_ERROR in JNDI
        }

        Packet res = new Packet();
        try {
            res.addItem(ItemType.RESPONSE_TEXT, sHost + PM_FIELD_DELIM + sId);
        } catch (Exception e) {
            e.printStackTrace();
            return failurePacket("Exception when adding host: "
                    + e.getMessage());
        }
        return res;
    }

    // Get all hosts. Each item has the format: <host name>:<host id>.
    private Packet getHosts(String sClientId) throws Exception {
        Packet res = new Packet();
        NamingEnumeration<?> hosts;

        try {
            SearchControls constraints = new SearchControls();
            constraints.setSearchScope(SearchControls.ONELEVEL_SCOPE);
            constraints.setReturningAttributes(new String[]{"pmId", "pmName"});
            hosts = ctx.search(sHostContainerDN, "(objectClass=*)", constraints);
        } catch (CommunicationException e) {
            if (debugFlag) {
                e.printStackTrace();
            }
            return failurePacket("AD connection error");
        } catch (Exception e) {
            if (debugFlag) {
                e.printStackTrace();
            }
            return failurePacket("Exception: " + e.getMessage());
        }

        while (hosts != null && hosts.hasMore()) {
            SearchResult sr = (SearchResult) hosts.next();
            String sName = (String) sr.getAttributes().get("pmName").get();
            String sId = (String) sr.getAttributes().get("pmId").get();
            res.addItem(ItemType.RESPONSE_TEXT, sName + PM_FIELD_DELIM + sId);
        }
        return res;
    }

    private Packet getHostInfo(String sSessId, String sHostId) {
        Packet res = new Packet();
        Attributes attrs;
        String sIsPdc, sName, sRepoPath;

        try {
            attrs = ctx.getAttributes("CN=" + sHostId + "," + sHostContainerDN);

            // First insert the name, id, and pdc.
            sName = (String) attrs.get("pmName").get();
            sIsPdc = (String) attrs.get("pmIsDomController").get();
            res.addItem(ItemType.RESPONSE_TEXT, sName + PM_FIELD_DELIM
                    + sHostId + PM_FIELD_DELIM + sIsPdc);

            // Now the repository path.
            sRepoPath = (String) attrs.get("pmPath").get();
            res.addItem(ItemType.RESPONSE_TEXT, sRepoPath);
        } catch (Exception e) {
            e.printStackTrace();
            return failurePacket("Exception in getHostInfo(): "
                    + e.getMessage());
        }
        return res;
    }

    // First empty almost all containers. Exceptions:
    // The HostContainer, the NameContainer.
    // Also, do not delete the current session in which the Admin Tool is
    // executing.
    private Packet reset(String sClientId, String sSessId) {
        try {
            emptyContainer(sUserContainerDN, null);
            emptyContainer(sEmailAcctContainerDN, null);
            emptyContainer(sUserAttrContainerDN, null);
            emptyContainer(sUserConfigContainerDN, null);
            emptyContainer(sPolicyContainerDN, null);
            emptyContainer(sObjAttrContainerDN, null);
            emptyContainer(sOpsetContainerDN, null);
            emptyContainer(sOsConfigContainerDN, null);
            emptyContainer(sVirtualObjContainerDN, null);
            emptyContainer(sVosNodeContainerDN, null);
            emptyContainer(sAdminVosNodeContainerDN, null);
            emptyContainer(sConnectorContainerDN, null);
            emptyContainer(sSessionContainerDN, sSessId);
            emptyContainer(sObjClassContainerDN, null);
            emptyContainer(sEventContainerDN, null);
            emptyContainer(sAttrSetContainerDN, null);
            emptyContainer(sSacContainerDN, null);
            emptyContainer(sDenyContainerDN, null);
            emptyContainer(sRuleContainerDN, null);
            emptyContainer(sTaskContainerDN, null);
            emptyContainer(sSconContainerDN, null);
            emptyContainer(sSconaContainerDN, null);
            emptyContainer(sTemplateContainerDN, null);
            emptyContainer(sPropertyContainerDN, null);
        } catch (Exception e) {
            if (debugFlag) {
                e.printStackTrace();
            }
            return failurePacket("Exception when emptying the database: "
                    + e.getMessage());
        }

        createInitialObjects();
        return successPacket();
    }

    private void emptyContainer(String sContainerDn, String sExceptedId) {
        // System.out.println("Flushing container " + sContainerDn);
        NamingEnumeration<?> members;
        //String sDn;

        try {
            SearchControls constraints = new SearchControls();
            constraints.setSearchScope(SearchControls.ONELEVEL_SCOPE);
            constraints.setReturningAttributes(new String[]{"pmId"});
            members = ctx.search(sContainerDn, "(objectClass=*)", constraints);
            while (members != null && members.hasMore()) {
                SearchResult sr = (SearchResult) members.next();
                String sName = sr.getName();
                if (sExceptedId != null) {
                    Attribute attr = sr.getAttributes().get("pmId");
                    if (attr != null) {
                        String sId = (String) attr.get();
                        if (sExceptedId.equals(sId)) {
                            continue;
                        }
                    }
                }
                ctx.destroySubcontext(sName + "," + sContainerDn);
            }
        } catch (Exception e) {
            if (debugFlag) {
                e.printStackTrace();
            }
        }
    }

    // Cannot delete object attributes associated to objects -
    // you have to delete the object.
    private Packet deleteNode(String sSessId, String sId, String sType,
                              String sIsVos) {
    	System.out.println("============================= sType = " + sType + " ========================================");
        if (sIsVos.equalsIgnoreCase("yes")) {
            sId = getAdminVosNodeOrigId(sId);
        }

        if (sType.equalsIgnoreCase(PM_NODE_USER)) {
            return deleteUser(sSessId, sId);
        } else if (sType.equalsIgnoreCase(PM_NODE_UATTR)) {
            return deleteUattr(sSessId, sId);
        } else if (sType.equalsIgnoreCase(PM_NODE_POL)) {
            return deletePolicyClass(sSessId, sId);
        } else if (sType.equalsIgnoreCase(PM_NODE_OATTR)
                || sType.equalsIgnoreCase(PM_NODE_ASSOC)) {
            return deleteOattr(sSessId, sId, true); // true means verify no
        } // opsets assigned to it.
        else if (sType.equalsIgnoreCase(PM_NODE_OPSET)) {
            return deleteOpset(sSessId, sId);
        } else {
            return failurePacket("This node cannot be deleted");
        }
    }

    // Delete an object attribute. It can be deleted only if it's not associated
    // to an object, and does not have ascendants.
    private Packet deleteOattr(String sSessId, String sIdToDelete,
                               boolean verifyOpsetsAndAssoc) {
        if (!entityExists(sIdToDelete, PM_NODE_OATTR)) {
            return failurePacket("No object attribute with id " + sIdToDelete);
        }
        if (attrHasAscendants(sIdToDelete, PM_NODE_OATTR)) {
            return failurePacket("Object attribute has ascendants");
        }
        if (verifyOpsetsAndAssoc && hasAssocObj(sIdToDelete)) {
            return failurePacket("Object attribute is associated to an object");
        }
        if (verifyOpsetsAndAssoc && attrHasOpsets(sIdToDelete, PM_NODE_OATTR)) {
            return failurePacket("An operation set is assigned to this object attribute");
        }

        // Delete the assignment this node ---> descendant attributes.
        Packet res;
        Attribute attr;
        String sId;

        try {
            attr = getToAttrs(sIdToDelete, PM_NODE_OATTR);
            if (attr != null) {
                for (NamingEnumeration<?> enumer = attr.getAll(); enumer.hasMore(); ) {
                    sId = (String) enumer.next();

                    // Now delete the assignment sIdToDelete (oattr) ---> sId
                    // (oattr).
                    res =  deleteDoubleLink(sIdToDelete, PM_NODE_OATTR,
                            sId, PM_NODE_OATTR);
                    if (res.hasError()) {
                        return res;
                    }
                }
            }
        } catch (Exception e) {
            if (debugFlag) {
                e.printStackTrace();
            }
            return failurePacket(e.getMessage());
        }

        // Get the policy classes this object attribute is assigned to and
        // delete the assignment.
        try {
            attr = getToPolicies(sIdToDelete, PM_NODE_OATTR);
            if (attr != null) {
                for (NamingEnumeration<?> enumer = attr.getAll(); enumer.hasMore(); ) {
                    sId = (String) enumer.next();

                    // Now delete the assignment sIdToDelete (oattr) ---> sId
                    // (policy class).
                    res =  deleteDoubleLink(sIdToDelete, PM_NODE_OATTR,
                            sId, PM_NODE_POL);
                    if (res.hasError()) {
                        return res;
                    }
                }
            }
        } catch (Exception e) {
            if (debugFlag) {
                e.printStackTrace();
            }
            return failurePacket(e.getMessage());
        }

        // If this attribute is assigned to the connector node, delete the
        // assignment.
        if (attrIsAssignedToConnector(sIdToDelete, PM_NODE_OATTR)) {
            // Now delete the assignment sIdToDelete (oattr) ---> Connector
            // node.
            res =  deleteDoubleLink(sIdToDelete, PM_NODE_OATTR,
                    PM_CONNECTOR_ID, PM_NODE_CONN);
            if (res.hasError()) {
                return res;
            }
        }

        // Destroy the object attribute PM object.
        try {
            ctx.destroySubcontext("CN=" + sIdToDelete + ","
                    + sObjAttrContainerDN);
        } catch (Exception e) {
            if (debugFlag) {
                e.printStackTrace();
            }
            return failurePacket("Could not delete object attribute "
                    + sIdToDelete);
        }

        return successPacket();
    }

    // Called for the "deleteNode" command, triggered when the user right-clicks
    // on the opset and selects the "delete node" popup menu.
    private Packet deleteOpset(String sClientId, String sIdToDelete) {
        return deleteOpsetAndOp(sClientId, sIdToDelete, null);
    }

    // Delete a PM user. Just delete all its assignments
    // to user attributes, delete its assignment to the connector node
    // if it's assigned, and delete the user object.
    private Packet deleteUser(String sSessId, String sIdToDelete) {
        // Get user attributes (directly) assigned to the user we want to
        // delete.
        Packet res;
        try {
            Attribute attr = getToAttrs(sIdToDelete, PM_NODE_USER);
            if (attr != null) {
                for (NamingEnumeration<?> enumer = attr.getAll(); enumer.hasMore(); ) {
                    String sId = (String) enumer.next();

                    // Now delete the assignment sIdToDelete (user) ---> sId
                    // (uattr).
                    res =  deleteDoubleLink(sIdToDelete, PM_NODE_USER,
                            sId, PM_NODE_UATTR);
                    if (res.hasError()) {
                        return res;
                    }
                }
            }
        } catch (Exception e) {
            if (debugFlag) {
                e.printStackTrace();
            }
            return failurePacket(e.getMessage());
        }

        // If this user is assigned to the connector node, delete the
        // assignment.
        if (userIsAssignedToConnector(sIdToDelete)) {
            res =  deleteDoubleLink(sIdToDelete, PM_NODE_USER,
                    PM_CONNECTOR_ID, PM_NODE_CONN);
            if (res.hasError()) {
                return res;
            }
        }

        // Now delete the user object.
        try {
            ctx.destroySubcontext("CN=" + sIdToDelete + "," + sUserContainerDN);
        } catch (Exception e) {
            if (debugFlag) {
                e.printStackTrace();
            }
            return failurePacket("Could not delete user " + sIdToDelete);
        }
        return successPacket();
    }

    // Delete a user attribute. We can delete it only if it's isolated, i.e., no
    // node is
    // assigned to it (it has no ascendants).
    private Packet deleteUattr(String sClientId, String sIdToDelete) {
        if (!entityExists(sIdToDelete, PM_NODE_UATTR)) {
            return failurePacket("No user attribute with id " + sIdToDelete);
        }
        if (attrHasAscendants(sIdToDelete, PM_NODE_UATTR)) {
            return failurePacket("User attribute has ascendants");
        }
        if (attrHasOpsets(sIdToDelete, PM_NODE_UATTR)) {
            return failurePacket("User attribute is assigned to operation sets");
        }

        // Get user attributes this user attribute is assigned to and delete the
        // assignment.
        Packet res;
        Attribute attr;
        String sId;

        try {
            attr = getToAttrs(sIdToDelete, PM_NODE_UATTR);
            if (attr != null) {
                for (NamingEnumeration<?> enumer = attr.getAll(); enumer.hasMore(); ) {
                    sId = (String) enumer.next();

                    // Now delete the assignment sIdToDelete (uattr) ---> sId
                    // (uattr).
                    res =  deleteDoubleLink(sIdToDelete, PM_NODE_UATTR,
                            sId, PM_NODE_UATTR);
                    if (res.hasError()) {
                        return res;
                    }
                }
            }
        } catch (Exception e) {
            if (debugFlag) {
                e.printStackTrace();
            }
            return failurePacket(e.getMessage());
        }

        // Get policy classes this user attribute is assigned to and delete the
        // assignment.
        try {
            attr = getToPolicies(sIdToDelete, PM_NODE_UATTR);
            if (attr != null) {
                for (NamingEnumeration<?> enumer = attr.getAll(); enumer.hasMore(); ) {
                    sId = (String) enumer.next();

                    // Now delete the assignment sIdToDelete (uattr) ---> sId
                    // (policy class).
                    res =  deleteDoubleLink(sIdToDelete, PM_NODE_UATTR,
                            sId, PM_NODE_POL);
                    if (res.hasError()) {
                        return res;
                    }
                }
            }
        } catch (Exception e) {
            if (debugFlag) {
                e.printStackTrace();
            }
            return failurePacket(e.getMessage());
        }

        // If this attribute is assigned to the connector node, delete the back
        // link
        // in the connector (there is no need to fully delete the assignment
        // because
        // the attribute will be destroyed).
        if (attrIsAssignedToConnector(sIdToDelete, PM_NODE_UATTR)) {
            // Now delete the assignment sIdToDelete (uattr) ---> Connector
            // node.
            res =  deleteDoubleLink(sIdToDelete, PM_NODE_UATTR,
                    PM_CONNECTOR_ID, PM_NODE_CONN);
            if (res.hasError()) {
                return res;
            }
        }

        // Destroy the user attribute object.
        try {
            ctx.destroySubcontext("CN=" + sIdToDelete + ","
                    + sUserAttrContainerDN);
        } catch (Exception e) {
            if (debugFlag) {
                e.printStackTrace();
            }
            return failurePacket("Could not delete user attribute "
                    + sIdToDelete);
        }

        return successPacket();
    }

    // Delete the assignment between two nodes of the graph at the user request.
    // The assignments that can be deleted are:
    // user ---> user attribute
    // user attribute ---> user attribute
    // user attribute ---> policy class
    // user attribute ---> operation set
    // object attribute ---> object attribute
    // object attribute ---> policy class
    // operation set ---> object attribute.
    // The assignments to the connector node cannot be deleted (or created)
    // explicitly by the administrator.
    // NOTE. The methods for deleting the assignment between specific types of
    // nodes,
    // like deleteAssgnUserUattr below do more than just delete the double link
    // between the nodes (for example, deleteAssgnUserUattr may also link the
    // user
    // to the connector node). If you just need to delete the double link, use
    // the deleteDoubleLink() method.
    private Packet deleteAssignment(String sSessId, String sProcId,
                                    String sId1, String sType1, String sId2, String sType2,
                                    String sIsAdminVos) {

        if (sIsAdminVos.equalsIgnoreCase("yes")) {
            sId1 = getAdminVosNodeOrigId(sId1);
            sId2 = getAdminVosNodeOrigId(sId2);
        }

        // Check permissions.
        // ...

        // Call the internal function.
        return deleteAssignmentInternal(sId1, sType1, sId2, sType2);
    }

    private Packet deleteAssignmentInternal(String sId1, String sType1,
                                            String sId2, String sType2) {
        if (sType1.equalsIgnoreCase(PM_NODE_USER)
                && sType2.equalsIgnoreCase(PM_NODE_UATTR)) {
            return deleteAssgnUserUattr(sId1, sId2);
        } else if (sType1.equalsIgnoreCase(PM_NODE_UATTR)
                && sType2.equalsIgnoreCase(PM_NODE_UATTR)) {
            return deleteAssgnUattrUattr(sId1, sId2);
        } else if (sType1.equalsIgnoreCase(PM_NODE_UATTR)
                && sType2.equalsIgnoreCase(PM_NODE_POL)) {
            return deleteAssgnUattrPolicy(sId1, sId2);
        } else if (sType1.equalsIgnoreCase(PM_NODE_UATTR)
                && sType2.equalsIgnoreCase(PM_NODE_OPSET)) {
            return deleteAssgnUattrOpset(sId1, sId2);
        } else if ((sType1.equalsIgnoreCase(PM_NODE_OATTR) || sType1.equalsIgnoreCase(PM_NODE_ASSOC))
                && sType2.equalsIgnoreCase(PM_NODE_OATTR)) {
            return deleteAssgnOattrOattr(sId1, sId2);
        } else if ((sType1.equalsIgnoreCase(PM_NODE_OATTR) || sType1.equalsIgnoreCase(PM_NODE_ASSOC))
                && sType2.equalsIgnoreCase(PM_NODE_POL)) {
            return deleteAssgnOattrPolicy(sId1, sId2);
        } else if (sType1.equalsIgnoreCase(PM_NODE_OPSET)
                && (sType2.equalsIgnoreCase(PM_NODE_OATTR) || sType2.equalsIgnoreCase(PM_NODE_ASSOC))) {
            return deleteAssgnOpsetOattr(sId1, sId2);
        }
        return failurePacket("The assignment cannot be deleted or does not exist");
    }

    private Packet addDoubleLink(String sId1, String sType1, String sId2,
                                 String sType2) {
        String sCont1, sCont2;
        String sAttr1, sAttr2;
        String sDn;
        ModificationItem[] mods = new ModificationItem[1];

        if (sType1.equalsIgnoreCase(PM_NODE_USER)) {
            sCont1 = sUserContainerDN;
            sAttr2 = "pmFromUser";
        } else if (sType1.equalsIgnoreCase(PM_NODE_UATTR)) {
            sCont1 = sUserAttrContainerDN;
            if (sType2.equalsIgnoreCase(PM_NODE_UATTR)
                    || sType2.equalsIgnoreCase(PM_NODE_OPSET)) {
                sAttr2 = "pmFromAttr";
            } else {
                sAttr2 = "pmFromUserAttr";
            }
        } else if (sType1.equalsIgnoreCase(PM_NODE_POL)) {
            sCont1 = sPolicyContainerDN;
            sAttr2 = "pmFromPolicyClass";
        } else if (sType1.equalsIgnoreCase(PM_NODE_OPSET)) {
            sCont1 = sOpsetContainerDN;
            sAttr2 = "pmFromOpSet";
        } else if (sType1.equalsIgnoreCase(PM_NODE_OATTR)) {
            sCont1 = sObjAttrContainerDN;
            if (sType2.equalsIgnoreCase(PM_NODE_OATTR)) {
                sAttr2 = "pmFromAttr";
            } else {
                sAttr2 = "pmFromObjAttr";
            }
        } else {
            return failurePacket("Incorrect first node type");
        }

        if (sType2.equalsIgnoreCase(PM_NODE_UATTR)) {
            sCont2 = sUserAttrContainerDN;
            sAttr1 = "pmToAttr";
        } else if (sType2.equalsIgnoreCase(PM_NODE_POL)) {
            sCont2 = sPolicyContainerDN;
            sAttr1 = "pmToPolicy";
        } else if (sType2.equalsIgnoreCase(PM_NODE_OPSET)) {
            sCont2 = sOpsetContainerDN;
            sAttr1 = "pmToOpSet";
        } else if (sType2.equalsIgnoreCase(PM_NODE_OATTR)) {
            sCont2 = sObjAttrContainerDN;
            sAttr1 = "pmToAttr";
        } else if (sType2.equalsIgnoreCase(PM_NODE_CONN)) {
            sCont2 = sConnectorContainerDN;
            sAttr1 = "pmToConnector";
        } else {
            return failurePacket("Incorrect second node type");
        }

        sDn = "CN=" + sId1 + "," + sCont1;
        mods[0] = new ModificationItem(DirContext.ADD_ATTRIBUTE,
                new BasicAttribute(sAttr1, sId2));
        try {
            ctx.modifyAttributes(sDn, mods);
        } catch (Exception e) {
            if (debugFlag) {
                e.printStackTrace();
            }
            return failurePacket("Couldn't add direct link between nodes");
        }
        sDn = "CN=" + sId2 + "," + sCont2;
        mods[0] = new ModificationItem(DirContext.ADD_ATTRIBUTE,
                new BasicAttribute(sAttr2, sId1));
        try {
            ctx.modifyAttributes(sDn, mods);
        } catch (Exception e) {
            if (debugFlag) {
                e.printStackTrace();
            }
            return failurePacket("Couldn't add back link between nodes");
        }
        return successPacket();
    }

    private Packet testDoubleLink() {
        String sCont2;
        String sAttr2;
        String sDn;
        ModificationItem[] mods = new ModificationItem[1];

        String sId2 = getEntityId("gavrila INBOX", PM_NODE_OATTR);
        sAttr2 = "pmFromAttr";
        sCont2 = sObjAttrContainerDN;

        for (int i = 0; i < 1000; i++) {
            String sId1 = "id" + (i + 1);

            System.out.println("Adding value " + sId1);

            sDn = "CN=" + sId2 + "," + sCont2;
            mods[0] = new ModificationItem(DirContext.ADD_ATTRIBUTE,
                    new BasicAttribute(sAttr2, sId1));
            try {
                ctx.modifyAttributes(sDn, mods);
            } catch (Exception e) {
                if (debugFlag) {
                    e.printStackTrace();
                }
                return failurePacket("Couldn't add back link between nodes");
            }
        }
        return successPacket();
    }

    private Packet deleteDoubleLink(String sId1, String sType1, String sId2,
                                    String sType2) {

        System.out.println(sId1 + "," + sType1 + ":" + sId2 + "," + sType2);

        String sCont1, sCont2;
        String sAttr1, sAttr2;
        String sDn;

        ModificationItem[] mods = new ModificationItem[1];

        if (sType1.equalsIgnoreCase(PM_NODE_USER)) {
            sCont1 = sUserContainerDN;
            sAttr2 = "pmFromUser";
        } else if (sType1.equalsIgnoreCase(PM_NODE_UATTR)) {
            sCont1 = sUserAttrContainerDN;
            if (sType2.equalsIgnoreCase(PM_NODE_UATTR)
                    || sType2.equalsIgnoreCase(PM_NODE_OPSET)) {
                sAttr2 = "pmFromAttr";
            } else {
                sAttr2 = "pmFromUserAttr";
            }
        } else if (sType1.equalsIgnoreCase(PM_NODE_POL)) {
            sCont1 = sPolicyContainerDN;
            sAttr2 = "pmFromPolicyClass";
        } else if (sType1.equalsIgnoreCase(PM_NODE_OPSET)) {
            sCont1 = sOpsetContainerDN;
            sAttr2 = "pmFromOpSet";
        } else if (sType1.equalsIgnoreCase(PM_NODE_OATTR)) {
            sCont1 = sObjAttrContainerDN;
            if (sType2.equalsIgnoreCase(PM_NODE_OATTR)) {
                sAttr2 = "pmFromAttr";
            } else {
                sAttr2 = "pmFromObjAttr";
            }
        } else {
            return failurePacket("Incorrect first node type");
        }

        if (sType2.equalsIgnoreCase(PM_NODE_UATTR)) {
            sCont2 = sUserAttrContainerDN;
            sAttr1 = "pmToAttr";
        } else if (sType2.equalsIgnoreCase(PM_NODE_POL)) {
            sCont2 = sPolicyContainerDN;
            sAttr1 = "pmToPolicy";
        } else if (sType2.equalsIgnoreCase(PM_NODE_OPSET)) {
            sCont2 = sOpsetContainerDN;
            sAttr1 = "pmToOpSet";
        } else if (sType2.equalsIgnoreCase(PM_NODE_OATTR)) {
            sCont2 = sObjAttrContainerDN;
            sAttr1 = "pmToAttr";
        } else if (sType2.equalsIgnoreCase(PM_NODE_CONN)) {
            sCont2 = sConnectorContainerDN;
            sAttr1 = "pmToConnector";
        } else {
            return failurePacket("Incorrect second node type");
        }

        sDn = "CN=" + sId1 + "," + sCont1;
        mods[0] = new ModificationItem(DirContext.REMOVE_ATTRIBUTE,
                new BasicAttribute(sAttr1, sId2));
        try {
            System.out.println("Delete " + sAttr1 + "=" + sId2 + " in " + sDn);
            ctx.modifyAttributes(sDn, mods);
        } catch (Exception e) {
            if (debugFlag) {
                e.printStackTrace();
            }
            return failurePacket("Couldn't delete direct link between nodes");
        }
        sDn = "CN=" + sId2 + "," + sCont2;
        mods[0] = new ModificationItem(DirContext.REMOVE_ATTRIBUTE,
                new BasicAttribute(sAttr2, sId1));
        try {
            System.out.println("Delete " + sAttr2 + "=" + sId1 + " in " + sDn);
            ctx.modifyAttributes(sDn, mods);
        } catch (Exception e) {
            if (debugFlag) {
                e.printStackTrace();
            }
            return failurePacket("Couldn't delete back link between nodes");
        }
        return successPacket();
    }

    private Packet deleteAssgnUserUattr(String sId1, String sId2) {
        // Conditions: sId1 is assigned to sId2.
        if (!userIsAssigned(sId1, sId2)) {
            return failurePacket("Marked user is not assigned to this attribute");
        }

        // Delete the double link between the user sId1 and the attribute sId2.
        Packet res =  deleteDoubleLink(sId1, PM_NODE_USER, sId2,
                PM_NODE_UATTR);
        if (res.hasError()) {
            return res;
        }

        // If the user is not assigned to any other node, assign it to the
        // connector.
        if (userHasNoDescendant(sId1)) {
            res =  addDoubleLink(sId1, PM_NODE_USER, PM_CONNECTOR_ID,
                    PM_NODE_CONN);
            if (res.hasError()) {
                return res;
            }
        }
        setLastUpdateTimestamp();
        return successPacket("User assignment to attribute successfully deleted");
    }

    private Packet deleteAssgnUattrUattr(String sId1, String sId2) {
        // Conditions: sId1 is assigned to sId2.
        if (!attrIsAssignedToAttr(sId1, sId2, PM_NODE_UATTR)) {
            return failurePacket("The marked user attribute is not assigned to this attribute");
        }

        // Delete the double link between the user attributes sId1, sId2.
        Packet res =  deleteDoubleLink(sId1, PM_NODE_UATTR, sId2,
                PM_NODE_UATTR);
        if (res.hasError()) {
            return res;
        }

        // If the user attribute is not assigned to any other node, assign it to
        // the connector.
        if (!attrHasDescendants(sId1, PM_NODE_UATTR)) {
            res =  addDoubleLink(sId1, PM_NODE_UATTR, PM_CONNECTOR_ID,
                    PM_NODE_CONN);
            if (res.hasError()) {
                return res;
            }
        }
        setLastUpdateTimestamp();
        return successPacket("Attribute assignment successfully deleted");
    }

    private Packet deleteAssgnUattrPolicy(String sId1, String sId2) {
        // Conditions: sId1 is assigned to sId2.
        if (!attrIsAssignedToPolicy(sId1, PM_NODE_UATTR, sId2)) {
            return failurePacket("Marked user attribute is not assigned to this policy class");
        }

        // Delete the double link between the user attribute sId1 and policy
        // sId2.
        Packet res =  deleteDoubleLink(sId1, PM_NODE_UATTR, sId2,
                PM_NODE_POL);
        if (res.hasError()) {
            return res;
        }

        // If the user attribute is not assigned to any other node, assign it to
        // the connector.
        if (!attrHasDescendants(sId1, PM_NODE_UATTR)) {
            res =  addDoubleLink(sId1, PM_NODE_UATTR, PM_CONNECTOR_ID,
                    PM_NODE_CONN);
            if (res.hasError()) {
                return res;
            }
        }
        setLastUpdateTimestamp();
        return successPacket("Attribute assignment to policy successfully deleted");
    }

    private Packet deleteAssgnUattrOpset(String sId1, String sId2) {
        // Conditions: sId1 is assigned to sId2.
        if (!attrIsAssignedToOpset(sId1, sId2)) {
            return failurePacket("Marked user attribute is not assigned to this operation set");
        }

        // Delete the double link between the user attribute sId1 and opset
        // sId2.
        Packet res =  deleteDoubleLink(sId1, PM_NODE_UATTR, sId2,
                PM_NODE_OPSET);
        if (res.hasError()) {
            return res;
        }

        // If the opset is not assigned to anything else (to another user
        // attribute,
        // or object attribute or to the connector), assign it to the connector
        // node.
        if (opsetIsIsolated(sId2) && !opsetIsAssignedToConnector(sId2)) {
            res =  addDoubleLink(sId2, PM_NODE_OPSET, PM_CONNECTOR_ID,
                    PM_NODE_CONN);
            if (res.hasError()) {
                return res;
            }
        }
        setLastUpdateTimestamp();
        return successPacket("Assignment successfully deleted");
    }

    private Packet deleteAssgnOattrOattr(String sId1, String sId2) {
        // Conditions: sId1 is assigned to sId2.
        if (!attrIsAssignedToAttr(sId1, sId2, PM_NODE_OATTR)) {
            return failurePacket("Marked object attribute is not assigned to this attribute");
        }

        // Delete the double link between the object attributes sId1, sId2.
        Packet res =  deleteDoubleLink(sId1, PM_NODE_OATTR, sId2,
                PM_NODE_OATTR);
        if (res.hasError()) {
            return res;
        }

        // If the object attribute is not assigned to any other node, assign it
        // to the connector.
        if (!attrHasDescendants(sId1, PM_NODE_OATTR)) {
            res =  addDoubleLink(sId1, PM_NODE_OATTR, PM_CONNECTOR_ID,
                    PM_NODE_CONN);
            if (res.hasError()) {
                return res;
            }
        }
        setLastUpdateTimestamp();
        return successPacket("Attribute assignment successfully deleted");
    }

    private Packet deleteAssgnOattrPolicy(String sId1, String sId2) {
        // Conditions: sId1 is assigned to sId2.
        if (!attrIsAssignedToPolicy(sId1, PM_NODE_OATTR, sId2)) {
            return failurePacket("Marked object attribute is not assigned to this policy class");
        }

        // Delete the double link between the object attribute sId1 and policy
        // sId2.
        Packet res =  deleteDoubleLink(sId1, PM_NODE_OATTR, sId2,
                PM_NODE_POL);
        if (res.hasError()) {
            return res;
        }

        // If the object attribute is not assigned to any other node, assign it
        // to the connector.
        if (!attrHasDescendants(sId1, PM_NODE_OATTR)) {
            res =  addDoubleLink(sId1, PM_NODE_OATTR, PM_CONNECTOR_ID,
                    PM_NODE_CONN);
            if (res.hasError()) {
                return res;
            }
        }
        setLastUpdateTimestamp();
        return successPacket("Attribute assignment to policy successfully deleted");
    }

    private Packet deleteAssgnOpsetOattr(String sId1, String sId2) {
        // Conditions: sId1 is assigned to sId2.
        if (!opsetIsAssignedToAttr(sId1, sId2)) {
            return failurePacket("Marked operation set is not assigned to this object attribute");
        }

        // Delete the double link between the user attribute sId1 and opset
        // sId2.
        Packet res =  deleteDoubleLink(sId1, PM_NODE_OPSET, sId2,
                PM_NODE_OATTR);
        if (res.hasError()) {
            return res;
        }

        // If the opset is not assigned to anything else (to a user attribute,
        // or object attribute, or to the connector), assign it to the connector
        // node.
        if (opsetIsIsolated(sId1) && !opsetIsAssignedToConnector(sId1)) {
            res =  addDoubleLink(sId1, PM_NODE_OPSET, PM_CONNECTOR_ID,
                    PM_NODE_CONN);
            if (res.hasError()) {
                return res;
            }
        }
        setLastUpdateTimestamp();
        return successPacket("Assignment successfully deleted");
    }

    private Packet assign(String sSessId, String sProcId, String sId1,
                          String sType1, String sId2, String sType2, String sIsAdminVos) {

        if (sIsAdminVos.equalsIgnoreCase("yes")) {
            sId1 = getAdminVosNodeOrigId(sId1);
            sId2 = getAdminVosNodeOrigId(sId2);
        }

        // Check permissions.
        if (!requestAssignPerms(sSessId, sProcId, sId1, sType1, sId2, sType2)) {
            return failurePacket(reqPermsMsg);
        }

        return assignInternal(sId1, sType1, sId2, sType2);
    }

    private Packet assignInternal(String sId1, String sType1, String sId2,
                                  String sType2) {
        // The permissible types are:
        // user ---> user attribute
        // user attribute ---> user attribute
        // user attribute ---> policy class
        // user attribute ---> operation set
        // object attribute ---> object attribute (but not associated to object)
        // object attribute ---> policy class
        // operation set ---> object attribute.
        if (sType1.equalsIgnoreCase(PM_NODE_USER)
                && sType2.equalsIgnoreCase(PM_NODE_UATTR)) {
            return assignUserToUattr(sId1, sId2);
        } else if (sType1.equalsIgnoreCase(PM_NODE_UATTR)
                && sType2.equalsIgnoreCase(PM_NODE_UATTR)) {
            return assignUattrToUattr(sId1, sId2);
        } else if (sType1.equalsIgnoreCase(PM_NODE_UATTR)
                && sType2.equalsIgnoreCase(PM_NODE_POL)) {
            return assignUattrToPolicy(sId1, sId2);
        } else if (sType1.equalsIgnoreCase(PM_NODE_UATTR)
                && sType2.equalsIgnoreCase(PM_NODE_OPSET)) {
            return assignUattrToOpset(sId1, sId2);
        } else if ((sType1.equalsIgnoreCase(PM_NODE_OATTR) || sType1.equalsIgnoreCase(PM_NODE_ASSOC))
                && sType2.equalsIgnoreCase(PM_NODE_OATTR)) {
            return assignOattrToOattr(sId1, sId2);
        } else if ((sType1.equalsIgnoreCase(PM_NODE_OATTR) || sType1.equalsIgnoreCase(PM_NODE_ASSOC))
                && sType2.equalsIgnoreCase(PM_NODE_POL)) {
            return assignOattrToPolicy(sId1, sId2);
        } else if (sType1.equalsIgnoreCase(PM_NODE_OPSET)
                && (sType2.equalsIgnoreCase(PM_NODE_OATTR) || sType2.equalsIgnoreCase(PM_NODE_ASSOC))) {
            return assignOpsetToOattr(sId1, sId2);
        } else {
            return failurePacket("Incompatible types for assignment");
        }
    }

    private Packet assignUserToUattr(String sId1, String sId2) {
        // Conditions: sId1 not already an ascendant of sId2.
        if (userIsAscendant(sId1, sId2)) {
            return failurePacket("Marked user already has this attribute");
        }

        // Add the double link between the user sId1 and the attribute sId2.
//		String sDn;
//		ModificationItem[] mods = new ModificationItem[1];

        Packet res =  addDoubleLink(sId1, PM_NODE_USER, sId2,
                PM_NODE_UATTR);
        if (res.hasError()) {
            return res;
        }

        // Check static constraints. If the admin op violates any of them,
        // roll back the operation.
        res =  checkSconForAssignUserToUattr(sId1, sId2);
        if (res.hasError()) {
            return res;
        }

        // If sId1 is assigned to the connector node, delete that assignment.
        if (userIsAssignedToConnector(sId1)) {
            res =  deleteDoubleLink(sId1, PM_NODE_USER,
                    PM_CONNECTOR_ID, PM_NODE_CONN);
            if (res.hasError()) {
                return res;
            }
        }
        setLastUpdateTimestamp();
        return successPacket("User successfully assigned to this attribute");
    }

    // Check the static constraints for the admin operation
    // "Assign User To Uattr".
    // If the user attribute has other users authorized, no check is necessary.
    private Packet checkSconForAssignUserToUattr(String sUserId, String sUattrId) {
        Packet res =  checkScons();
        if (!res.hasError()) {
            return res;
        }

        // The SCons are violated. Tell the client the admin op is rolled back.
        String sErr = res.getErrorMessage()
                + " Rolling back the AssignUser operation.";

        // Roll back the operation.
        res =  deleteDoubleLink(sUserId, PM_NODE_USER, sUattrId,
                PM_NODE_UATTR);
        if (res.hasError()) {
            sErr += " Error during rollback (delete link).";
        }
        return failurePacket(sErr);
    }

    private Packet assignUattrToUattr(String sId1, String sId2) {
        // Conditions: sId1 not already an ascendant of sId2, sId2 not an
        // ascendant of sId1.
        if (attrIsAscendant(sId1, sId2, PM_NODE_UATTR)) {
            return failurePacket("Marked attribute already contains this attribute");
        }
        if (attrIsAscendant(sId2, sId1, PM_NODE_UATTR)) {
            return failurePacket("Assignment would create a cycle");
        }

        // Add the double link between the attribute sId1 and the attribute
        // sId2.
        Packet res =  addDoubleLink(sId1, PM_NODE_UATTR, sId2,
                PM_NODE_UATTR);
        if (res.hasError()) {
            return res;
        }

        // Check static constraints. If the admin op violates any of them,
        // roll back the operation.
        res =  checkSconForAssignUattrToUattr(sId1, sId2);
        if (res.hasError()) {
            return res;
        }

        // If sId1 is assigned to the connector node, delete that assignment.
        if (attrIsAssignedToConnector(sId1, PM_NODE_UATTR)) {
            res =  deleteDoubleLink(sId1, PM_NODE_UATTR,
                    PM_CONNECTOR_ID, PM_NODE_CONN);
            if (res.hasError()) {
                return res;
            }
        }

        // If sId1--->policy class pc, and sId2--->*pc, delete sId1--->pc.
        try {
            Attribute attr = getToPolicies(sId1, PM_NODE_UATTR);
            if (attr != null) {
                for (NamingEnumeration<?> enumer = attr.getAll(); enumer.hasMore(); ) {
                    String sId = (String) enumer.next();
                    if (attrIsAscendantToPolicy(sId2, PM_NODE_UATTR, sId)) {
                        res =  deleteDoubleLink(sId1, PM_NODE_UATTR,
                                sId, PM_NODE_POL);
                        if (res.hasError()) {
                            return res;
                        }
                    }
                }
            }
        } catch (Exception e) {
            if (debugFlag) {
                e.printStackTrace();
            }
            return failurePacket("Error when deleting assignment to a policy class");
        }

        // For all uattr sId such that sId1--->sId and sId != sId2 and
        // sId2--->*sId,
        // delete sId1--->sId.
        try {
            Attribute attr = getToAttrs(sId1, PM_NODE_UATTR);
            if (attr != null) {
                for (NamingEnumeration<?> enumer = attr.getAll(); enumer.hasMore(); ) {
                    String sId = (String) enumer.next();
                    if (!sId.equalsIgnoreCase(sId2)
                            && attrIsAscendant(sId2, sId, PM_NODE_UATTR)) {
                        res =  deleteDoubleLink(sId1, PM_NODE_UATTR,
                                sId, PM_NODE_UATTR);
                        if (res.hasError()) {
                            return res;
                        }
                    }
                }
            }
        } catch (Exception e) {
            if (debugFlag) {
                e.printStackTrace();
            }
            return failurePacket("Error when deleting assignment to an attribute");
        }
        setLastUpdateTimestamp();
        return successPacket();
    }

    // Check the static constraints for the admin operation
    // "Assign Uattr To Uattr".
    // If the user attribute uattr2 has other users authorized, no check is
    // necessary.
    private Packet checkSconForAssignUattrToUattr(String sId1, String sId2) {
        Packet res =  checkScons();
        if (!res.hasError()) {
            return res;
        }

        // The SCons are violated. Tell the client the admin op is rolled back.
        String sErr = res.getErrorMessage()
                + " Rolling back the AssignUserAttribute operation.";

        // Roll back the operation.
        res =  deleteDoubleLink(sId1, PM_NODE_UATTR, sId2,
                PM_NODE_UATTR);
        if (res.hasError()) {
            sErr += " Error during rollback (delete link).";
        }
        return failurePacket(sErr);
    }

    private Packet assignUattrToPolicy(String sId1, String sId2) {
        // Conditions: sId1 not already an ascendant of sId2.
        if (attrIsAscendantToPolicy(sId1, PM_NODE_UATTR, sId2)) {
            return failurePacket("Marked attribute already pertains to this policy");
        }

        // Add the double link between the attribute sId1 and the policy sId2.
        Packet res =  addDoubleLink(sId1, PM_NODE_UATTR, sId2,
                PM_NODE_POL);
        if (res.hasError()) {
            return res;
        }

        // Check static constraints. If the admin op violates any of them,
        // roll back the operation.
        res =  checkSconForAssignUattrToPolicy(sId1, sId2);
        if (res.hasError()) {
            return res;
        }

        // If sId1 is assigned to the connector node, delete that assignment.
        if (attrIsAssignedToConnector(sId1, PM_NODE_UATTR)) {
            res =  deleteDoubleLink(sId1, PM_NODE_UATTR,
                    PM_CONNECTOR_ID, PM_NODE_CONN);
            if (res.hasError()) {
                return res;
            }
        }
        setLastUpdateTimestamp();
        return successPacket("Marked attribute successfully assigned to this policy");
    }

    // Check the static constraints for the admin operation
    // "Assign Uattr To Policy".
    // If the user attribute does not have authorized users, no check is
    // necessary.
    private Packet checkSconForAssignUattrToPolicy(String sId1, String sId2) {
        Packet res =  checkScons();
        if (!res.hasError()) {
            return res;
        }

        // The SCons are violated. Tell the client the admin op is rolled back.
        String sErr = res.getErrorMessage()
                + " Rolling back the AssignUserAttributeToPolicy operation.";

        // Roll back the operation.
        res =  deleteDoubleLink(sId1, PM_NODE_UATTR, sId2, PM_NODE_POL);
        if (res.hasError()) {
            sErr += " Error during rollback (delete link).";
        }
        return failurePacket(sErr);
    }

    private Packet assignUattrToOpset(String sId1, String sId2) {
        // Conditions: sId1 not assigned to sId2.
        if (attrIsAssignedToOpset(sId1, sId2)) {
            return failurePacket("Marked attribute already assigned to this operation set");
        }

        // Add the double link between the attribute sId1 and the operation set
        // sId2.
        Packet res =  addDoubleLink(sId1, PM_NODE_UATTR, sId2,
                PM_NODE_OPSET);
        if (res.hasError()) {
            return res;
        }

        // Check static constraints. If the admin op violates any of them,
        // roll back the operation.
        res =  checkSconForAssignUattrToOpset(sId1, sId2);
        if (res.hasError()) {
            return res;
        }

        // If the opset is assigned to the connector, delete this assignment.
        if (opsetIsAssignedToConnector(sId2)) {
            res =  deleteDoubleLink(sId2, PM_NODE_OPSET,
                    PM_CONNECTOR_ID, PM_NODE_CONN);
            if (res.hasError()) {
                return res;
            }
        }
        setLastUpdateTimestamp();
        return successPacket("Marked attribute successfully assigned to this operation set");
    }

    // Check the static constraints for the admin operation
    // "Assign Uattr To Opset".
    // If the user attribute does not have authorized users, no check is
    // necessary.
    private Packet checkSconForAssignUattrToOpset(String sId1, String sId2) {
        Packet res =  checkScons();
        if (!res.hasError()) {
            return res;
        }

        // The SCons are violated. Tell the client the admin op is rolled back.
        String sErr = res.getErrorMessage()
                + " Rolling back the AssignUserAttributeToOpset operation.";

        // Roll back the operation.
        res =  deleteDoubleLink(sId1, PM_NODE_UATTR, sId2,
                PM_NODE_OPSET);
        if (res.hasError()) {
            sErr += " Error during rollback (delete link).";
        }

        return failurePacket(sErr);
    }

    private Packet assignOattrToOattr(String sId1, String sId2) {
        // Conditions: sId2 not associated to an object,
        // sId1 not already an ascendant of sId2,
        // sId2 not an ascendant of sId1.
        if (hasAssocObj(sId2)) {
            return failurePacket("The selected attribute is asociated to an object");
        }
        if (attrIsAscendant(sId1, sId2, PM_NODE_OATTR)) {
            return failurePacket("Already contained");
        }
        if (attrIsAscendant(sId2, sId1, PM_NODE_OATTR)) {
            return failurePacket("Assignment would create a cycle");
        }

        // Add the double link between the attribute sId1 and the attribute
        // sId2.
        Packet res =  addDoubleLink(sId1, PM_NODE_OATTR, sId2,
                PM_NODE_OATTR);
        if (res.hasError()) {
            return res;
        }

        // Check static constraints. If the admin op violates any of them,
        // roll back the operation.
        res =  checkSconForAssignOattrToOattr(sId1, sId2);
        if (res.hasError()) {
            return res;
        }

        // If sId1 is assigned to the connector node, delete that assignment.
        if (attrIsAssignedToConnector(sId1, PM_NODE_OATTR)) {
            res =  deleteDoubleLink(sId1, PM_NODE_OATTR,
                    PM_CONNECTOR_ID, PM_NODE_CONN);
            if (res.hasError()) {
                return res;
            }
        }

        String sId;

        // If sId1--->policy class pc, and sId2--->*pc, delete sId1--->pc.
        try {
            Attribute attr = getToPolicies(sId1, PM_NODE_OATTR);
            if (attr != null) {
                for (NamingEnumeration<?> enumer = attr.getAll(); enumer.hasMore(); ) {
                    sId = (String) enumer.next();
                    if (attrIsAscendantToPolicy(sId2, PM_NODE_OATTR, sId)) {
                        res =  deleteDoubleLink(sId1, PM_NODE_OATTR,
                                sId, PM_NODE_POL);
                        if (res.hasError()) {
                            return res;
                        }
                    }
                }
            }
        } catch (Exception e) {
            if (debugFlag) {
                e.printStackTrace();
            }
            return failurePacket("Error when deleting assignment to policy class");
        }

        // For all oattr sId such that sId1--->sId and sId != sId2 and
        // sId2--->*sId,
        // delete sId1--->sId.
        try {
            Attribute attr = getToAttrs(sId1, PM_NODE_OATTR);
            if (attr != null) {
                for (NamingEnumeration<?> enumer = attr.getAll(); enumer.hasMore(); ) {
                    sId = (String) enumer.next();
                    if (!sId.equalsIgnoreCase(sId2)
                            && attrIsAscendant(sId2, sId, PM_NODE_OATTR)) {
                        res =  deleteDoubleLink(sId1, PM_NODE_OATTR,
                                sId, PM_NODE_OATTR);
                        if (res.hasError()) {
                            return res;
                        }
                    }
                }
            }
        } catch (Exception e) {
            if (debugFlag) {
                e.printStackTrace();
            }
            return failurePacket("Error when deleting assignment to policy class");
        }
        setLastUpdateTimestamp();
        return successPacket();
    }

    // Check the static constraints for the admin operation
    // "Assign Oattr To Oattr".
    private Packet checkSconForAssignOattrToOattr(String sId1, String sId2) {
        Packet res =  checkScons();
        if (!res.hasError()) {
            return res;
        }

        // The SCons are violated. Tell the client the admin op is rolled back.
        String sErr = res.getErrorMessage()
                + " Rolling back the AssignObjectAttribute operation.";

        // Roll back the operation.
        res =  deleteDoubleLink(sId1, PM_NODE_OATTR, sId2,
                PM_NODE_OATTR);
        if (res.hasError()) {
            sErr += " Error during rollback (delete link).";
        }
        return failurePacket(sErr);
    }

    private Packet assignOattrToPolicy(String sId1, String sId2) {
        // Conditions: sId1 not already an ascendant of sId2.
        if (attrIsAscendantToPolicy(sId1, PM_NODE_OATTR, sId2)) {
            return failurePacket("Marked attribute already pertains to this policy");
        }

        // Add the double link between the object attribute sId1 and the policy
        // sId2.
        Packet res =  addDoubleLink(sId1, PM_NODE_OATTR, sId2,
                PM_NODE_POL);
        if (res.hasError()) {
            return res;
        }

        // Check static constraints. If the admin op violates any of them,
        // roll back the operation.
        res =  checkSconForAssignOattrToPolicy(sId1, sId2);
        if (res.hasError()) {
            return res;
        }

        // If sId1 is assigned to the connector node, delete that assignment.
        if (attrIsAssignedToConnector(sId1, PM_NODE_OATTR)) {
            res =  deleteDoubleLink(sId1, PM_NODE_OATTR,
                    PM_CONNECTOR_ID, PM_NODE_CONN);
            if (res.hasError()) {
                return res;
            }
        }
        setLastUpdateTimestamp();
        return successPacket("Marked attribute successfully assigned to this policy");
    }

    // Check the static constraints for the admin operation
    // "Assign Oattr To Policy".
    private Packet checkSconForAssignOattrToPolicy(String sId1, String sId2) {
        Packet res =  checkScons();
        if (!res.hasError()) {
            return res;
        }

        // The SCons are violated. Tell the client the admin op is rolled back.
        String sErr = res.getErrorMessage()
                + " Rolling back the AssignObjectAttributeToPolicy operation.";

        // Roll back the operation.
        res =  deleteDoubleLink(sId1, PM_NODE_OATTR, sId2, PM_NODE_POL);
        if (res.hasError()) {
            sErr += " Error during rollback (delete link).";
        }
        return failurePacket(sErr);
    }

    private Packet assignOpsetToOattr(String sId1, String sId2) {
        // Conditions: sId1 not assigned to sId2.
        if (opsetIsAssignedToAttr(sId1, sId2)) {
            return failurePacket("Marked operation set is already assigned to this object attribute");
        }

        // Add the double link between the operation set sId1 and the object
        // attribute sId2.
        Packet res =  addDoubleLink(sId1, PM_NODE_OPSET, sId2,
                PM_NODE_OATTR);
        if (res.hasError()) {
            return res;
        }

        // Check static constraints. If the admin op violates any of them,
        // roll back the operation.
        res =  checkSconForAssignOpsetToOattr(sId1, sId2);
        if (res.hasError()) {
            return res;
        }

        // If the opset is assigned to the connector, delete this assignment.
        if (opsetIsAssignedToConnector(sId1)) {
            res =  deleteDoubleLink(sId1, PM_NODE_OPSET,
                    PM_CONNECTOR_ID, PM_NODE_CONN);
            if (res.hasError()) {
                return res;
            }
        }

        setLastUpdateTimestamp();
        return successPacket("Marked operation set successfully assigned to this object attribute");
    }

    // Check the static constraints for the admin operation
    // "Assign Opset To Oattr".
    private Packet checkSconForAssignOpsetToOattr(String sId1, String sId2) {
        Packet res =  checkScons();
        if (!res.hasError()) {
            return res;
        }

        // The SCons are violated. Tell the client the admin op is rolled back.
        String sErr = res.getErrorMessage()
                + " Rolling back the AssignOpsetToObjectAttribute operation.";

        // Roll back the operation.
        res =  deleteDoubleLink(sId1, PM_NODE_OPSET, sId2,
                PM_NODE_OATTR);
        if (res.hasError()) {
            sErr += " Error during rollback (delete link).";
        }
        return failurePacket(sErr);
    }

    // Get the selectable VOS graph. This is the entire virtual object system
    // graph,
    // in which the user can select multiple nodes.
    // In the sequence of calls to this function issued by a client, sAction
    // must be:
    // open, null, ..., null, close.
    private Packet getSelVosGraph(String sClientId, String sSessId,
                                  String sChooserId, String sAnchorId, String sAnchorLabel,
                                  String sAnchorType, String sLevel, String sSelId, String sSelLabel,
                                  String sSelType, String sSelMode, String sAction) {

        String sUserId = getSessionUserId(sSessId);
        if (sUserId == null) {
            return failurePacket("Couldn't retrieve the session user id");
        }
        String sUserName = getEntityName(sUserId, PM_NODE_USER);
        if (sUserName == null) {
            return failurePacket("Couldn't retrieve the session user name");
        }

        // Anchor type can only be o, b, p, c.
        if (sAnchorType.equalsIgnoreCase(PM_NODE_ASSOC)) {
            sAnchorType = PM_NODE_OATTR;
        }
        if (!sAnchorType.equalsIgnoreCase(PM_NODE_OATTR)
                && !sAnchorType.equalsIgnoreCase(PM_NODE_POL)
                && !sAnchorType.equalsIgnoreCase(PM_NODE_CONN)) {
            return failurePacket("Node type incompatible with graph view");
        }

        Packet graph = new Packet();

        HashSet<String> visitedSet = new HashSet<String>();
        ArrayList<QueueElement> queue = new ArrayList<QueueElement>();
        QueueElement qe, crtQe;
        String sId = null;
        String sType;

        // If this is the first time a client asks for the selectable graph,
        // generate a new client id and open an empty entry in htSelVosNodes.
        if (sAction != null) {
            if (sAction.equals("open")) {
                RandomGUID myGUID = new RandomGUID();
                sChooserId = myGUID.toStringNoDashes();
                try {
                    graph.addItem(ItemType.RESPONSE_TEXT, PM_ID
                            + PM_FIELD_DELIM + sChooserId);
                } catch (Exception e) {
                    e.printStackTrace();
                    return failurePacket("Failed to add chooser id at open in getSelVosGraph");
                }
                htSelVosNodes.put(sChooserId, new HashSet<String>());
            } else if (sAction.equals("close")) {
                if (sChooserId == null
                        || !htSelVosNodes.containsKey(sChooserId)) {
                    return failurePacket("Your client id is invalid!");
                }
                htSelVosNodes.remove(sChooserId);
                return successPacket();
            } else {
                return failurePacket("Invalid action!");
            }
        }

        Set<String> hs = htSelVosNodes.get(sChooserId);
        if (sSelMode.equals(PM_SELECTION_MULTIPLE)) {
            if (hs.contains(sSelId)) {
                hs.remove(sSelId);
            } else {
                hs.add(sSelId);
            }
        } else if (sSelMode.equals(PM_SELECTION_SINGLE)) {
            if (hs.contains(sSelId)) {
                hs.remove(sSelId);
            } else {
                hs.clear();
                hs.add(sSelId);
            }
        }
        int nMaxLevel = Integer.valueOf(sLevel).intValue();

        // Whenever we insert a node in the queue, we add it to the graph.
        // Start by inserting the anchor in the queue with level 0
        crtQe = new QueueElement(sAnchorType, sAnchorId, 0);
        queue.add(crtQe);

        try {
            sType = getTrueType(sAnchorId, sAnchorType.toUpperCase());
            addSelVosNode(graph, sType, sAnchorId, hs);
            while (!queue.isEmpty()) {
                crtQe = queue.remove(0);
                if (debugFlag) {
                    System.out.println("Out of queue: " + crtQe.getId());
                }
                if (crtQe.getLevel() < nMaxLevel) {

                    if (crtQe.getType().equalsIgnoreCase(PM_NODE_OATTR)) {
                        // OBJECT ATTRIBUTE NODE.
                        // Process the object attributes assigned to this object
                        // attribute
                        // (the ascendants).
                        Attribute attr = getFromAttrs(crtQe);
                        if (attr != null) {
                            for (NamingEnumeration<?> attrEnum = attr.getAll(); attrEnum.hasMore(); ) {
                                sId = (String) attrEnum.next();
                                if (!visitedSet.contains(sId)) {
                                    qe = new QueueElement(PM_NODE_OATTR, sId,
                                            crtQe.getLevel() + 1);
                                    queue.add(qe);
                                    sType = getTrueType(sId, PM_NODE_OATTR);
                                    addSelVosNode(graph, sType, sId, hs);
                                    visitedSet.add(sId);
                                }
                                addRel(graph, sId, crtQe.getId());
                            }
                        }

                    } else if (crtQe.getType().equalsIgnoreCase(PM_NODE_POL)) {
                        // POLICY CLASS NODE.
                        // Process object attributes assigned to it.
                        Attribute attr = getFromObjAttrs(crtQe);
                        if (attr != null) {
                            for (NamingEnumeration<?> attrEnum = attr.getAll(); attrEnum.hasMore(); ) {
                                sId = (String) attrEnum.next();
                                if (!visitedSet.contains(sId)) {
                                    qe = new QueueElement(PM_NODE_OATTR, sId,
                                            crtQe.getLevel() + 1);
                                    queue.add(qe);
                                    sType = getTrueType(sId, PM_NODE_OATTR);
                                    addSelVosNode(graph, sType, sId, hs);
                                    visitedSet.add(sId);
                                }
                                addRel(graph, sId, crtQe.getId());
                            }
                        }

                    } else if (crtQe.getType().equalsIgnoreCase(PM_NODE_CONN)) {
                        // CONNECTOR NODE.
                        // Process object attributes assigned to the connector
                        // node.
                        Attribute attr = getFromObjAttrs(crtQe);
                        if (attr != null) {
                            for (NamingEnumeration<?> attrEnum = attr.getAll(); attrEnum.hasMore(); ) {
                                sId = (String) attrEnum.next();
                                if (!visitedSet.contains(sId)) {
                                    qe = new QueueElement(PM_NODE_OATTR, sId,
                                            crtQe.getLevel() + 1);
                                    queue.add(qe);
                                    sType = getTrueType(sId, PM_NODE_OATTR);
                                    addSelVosNode(graph, sType, sId, hs);
                                    visitedSet.add(sId);
                                }
                                addRel(graph, sId, crtQe.getId());
                            }
                        }

                        // Process the policy classes assigned to the connector
                        // node.
                        attr = getFromPolicies(crtQe);
                        if (attr != null) {
                            for (NamingEnumeration<?> attrEnum = attr.getAll(); attrEnum.hasMore(); ) {
                                sId = (String) attrEnum.next();
                                if (!visitedSet.contains(sId)) {
                                    qe = new QueueElement(PM_NODE_POL, sId,
                                            crtQe.getLevel() + 1);
                                    queue.add(qe);
                                    addSelVosNode(graph, PM_NODE_POL, sId, hs);
                                    visitedSet.add(sId);
                                }
                                addRel(graph, sId, crtQe.getId());
                            }
                        }
                    }
                }
            }
        } catch (NameNotFoundException e) {
            if (debugFlag) {
                e.printStackTrace();
            }
            return failurePacket("Database inconsistency about node "
                    + crtQe.getId() + " or " + sId);
        } catch (CommunicationException e) {
            if (debugFlag) {
                e.printStackTrace();
            }
            return failurePacket("AD connection error");
        } catch (Exception e) {
            if (debugFlag) {
                e.printStackTrace();
            }
            return failurePacket(e.getMessage());
        }

        crtQe = new QueueElement(sAnchorType, sAnchorId, 0);
        queue.add(crtQe);

        try {
            while (!queue.isEmpty()) {
                crtQe = queue.remove(0);
                if (debugFlag) {
                    System.out.println("Out of queue: " + crtQe.getId());
                }
                if (crtQe.getLevel() < nMaxLevel) {

                    if (crtQe.getType().equalsIgnoreCase(PM_NODE_OATTR)) {
                        // OBJECT ATTRIBUTE NODE.
                        // Process the object attributes this object attribute
                        // is assigned to.
                        Attribute attr = getToAttrs(crtQe);
                        if (attr != null) {
                            for (NamingEnumeration<?> attrEnum = attr.getAll(); attrEnum.hasMore(); ) {
                                sId = (String) attrEnum.next();
                                if (!visitedSet.contains(sId)) {
                                    qe = new QueueElement(PM_NODE_OATTR, sId,
                                            crtQe.getLevel() + 1);
                                    queue.add(qe);
                                    sType = getTrueType(sId, PM_NODE_OATTR);
                                    addSelVosNode(graph, sType, sId, hs);
                                    visitedSet.add(sId);
                                }
                                addRel(graph, crtQe.getId(), sId);
                            }
                        }
                        // Process the policy classes this object attribute is
                        // assigned to.
                        attr = getToPolicies(crtQe);
                        if (attr != null) {
                            for (NamingEnumeration<?> attrEnum = attr.getAll(); attrEnum.hasMore(); ) {
                                sId = (String) attrEnum.next();
                                if (!visitedSet.contains(sId)) {
                                    qe = new QueueElement(PM_NODE_POL, sId,
                                            crtQe.getLevel() + 1);
                                    queue.add(qe);
                                    addSelVosNode(graph, PM_NODE_POL, sId, hs);
                                    visitedSet.add(sId);
                                }
                                addRel(graph, crtQe.getId(), sId);
                            }
                        }
                        // Process the connector node if this object attribute
                        // is assigned to it.
                        if (attrIsAssignedToConnector(crtQe.getId(),
                                PM_NODE_OATTR)) {
                            if (!visitedSet.contains(PM_CONNECTOR_ID)) {
                                qe = new QueueElement(PM_NODE_CONN,
                                        PM_CONNECTOR_ID, crtQe.getLevel() + 1);
                                queue.add(qe);
                                addSelVosNode(graph, PM_NODE_CONN,
                                        PM_CONNECTOR_ID, hs);
                                visitedSet.add(PM_CONNECTOR_ID);
                            }
                            addRel(graph, crtQe.getId(), PM_CONNECTOR_ID);
                        }

                    } else if (crtQe.getType().equalsIgnoreCase(PM_NODE_POL)) {
                        // POLICY CLASS NODE.
                        // Process the connector node.
                        if (!visitedSet.contains(PM_CONNECTOR_ID)) {
                            qe = new QueueElement(PM_NODE_CONN,
                                    PM_CONNECTOR_ID, crtQe.getLevel() + 1);
                            queue.add(qe);
                            addSelVosNode(graph, PM_NODE_CONN, PM_CONNECTOR_ID,
                                    hs);
                            visitedSet.add(PM_CONNECTOR_ID);
                        }
                        addRel(graph, crtQe.getId(), PM_CONNECTOR_ID);
                    }
                }
            }
        } catch (NameNotFoundException e) {
            if (debugFlag) {
                e.printStackTrace();
            }
            return failurePacket("Database inconsistency");
        } catch (CommunicationException e) {
            if (debugFlag) {
                e.printStackTrace();
            }
            return failurePacket("AD connection error");
        } catch (Exception e) {
            if (debugFlag) {
                e.printStackTrace();
            }
            return failurePacket(e.getMessage());
        }

        return graph;
    }

    // Get the selectable VOS graph. This is the virtual object system graph
    // visible
    // to the session's user.
    // sAction must be open, null, ..., null, close in a sequence of calls.
    private Packet getSelVosGraph2(String sClientId, String sSessId,
                                   String sChooserId, String sAnchorId, String sAnchorLabel,
                                   String sAnchorType, String sLevel, String sSelId, String sSelLabel,
                                   String sSelType, String sSelMode, String sAction) {

        String sUserId = getSessionUserId(sSessId);
        if (sUserId == null) {
            return failurePacket("Couldn't retrieve the session user id");
        }
        String sUserName = getEntityName(sUserId, PM_NODE_USER);
        if (sUserName == null) {
            return failurePacket("Couldn't retrieve the session user name");
        }

        // Anchor type can only be o, b, p, c.
        if (sAnchorType.equalsIgnoreCase(PM_NODE_ASSOC)) {
            sAnchorType = PM_NODE_OATTR;
        }
        if (!sAnchorType.equalsIgnoreCase(PM_NODE_OATTR)
                && !sAnchorType.equalsIgnoreCase(PM_NODE_POL)
                && !sAnchorType.equalsIgnoreCase(PM_NODE_CONN)) {
            return failurePacket("Anchor type incompatible with VOS view!");
        }

        if (sAnchorId.equals(PM_CONNECTOR_ID)) {
            sAnchorId = getVosNodeId(PM_CONNECTOR_ID, sSessId);
            if (sAnchorId == null) {
                return failurePacket("Couldn't get the connector's VOS id");
            }
        }

        Packet graph = new Packet();

        HashSet<String> visitedSet = new HashSet<String>();
        ArrayList<QueueElement> queue = new ArrayList<QueueElement>();
        QueueElement qe, crtQe;
        String sId = null;
        String sType;

        // If this is the first time a client asks for the selectable graph,
        // generate a new client id and open an empty entry in htSelVosNodes.
        if (sAction != null) {
            if (sAction.equals("open")) {
                RandomGUID myGUID = new RandomGUID();
                sChooserId = myGUID.toStringNoDashes();
                try {
                    graph.addItem(ItemType.RESPONSE_TEXT, PM_ID
                            + PM_FIELD_DELIM + sChooserId);
                } catch (Exception e) {
                    e.printStackTrace();
                    return failurePacket("Failed to add chooser id in getSelVosGraph2");
                }
                htSelVosNodes.put(sChooserId, new HashSet<String>());
            } else if (sAction.equals("close")) {
                if (sChooserId == null
                        || !htSelVosNodes.containsKey(sChooserId)) {
                    return failurePacket("Your client id is invalid!");
                }
                htSelVosNodes.remove(sChooserId);
                return successPacket();
            } else {
                return failurePacket("Invalid action!");
            }
        }

        Set<String> hs = htSelVosNodes.get(sChooserId);
        if (sSelMode.equals(PM_SELECTION_MULTIPLE)) {
            if (hs.contains(sSelId)) {
                hs.remove(sSelId);
            } else {
                hs.add(sSelId);
            }
        } else if (sSelMode.equals(PM_SELECTION_SINGLE)) {
            if (hs.contains(sSelId)) {
                hs.remove(sSelId);
            } else {
                hs.clear();
                hs.add(sSelId);
            }
        }
        int nMaxLevel = Integer.valueOf(sLevel).intValue();

        // Whenever we insert a node in the queue, we add it to the graph.
        // Start by inserting the anchor in the queue with level 0
        sType = getVosNodeType(sAnchorId);
        if (sType == null) {
            return failurePacket("Error in getVosNodeType(): check AD connection?");
        }
        crtQe = new QueueElement(sType, sAnchorId, 0);
        queue.add(crtQe);

        try {
            addSelVosNode2(graph, sType, sAnchorId, hs);
            while (!queue.isEmpty()) {
                crtQe = queue.remove(0);
                if (debugFlag) {
                    System.out.println("Out of queue: " + crtQe.getId());
                }
                if (crtQe.getLevel() < nMaxLevel) {

                    if (crtQe.getType().equalsIgnoreCase(PM_NODE_OATTR)
                            || crtQe.getType().equalsIgnoreCase(PM_NODE_ASSOC)) {
                        // The current VOS node is an OBJECT ATTRIBUTE NODE.
                        // Its ascendants can only be object attributes.
                        Attribute attr = getVosNodeAscs(crtQe.getId());
                        if (attr != null) {
                            for (NamingEnumeration<?> attrEnum = attr.getAll(); attrEnum.hasMore(); ) {
                                sId = (String) attrEnum.next();
                                if (!visitedSet.contains(sId)) {
                                    sType = getVosNodeType(sId);
                                    if (sType == null) {
                                        return failurePacket("Error in getVosNodeType(): check AD connection?");
                                    }

                                    qe = new QueueElement(sType, sId,
                                            crtQe.getLevel() + 1);
                                    queue.add(qe);
                                    addSelVosNode2(graph, sType, sId, hs);
                                    visitedSet.add(sId);
                                }
                                addRel(graph, sId, crtQe.getId());
                            }
                        }

                    } else if (crtQe.getType().equalsIgnoreCase(PM_NODE_POL)) {
                        // The current VOS node is a POLICY CLASS NODE.
                        // Its ascendants can only be object attributes.
                        Attribute attr = getVosNodeAscs(crtQe.getId());
                        if (attr != null) {
                            for (NamingEnumeration<?> attrEnum = attr.getAll(); attrEnum.hasMore(); ) {
                                sId = (String) attrEnum.next();
                                if (!visitedSet.contains(sId)) {
                                    sType = getVosNodeType(sId);
                                    if (sType == null) {
                                        return failurePacket("Error in getVosNodeType(): check AD connection?");
                                    }
                                    qe = new QueueElement(sType, sId,
                                            crtQe.getLevel() + 1);
                                    queue.add(qe);
                                    addSelVosNode2(graph, sType, sId, hs);
                                    visitedSet.add(sId);
                                }
                                addRel(graph, sId, crtQe.getId());
                            }
                        }

                    } else if (crtQe.getType().equalsIgnoreCase(PM_NODE_CONN)) {
                        // The current VOS node is the CONNECTOR NODE.
                        // Its ascendants can only be policy classes.
                        Attribute attr = getVosNodeAscs(crtQe.getId());
                        if (attr != null) {
                            for (NamingEnumeration<?> attrEnum = attr.getAll(); attrEnum.hasMore(); ) {
                                sId = (String) attrEnum.next();
                                if (!visitedSet.contains(sId)) {
                                    qe = new QueueElement(PM_NODE_POL, sId,
                                            crtQe.getLevel() + 1);
                                    queue.add(qe);
                                    addSelVosNode2(graph, PM_NODE_POL, sId, hs);
                                    visitedSet.add(sId);
                                }
                                addRel(graph, sId, crtQe.getId());
                            }
                        }
                    }
                }
            }
        } catch (NameNotFoundException e) {
            if (debugFlag) {
                e.printStackTrace();
            }
            return failurePacket("VOS Database inconsistency about node "
                    + crtQe.getId() + " or " + sId);
        } catch (CommunicationException e) {
            if (debugFlag) {
                e.printStackTrace();
            }
            return failurePacket("AD connection error");
        } catch (Exception e) {
            if (debugFlag) {
                e.printStackTrace();
            }
            return failurePacket(e.getMessage());
        }

        crtQe = new QueueElement(sAnchorType, sAnchorId, 0);
        queue.add(crtQe);

        try {
            while (!queue.isEmpty()) {
                crtQe = queue.remove(0);
                if (debugFlag) {
                    System.out.println("Out of queue: " + crtQe.getId());
                }
                if (crtQe.getLevel() < nMaxLevel) {

                    if (crtQe.getType().equalsIgnoreCase(PM_NODE_OATTR)
                            || crtQe.getType().equalsIgnoreCase(PM_NODE_ASSOC)) {
                        // The current VOS node is an OBJECT ATTRIBUTE NODE.
                        // Its descendants can be object attributes or policy
                        // classes.
                        Attribute attr = getVosNodeDescs(crtQe.getId());
                        if (attr != null) {
                            for (NamingEnumeration<?> attrEnum = attr.getAll(); attrEnum.hasMore(); ) {
                                sId = (String) attrEnum.next();
                                if (!visitedSet.contains(sId)) {
                                    sType = getVosNodeType(sId);
                                    if (sType == null) {
                                        return failurePacket("Error in getVosNodeType(): check AD connection?");
                                    }
                                    qe = new QueueElement(sType, sId,
                                            crtQe.getLevel() + 1);
                                    queue.add(qe);
                                    addSelVosNode2(graph, sType, sId, hs);
                                    visitedSet.add(sId);
                                }
                                addRel(graph, crtQe.getId(), sId);
                            }
                        }
                    } else if (crtQe.getType().equalsIgnoreCase(PM_NODE_POL)) {
                        // POLICY CLASS NODE.
                        // Its (only) descendant is the connector node.
                        Attribute attr = getVosNodeDescs(crtQe.getId());
                        if (attr != null) {
                            for (NamingEnumeration<?> attrEnum = attr.getAll(); attrEnum.hasMore(); ) {
                                sId = (String) attrEnum.next();
                                if (!visitedSet.contains(sId)) {
                                    sType = getVosNodeType(sId);
                                    if (sType == null) {
                                        return failurePacket("Error in getVosNodeType(): check AD connection?");
                                    }
                                    addSelVosNode2(graph, sType, sId, hs);
                                    visitedSet.add(sId);
                                }
                                addRel(graph, crtQe.getId(), sId);
                            }
                        }
                    }
                }
            }
        } catch (NameNotFoundException e) {
            if (debugFlag) {
                e.printStackTrace();
            }
            return failurePacket("Database inconsistency");
        } catch (CommunicationException e) {
            if (debugFlag) {
                e.printStackTrace();
            }
            return failurePacket("AD connection error");
        } catch (Exception e) {
            if (debugFlag) {
                e.printStackTrace();
            }
            return failurePacket(e.getMessage());
        }

        return graph;
    }

    private Packet getSimpleVosGraph(String sClientId, String sSessId,
                                     String sAnchorId, String sAnchorLabel, String sAnchorType,
                                     String sLevel) {
        String sUserId = getSessionUserId(sSessId);
        if (sUserId == null) {
            return failurePacket("Couldn't retrieve the session user id");
        }
        String sUserName = getEntityName(sUserId, PM_NODE_USER);
        if (sUserName == null) {
            return failurePacket("Couldn't retrieve the session user name");
        }
        return getVosGraph(sClientId, PM_VOS_PRES_USER, sUserName, sUserId,
                sSessId, sAnchorId, sAnchorLabel, sAnchorType, sLevel);
    }

    // Function getAdminVosGraph:
    // Obtain a text representation of the Virtual Object System graph - The
    // Admin
    // presentation - for the specified user.
    // The graph is extracted from the PmAdminVosNodeContainer.
    // The graph is returned encoded as a Packet of strings. Each string
    // encodes either a graph node or an arc.
    // A node is encoded as:
    // {c|p|a|u|o|b|c|s}:<id>:<name>,
    // where c denotes the connector node, p denotes policy class, a denotes
    // user attribute, u denotes user, o denotes object attribute associated
    // to an object, b denotes object attribute, s denotes operation set.
    // The <id> is the unique identifier of the PM entity
    // represented by the node, and the <name> is the name of that entity
    // (the name will appear as the node label).
    // An arc from the node identified by <id1> to the node identified by <id2>
    // is encoded as:
    // r:<id1>:<id2>
    // The parameters are:
    // sClientId: the name of the client asking for the graph.
    // sAnchorId: the id of the currently selected node of the sub-graph to be
    // displayed.
    // sAnchorLabel: the label (name) of the currently selected node of the
    // sub-graph
    // to be displayed.
    // sAnchorType: the type of the anchor node. It can be c, p, a, u, b, o.
    // Type o will be converted to b at the beginning of this method.
    // sLevel: the number of node layers above and under the current node that
    // will be displayed.
    // First time a the client asks for the graph AFTER the graph data were
    // obtained with the command "computeVos", the graph starts with the PM
    // as anchor, because at this time the client does not know the id of any
    // node. Each time the engine recalculates the VOS graph, it allocates new
    // ids
    // (even for the connector), to distinguish between graphs for different
    // sessions. We can determine the anchor only by its original id (in the
    // general PM graph), but only the connector node has a known
    // original id (1). At this time we don't keep track of the original ids
    // IN THE CLIENT. Hence, in the first call to this function after a call
    // to computeVos(), the client needs to send the anchor id as 1,
    // and the engine shall look for the node that has pmOriginalId = 1 and
    // pmSessId = the session id. For subsequent calls, the client knows the
    // VOS id of each node.
    private Packet getAdminVosGraph(String sClientId, String sUserName,
                                    String sUserId, String sSessId, String sAnchorId,
                                    String sAnchorLabel, String sAnchorType, String sLevel) {

        if (sAnchorType.equalsIgnoreCase(PM_NODE_ASSOC)) {
            sAnchorType = PM_NODE_OATTR;
        }

        System.out.println("getAdminVosGraph called with anchor "
                + sAnchorLabel + "(" + sAnchorId + ", " + sAnchorType + ")");
        // No VOS id is ever 1. The client sending the anchor id = 1 means the
        // anchor is the connector node, so look for its real VOS id.
        if (sAnchorId.equals(PM_CONNECTOR_ID)) {
            sAnchorId = getAdminVosNodeId(PM_CONNECTOR_ID, sSessId);
            if (sAnchorId == null) {
                return failurePacket("Couldn't get the connector's new id");
            }
            System.out.println("  Anchor was replaced with " + sAnchorId);
        }

        Packet graph = new Packet();

        HashSet<String> visitedSet = new HashSet<String>();
        ArrayList<QueueElement> queue = new ArrayList<QueueElement>();
        QueueElement qe, crtQe;
        String sId = null;
        String sType = null;

        int nMaxLevel = Integer.valueOf(sLevel).intValue();

        // Whenever we insert a node in the queue, we add it to the graph.
        // Start by inserting the anchor's type, id, and level 0 into the queue.
        sType = getAdminVosNodeType(sAnchorId);
        if (sType == null) {
            return failurePacket("Error in getAdminVosNodeType() for admin VOS node "
                    + sAnchorId);
        }
        crtQe = new QueueElement(sType, sAnchorId, 0);
        queue.add(crtQe);

        try {
            addAdminVosNode(graph, sType.toUpperCase(), sAnchorId);
            while (!queue.isEmpty()) {
                crtQe = queue.remove(0);
                if (debugFlag) {
                    System.out.println("Out of queue: " + crtQe.getId());
                }
                if (crtQe.getLevel() < nMaxLevel) {
                    Attribute attr = getAdminVosNodeAscs(crtQe.getId());
                    if (attr != null) {
                        for (NamingEnumeration<?> attrEnum = attr.getAll(); attrEnum.hasMore(); ) {
                            sId = (String) attrEnum.next();
                            if (!visitedSet.contains(sId)) {
                                sType = getAdminVosNodeType(sId);
                                if (sType == null) {
                                    return failurePacket("Error in getVosNodeType(): check AD connection?");
                                }
                                qe = new QueueElement(sType, sId,
                                        crtQe.getLevel() + 1);
                                queue.add(qe);
                                addAdminVosNode(graph, sType, sId);
                                visitedSet.add(sId);
                            }
                            addRel(graph, sId, crtQe.getId());
                        }
                    }
                }
            }
        } catch (NameNotFoundException e) {
            if (debugFlag) {
                e.printStackTrace();
            }
            return failurePacket("Admin VOS Database inconsistency about node "
                    + crtQe.getId() + " or " + sId);
        } catch (CommunicationException e) {
            if (debugFlag) {
                e.printStackTrace();
            }
            return failurePacket("AD connection error");
        } catch (Exception e) {
            if (debugFlag) {
                e.printStackTrace();
            }
            return failurePacket(e.getMessage());
        }

        crtQe = new QueueElement(sAnchorType, sAnchorId, 0);
        queue.add(crtQe);

        try {
            while (!queue.isEmpty()) {
                crtQe = queue.remove(0);
                if (debugFlag) {
                    System.out.println("Out of queue: " + crtQe.getId());
                }
                if (crtQe.getLevel() < nMaxLevel) {
                    Attribute attr = getAdminVosNodeDescs(crtQe.getId());
                    if (attr != null) {
                        for (NamingEnumeration<?> attrEnum = attr.getAll(); attrEnum.hasMore(); ) {
                            sId = (String) attrEnum.next();
                            if (!visitedSet.contains(sId)) {
                                sType = getAdminVosNodeType(sId);
                                if (sType == null) {
                                    return failurePacket("Error in getAdminVosNodeType()");
                                }
                                qe = new QueueElement(sType, sId,
                                        crtQe.getLevel() + 1);
                                queue.add(qe);
                                addAdminVosNode(graph, sType, sId);
                                visitedSet.add(sId);
                            }
                            addRel(graph, crtQe.getId(), sId);
                        }
                    }
                }
            }
        } catch (NameNotFoundException e) {
            if (debugFlag) {
                e.printStackTrace();
            }
            return failurePacket("Database inconsistency");
        } catch (CommunicationException e) {
            if (debugFlag) {
                e.printStackTrace();
            }
            return failurePacket("AD connection error");
        } catch (Exception e) {
            if (debugFlag) {
                e.printStackTrace();
            }
            return failurePacket(e.getMessage());
        }

        return graph;
    }

    // Function getVosGraph:
    // Obtain a text representation of the Virtual Object System graph
    // for the specified user.
    // The graph contains the connector node, policy classes, object attributes
    // that might be accessible to the user.
    // It is extracted from the VOS node container with the name
    // PmVosNodeContainer (kept in the Java variable sVosNodeContainerDN).
    // The graph is returned encoded as a Packet of strings. Each string
    // encodes either a graph node or an arc.
    // A node is encoded as:
    // {p|a|u|o|b|c|s}:<id>:<name>,
    // where p means policy class, u means user, a means user attribute, o means
    // object (actually object attribute associated to the object),
    // b means object attribute, s means operation set, and c means the
    // connector node. The <id> is the unique identifier of the PM entity
    // represented by the node, and the <name> is the name of that entity
    // (the name will appear as the node label).
    // An arc from the node identified by <id1> to the node identified by <id2>
    // is encoded as:
    // r:<id1>:<id2>
    //
    // The parameters are:
    // sClientId: the name of the client asking for the graph.
    // sAnchorId: the id of the currently selected node of the sub-graph to be
    // displayed.
    // sAnchorLabel: the label (name) of the currently selected node of the
    // sub-graph
    // to be displayed.
    // sAnchorType: the type of the anchor node. It can be:
    // p: policy class;
    // b: object attribute;
    // o: object attribute associated to an object, converted to b at the start
    // of this function;
    // c: the connector node.
    // sLevel: the number of node layers above and under the current node that
    // will be displayed.
    // First time a the client asks for the graph AFTER the graph data were
    // obtained with the command "computeVos", the graph starts with the PM
    // as anchor, because at this time the client does not know the id of any
    // node. Each time the engine recalculates the VOS graph, it allocates new
    // ids
    // (even for the connector), to distinguish between graphs for different
    // sessions. We can determine the anchor only by its original id (in the
    // general PM graph), but only the connector node has a known
    // original id (1). At this time we don't keep track of the original ids
    // IN THE CLIENT. Hence, in the first call to this function after a call
    // to computeVos(), the client needs to send the anchor id as 1,
    // and the engine shall look for the node that has pmOriginalId = 1 and
    // pmSessId = the session id. For subsequent calls, the client knows the
    // VOS id of each node.
    private Packet getVosGraph(String sClientId, String sPresType,
                               String sUserName, String sUserId, String sSessId, String sAnchorId,
                               String sAnchorLabel, String sAnchorType, String sLevel) {

        if (sPresType.equalsIgnoreCase(PM_VOS_PRES_ADMIN)) {
            return getAdminVosGraph(sClientId, sUserName, sUserId, sSessId,
                    sAnchorId, sAnchorLabel, sAnchorType, sLevel);
        }

        if (sAnchorType.equalsIgnoreCase(PM_NODE_ASSOC)) {
            sAnchorType = PM_NODE_OATTR;
        }

        // Anchor type can only be b, p, c.
        if (!sAnchorType.equalsIgnoreCase(PM_NODE_OATTR)
                && !sAnchorType.equalsIgnoreCase(PM_NODE_POL)
                && !sAnchorType.equalsIgnoreCase(PM_NODE_CONN)) {
            return failurePacket("Node type incompatible with VOS graph");
        }

        System.out.println("getVosGraph: anchor id = " + sAnchorId);
        if (sAnchorId.equals(PM_CONNECTOR_ID)) {
            sAnchorId = getVosNodeId(PM_CONNECTOR_ID, sSessId);
            System.out.println("getVosGraph: anchor was replaced with "
                    + sAnchorId);
            if (sAnchorId == null) {
                return failurePacket("Couldn't get the connector's new id");
            }
        }

        Packet graph = new Packet();

        HashSet<String> visitedSet = new HashSet<String>();
        ArrayList<QueueElement> queue = new ArrayList<QueueElement>();
        QueueElement qe, crtQe;
        String sId = null;
        String sType = null;

        int nMaxLevel = Integer.valueOf(sLevel).intValue();

        // Whenever we insert a node in the queue, we add it to the graph.
        // Start by inserting the anchor in the queue with level 0.
        sType = getVosNodeType(sAnchorId);
        if (sType == null) {
            return failurePacket("Error in getVosNodeType(): check AD connection?");
        }
        crtQe = new QueueElement(sType, sAnchorId, 0);
        queue.add(crtQe);

        try {
            addVosNode(graph, sType.toUpperCase(), sAnchorId);
            while (!queue.isEmpty()) {
                crtQe = queue.remove(0);
                if (debugFlag) {
                    System.out.println("Out of queue: " + crtQe.getId());
                }
                if (crtQe.getLevel() < nMaxLevel) {

                    if (crtQe.getType().equalsIgnoreCase(PM_NODE_OATTR)
                            || crtQe.getType().equalsIgnoreCase(PM_NODE_ASSOC)) {
                        // The current VOS node is an OBJECT ATTRIBUTE NODE.
                        // Its ascendants can only be object attributes.
                        Attribute attr = getVosNodeAscs(crtQe.getId());
                        if (attr != null) {
                            for (NamingEnumeration<?> attrEnum = attr.getAll(); attrEnum.hasMore(); ) {
                                sId = (String) attrEnum.next();
                                if (!visitedSet.contains(sId)) {
                                    sType = getVosNodeType(sId);
                                    if (sType == null) {
                                        return failurePacket("Error in getVosNodeType(): check AD connection?");
                                    }
                                    qe = new QueueElement(sType, sId,
                                            crtQe.getLevel() + 1);
                                    queue.add(qe);
                                    addVosNode(graph, sType, sId);
                                    visitedSet.add(sId);
                                }
                                addRel(graph, sId, crtQe.getId());
                            }
                        }

                    } else if (crtQe.getType().equalsIgnoreCase(PM_NODE_POL)) {
                        // The current VOS node is a POLICY CLASS NODE.
                        // Its ascendants can only be object attributes.
                        Attribute attr = getVosNodeAscs(crtQe.getId());
                        if (attr != null) {
                            for (NamingEnumeration<?> attrEnum = attr.getAll(); attrEnum.hasMore(); ) {
                                sId = (String) attrEnum.next();
                                if (!visitedSet.contains(sId)) {
                                    sType = getVosNodeType(sId);
                                    if (sType == null) {
                                        return failurePacket("Error in getVosNodeType(): check AD connection?");
                                    }
                                    qe = new QueueElement(sType, sId,
                                            crtQe.getLevel() + 1);
                                    queue.add(qe);
                                    addVosNode(graph, sType, sId);
                                    visitedSet.add(sId);
                                }
                                addRel(graph, sId, crtQe.getId());
                            }
                        }

                    } else if (crtQe.getType().equalsIgnoreCase(PM_NODE_CONN)) {
                        // The current VOS node is the CONNECTOR NODE.
                        // Its ascendants can only be policy classes.
                        Attribute attr = getVosNodeAscs(crtQe.getId());
                        if (attr != null) {
                            for (NamingEnumeration<?> attrEnum = attr.getAll(); attrEnum.hasMore(); ) {
                                sId = (String) attrEnum.next();
                                if (!visitedSet.contains(sId)) {
                                    qe = new QueueElement(PM_NODE_POL, sId,
                                            crtQe.getLevel() + 1);
                                    queue.add(qe);
                                    addVosNode(graph, PM_NODE_POL, sId);
                                    visitedSet.add(sId);
                                }
                                addRel(graph, sId, crtQe.getId());
                            }
                        }
                    }
                }
            }
        } catch (NameNotFoundException e) {
            if (debugFlag) {
                e.printStackTrace();
            }
            return failurePacket("VOS Database inconsistency about node "
                    + crtQe.getId() + " or " + sId);
        } catch (CommunicationException e) {
            if (debugFlag) {
                e.printStackTrace();
            }
            return failurePacket("AD connection error");
        } catch (Exception e) {
            if (debugFlag) {
                e.printStackTrace();
            }
            return failurePacket(e.getMessage());
        }

        crtQe = new QueueElement(sAnchorType, sAnchorId, 0);
        queue.add(crtQe);

        try {
            while (!queue.isEmpty()) {
                crtQe = queue.remove(0);
                if (debugFlag) {
                    System.out.println("Out of queue: " + crtQe.getId());
                }
                if (crtQe.getLevel() < nMaxLevel) {

                    if (crtQe.getType().equalsIgnoreCase(PM_NODE_OATTR)
                            || crtQe.getType().equalsIgnoreCase(PM_NODE_ASSOC)) {
                        // The current VOS node is an OBJECT ATTRIBUTE NODE.
                        // Its descendants can be object attributes or policy
                        // classes.
                        Attribute attr = getVosNodeDescs(crtQe.getId());
                        if (attr != null) {
                            for (NamingEnumeration<?> attrEnum = attr.getAll(); attrEnum.hasMore(); ) {
                                sId = (String) attrEnum.next();
                                if (!visitedSet.contains(sId)) {
                                    sType = getVosNodeType(sId);
                                    if (sType == null) {
                                        return failurePacket("Error in getVosNodeType(): check AD connection?");
                                    }
                                    qe = new QueueElement(sType, sId,
                                            crtQe.getLevel() + 1);
                                    queue.add(qe);
                                    addVosNode(graph, sType, sId);
                                    visitedSet.add(sId);
                                }
                                addRel(graph, crtQe.getId(), sId);
                            }
                        }
                    } else if (crtQe.getType().equalsIgnoreCase(PM_NODE_POL)) {
                        // POLICY CLASS NODE.
                        // Its (only) descendant is the connector node.
                        Attribute attr = getVosNodeDescs(crtQe.getId());
                        if (attr != null) {
                            for (NamingEnumeration<?> attrEnum = attr.getAll(); attrEnum.hasMore(); ) {
                                sId = (String) attrEnum.next();
                                if (!visitedSet.contains(sId)) {
                                    sType = getVosNodeType(sId);
                                    if (sType == null) {
                                        return failurePacket("Error in getVosNodeType(): check AD connection?");
                                    }
                                    addVosNode(graph, sType, sId);
                                    visitedSet.add(sId);
                                }
                                addRel(graph, crtQe.getId(), sId);
                            }
                        }
                    }
                }
            }
        } catch (NameNotFoundException e) {
            if (debugFlag) {
                e.printStackTrace();
            }
            return failurePacket("Database inconsistency");
        } catch (CommunicationException e) {
            if (debugFlag) {
                e.printStackTrace();
            }
            return failurePacket("AD connection error");
        } catch (Exception e) {
            if (debugFlag) {
                e.printStackTrace();
            }
            return failurePacket(e.getMessage());
        }

        return graph;
    }

    // Get the startups for the user of the session passed as argument.
    // If the session does not have predefined startups, return null.
    // Also if we encounter an error we return null.
    private Attribute getPosStartups(String sSessId) {
        String sUserId = getSessionUserId(sSessId);
        Attributes attrs = null;
        try {
            attrs = ctx.getAttributes("CN=" + sUserId + ","
                    + sStartupContainerDN);
        } catch (Exception e) {
            e.printStackTrace();
            return null;
        }
        Attribute attr = attrs.get("pmStartup");
        if (attr == null) {
            return null;
        }
        if (attr.size() == 0) {
            return null;
        }
        try {
            Attribute newAttr = new BasicAttribute("pmUnknown");
            for (NamingEnumeration<?> attrEnum = attr.getAll(); attrEnum.hasMore(); ) {
                String sOrigId = (String) attrEnum.next();
                System.out.println("In getPosStartup found origid=" + sOrigId);
                String sPosId = getVosNodeId(sOrigId, sSessId);
                newAttr.add(sPosId);
            }
            return newAttr;
        } catch (Exception e) {
            e.printStackTrace();
            return null;
        }
    }

    // For a given VOS node, return its direct ascendants.
    // sId is the real (new) id of the VOS node.
    private Attribute getVosNodeAscs(String sId) {
        try {
            Attributes attrs = ctx.getAttributes("CN=" + sId + ","
                    + sVosNodeContainerDN);
            Attribute attr = attrs.get("pmAscNode");
            return attr;
        } catch (Exception e) {
            if (debugFlag) {
                e.printStackTrace();
            }
            return null;
        }
    }

    // For a given VOS node, return its direct descendants.
    // sId is the real (new) id of the VOS node.
    private Attribute getVosNodeDescs(String sId) {
        try {
            Attributes attrs = ctx.getAttributes("CN=" + sId + ","
                    + sVosNodeContainerDN);
            Attribute attr = attrs.get("pmDescNode");
            return attr;
        } catch (Exception e) {
            if (debugFlag) {
                e.printStackTrace();
            }
            return null;
        }
    }

    // For a given VOS node, return its name.
    // The parameter sId is the real (new) id of the VOS node.
    private String getVosNodeName(String sId) {
        try {
            Attributes attrs = ctx.getAttributes("CN=" + sId + ","
                    + sVosNodeContainerDN);
            return (String) attrs.get("pmOriginalName").get();
        } catch (Exception e) {
            if (debugFlag) {
                e.printStackTrace();
            }
            return null;
        }
    }

    // For a given VOS node, return its type.
    // sId is the new id of the VOS node.
    private String getVosNodeType(String sId) {
        try {
            Attributes attrs = ctx.getAttributes("CN=" + sId + ","
                    + sVosNodeContainerDN);
            String sClass = (String) attrs.get("pmObjClass").get();
            if (sClass.equals(sConnectorClass)) {
                return PM_NODE_CONN;
            } else if (sClass.equals(sPolicyClass)) {
                return PM_NODE_POL;
            } else if (sClass.equals(sObjAttrClass)) {
                String sAssoc = (String) attrs.get("pmIsObj").get();
                if (sAssoc.equalsIgnoreCase("true")) {
                    return PM_NODE_ASSOC;
                } else {
                    return PM_NODE_OATTR;
                }
            }
            return null;
        } catch (Exception e) {
            if (debugFlag) {
                e.printStackTrace();
            }
            return null;
        }
    }

    // Given a VOS node's original id and the session id, returns the new id
    // of that VOS node.
    private String getVosNodeId(String sOrigId, String sSessId) {
        NamingEnumeration<?> nodes;

        try {
            SearchControls constraints = new SearchControls();
            constraints.setSearchScope(SearchControls.ONELEVEL_SCOPE);
            constraints.setReturningAttributes(new String[]{"pmId"});
            nodes = ctx.search(sVosNodeContainerDN, "(&(pmOriginalId="
                    + sOrigId + ")(pmSessId=" + sSessId + "))", constraints);
        } catch (Exception e) {
            if (debugFlag) {
                e.printStackTrace();
            }
            return null;
        }
        try {
            if (nodes == null || !nodes.hasMore()) {
                return null;
            }
            SearchResult sr = (SearchResult) nodes.next();
            return (String) sr.getAttributes().get("pmId").get();
        } catch (Exception e) {
            if (debugFlag) {
                e.printStackTrace();
            }
            return null;
        }
    }

    // Obtain a text representation of the policy machine graph containing
    // users,
    // objects, operation sets, attributes, and their relations for all policy
    // classes.
    // The graph is returned encoded as a Packet of strings. Each string
    // encodes either a graph node or an arc.
    // A node is encoded as:
    // {p|u|a|o|b|s|c}:<id>:<name>,
    // where p means policy class, u means user, a means user attribute, o means
    // object (actually object attribute associated to the object),
    // b means object attribute, s means operation set, and c means the
    // connector node. The <id> is the unique identifier of the PM entity
    // represented by the node, and the <name> is the name of that entity
    // (the name will appear as the node label).
    // An arc from the node identified by <id1> to the node identified by <id2>
    // is encoded as:
    // r:<id1>:<id2>
    //
    // The parameters are:
    // sClientId: the name of the client asking for the graph.
    // sType: the type of graph desired. It can be:
    // ua: user attributes (including policy classes and users);
    // ca: user attributes with capabilities;
    // oa: object attributes (including policy classes);
    // ac: object attributes with access control entries;
    // pe: permissions (operation sets with assigned user and object attributes.
    // sAnchorId: the id of the currently selected node of the sub-graph to be
    // displayed.
    // sAnchorLabel: the label (name) of the currently selected node of the
    // sub-graph
    // to be displayed.
    // sAnchorType: the type of the anchor node. It can be:
    // u: user;
    // a: user attribute;
    // p: policy class;
    // b: object attribute;
    // o: object attribute associated to an object, converted to b at the start
    // of this function;
    // s: operation set;
    // c: the connector node.
    // sLevel: the number of node layers above and under the current node that
    // will be displayed.
    // NOTE: IT COULD HAPPEN THAT THE ANCHOR NODE (selectedNode in the client)
    // DOES NOT EXIST ANYMORE BECAUSE IT WAS DELETED JUST PRIOR TO DRAWING THE
    // GRAPH. IN THIS CASE WE USE THE CONNECTOR NODE AS ANCHOR.
    private Packet getGraph(String sClientId, String sGraphType,
                            String sAnchorId, String sAnchorLabel, String sAnchorType,
                            String sLevel) {
        if (sAnchorType.equalsIgnoreCase(PM_NODE_ASSOC)) {
            sAnchorType = PM_NODE_OATTR;
        }

        if (sAnchorId == null) {
            sAnchorId = getEntityId(sAnchorLabel, sAnchorType);
            if (sAnchorId == null) {
                sAnchorId = PM_CONNECTOR_ID;
                sAnchorLabel = PM_CONNECTOR_NAME;
                sAnchorType = PM_NODE_CONN;
            }
        } else {
            if (!entityExists(sAnchorId, sAnchorType)) {
                sAnchorId = PM_CONNECTOR_ID;
                sAnchorLabel = PM_CONNECTOR_NAME;
                sAnchorType = PM_NODE_CONN;
            }
        }

        if (sGraphType.equalsIgnoreCase(PM_GRAPH_UATTR)) {
            return getUattrGraph(sAnchorId, sAnchorLabel, sAnchorType, sLevel);
        } else if (sGraphType.equalsIgnoreCase(PM_GRAPH_CAPS)) {
            return getCapsGraph(sAnchorId, sAnchorLabel, sAnchorType, sLevel);
        } else if (sGraphType.equalsIgnoreCase(PM_GRAPH_OATTR)) {
            return getOattrGraph(sAnchorId, sAnchorLabel, sAnchorType, sLevel);
        } else if (sGraphType.equalsIgnoreCase(PM_GRAPH_ACES)) {
            return getAcesGraph(sAnchorId, sAnchorLabel, sAnchorType, sLevel);
        } else if (sGraphType.equalsIgnoreCase(PM_GRAPH_PERMS)) {
            return getPermsGraph(sAnchorId, sAnchorLabel, sAnchorType, sLevel);
        } else {
            return failurePacket("Invalid graph type");
        }
    }

    // Get the text representation for a PM_GRAPH_UATTR view of the PM graph.
    // The nodes can be of types PM_NODE_USER, PM_NODE_UATTR, PM_NODE_POL,
    // PM_NODE_CONN.
    private Packet getUattrGraph(String sAnchorId, String sAnchorLabel,
                                 String sAnchorType, String sLevel) {
        // Anchor type can only be u, a, p, c.
        if (!sAnchorType.equalsIgnoreCase(PM_NODE_USER)
                && !sAnchorType.equalsIgnoreCase(PM_NODE_UATTR)
                && !sAnchorType.equalsIgnoreCase(PM_NODE_POL)
                && !sAnchorType.equalsIgnoreCase(PM_NODE_CONN)) {
            return failurePacket("Node type incompatible with graph view");
        }

        Packet graph = new Packet();

        HashSet<String> visitedSet = new HashSet<String>();
        ArrayList<QueueElement> queue = new ArrayList<QueueElement>();
        QueueElement qe, crtQe;
        String sId = null;

        int nMaxLevel = Integer.valueOf(sLevel).intValue();

        // Whenever we insert a node in the queue, we add it to the graph.
        // Start by inserting the anchor in the queue with level 0
        crtQe = new QueueElement(sAnchorType, sAnchorId, 0);
        queue.add(crtQe);

        try {
            addNode(graph, sAnchorType.toUpperCase(), sAnchorId);
            while (!queue.isEmpty()) {
                crtQe = queue.remove(0);
                if (debugFlag) {
                    System.out.println("Out of queue: " + crtQe.getId());
                }
                if (crtQe.getLevel() < nMaxLevel) {

                    if (crtQe.getType().equalsIgnoreCase(PM_NODE_UATTR)) {
                        // USER ATTRIBUTE NODE.

                        // First, let's count how many ascendants (user
                        // attributes and users).
                        // If more than nMaxDspAscs, make a fake node
                        // with the name "Members_of_<crtQe.getName>", output it
                        // and
                        // its assignment to the crt node.
                        int n = getAscsCount(crtQe, PM_GRAPH_UATTR, false);
                        if (debugFlag) {
                            System.out.println("Node "
                                    + getEntityName(crtQe.getId(),
                                    crtQe.getType()) + " has " + n
                                    + " ascendants.");
                        }
                        if (n > nMaxDspAscs) {
                            // Add the "Members_of_..." node and its assignment
                            // to crtQe.
                            addMembersOfNode(graph, crtQe.getType(),
                                    crtQe.getId());

                        } else {

                            // Process the users assigned to this user
                            // attribute.
                            Attribute attr = getFromUsers(crtQe);
                            if (attr != null) {
                                for (NamingEnumeration<?> attrEnum = attr.getAll(); attrEnum.hasMore(); ) {
                                    sId = (String) attrEnum.next();
                                    if (!visitedSet.contains(sId)) {
                                        qe = new QueueElement(PM_NODE_USER,
                                                sId, crtQe.getLevel() + 1);
                                        queue.add(qe);
                                        addNode(graph, PM_NODE_USER, sId);
                                        visitedSet.add(sId);
                                    }
                                    addRel(graph, sId, crtQe.getId());
                                }
                            }
                            // Process the user attributes assigned to this user
                            // attribute.
                            attr = getFromAttrs(crtQe);
                            if (attr != null) {
                                for (NamingEnumeration<?> attrEnum = attr.getAll(); attrEnum.hasMore(); ) {
                                    sId = (String) attrEnum.next();
                                    if (!visitedSet.contains(sId)) {
                                        qe = new QueueElement(PM_NODE_UATTR,
                                                sId, crtQe.getLevel() + 1);
                                        queue.add(qe);
                                        addNode(graph, PM_NODE_UATTR, sId);
                                        visitedSet.add(sId);
                                    }
                                    addRel(graph, sId, crtQe.getId());
                                }
                            }
                        }

                    } else if (crtQe.getType().equalsIgnoreCase(PM_NODE_POL)) {
                        // POLICY CLASS NODE.

                        // First count the direct ascendants of the policy.
                        int n = getAscsCount(crtQe, PM_GRAPH_UATTR, false);
                        if (debugFlag) {
                            System.out.println("Node "
                                    + getEntityName(crtQe.getId(),
                                    crtQe.getType()) + " has " + n
                                    + " ascendants.");
                        }
                        if (n > nMaxDspAscs) {
                            // Add the "Members_of_..." node and its assignment
                            // to crtQe.
                            addMembersOfNode(graph, crtQe.getType(),
                                    crtQe.getId());

                        } else {

                            // Process user attributes assigned to it.
                            Attribute attr = getFromUserAttrs(crtQe);
                            if (attr != null) {
                                for (NamingEnumeration<?> attrEnum = attr.getAll(); attrEnum.hasMore(); ) {
                                    sId = (String) attrEnum.next();
                                    if (!visitedSet.contains(sId)) {
                                        qe = new QueueElement(PM_NODE_UATTR,
                                                sId, crtQe.getLevel() + 1);
                                        queue.add(qe);
                                        addNode(graph, PM_NODE_UATTR, sId);
                                        visitedSet.add(sId);
                                    }
                                    addRel(graph, sId, crtQe.getId());
                                }
                            }
                        }

                    } else if (crtQe.getType().equalsIgnoreCase(PM_NODE_CONN)) {
                        // CONNECTOR NODE.

                        // First count the direct ascendants of the connector.
                        int n = getAscsCount(crtQe, PM_GRAPH_UATTR, false);
                        if (debugFlag) {
                            System.out.println("Node "
                                    + getEntityName(crtQe.getId(),
                                    crtQe.getType()) + " has " + n
                                    + " ascendants.");
                        }
                        if (n > nMaxDspAscs) {
                            // Add the "Members_of_..." node and its assignment
                            // to crtQe.
                            addMembersOfNode(graph, crtQe.getType(),
                                    crtQe.getId());

                        } else {

                            // Process user attributes assigned to the connector
                            // node.
                            Attribute attr = getFromUserAttrs(crtQe);
                            if (attr != null) {
                                for (NamingEnumeration<?> attrEnum = attr.getAll(); attrEnum.hasMore(); ) {
                                    sId = (String) attrEnum.next();
                                    if (!visitedSet.contains(sId)) {
                                        qe = new QueueElement(PM_NODE_UATTR,
                                                sId, crtQe.getLevel() + 1);
                                        queue.add(qe);
                                        addNode(graph, PM_NODE_UATTR, sId);
                                        visitedSet.add(sId);
                                    }
                                    addRel(graph, sId, crtQe.getId());
                                }
                            }

                            // Process the users assigned to the connector node.
                            attr = getFromUsers(crtQe);
                            if (attr != null) {
                                for (NamingEnumeration<?> attrEnum = attr.getAll(); attrEnum.hasMore(); ) {
                                    sId = (String) attrEnum.next();
                                    if (!visitedSet.contains(sId)) {
                                        qe = new QueueElement(PM_NODE_USER,
                                                sId, crtQe.getLevel() + 1);
                                        queue.add(qe);
                                        addNode(graph, PM_NODE_USER, sId);
                                        visitedSet.add(sId);
                                    }
                                    addRel(graph, sId, crtQe.getId());
                                }
                            }

                            // Process the policy classes assigned to the
                            // connector node.
                            attr = getFromPolicies(crtQe);
                            if (attr != null) {
                                for (NamingEnumeration<?> attrEnum = attr.getAll(); attrEnum.hasMore(); ) {
                                    sId = (String) attrEnum.next();

                                    // vincent:
                                    // if (sId.equalsIgnoreCase("2")) continue;

                                    if (!visitedSet.contains(sId)) {
                                        qe = new QueueElement(PM_NODE_POL, sId,
                                                crtQe.getLevel() + 1);
                                        queue.add(qe);
                                        addNode(graph, PM_NODE_POL, sId);
                                        visitedSet.add(sId);
                                    }
                                    addRel(graph, sId, crtQe.getId());
                                }
                            }
                        }
                    }
                }
            }
        } catch (NameNotFoundException e) {
            if (debugFlag) {
                e.printStackTrace();
            }
            return failurePacket("Database inconsistency about node "
                    + crtQe.getId() + " or " + sId);
        } catch (CommunicationException e) {
            if (debugFlag) {
                e.printStackTrace();
            }
            return failurePacket("AD connection error");
        } catch (Exception e) {
            if (debugFlag) {
                e.printStackTrace();
            }
            return failurePacket(e.getMessage());
        }

        crtQe = new QueueElement(sAnchorType, sAnchorId, 0);
        queue.add(crtQe);

        try {
            while (!queue.isEmpty()) {
                crtQe = queue.remove(0);
                if (debugFlag) {
                    System.out.println("Out of queue: " + crtQe.getId());
                }
                if (crtQe.getLevel() < nMaxLevel) {

                    if (crtQe.getType().equalsIgnoreCase(PM_NODE_UATTR)) {
                        // USER ATTRIBUTE NODE.
                        // Process the user attributes this user attribute is
                        // assigned to.
                        Attribute attr = getToAttrs(crtQe);
                        if (attr != null) {
                            for (NamingEnumeration<?> attrEnum = attr.getAll(); attrEnum.hasMore(); ) {
                                sId = (String) attrEnum.next();
                                if (!visitedSet.contains(sId)) {
                                    qe = new QueueElement(PM_NODE_UATTR, sId,
                                            crtQe.getLevel() + 1);
                                    queue.add(qe);
                                    addNode(graph, PM_NODE_UATTR, sId);
                                    visitedSet.add(sId);
                                }
                                addRel(graph, crtQe.getId(), sId);
                            }
                        }
                        // Process the policy classes this user attribute is
                        // assigned to.
                        attr = getToPolicies(crtQe);
                        if (attr != null) {
                            for (NamingEnumeration<?> attrEnum = attr.getAll(); attrEnum.hasMore(); ) {
                                sId = (String) attrEnum.next();
                                if (!visitedSet.contains(sId)) {
                                    qe = new QueueElement(PM_NODE_POL, sId,
                                            crtQe.getLevel() + 1);
                                    queue.add(qe);
                                    addNode(graph, PM_NODE_POL, sId);
                                    visitedSet.add(sId);
                                }
                                addRel(graph, crtQe.getId(), sId);
                            }
                        }
                        // Process the connector node if this user attribute is
                        // assigned to it.
                        if (attrIsAssignedToConnector(crtQe.getId(),
                                PM_NODE_UATTR)) {
                            if (!visitedSet.contains(PM_CONNECTOR_ID)) {
                                qe = new QueueElement(PM_NODE_CONN,
                                        PM_CONNECTOR_ID, crtQe.getLevel() + 1);
                                queue.add(qe);
                                addNode(graph, PM_NODE_CONN, PM_CONNECTOR_ID);
                                visitedSet.add(PM_CONNECTOR_ID);
                            }
                            addRel(graph, crtQe.getId(), PM_CONNECTOR_ID);
                        }

                    } else if (crtQe.getType().equalsIgnoreCase(PM_NODE_USER)) {
                        // USER NODE.
                        // Process user attributes this user is assigned to.
                        Attribute attr = getToAttrs(crtQe);
                        if (attr != null) {
                            for (NamingEnumeration<?> attrEnum = attr.getAll(); attrEnum.hasMore(); ) {
                                sId = (String) attrEnum.next();
                                if (!visitedSet.contains(sId)) {
                                    qe = new QueueElement(PM_NODE_UATTR, sId,
                                            crtQe.getLevel() + 1);
                                    queue.add(qe);
                                    addNode(graph, PM_NODE_UATTR, sId);
                                    visitedSet.add(sId);
                                }
                                addRel(graph, crtQe.getId(), sId);
                            }
                        }

                        // Process the connector node if this user is assigned
                        // to it.
                        if (userIsAssignedToConnector(crtQe.getId())) {
                            if (!visitedSet.contains(PM_CONNECTOR_ID)) {
                                qe = new QueueElement(PM_NODE_CONN,
                                        PM_CONNECTOR_ID, crtQe.getLevel() + 1);
                                queue.add(qe);
                                addNode(graph, PM_NODE_CONN, PM_CONNECTOR_ID);
                                visitedSet.add(PM_CONNECTOR_ID);
                            }
                            addRel(graph, crtQe.getId(), PM_CONNECTOR_ID);
                        }

                    } else if (crtQe.getType().equalsIgnoreCase(PM_NODE_POL)) {
                        // POLICY CLASS NODE.
                        // Process the connector node.
                        if (!visitedSet.contains(PM_CONNECTOR_ID)) {
                            qe = new QueueElement(PM_NODE_CONN,
                                    PM_CONNECTOR_ID, crtQe.getLevel() + 1);
                            queue.add(qe);
                            addNode(graph, PM_NODE_CONN, PM_CONNECTOR_ID);
                            visitedSet.add(PM_CONNECTOR_ID);
                        }
                        addRel(graph, crtQe.getId(), PM_CONNECTOR_ID);
                    }
                }
            }
        } catch (NameNotFoundException e) {
            if (debugFlag) {
                e.printStackTrace();
            }
            return failurePacket("Database inconsistency");
        } catch (CommunicationException e) {
            if (debugFlag) {
                e.printStackTrace();
            }
            return failurePacket("AD connection error");
        } catch (Exception e) {
            if (debugFlag) {
                e.printStackTrace();
            }
            return failurePacket(e.getMessage());
        }

        // graph.add(PM_EOD);
        return graph;
    }

    // Nodes of type object attribute and object attribute anchor,
    // (i.e., PM_NODE_OATTR, PM_NODE_OATTRA) may be associated to
    // objects. In this case, change their type to PM_NODE_ASSOC
    // and PM_NODE_ASSOCA respectively.
    private String getTrueType(String sId, String sType) {
        boolean a = sType.equals(PM_NODE_OATTR);
        boolean b = sType.equals(PM_NODE_OATTRA);
        if (a || b) {
            if (hasAssocObj(sId)) {
                if (a) {
                    return PM_NODE_ASSOC;
                } else {
                    return PM_NODE_ASSOCA;
                }
            }
        }
        return sType;
    }

    // Add a node representing the members of a container. sNodeType and sNodeId
    // are the type (user attribute, object attribute, policy, or connector)
    // and id of the container.
    private void addMembersOfNode(Packet graph, String sNodeType, String sNodeId) {
        // Build the new node.
        String sLabel = "Members of " + getEntityName(sNodeId, sNodeType);
        RandomGUID myGUID = new RandomGUID();
        String sId = myGUID.toStringNoDashes();
        String sType = PM_NODE_M_PREFIX + sNodeType;
        StringBuffer sb = new StringBuffer();
        try {
            sb.append(sType);
            sb.append(PM_FIELD_DELIM);
            sb.append(sId);
            sb.append(PM_FIELD_DELIM);
            sb.append(sLabel);
            graph.addItem(ItemType.RESPONSE_TEXT, sb.toString());

            // Assign it to the container.
            sb = new StringBuffer();
            sb.append(PM_ARC);
            sb.append(PM_FIELD_DELIM);
            sb.append(sId);
            sb.append(PM_FIELD_DELIM);
            sb.append(sNodeId);
            graph.addItem(ItemType.RESPONSE_TEXT, sb.toString());
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    // Add a node to the text representation of the graph.
    // If the node type is PM_NODE_OATTR or PM_NODE_OATTRA, i.e., an object
    // attribute,
    // check whether it's associated to an object. If yes, change its type to
    // PM_NODE_ASSOC or PM_NODE_ASSOCA respectively.
    private void addNode(Packet graph, String sType, String sId)
            throws Exception {
        // First get the node label, which is the node name (AD attribute
        // "pmName").
        String sLabel = getEntityName(sId, sType);
        StringBuffer sb = new StringBuffer();
        sb.append(sType);
        sb.append(PM_FIELD_DELIM);
        sb.append(sId);
        sb.append(PM_FIELD_DELIM);
        sb.append(sLabel);
        graph.addItem(ItemType.RESPONSE_TEXT, sb.toString());
    }

    private void addSelVosNode(Packet graph, String sType, String sId,
                               Set<String> hs) throws Exception {
        // First get the node label, which is the node name (AD attribute
        // "pmName").
        String sLabel = getEntityName(sId, sType);
        StringBuffer sb = new StringBuffer();
        sb.append(sType);
        sb.append(PM_FIELD_DELIM);
        sb.append(sId);
        sb.append(PM_FIELD_DELIM);
        sb.append(sLabel);
        if (hs.contains(sId)) {
            sb.append(PM_FIELD_DELIM);
            sb.append(PM_SELECTED);
        }
        graph.addItem(ItemType.RESPONSE_TEXT, sb.toString());
    }

    private void addSelVosNode2(Packet graph, String sType, String sId,
                                Set<String> hs) throws Exception {
        // First get the node label, which is the node name (AD attribute
        // "pmName").
        String sLabel = getVosNodeName(sId);
        StringBuffer sb = new StringBuffer();
        sb.append(sType);
        sb.append(PM_FIELD_DELIM);
        sb.append(sId);
        sb.append(PM_FIELD_DELIM);
        sb.append(sLabel);
        if (hs.contains(sId)) {
            sb.append(PM_FIELD_DELIM);
            sb.append(PM_SELECTED);
        }
        graph.addItem(ItemType.RESPONSE_TEXT, sb.toString());
    }

    private void addVosNode(Packet graph, String sType, String sId)
            throws Exception {
        String sLabel = getVosNodeName(sId);
        StringBuffer sb = new StringBuffer();
        sb.append(sType);
        sb.append(PM_FIELD_DELIM);
        sb.append(sId);
        sb.append(PM_FIELD_DELIM);
        sb.append(sLabel);
        graph.addItem(ItemType.RESPONSE_TEXT, sb.toString());
    }

    private void addRel(Packet graph, String sId1, String sId2)
            throws Exception {
        StringBuffer sb = new StringBuffer();
        sb.append(PM_ARC);
        sb.append(PM_FIELD_DELIM);
        sb.append(sId1);
        sb.append(PM_FIELD_DELIM);
        sb.append(sId2);
        graph.addItem(ItemType.RESPONSE_TEXT, sb.toString());
    }

    // The nodes "discovered" by this function can have the type:
    // PM_NODE_USER, PM_NODE_UATTR, PM_NODE_POL, PM_NODE_CONN, PM_NODE_OPSET,
    // and PM_NODE_OATTR. All except PM_NODE_OATTR can be anchors.
    // We only visit PM_NODE_OPSET nodes assigned to the anchor (which
    // can be PM_NODE_UATTR or PM_NODE_CONN).
    private Packet getCapsGraph(String sAnchorId, String sAnchorLabel,
                                String sAnchorType, String sLevel) {
        if (!sAnchorType.equalsIgnoreCase(PM_NODE_USER)
                && !sAnchorType.equalsIgnoreCase(PM_NODE_UATTR)
                && !sAnchorType.equalsIgnoreCase(PM_NODE_POL)
                && !sAnchorType.equalsIgnoreCase(PM_NODE_CONN)
                && !sAnchorType.equalsIgnoreCase(PM_NODE_OPSET)) {
            return failurePacket("Node type incompatible with graph view");
        }

        Packet graph = new Packet();

        HashSet<String> visitedSet = new HashSet<String>();
        ArrayList<QueueElement> queue = new ArrayList<QueueElement>();
        QueueElement qe, crtQe;
        String sId = null;
        String sType = null;

        int nMaxLevel = Integer.valueOf(sLevel).intValue();

        // Whenever we insert a node in the queue, we add it to the graph.
        // Start by inserting the anchor in the queue with level 0
        crtQe = new QueueElement(sAnchorType, sAnchorId, 0);
        queue.add(crtQe);

        try {
            addNode(graph, sAnchorType.toUpperCase(), sAnchorId);
            while (!queue.isEmpty()) {
                crtQe = queue.remove(0);
                if (debugFlag) {
                    System.out.println("Out of queue: " + crtQe.getId());
                }
                if (crtQe.getLevel() < nMaxLevel) {

                    if (crtQe.getType().equalsIgnoreCase(PM_NODE_UATTR)) {
                        // USER ATTRIBUTE NODE.

                        int n = getAscsCount(crtQe, PM_GRAPH_CAPS, false);
                        if (debugFlag) {
                            System.out.println("Node "
                                    + getEntityName(crtQe.getId(),
                                    crtQe.getType()) + " has " + n
                                    + " ascendants.");
                        }
                        if (n > nMaxDspAscs) {
                            // Add the "Members_of_..." node and its assignment
                            // to crtQe.
                            addMembersOfNode(graph, crtQe.getType(),
                                    crtQe.getId());

                        } else {

                            // Process the users assigned to this user
                            // attribute.
                            Attribute attr = getFromUsers(crtQe);
                            if (attr != null) {
                                for (NamingEnumeration<?> attrEnum = attr.getAll(); attrEnum.hasMore(); ) {
                                    sId = (String) attrEnum.next();
                                    if (!visitedSet.contains(sId)) {
                                        qe = new QueueElement(PM_NODE_USER,
                                                sId, crtQe.getLevel() + 1);
                                        queue.add(qe);
                                        addNode(graph, PM_NODE_USER, sId);
                                        visitedSet.add(sId);
                                    }
                                    addRel(graph, sId, crtQe.getId());
                                }
                            }

                            // Process the user attributes assigned to this user
                            // attribute.
                            attr = getFromAttrs(crtQe);
                            if (attr != null) {
                                for (NamingEnumeration<?> attrEnum = attr.getAll(); attrEnum.hasMore(); ) {
                                    sId = (String) attrEnum.next();
                                    if (!visitedSet.contains(sId)) {
                                        qe = new QueueElement(PM_NODE_UATTR,
                                                sId, crtQe.getLevel() + 1);
                                        queue.add(qe);
                                        addNode(graph, PM_NODE_UATTR, sId);
                                        visitedSet.add(sId);
                                    }
                                    addRel(graph, sId, crtQe.getId());
                                }
                            }
                        }

                    } else if (crtQe.getType().equalsIgnoreCase(PM_NODE_POL)) {
                        // POLICY CLASS NODE.

                        int n = getAscsCount(crtQe, PM_GRAPH_CAPS, false);
                        if (debugFlag) {
                            System.out.println("Node "
                                    + getEntityName(crtQe.getId(),
                                    crtQe.getType()) + " has " + n
                                    + " ascendants.");
                        }
                        if (n > nMaxDspAscs) {
                            // Add the "Members_of_..." node and its assignment
                            // to crtQe.
                            addMembersOfNode(graph, crtQe.getType(),
                                    crtQe.getId());

                        } else {

                            // Process user attributes assigned to it.
                            Attribute attr = getFromUserAttrs(crtQe);
                            if (attr != null) {
                                for (NamingEnumeration<?> attrEnum = attr.getAll(); attrEnum.hasMore(); ) {
                                    sId = (String) attrEnum.next();
                                    if (!visitedSet.contains(sId)) {
                                        qe = new QueueElement(PM_NODE_UATTR,
                                                sId, crtQe.getLevel() + 1);
                                        queue.add(qe);
                                        addNode(graph, PM_NODE_UATTR, sId);
                                        visitedSet.add(sId);
                                    }
                                    addRel(graph, sId, crtQe.getId());
                                }
                            }
                        }

                    } else if (crtQe.getType().equalsIgnoreCase(PM_NODE_CONN)) {
                        // CONNECTOR NODE.

                        int n = getAscsCount(crtQe, PM_GRAPH_CAPS,
                                sAnchorId.equalsIgnoreCase(PM_CONNECTOR_ID));
                        if (debugFlag) {
                            System.out.println("Node "
                                    + getEntityName(crtQe.getId(),
                                    crtQe.getType()) + " has " + n
                                    + " ascendants.");
                        }
                        if (n > nMaxDspAscs) {
                            // Add the "Members_of_..." node and its assignment
                            // to crtQe.
                            addMembersOfNode(graph, crtQe.getType(),
                                    crtQe.getId());

                        } else {

                            // Process user attributes assigned to the connector
                            // node.
                            Attribute attr = getFromUserAttrs(crtQe);
                            if (attr != null) {
                                for (NamingEnumeration<?> attrEnum = attr.getAll(); attrEnum.hasMore(); ) {
                                    sId = (String) attrEnum.next();
                                    if (!visitedSet.contains(sId)) {
                                        qe = new QueueElement(PM_NODE_UATTR,
                                                sId, crtQe.getLevel() + 1);
                                        queue.add(qe);
                                        addNode(graph, PM_NODE_UATTR, sId);
                                        visitedSet.add(sId);
                                    }
                                    addRel(graph, sId, crtQe.getId());
                                }
                            }

                            // Process the users assigned to the connector node.
                            attr = getFromUsers(crtQe);
                            if (attr != null) {
                                for (NamingEnumeration<?> attrEnum = attr.getAll(); attrEnum.hasMore(); ) {
                                    sId = (String) attrEnum.next();
                                    if (!visitedSet.contains(sId)) {
                                        qe = new QueueElement(PM_NODE_USER,
                                                sId, crtQe.getLevel() + 1);
                                        queue.add(qe);
                                        addNode(graph, PM_NODE_USER, sId);
                                        visitedSet.add(sId);
                                    }
                                    addRel(graph, sId, crtQe.getId());
                                }
                            }

                            // Process the policy classes assigned to the
                            // connector node.
                            attr = getFromPolicies(crtQe);
                            if (attr != null) {
                                for (NamingEnumeration<?> attrEnum = attr.getAll(); attrEnum.hasMore(); ) {
                                    sId = (String) attrEnum.next();
                                    if (!visitedSet.contains(sId)) {
                                        qe = new QueueElement(PM_NODE_POL, sId,
                                                crtQe.getLevel() + 1);
                                        queue.add(qe);
                                        addNode(graph, PM_NODE_POL, sId);
                                        visitedSet.add(sId);
                                    }
                                    addRel(graph, sId, crtQe.getId());
                                }
                            }

                            // Process the operation sets assigned to the
                            // connector node,
                            // but only if the connector node is the anchor.
                            if (sAnchorId.equalsIgnoreCase(PM_CONNECTOR_ID)) {
                                attr = getFromOpsets(crtQe);
                                if (attr != null) {
                                    for (NamingEnumeration<?> attrEnum = attr.getAll(); attrEnum.hasMore(); ) {
                                        sId = (String) attrEnum.next();
                                        if (!visitedSet.contains(sId)) {
                                            qe = new QueueElement(
                                                    PM_NODE_OPSET, sId,
                                                    crtQe.getLevel() + 1);
                                            queue.add(qe);
                                            addNode(graph, PM_NODE_OPSET, sId);
                                            visitedSet.add(sId);
                                        }
                                        addRel(graph, sId, crtQe.getId());
                                    }
                                }
                            }
                        }

                    } else if (crtQe.getType().equalsIgnoreCase(PM_NODE_OPSET)) {
                        // OPERATION SET NODE.

                        int n = getAscsCount(crtQe, PM_GRAPH_CAPS, false);
                        if (debugFlag) {
                            System.out.println("Node "
                                    + getEntityName(crtQe.getId(),
                                    crtQe.getType()) + " has " + n
                                    + " ascendants.");
                        }
                        if (n > nMaxDspAscs) {
                            // Add the "Members_of_..." node and its assignment
                            // to crtQe.
                            addMembersOfNode(graph, crtQe.getType(),
                                    crtQe.getId());

                        } else {

                            // Process user attributes assigned to the op set
                            // node.
                            Attribute attr = getFromAttrs(crtQe);
                            if (attr != null) {
                                for (NamingEnumeration<?> attrEnum = attr.getAll(); attrEnum.hasMore(); ) {
                                    sId = (String) attrEnum.next();
                                    if (!visitedSet.contains(sId)) {
                                        qe = new QueueElement(PM_NODE_UATTR,
                                                sId, crtQe.getLevel() + 1);
                                        queue.add(qe);
                                        addNode(graph, PM_NODE_UATTR, sId);
                                        visitedSet.add(sId);
                                    }
                                    addRel(graph, sId, crtQe.getId());
                                }
                            }
                        }
                    }

                }
            }
        } catch (NameNotFoundException e) {
            if (debugFlag) {
                e.printStackTrace();
            }
            return failurePacket("Database inconsistency about node "
                    + crtQe.getId() + " or " + sId);
        } catch (CommunicationException e) {
            if (debugFlag) {
                e.printStackTrace();
            }
            return failurePacket("AD connection error");
        } catch (Exception e) {
            if (debugFlag) {
                e.printStackTrace();
            }
            return failurePacket(e.getMessage());
        }

        crtQe = new QueueElement(sAnchorType, sAnchorId, 0);
        queue.add(crtQe);

        try {
            while (!queue.isEmpty()) {
                crtQe = queue.remove(0);
                if (debugFlag) {
                    System.out.println("Out of queue: " + crtQe.getId());
                }
                if (crtQe.getLevel() < nMaxLevel) {

                    if (crtQe.getType().equalsIgnoreCase(PM_NODE_UATTR)) {
                        // USER ATTRIBUTE NODE.

                        // Process the user attributes this user attribute is
                        // assigned to.
                        Attribute attr = getToAttrs(crtQe);
                        if (attr != null) {
                            for (NamingEnumeration<?> attrEnum = attr.getAll(); attrEnum.hasMore(); ) {
                                sId = (String) attrEnum.next();
                                if (!visitedSet.contains(sId)) {
                                    qe = new QueueElement(PM_NODE_UATTR, sId,
                                            crtQe.getLevel() + 1);
                                    queue.add(qe);
                                    addNode(graph, PM_NODE_UATTR, sId);
                                    visitedSet.add(sId);
                                }
                                addRel(graph, crtQe.getId(), sId);
                            }
                        }

                        // Process the policy classes this user attribute is
                        // assigned to.
                        attr = getToPolicies(crtQe);
                        if (attr != null) {
                            for (NamingEnumeration<?> attrEnum = attr.getAll(); attrEnum.hasMore(); ) {
                                sId = (String) attrEnum.next();
                                if (!visitedSet.contains(sId)) {
                                    qe = new QueueElement(PM_NODE_POL, sId,
                                            crtQe.getLevel() + 1);
                                    queue.add(qe);
                                    addNode(graph, PM_NODE_POL, sId);
                                    visitedSet.add(sId);
                                }
                                addRel(graph, crtQe.getId(), sId);
                            }
                        }

                        // Process the connector node if this user attribute is
                        // assigned to it.
                        if (attrIsAssignedToConnector(crtQe.getId(),
                                PM_NODE_UATTR)) {
                            if (!visitedSet.contains(PM_CONNECTOR_ID)) {
                                qe = new QueueElement(PM_NODE_CONN,
                                        PM_CONNECTOR_ID, crtQe.getLevel() + 1);
                                queue.add(qe);
                                addNode(graph, PM_NODE_CONN, PM_CONNECTOR_ID);
                                visitedSet.add(PM_CONNECTOR_ID);
                            }
                            addRel(graph, crtQe.getId(), PM_CONNECTOR_ID);
                        }

                        // Process the operation sets this user attribute is
                        // assigned to,
                        // but only if the user attribute is anchor.
                        if (sAnchorId.equalsIgnoreCase(crtQe.getId())) {
                            attr = getToOpsets(crtQe);
                            if (attr != null) {
                                for (NamingEnumeration<?> attrEnum = attr.getAll(); attrEnum.hasMore(); ) {
                                    sId = (String) attrEnum.next();
                                    if (!visitedSet.contains(sId)) {
                                        qe = new QueueElement(PM_NODE_OPSET,
                                                sId, crtQe.getLevel() + 1);
                                        queue.add(qe);
                                        addNode(graph, PM_NODE_OPSET, sId);
                                        visitedSet.add(sId);
                                    }
                                    addRel(graph, crtQe.getId(), sId);
                                }
                            }
                        }

                    } else if (crtQe.getType().equalsIgnoreCase(PM_NODE_USER)) {
                        // USER NODE.

                        // Process user attributes this user is assigned to.
                        Attribute attr = getToAttrs(crtQe);
                        if (attr != null) {
                            for (NamingEnumeration<?> attrEnum = attr.getAll(); attrEnum.hasMore(); ) {
                                sId = (String) attrEnum.next();
                                if (!visitedSet.contains(sId)) {
                                    qe = new QueueElement(PM_NODE_UATTR, sId,
                                            crtQe.getLevel() + 1);
                                    queue.add(qe);
                                    addNode(graph, PM_NODE_UATTR, sId);
                                    visitedSet.add(sId);
                                }
                                addRel(graph, crtQe.getId(), sId);
                            }
                        }

                        // Process the connector node if this user is assigned
                        // to it.
                        if (userIsAssignedToConnector(crtQe.getId())) {
                            if (!visitedSet.contains(PM_CONNECTOR_ID)) {
                                qe = new QueueElement(PM_NODE_CONN,
                                        PM_CONNECTOR_ID, crtQe.getLevel() + 1);
                                queue.add(qe);
                                addNode(graph, PM_NODE_CONN, PM_CONNECTOR_ID);
                                visitedSet.add(PM_CONNECTOR_ID);
                            }
                            addRel(graph, crtQe.getId(), PM_CONNECTOR_ID);
                        }

                    } else if (crtQe.getType().equalsIgnoreCase(PM_NODE_POL)) {
                        // POLICY CLASS NODE.

                        // Process the connector node.
                        if (!visitedSet.contains(PM_CONNECTOR_ID)) {
                            qe = new QueueElement(PM_NODE_CONN,
                                    PM_CONNECTOR_ID, crtQe.getLevel() + 1);
                            queue.add(qe);
                            addNode(graph, PM_NODE_CONN, PM_CONNECTOR_ID);
                            visitedSet.add(PM_CONNECTOR_ID);
                        }
                        addRel(graph, crtQe.getId(), PM_CONNECTOR_ID);

                    } else if (crtQe.getType().equalsIgnoreCase(PM_NODE_OPSET)) {
                        // OPERATION SET NODE.

                        // Process object attributes this opset is assigned to.
                        Attribute attr = getToAttrs(crtQe);
                        if (attr != null) {
                            for (NamingEnumeration<?> attrEnum = attr.getAll(); attrEnum.hasMore(); ) {
                                sId = (String) attrEnum.next();
                                if (!visitedSet.contains(sId)) {
                                    qe = new QueueElement(PM_NODE_OATTR, sId,
                                            crtQe.getLevel() + 1);
                                    queue.add(qe);
                                    sType = getTrueType(sId, PM_NODE_OATTR);
                                    addNode(graph, sType, sId);
                                    visitedSet.add(sId);
                                }
                                addRel(graph, crtQe.getId(), sId);
                            }
                        }

                        // Process the connector node if this operation set is
                        // assigned to it.
                        if (opsetIsAssignedToConnector(crtQe.getId())) {
                            if (!visitedSet.contains(PM_CONNECTOR_ID)) {
                                qe = new QueueElement(PM_NODE_CONN,
                                        PM_CONNECTOR_ID, crtQe.getLevel() + 1);
                                queue.add(qe);
                                addNode(graph, PM_NODE_CONN, PM_CONNECTOR_ID);
                                visitedSet.add(PM_CONNECTOR_ID);
                            }
                            addRel(graph, crtQe.getId(), PM_CONNECTOR_ID);
                        }

                    }
                }
            }
        } catch (NameNotFoundException e) {
            if (debugFlag) {
                e.printStackTrace();
            }
            return failurePacket("Database inconsistency");
        } catch (CommunicationException e) {
            if (debugFlag) {
                e.printStackTrace();
            }
            return failurePacket("AD connection error");
        } catch (Exception e) {
            if (debugFlag) {
                e.printStackTrace();
            }
            return failurePacket(e.getMessage());
        }

        // graph.add(PM_EOD);
        return graph;
    }

    // The anchor type is one of PM_NODE_OATTR, PM_NODE_POL, PM_NODE_CONN.
    // Note that PM_NODE_ASSOC was converted to PM_NODE_OATTR at the start
    // of the getGraph function, so it arrives here as PM_NODE_OATTR.
    private Packet getOattrGraph(String sAnchorId, String sAnchorLabel,
                                 String sAnchorType, String sLevel) {
        // Anchor type can only be b, p, c.
        if (!sAnchorType.equalsIgnoreCase(PM_NODE_OATTR)
                && !sAnchorType.equalsIgnoreCase(PM_NODE_POL)
                && !sAnchorType.equalsIgnoreCase(PM_NODE_CONN)) {
            return failurePacket("Node type incompatible with graph view");
        }

        Packet graph = new Packet();

        HashSet<String> visitedSet = new HashSet<String>();
        ArrayList<QueueElement> queue = new ArrayList<QueueElement>();
        QueueElement qe, crtQe;
        String sId = null;
        String sType;

        int nMaxLevel = Integer.valueOf(sLevel).intValue();

        // Whenever we insert a node in the queue, we add it to the graph.
        // Start by inserting the anchor in the queue with level 0
        crtQe = new QueueElement(sAnchorType, sAnchorId, 0);
        queue.add(crtQe);

        try {
            sType = getTrueType(sAnchorId, sAnchorType.toUpperCase());
            addNode(graph, sType, sAnchorId);
            while (!queue.isEmpty()) {
                crtQe = queue.remove(0);
                if (debugFlag) {
                    System.out.println("Out of queue: " + crtQe.getId());
                }
                if (crtQe.getLevel() < nMaxLevel) {

                    if (crtQe.getType().equalsIgnoreCase(PM_NODE_OATTR)) {
                        // OBJECT ATTRIBUTE NODE.

                        // If the crt node has more than nMaxDspAscs, make a
                        // fake node
                        // with the name "Members_of_<crtQe.getName>", output it
                        // and
                        // its assignment to the crt node.
                        int n = getAscsCount(crtQe, PM_GRAPH_OATTR, false);
                        if (debugFlag) {
                            System.out.println("Node "
                                    + getEntityName(crtQe.getId(),
                                    crtQe.getType()) + " has " + n
                                    + " ascendants.");
                        }
                        if (n > nMaxDspAscs) {
                            // Add the "Members_of_..." node and its assignment
                            // to crtQe.
                            addMembersOfNode(graph, crtQe.getType(),
                                    crtQe.getId());

                        } else {
                            // Process the object attributes assigned to this
                            // object attribute
                            // (the ascendants).
                            Attribute attr = getFromAttrs(crtQe);
                            if (attr != null) {
                                for (NamingEnumeration<?> attrEnum = attr.getAll(); attrEnum.hasMore(); ) {
                                    sId = (String) attrEnum.next();
                                    if (!visitedSet.contains(sId)) {
                                        qe = new QueueElement(PM_NODE_OATTR,
                                                sId, crtQe.getLevel() + 1);
                                        queue.add(qe);
                                        sType = getTrueType(sId, PM_NODE_OATTR);
                                        addNode(graph, sType, sId);
                                        visitedSet.add(sId);
                                    }
                                    addRel(graph, sId, crtQe.getId());
                                }
                            }
                        }
                    } else if (crtQe.getType().equalsIgnoreCase(PM_NODE_POL)) {
                        // POLICY CLASS NODE.

                        // If the crt node has more than nMaxDspAscs, make a
                        // fake node
                        // with the name "Members_of_<crtQe.getName>", output it
                        // and
                        // its assignment to the crt node.
                        int n = getAscsCount(crtQe, PM_GRAPH_OATTR, false);
                        if (debugFlag) {
                            System.out.println("Node "
                                    + getEntityName(crtQe.getId(),
                                    crtQe.getType()) + " has " + n
                                    + " ascendants.");
                        }
                        if (n > nMaxDspAscs) {
                            // Add the "Members_of_..." node and its assignment
                            // to crtQe.
                            addMembersOfNode(graph, crtQe.getType(),
                                    crtQe.getId());

                        } else {

                            // Process object attributes assigned to it.
                            Attribute attr = getFromObjAttrs(crtQe);
                            if (attr != null) {
                                for (NamingEnumeration<?> attrEnum = attr.getAll(); attrEnum.hasMore(); ) {
                                    sId = (String) attrEnum.next();
                                    if (!visitedSet.contains(sId)) {
                                        qe = new QueueElement(PM_NODE_OATTR,
                                                sId, crtQe.getLevel() + 1);
                                        queue.add(qe);
                                        sType = getTrueType(sId, PM_NODE_OATTR);
                                        addNode(graph, sType, sId);
                                        visitedSet.add(sId);
                                    }
                                    addRel(graph, sId, crtQe.getId());
                                }
                            }
                        }

                    } else if (crtQe.getType().equalsIgnoreCase(PM_NODE_CONN)) {
                        // CONNECTOR NODE.

                        // If the crt node has more than nMaxDspAscs, make a
                        // fake node
                        // with the name "Members_of_<crtQe.getName>", output it
                        // and
                        // its assignment to the crt node.
                        int n = getAscsCount(crtQe, PM_GRAPH_OATTR, false);
                        if (debugFlag) {
                            System.out.println("Node "
                                    + getEntityName(crtQe.getId(),
                                    crtQe.getType()) + " has " + n
                                    + " ascendants.");
                        }
                        if (n > nMaxDspAscs) {
                            // Add the "Members_of_..." node and its assignment
                            // to crtQe.
                            addMembersOfNode(graph, crtQe.getType(),
                                    crtQe.getId());

                        } else {

                            // Process object attributes assigned to the
                            // connector node.
                            Attribute attr = getFromObjAttrs(crtQe);
                            if (attr != null) {
                                for (NamingEnumeration<?> attrEnum = attr.getAll(); attrEnum.hasMore(); ) {
                                    sId = (String) attrEnum.next();
                                    if (!visitedSet.contains(sId)) {
                                        qe = new QueueElement(PM_NODE_OATTR,
                                                sId, crtQe.getLevel() + 1);
                                        queue.add(qe);
                                        sType = getTrueType(sId, PM_NODE_OATTR);
                                        addNode(graph, sType, sId);
                                        visitedSet.add(sId);
                                    }
                                    addRel(graph, sId, crtQe.getId());
                                }
                            }

                            // Process the policy classes assigned to the
                            // connector node.
                            attr = getFromPolicies(crtQe);
                            if (attr != null) {
                                for (NamingEnumeration<?> attrEnum = attr.getAll(); attrEnum.hasMore(); ) {
                                    sId = (String) attrEnum.next();
                                    if (!visitedSet.contains(sId)) {
                                        qe = new QueueElement(PM_NODE_POL, sId,
                                                crtQe.getLevel() + 1);
                                        queue.add(qe);
                                        addNode(graph, PM_NODE_POL, sId);
                                        visitedSet.add(sId);
                                    }
                                    addRel(graph, sId, crtQe.getId());
                                }
                            }
                        }
                    }
                }
            }
        } catch (NameNotFoundException e) {
            if (debugFlag) {
                e.printStackTrace();
            }
            return failurePacket("Database inconsistency about node "
                    + crtQe.getId() + " or " + sId);
        } catch (CommunicationException e) {
            if (debugFlag) {
                e.printStackTrace();
            }
            return failurePacket("AD connection error");
        } catch (Exception e) {
            if (debugFlag) {
                e.printStackTrace();
            }
            return failurePacket(e.getMessage());
        }

        crtQe = new QueueElement(sAnchorType, sAnchorId, 0);
        queue.add(crtQe);

        try {
            while (!queue.isEmpty()) {
                crtQe = queue.remove(0);
                if (debugFlag) {
                    System.out.println("Out of queue: " + crtQe.getId());
                }
                if (crtQe.getLevel() < nMaxLevel) {

                    if (crtQe.getType().equalsIgnoreCase(PM_NODE_OATTR)) {
                        // OBJECT ATTRIBUTE NODE.
                        // Process the object attributes this object attribute
                        // is assigned to.
                        Attribute attr = getToAttrs(crtQe);
                        if (attr != null) {
                            for (NamingEnumeration<?> attrEnum = attr.getAll(); attrEnum.hasMore(); ) {
                                sId = (String) attrEnum.next();
                                if (!visitedSet.contains(sId)) {
                                    qe = new QueueElement(PM_NODE_OATTR, sId,
                                            crtQe.getLevel() + 1);
                                    queue.add(qe);
                                    sType = getTrueType(sId, PM_NODE_OATTR);
                                    addNode(graph, sType, sId);
                                    visitedSet.add(sId);
                                }
                                addRel(graph, crtQe.getId(), sId);
                            }
                        }
                        // Process the policy classes this object attribute is
                        // assigned to.
                        attr = getToPolicies(crtQe);
                        if (attr != null) {
                            for (NamingEnumeration<?> attrEnum = attr.getAll(); attrEnum.hasMore(); ) {
                                sId = (String) attrEnum.next();
                                if (!visitedSet.contains(sId)) {
                                    qe = new QueueElement(PM_NODE_POL, sId,
                                            crtQe.getLevel() + 1);
                                    queue.add(qe);
                                    addNode(graph, PM_NODE_POL, sId);
                                    visitedSet.add(sId);
                                }
                                addRel(graph, crtQe.getId(), sId);
                            }
                        }
                        // Process the connector node if this object attribute
                        // is assigned to it.
                        if (attrIsAssignedToConnector(crtQe.getId(),
                                PM_NODE_OATTR)) {
                            if (!visitedSet.contains(PM_CONNECTOR_ID)) {
                                qe = new QueueElement(PM_NODE_CONN,
                                        PM_CONNECTOR_ID, crtQe.getLevel() + 1);
                                queue.add(qe);
                                addNode(graph, PM_NODE_CONN, PM_CONNECTOR_ID);
                                visitedSet.add(PM_CONNECTOR_ID);
                            }
                            addRel(graph, crtQe.getId(), PM_CONNECTOR_ID);
                        }

                    } else if (crtQe.getType().equalsIgnoreCase(PM_NODE_POL)) {
                        // POLICY CLASS NODE.
                        // Process the connector node.
                        if (!visitedSet.contains(PM_CONNECTOR_ID)) {
                            qe = new QueueElement(PM_NODE_CONN,
                                    PM_CONNECTOR_ID, crtQe.getLevel() + 1);
                            queue.add(qe);
                            addNode(graph, PM_NODE_CONN, PM_CONNECTOR_ID);
                            visitedSet.add(PM_CONNECTOR_ID);
                        }
                        addRel(graph, crtQe.getId(), PM_CONNECTOR_ID);
                    }
                }
            }
        } catch (NameNotFoundException e) {
            if (debugFlag) {
                e.printStackTrace();
            }
            return failurePacket("Database inconsistency");
        } catch (CommunicationException e) {
            if (debugFlag) {
                e.printStackTrace();
            }
            return failurePacket("AD connection error");
        } catch (Exception e) {
            if (debugFlag) {
                e.printStackTrace();
            }
            return failurePacket(e.getMessage());
        }

        // graph.add(PM_EOD);
        return graph;
    }

    // The nodes "discovered" by this function can have the type:
    // PM_NODE_OATTR, PM_NODE_POL, PM_NODE_CONN, PM_NODE_OPSET,
    // and PM_NODE_UATTR. All except PM_NODE_UATTR can be anchors.
    // We only visit PM_NODE_OPSET nodes assigned to the anchor (which
    // can be PM_NODE_OATTR or PM_NODE_CONN).
    private Packet getAcesGraph(String sAnchorId, String sAnchorLabel,
                                String sAnchorType, String sLevel) {
        if (!sAnchorType.equalsIgnoreCase(PM_NODE_OATTR)
                && !sAnchorType.equalsIgnoreCase(PM_NODE_POL)
                && !sAnchorType.equalsIgnoreCase(PM_NODE_OPSET)
                && !sAnchorType.equalsIgnoreCase(PM_NODE_CONN)) {
            return failurePacket("Node type incompatible with graph view");
        }

        Packet graph = new Packet();

        HashSet<String> visitedSet = new HashSet<String>();
        ArrayList<QueueElement> queue = new ArrayList<QueueElement>();
        QueueElement qe, crtQe;
        String sId = null;
        String sType;

        int nMaxLevel = Integer.valueOf(sLevel).intValue();

        // Whenever we insert a node in the queue, we add it to the graph.
        // Start by inserting the anchor in the queue with level 0
        crtQe = new QueueElement(sAnchorType, sAnchorId, 0);
        queue.add(crtQe);

        try {
            sType = getTrueType(sAnchorId, sAnchorType.toUpperCase());
            addNode(graph, sType, sAnchorId);
            while (!queue.isEmpty()) {
                crtQe = queue.remove(0);
                if (debugFlag) {
                    System.out.println("Out of queue: " + crtQe.getId());
                }
                if (crtQe.getLevel() < nMaxLevel) {

                    if (crtQe.getType().equalsIgnoreCase(PM_NODE_OATTR)) {
                        // OBJECT ATTRIBUTE NODE.

                        int n = getAscsCount(crtQe, PM_GRAPH_ACES,
                                sAnchorId.equalsIgnoreCase(crtQe.getId()));
                        if (debugFlag) {
                            System.out.println("Node "
                                    + getEntityName(crtQe.getId(),
                                    crtQe.getType()) + " has " + n
                                    + " ascendants.");
                        }
                        if (n > nMaxDspAscs) {
                            // Add the "Members_of_..." node and its assignment
                            // to crtQe.
                            addMembersOfNode(graph, crtQe.getType(),
                                    crtQe.getId());

                        } else {

                            // Process the object attributes assigned to this
                            // object attribute
                            // (the ascendants).
                            Attribute attr = getFromAttrs(crtQe);
                            if (attr != null) {
                                for (NamingEnumeration<?> attrEnum = attr.getAll(); attrEnum.hasMore(); ) {
                                    sId = (String) attrEnum.next();
                                    if (!visitedSet.contains(sId)) {
                                        qe = new QueueElement(PM_NODE_OATTR,
                                                sId, crtQe.getLevel() + 1);
                                        queue.add(qe);
                                        sType = getTrueType(sId, PM_NODE_OATTR);
                                        addNode(graph, sType, sId);
                                        visitedSet.add(sId);
                                    }
                                    addRel(graph, sId, crtQe.getId());
                                }
                            }

                            // Process the operation sets assigned to this
                            // object attribute,
                            // but only if the object attribute is anchor.
                            if (sAnchorId.equalsIgnoreCase(crtQe.getId())) {
                                attr = getFromOpsets(crtQe);
                                if (attr != null) {
                                    for (NamingEnumeration<?> attrEnum = attr.getAll(); attrEnum.hasMore(); ) {
                                        sId = (String) attrEnum.next();
                                        if (!visitedSet.contains(sId)) {
                                            qe = new QueueElement(
                                                    PM_NODE_OPSET, sId,
                                                    crtQe.getLevel() + 1);
                                            queue.add(qe);
                                            addNode(graph, PM_NODE_OPSET, sId);
                                            visitedSet.add(sId);
                                        }
                                        addRel(graph, sId, crtQe.getId());
                                    }
                                }
                            }
                        }
                    } else if (crtQe.getType().equalsIgnoreCase(PM_NODE_POL)) {
                        // POLICY CLASS NODE.

                        int n = getAscsCount(crtQe, PM_GRAPH_ACES, false);
                        if (debugFlag) {
                            System.out.println("Node "
                                    + getEntityName(crtQe.getId(),
                                    crtQe.getType()) + " has " + n
                                    + " ascendants.");
                        }
                        if (n > nMaxDspAscs) {
                            // Add the "Members_of_..." node and its assignment
                            // to crtQe.
                            addMembersOfNode(graph, crtQe.getType(),
                                    crtQe.getId());

                        } else {

                            // Process object attributes assigned to it.
                            Attribute attr = getFromObjAttrs(crtQe);
                            if (attr != null) {
                                for (NamingEnumeration<?> attrEnum = attr.getAll(); attrEnum.hasMore(); ) {
                                    sId = (String) attrEnum.next();
                                    if (!visitedSet.contains(sId)) {
                                        qe = new QueueElement(PM_NODE_OATTR,
                                                sId, crtQe.getLevel() + 1);
                                        queue.add(qe);
                                        sType = getTrueType(sId, PM_NODE_OATTR);
                                        addNode(graph, sType, sId);
                                        visitedSet.add(sId);
                                    }
                                    addRel(graph, sId, crtQe.getId());
                                }
                            }
                        }

                    } else if (crtQe.getType().equalsIgnoreCase(PM_NODE_CONN)) {
                        // CONNECTOR NODE.

                        int n = getAscsCount(crtQe, PM_GRAPH_ACES,
                                sAnchorId.equalsIgnoreCase(PM_CONNECTOR_ID));
                        if (debugFlag) {
                            System.out.println("Node "
                                    + getEntityName(crtQe.getId(),
                                    crtQe.getType()) + " has " + n
                                    + " ascendants.");
                        }
                        if (n > nMaxDspAscs) {
                            // Add the "Members_of_..." node and its assignment
                            // to crtQe.
                            addMembersOfNode(graph, crtQe.getType(),
                                    crtQe.getId());

                        } else {

                            // Process object attributes assigned to the
                            // connector node.
                            Attribute attr = getFromObjAttrs(crtQe);
                            if (attr != null) {
                                for (NamingEnumeration<?> attrEnum = attr.getAll(); attrEnum.hasMore(); ) {
                                    sId = (String) attrEnum.next();
                                    if (!visitedSet.contains(sId)) {
                                        qe = new QueueElement(PM_NODE_OATTR,
                                                sId, crtQe.getLevel() + 1);
                                        queue.add(qe);
                                        sType = getTrueType(sId, PM_NODE_OATTR);
                                        addNode(graph, sType, sId);
                                        visitedSet.add(sId);
                                    }
                                    addRel(graph, sId, crtQe.getId());
                                }
                            }

                            // Process the policy classes assigned to the
                            // connector node.
                            attr = getFromPolicies(crtQe);
                            if (attr != null) {
                                for (NamingEnumeration<?> attrEnum = attr.getAll(); attrEnum.hasMore(); ) {
                                    sId = (String) attrEnum.next();
                                    if (!visitedSet.contains(sId)) {
                                        qe = new QueueElement(PM_NODE_POL, sId,
                                                crtQe.getLevel() + 1);
                                        queue.add(qe);
                                        addNode(graph, PM_NODE_POL, sId);
                                        visitedSet.add(sId);
                                    }
                                    addRel(graph, sId, crtQe.getId());
                                }
                            }

                            // Process the operation sets assigned to the
                            // connector node,
                            // but only if the connector node is the anchor.
                            if (sAnchorId.equalsIgnoreCase(PM_CONNECTOR_ID)) {
                                attr = getFromOpsets(crtQe);
                                if (attr != null) {
                                    for (NamingEnumeration<?> attrEnum = attr.getAll(); attrEnum.hasMore(); ) {
                                        sId = (String) attrEnum.next();
                                        if (!visitedSet.contains(sId)) {
                                            qe = new QueueElement(
                                                    PM_NODE_OPSET, sId,
                                                    crtQe.getLevel() + 1);
                                            queue.add(qe);
                                            addNode(graph, PM_NODE_OPSET, sId);
                                            visitedSet.add(sId);
                                        }
                                        addRel(graph, sId, crtQe.getId());
                                    }
                                }
                            }
                        }

                    } else if (crtQe.getType().equalsIgnoreCase(PM_NODE_OPSET)) {
                        // OPERATION SET NODE.

                        int n = getAscsCount(crtQe, PM_GRAPH_ACES, false);
                        if (debugFlag) {
                            System.out.println("Node "
                                    + getEntityName(crtQe.getId(),
                                    crtQe.getType()) + " has " + n
                                    + " ascendants.");
                        }
                        if (n > nMaxDspAscs) {
                            // Add the "Members_of_..." node and its assignment
                            // to crtQe.
                            addMembersOfNode(graph, crtQe.getType(),
                                    crtQe.getId());

                        } else {

                            // Process user attributes assigned to the op set
                            // node.
                            Attribute attr = getFromAttrs(crtQe);
                            if (attr != null) {
                                for (NamingEnumeration<?> attrEnum = attr.getAll(); attrEnum.hasMore(); ) {
                                    sId = (String) attrEnum.next();
                                    if (!visitedSet.contains(sId)) {
                                        qe = new QueueElement(PM_NODE_UATTR,
                                                sId, crtQe.getLevel() + 1);
                                        queue.add(qe);
                                        addNode(graph, PM_NODE_UATTR, sId);
                                        visitedSet.add(sId);
                                    }
                                    addRel(graph, sId, crtQe.getId());
                                }
                            }
                        }
                    }
                }
            }
        } catch (NameNotFoundException e) {
            if (debugFlag) {
                e.printStackTrace();
            }
            return failurePacket("Database inconsistency about node "
                    + crtQe.getId() + " or " + sId);
        } catch (CommunicationException e) {
            if (debugFlag) {
                e.printStackTrace();
            }
            return failurePacket("AD connection error");
        } catch (Exception e) {
            if (debugFlag) {
                e.printStackTrace();
            }
            return failurePacket(e.getMessage());
        }

        crtQe = new QueueElement(sAnchorType, sAnchorId, 0);
        queue.add(crtQe);

        try {
            while (!queue.isEmpty()) {
                crtQe = queue.remove(0);
                if (debugFlag) {
                    System.out.println("Out of queue: " + crtQe.getId());
                }
                if (crtQe.getLevel() < nMaxLevel) {

                    if (crtQe.getType().equalsIgnoreCase(PM_NODE_OATTR)) {
                        // OBJECT ATTRIBUTE NODE.
                        // Process the object attributes this object attribute
                        // is assigned to.
                        Attribute attr = getToAttrs(crtQe);
                        if (attr != null) {
                            for (NamingEnumeration<?> attrEnum = attr.getAll(); attrEnum.hasMore(); ) {
                                sId = (String) attrEnum.next();
                                if (!visitedSet.contains(sId)) {
                                    qe = new QueueElement(PM_NODE_OATTR, sId,
                                            crtQe.getLevel() + 1);
                                    queue.add(qe);
                                    sType = getTrueType(sId, PM_NODE_OATTR);
                                    addNode(graph, sType, sId);
                                    visitedSet.add(sId);
                                }
                                addRel(graph, crtQe.getId(), sId);
                            }
                        }
                        // Process the policy classes this object attribute is
                        // assigned to.
                        attr = getToPolicies(crtQe);
                        if (attr != null) {
                            for (NamingEnumeration<?> attrEnum = attr.getAll(); attrEnum.hasMore(); ) {
                                sId = (String) attrEnum.next();
                                if (!visitedSet.contains(sId)) {
                                    qe = new QueueElement(PM_NODE_POL, sId,
                                            crtQe.getLevel() + 1);
                                    queue.add(qe);
                                    addNode(graph, PM_NODE_POL, sId);
                                    visitedSet.add(sId);
                                }
                                addRel(graph, crtQe.getId(), sId);
                            }
                        }
                        // Process the connector node if this object attribute
                        // is assigned to it.
                        if (attrIsAssignedToConnector(crtQe.getId(),
                                PM_NODE_OATTR)) {
                            if (!visitedSet.contains(PM_CONNECTOR_ID)) {
                                qe = new QueueElement(PM_NODE_CONN,
                                        PM_CONNECTOR_ID, crtQe.getLevel() + 1);
                                queue.add(qe);
                                addNode(graph, PM_NODE_CONN, PM_CONNECTOR_ID);
                                visitedSet.add(PM_CONNECTOR_ID);
                            }
                            addRel(graph, crtQe.getId(), PM_CONNECTOR_ID);
                        }

                    } else if (crtQe.getType().equalsIgnoreCase(PM_NODE_POL)) {
                        // POLICY CLASS NODE.
                        // Process the connector node.
                        if (!visitedSet.contains(PM_CONNECTOR_ID)) {
                            qe = new QueueElement(PM_NODE_CONN,
                                    PM_CONNECTOR_ID, crtQe.getLevel() + 1);
                            queue.add(qe);
                            addNode(graph, PM_NODE_CONN, PM_CONNECTOR_ID);
                            visitedSet.add(PM_CONNECTOR_ID);
                        }
                        addRel(graph, crtQe.getId(), PM_CONNECTOR_ID);

                    } else if (crtQe.getType().equalsIgnoreCase(PM_NODE_OPSET)) {
                        // OPERATION SET NODE.

                        // Process object attributes this opset is assigned to.
                        Attribute attr = getToAttrs(crtQe);
                        if (attr != null) {
                            for (NamingEnumeration<?> attrEnum = attr.getAll(); attrEnum.hasMore(); ) {
                                sId = (String) attrEnum.next();
                                if (!visitedSet.contains(sId)) {
                                    qe = new QueueElement(PM_NODE_OATTR, sId,
                                            crtQe.getLevel() + 1);
                                    queue.add(qe);
                                    sType = getTrueType(sId, PM_NODE_OATTR);
                                    addNode(graph, sType, sId);
                                    visitedSet.add(sId);
                                }
                                addRel(graph, crtQe.getId(), sId);
                            }
                        }

                        // Process the connector node if this operation set is
                        // assigned to it.
                        if (opsetIsAssignedToConnector(crtQe.getId())) {
                            if (!visitedSet.contains(PM_CONNECTOR_ID)) {
                                qe = new QueueElement(PM_NODE_CONN,
                                        PM_CONNECTOR_ID, crtQe.getLevel() + 1);
                                queue.add(qe);
                                addNode(graph, PM_NODE_CONN, PM_CONNECTOR_ID);
                                visitedSet.add(PM_CONNECTOR_ID);
                            }
                            addRel(graph, crtQe.getId(), PM_CONNECTOR_ID);
                        }
                    }
                }
            }
        } catch (NameNotFoundException e) {
            if (debugFlag) {
                e.printStackTrace();
            }
            return failurePacket("Database inconsistency");
        } catch (CommunicationException e) {
            if (debugFlag) {
                e.printStackTrace();
            }
            return failurePacket("AD connection error");
        } catch (Exception e) {
            if (debugFlag) {
                e.printStackTrace();
            }
            return failurePacket(e.getMessage());
        }

        // graph.add(PM_EOD);
        return graph;
    }

    private Packet getPermsGraph(String sAnchorId, String sAnchorLabel,
                                 String sAnchorType, String sLevel) {
        System.out.println("Selected node is " + sAnchorId + ", "
                + sAnchorLabel + ", " + sAnchorType);
        Packet graph = new Packet();

        HashSet<String> visitedSet = new HashSet<String>();

        try {
            if (sAnchorType.equalsIgnoreCase(PM_NODE_UATTR)) {
                String sType = getTrueType(sAnchorId, sAnchorType.toUpperCase());

                addNode(graph, sType, sAnchorId);

                Vector<String> opsets = getToOpsets(sAnchorId);
                for (int i = 0; i < opsets.size(); i++) {
                    String sOpsetId = opsets.get(i);
                    addNode(graph, PM_NODE_OPSET, sOpsetId);
                    addRel(graph, sAnchorId, sOpsetId);

                    Vector<String> oattrs = getToAttrs(sOpsetId);
                    for (int j = 0; j < oattrs.size(); j++) {
                        String sOattrId = oattrs.get(j);
                        if (!visitedSet.contains(sOattrId)) {
                            sType = getTrueType(sOattrId, PM_NODE_OATTR);
                            addNode(graph, sType, sOattrId);
                            visitedSet.add(sOattrId);
                        }
                        addRel(graph, sOpsetId, sOattrId);
                    }
                }
            } else if (sAnchorType.equalsIgnoreCase(PM_NODE_OPSET)) {
                String sType = getTrueType(sAnchorId, sAnchorType.toUpperCase());

                addNode(graph, sType, sAnchorId);

                Vector<String> uattrs = getFromAttrs(sAnchorId);
                for (int i = 0; i < uattrs.size(); i++) {
                    String sUattrId = uattrs.get(i);

                    if (!visitedSet.contains(sUattrId)) {
                        addNode(graph, PM_NODE_UATTR, sUattrId);
                        visitedSet.add(sUattrId);
                    }
                    addRel(graph, sUattrId, sAnchorId);
                }

                Vector<String> oattrs = getToAttrs(sAnchorId);
                for (int i = 0; i < oattrs.size(); i++) {
                    String sOattrId = oattrs.get(i);
                    if (!visitedSet.contains(sOattrId)) {
                        sType = getTrueType(sOattrId, PM_NODE_OATTR);
                        addNode(graph, sType, sOattrId);
                        visitedSet.add(sOattrId);
                    }
                    addRel(graph, sAnchorId, sOattrId);
                }
            } else if (sAnchorType.equalsIgnoreCase(PM_NODE_OATTR)) {
                String sType = getTrueType(sAnchorId, sAnchorType.toUpperCase());

                addNode(graph, sType, sAnchorId);

                Vector<String> opsets = getFromOpsets(sAnchorId);
                for (int i = 0; i < opsets.size(); i++) {
                    String sOpsetId = opsets.get(i);
                    addNode(graph, PM_NODE_OPSET, sOpsetId);
                    addRel(graph, sOpsetId, sAnchorId);

                    Vector<String> uattrs = getFromAttrs(sOpsetId);
                    for (int j = 0; j < uattrs.size(); j++) {
                        String sUattrId = uattrs.get(j);
                        if (!visitedSet.contains(sUattrId)) {
                            addNode(graph, PM_NODE_UATTR, sUattrId);
                            visitedSet.add(sUattrId);
                        }
                        addRel(graph, sUattrId, sOpsetId);
                    }
                }
            } else {
                return failurePacket("Invalid anchor type for this kind of view!");
            }
        } catch (NameNotFoundException e) {
            if (debugFlag) {
                e.printStackTrace();
            }
            return failurePacket("Database inconsistency");
        } catch (CommunicationException e) {
            if (debugFlag) {
                e.printStackTrace();
            }
            return failurePacket("AD connection error");
        } catch (Exception e) {
            if (debugFlag) {
                e.printStackTrace();
            }
            return failurePacket(e.getMessage());
        }
        // graph.add(PM_EOD);
        return graph;
    }

    // The base node can be:
    // - null; then add the user as an ascendant of the connector node;
    // - a user attribute; add the user as an ascendant of the user attribute;
    // - the connector node; add the user as an ascendant of the connector node.
    // Parameter sBaseIsVos (values "yes" or "no"), tells whether the base node
    // id is a VOS node id.
    private Packet addUser(String sSessId, String sProcId, String sName,
                           String sFull, String sInfo, String sPass, String sBaseId,
                           String sBaseType, String sBaseIsVos) {

        System.out.println("AddUser sName = " + sName);
        System.out.println("AddUser sFull = " + sFull);
        System.out.println("AddUser sInfo = " + sInfo);
        System.out.println("AddUser sPass = " + sPass);
        System.out.println("AddUser sBaseId = " + sBaseId);
        System.out.println("AddUser sBaseType = " + sBaseType);
        System.out.println("AddUser sBaseIsVos = " + sBaseIsVos);

        if (sBaseIsVos.equalsIgnoreCase("yes")) {
            sBaseId = getAdminVosNodeOrigId(sBaseId);
        } else if (sBaseId == null) {
            sBaseId = PM_CONNECTOR_ID;
            sBaseType = PM_NODE_CONN;
        }

        // Do permission checks.
        if (!requestAddUserPerms(sSessId, sProcId, sBaseId, sBaseType)) {
            return failurePacket(reqPermsMsg);
        }

        // Call addUserInternal() with a null sId to force generation of the
        // user id:
        Packet res =  addUserInternal(sName, null, sFull, sInfo, sPass,
                sBaseId, sBaseType);
        if (res.hasError()) {
            return res;
        }

        setLastUpdateTimestamp();

        // addUserInternal returns the new user's name and id in the first item.
        String sLine = res.getStringValue(0);
        String[] pieces = sLine.split(PM_FIELD_DELIM);

        System.out.println("Before event");
        Packet eventRes =  processEvent(sSessId, null,
                PM_EVENT_USER_CREATE, sName, pieces[1], PM_CLASS_USER_NAME,
                null, null, null);
        System.out.println("After event");

        if (eventRes.hasError()) {
            return eventRes;
        }

        return res;
    }

    // Internally used, no permission checks. In general, the user id is null
    // because this is a new user. Only for initial users, like super,
    // is the id known.
    private Packet addUserInternal(String sName, String sId, String sFull,
                                   String sInfo, String sPass, String sBaseId, String sBaseType) {
        System.out.println("AddUserInternal sName = " + sName);
        System.out.println("AddUserInternal sId = " + sId);
        System.out.println("AddUserInternal sFull = " + sFull);
        System.out.println("AddUserInternal sInfo = " + sInfo);
        System.out.println("AddUserInternal sPass = " + sPass);
        System.out.println("AddUserInternal sBaseId = " + sBaseId);
        System.out.println("AddUserInternal sBaseType = " + sBaseType);

        // Test if duplicate name.
        if (entityNameExists(sName, PM_NODE_USER)) {
            return failurePacket("Duplicate name!");
        }

        // A null password means an empty one.
        if (sPass == null) {
            sPass = "";
        }

        // Get a random 12-byte salt.
        SecureRandom random = new SecureRandom();
        byte[] salt = new byte[12];
        random.nextBytes(salt);

        // Get a message digest instance and hash the salt and the password.
        byte[] digest;
        try {
            MessageDigest md = MessageDigest.getInstance("MD5");
            md.update(salt);
            md.update(sPass.getBytes());
            sPass = null;
            digest = md.digest();
        } catch (Exception e) {
            e.printStackTrace();
            return failurePacket("Error while hashing the password!");
        }

        // Convert the hash to a string of hex digits.
        String sHash = byteArray2HexString(salt) + byteArray2HexString(digest);

        // In general, the user id is null when called from the Admin Tool.
        // When called for the initial objects, the id is predefined.
        if (sId == null) {
            RandomGUID myGUID = new RandomGUID();
            sId = myGUID.toStringNoDashes();
        }

        // Prepare the attributes of the new user object.
        Attributes attrs = new BasicAttributes(true);
        attrs.put("objectClass", sUserClass);
        attrs.put("pmId", sId);
        attrs.put("pmName", sName);
        attrs.put("pmFullName", sFull);
        attrs.put("pmOtherInfo", sInfo);
        attrs.put("pmPassword", sHash);

        System.out.print("Attempting to create the user object...");
        // Prepare the path and create the new user object.
        String sDn = "CN=" + sId + "," + sUserContainerDN;
        try {
            ctx.bind(sDn, null, attrs);
        } catch (InvalidNameException e) {
            if (debugFlag) {
                e.printStackTrace();
            }
            return failurePacket("Invalid user id " + sId);
        } catch (NameAlreadyBoundException e) {
            if (debugFlag) {
                e.printStackTrace();
            }
            return failurePacket("Duplicate id " + sId);
        } catch (Exception e) {
            if (debugFlag) {
                e.printStackTrace();
            }
            return failurePacket("Probably invalid id " + sId);
        }
        System.out.println("OK");

        // A null base node is interpreted as the connector node.
        if (sBaseId == null) {
            sBaseId = PM_CONNECTOR_ID;
            sBaseType = PM_NODE_CONN;
        }
        Packet res =  addDoubleLink(sId, PM_NODE_USER, sBaseId,
                sBaseType);
        if (res.hasError()) {
            return res;
        }

        System.out.println("OK2");

        // Check static constraints. If the admin op violates any of them,
        // roll back the operation.
        res =  checkSconForAddUser(sId, sBaseId, sBaseType);
        System.out.println("OK3");

        if (res.hasError()) {
            return res;
        }

        res = new Packet();
        try {
            res.addItem(ItemType.RESPONSE_TEXT, sName + PM_FIELD_DELIM + sId);
        } catch (Exception e) {
            e.printStackTrace();
        }
        System.out.println("OK4");
        return res;
    }

    // Check the static constraints for the admin operation "Add User".
    // If the base node is not a user attribute, or if the base node is a user
    // attribute that has other users authorized, no check is necessary.
    private Packet checkSconForAddUser(String sUserId, String sBaseId,
                                       String sBaseType) {
        if (!sBaseType.equalsIgnoreCase(PM_NODE_UATTR)) {
            return successPacket();
        }

        Packet res =  checkScons();
        if (isSuccessPacket(res)) {
            return res;
        }

        // The SCons are violated. Tell the client the admin op is rolled back.
        String sErr = res.getErrorMessage()
                + " Rolling back the AddUser operation.";

        // The operation violates at least one constraint. Roll back the
        // operation.
        // First, cut the assignment to the base node. If error, add it as the
        // second
        // item in the return (the first is still the constraint violation).
        res =  deleteDoubleLink(sUserId, PM_NODE_USER, sBaseId,
                sBaseType);
        if (res.hasError()) {
            sErr += " Error during rollback (delete link).";
            return failurePacket(sErr);
        }
        // Now delete the new user. If error, add it as the second item in the
        // return. The first is still the constraint violation.
        try {
            ctx.destroySubcontext("CN=" + sUserId + "," + sUserContainerDN);
        } catch (Exception e) {
            if (debugFlag) {
                e.printStackTrace();
            }
            sErr += " Error during rollback (delete user).";
        }
        return failurePacket(sErr);
    }

    /*private boolean acrossSessionsSacExists() {
    NamingEnumeration<?> sacs;

    try {
    SearchControls constraints = new SearchControls();
    constraints.setSearchScope(SearchControls.ONELEVEL_SCOPE);
    constraints.setReturningAttributes(new String[] { "pmId", "pmName",
    "pmType" });
    sacs = ctx.search(sSacContainerDN, "(pmType="
    + PM_DENY_ACROSS_SESSIONS + ")", constraints);
    if (sacs == null || !sacs.hasMore()) {
    return false;
    }
    return true;
    } catch (CommunicationException e) {
    if (debugFlag) {
    e.printStackTrace();
    }
    return false;
    } catch (Exception e) {
    if (debugFlag) {
    e.printStackTrace();
    }
    return false;
    }
    }
     */
    private HashSet<String> getAcrossSessSacAttrs() {
        HashSet<String> result = new HashSet<String>();
        NamingEnumeration<?> sacs;

        try {
            SearchControls constraints = new SearchControls();
            constraints.setSearchScope(SearchControls.ONELEVEL_SCOPE);
            constraints.setReturningAttributes(new String[]{"pmAttrSet"});
            sacs = ctx.search(sSacContainerDN, "(pmType="
                    + PM_DENY_ACROSS_SESSIONS + ")", constraints);
            while (sacs != null && sacs.hasMore()) {
                SearchResult sr = (SearchResult) sacs.next();
                Attribute attr = sr.getAttributes().get("pmAttrSet");
                if (attr != null) {
                    for (NamingEnumeration<?> enumer = attr.getAll(); enumer.hasMore(); ) {
                        String sAsetId = (String) enumer.next();
                        Attributes attrs = ctx.getAttributes("CN=" + sAsetId
                                + "," + sAttrSetContainerDN);
                        Attribute attr2 = attrs.get("pmAttr");
                        if (attr2 != null) {
                            for (NamingEnumeration<?> enum2 = attr2.getAll(); enum2.hasMore(); ) {
                                result.add((String) enum2.next());
                            }
                        }
                    }
                }
            }
            return result;
        } catch (Exception e) {
            if (debugFlag) {
                e.printStackTrace();
            }
            return new HashSet<String>();
        }
    }

    // Get all SACs (Subject Activation Constraints).
    // Each item contains:
    // <sac name>:<sac id>:<sac type>.
    private Packet getSacs(String sClientId) {
        Packet res = new Packet();
        NamingEnumeration<?> sacs;

        try {
            SearchControls constraints = new SearchControls();
            constraints.setSearchScope(SearchControls.ONELEVEL_SCOPE);
            constraints.setReturningAttributes(new String[]{"pmId", "pmName",
                    "pmType"});
            sacs = ctx.search(sSacContainerDN, "(objectClass=*)", constraints);

            while (sacs != null && sacs.hasMore()) {
                SearchResult sr = (SearchResult) sacs.next();
                String sName = (String) sr.getAttributes().get("pmName").get();
                String sId = (String) sr.getAttributes().get("pmId").get();
                String sType = (String) sr.getAttributes().get("pmType").get();
                res.addItem(ItemType.RESPONSE_TEXT, sName + PM_FIELD_DELIM
                        + sId + PM_FIELD_DELIM + sType);
            }
            return res;
        } catch (CommunicationException e) {
            if (debugFlag) {
                e.printStackTrace();
            }
            return failurePacket("AD connection error");
        } catch (Exception e) {
            if (debugFlag) {
                e.printStackTrace();
            }
            return failurePacket("Exception: " + e.getMessage());
        }
    }

    // Each item contains only the sac id.
    private Vector<String> getSacs() {
        Vector<String> v = new Vector<String>();
        NamingEnumeration<?> sacs;

        try {
            SearchControls constraints = new SearchControls();
            constraints.setSearchScope(SearchControls.ONELEVEL_SCOPE);
            constraints.setReturningAttributes(new String[]{"pmId"});
            sacs = ctx.search(sSacContainerDN, "(objectClass=*)", constraints);
            while (sacs != null && sacs.hasMore()) {
                SearchResult sr = (SearchResult) sacs.next();
                String sId = (String) sr.getAttributes().get("pmId").get();
                v.add(sId);
            }
        } catch (Exception e) {
            if (debugFlag) {
                e.printStackTrace();
            }
        }
        return v;
    }

    // Get all info about a SAC: id, name, attribute sets.
    // Item 0: <sac name>:<sac id>:<sac type>
    // Item 1, ...: <aset name>:<aset id>
    private Packet getSacInfo(String sClientId, String sId) {
        Attributes attrs;
        Attribute attr;

        Packet res = new Packet();

        try {
            attrs = ctx.getAttributes("CN=" + sId + "," + sSacContainerDN);

            attr = attrs.get("pmName");
            String sSac = (String) attr.get();
            attr = attrs.get("pmType");
            String sType = (String) attr.get();

            res.addItem(ItemType.RESPONSE_TEXT, sSac + PM_FIELD_DELIM + sId
                    + PM_FIELD_DELIM + sType);

            // items 1,...: the attribute sets.
            attr = attrs.get("pmAttrSet");
            if (attr != null) {
                for (NamingEnumeration<?> enumer = attr.getAll(); enumer.hasMore(); ) {
                    String sAsetId = (String) enumer.next();
                    String sAset = getEntityName(sAsetId, PM_ASET);
                    res.addItem(ItemType.RESPONSE_TEXT, sAset + PM_FIELD_DELIM
                            + sAsetId);
                }
            }
        } catch (Exception e) {
            e.printStackTrace();
            return failurePacket("Unable to retrieve complete information: "
                    + e.getMessage());
        }
        return res;
    }

    // Delete a SAC and/or a member attribute set.
    // The SAC id cannot be null or empty. The SAC must exist.
    // If the attribute set is present, delete the attribute set from the SAC.
    // Otherwise delete the sac.
    private Packet deleteSacAndAset(String sClientId, String sSacId,
                                    String sAsetId, String sAset) {
        if (sSacId == null || sSacId.length() == 0) {
            return failurePacket("The SAC id cannot be null or empty");
        }
        String sName = getEntityName(sSacId, PM_SAC);
        if (sName == null) {
            return failurePacket("Unknown SAC set " + sSacId);
        }
        if (sAsetId != null && sAsetId.length() > 0) {
            String sAsetName = getEntityName(sAsetId, PM_ASET);
            if (sAsetName == null || !sAsetName.equals(sAset)) {
                return failurePacket("No such attribute set");
            }
        }

        if (sAsetId == null || sAsetId.length() == 0) {
            // No attribute set was selected, try to delete the SAC.
            try {
                ctx.destroySubcontext("CN=" + sSacId + "," + sSacContainerDN);
            } catch (Exception e) {
                if (debugFlag) {
                    e.printStackTrace();
                }
                return failurePacket("Error while deleting SAC set " + sName
                        + ": " + e.getMessage());
            }
        } else {
            // An attribute set of the SAC is also selected. Delete the
            // attribute set only.
            ModificationItem[] mods = new ModificationItem[1];
            mods[0] = new ModificationItem(DirContext.REMOVE_ATTRIBUTE,
                    new BasicAttribute("pmAttrSet", sAsetId));
            try {
                ctx.modifyAttributes("CN=" + sSacId + "," + sSacContainerDN,
                        mods);
            } catch (Exception e) {
                if (debugFlag) {
                    e.printStackTrace();
                }
                return failurePacket("Error while deleting attribute set "
                        + sAset + ": " + e.getMessage());
            }
        }
        return successPacket();
    }

    // Add a new SAC and/or a new attribute set to it.
    // The arguments are the name of the SAC, and the id and the name of the
    // attribute set
    // to be added (or nulls).
    private Packet addSacAndAset(String sClientId, String sSac, String sType,
                                 String sAsetId, String sAset) {
        // Test if the attr set exists.
        String sSacId = getEntityId(sSac, PM_SAC);
        ModificationItem[] mods = new ModificationItem[1];

        if (sAsetId != null && sAsetId.length() > 0) {
            String sAsetName = getEntityName(sAsetId, PM_ASET);
            if (sAsetName == null || !sAsetName.equals(sAset)) {
                return failurePacket("No such attribute set");
            }
        }

        if (sSacId == null) {
            // The SAC set does not exist. Add the SAC, its type, and the
            // optional attribute set.
            Attributes attrs = new BasicAttributes(true);
            RandomGUID myGUID = new RandomGUID();
            sSacId = myGUID.toStringNoDashes();
            attrs.put("objectClass", sSacClass);
            attrs.put("pmId", sSacId);
            attrs.put("pmName", sSac);
            attrs.put("pmType", sType);
            attrs.put("pmOtherInfo", sSac);
            attrs.put("pmDescription", sSac);
            String sSacDn = "CN=" + sSacId + "," + sSacContainerDN;
            try {
                ctx.bind(sSacDn, null, attrs);
            } catch (Exception e) {
                e.printStackTrace();
                return failurePacket("Unable to create SAC set \"" + sSac
                        + "\"");
            }
            // If the attribute set is present, add it to the SAC.
            if (sAset != null && sAset.length() > 0) {
                mods[0] = new ModificationItem(DirContext.ADD_ATTRIBUTE,
                        new BasicAttribute("pmAttrSet", sAsetId));
                try {
                    ctx.modifyAttributes(sSacDn, mods);
                } catch (Exception e) {
                    e.printStackTrace();
                    return failurePacket("Unable to add attribute set \""
                            + sAset + "\": " + e.getMessage());
                }
            }
        } else {
            // SAC, try to add the attribute set, which cannot be null or
            // duplicate.
            if (sAset == null || sAset.length() == 0) {
                return failurePacket("The attribute set name cannot be null or empty");
            }

            if (sacHasAset(sSacId, sAsetId)) {
                return failurePacket("Duplicate attribute set in SAC set");
            }

            // Add the attribute set.
            mods[0] = new ModificationItem(DirContext.ADD_ATTRIBUTE,
                    new BasicAttribute("pmAttrSet", sAsetId));
            try {
                ctx.modifyAttributes("CN=" + sSacId + "," + sSacContainerDN,
                        mods);
            } catch (Exception e) {
                e.printStackTrace();
                return failurePacket("Unable to add attribute set \"" + sAset
                        + "\"; " + e.getMessage());
            }
        }

        Packet res = new Packet();
        try {
            res.addItem(ItemType.RESPONSE_TEXT, sSac + PM_FIELD_DELIM + sSacId);
        } catch (Exception e) {
            e.printStackTrace();
            return failurePacket("Exception when building the result packet!");
        }
        return res;
    }

    // Get all the attribute sets. Each item of the rsult contains name:id
    // of an attribute set.
    private Packet getAsets(String sClientId) {
        Packet res = new Packet();
        NamingEnumeration<?> asets;

        try {
            SearchControls constraints = new SearchControls();
            constraints.setSearchScope(SearchControls.ONELEVEL_SCOPE);
            constraints.setReturningAttributes(new String[]{"pmId", "pmName"});
            asets = ctx.search(sAttrSetContainerDN, "(objectClass=*)",
                    constraints);

            while (asets != null && asets.hasMore()) {
                SearchResult sr = (SearchResult) asets.next();
                String sName = (String) sr.getAttributes().get("pmName").get();
                String sId = (String) sr.getAttributes().get("pmId").get();
                res.addItem(ItemType.RESPONSE_TEXT, sName + PM_FIELD_DELIM
                        + sId);
            }
            return res;
        } catch (CommunicationException e) {
            if (debugFlag) {
                e.printStackTrace();
            }
            return failurePacket("AD connection error");
        } catch (Exception e) {
            if (debugFlag) {
                e.printStackTrace();
            }
            return failurePacket("Exception: " + e.getMessage());
        }
    }

    // Get all info about an attrset: id, name, attributes.
    private Packet getAsetInfo(String sClientId, String sId) {
        Packet res = new Packet();
        Attributes attrs;
        Attribute attr;
//		String s;

        try {
            // 0: the id.
            res.addItem(ItemType.RESPONSE_TEXT, sId);

            attrs = ctx.getAttributes("CN=" + sId + "," + sAttrSetContainerDN);

            // 1: the name.
            attr = attrs.get("pmName");
            res.addItem(ItemType.RESPONSE_TEXT, (String) attr.get());

            // 2...: the attributes.
            attr = attrs.get("pmAttr");
            if (attr != null) {
                for (NamingEnumeration<?> enumer = attr.getAll(); enumer.hasMore(); ) {
                    String sAttrId = (String) enumer.next();
                    String sAttr = getEntityName(sAttrId, PM_NODE_UATTR);
                    res.addItem(ItemType.RESPONSE_TEXT, sAttr + PM_FIELD_DELIM
                            + sAttrId);
                }
            }
        } catch (Exception e) {
            e.printStackTrace();
            return failurePacket("Unable to retrieve complete information: "
                    + e.getMessage());
        }
        return res;
    }

    // The attr set id cannot be null or empty. The attr set must exist.
    // If the attribute is present, delete the attribute from the attrset.
    // Otherwise delete the attrset.
    private Packet deleteAsetAndAttr(String sClientId, String sAsetId,
                                     String sAttrId, String sAttr) {
        if (sAsetId == null || sAsetId.length() == 0) {
            return failurePacket("The attribute set id cannot be null or empty");
        }
        String sName = getEntityName(sAsetId, PM_ASET);
        if (sName == null) {
            return failurePacket("Unknown attribute set " + sAsetId);
        }
        if (sAttrId != null && sAttrId.length() > 0) {
            String sAttrName = getEntityName(sAttrId, PM_NODE_UATTR);
            if (sAttrName == null || !sAttrName.equals(sAttr)) {
                return failurePacket("No such attribute");
            }
        }

        if (sAttrId == null || sAttrId.length() == 0) {
            // No attribute was selected, try to delete the attribute set.
            try {
                ctx.destroySubcontext("CN=" + sAsetId + ","
                        + sAttrSetContainerDN);
            } catch (Exception e) {
                if (debugFlag) {
                    e.printStackTrace();
                }
                return failurePacket("Error while deleting attribute set "
                        + sName + ": " + e.getMessage());
            }
        } else {
            // An attribute of the attrset is also selected. Delete the
            // attribute only.
            ModificationItem[] mods = new ModificationItem[1];
            mods[0] = new ModificationItem(DirContext.REMOVE_ATTRIBUTE,
                    new BasicAttribute("pmAttr", sAttrId));
            try {
                ctx.modifyAttributes("CN=" + sAsetId + ","
                        + sAttrSetContainerDN, mods);
            } catch (Exception e) {
                if (debugFlag) {
                    e.printStackTrace();
                }
                return failurePacket("Error while deleting attribute " + sAttr
                        + ": " + e.getMessage());
            }
        }
        return successPacket();
    }

    // Add an attribute set and/or a new attribute to it.
    // The arguments are the name of the attr set, and the id and the name of
    // the attribute
    // to be added (or nulls).
    private Packet addAsetAndAttr(String sSessId, String sAset, String sAttrId,
                                  String sAttr) {
        // Test if the attr set exists.
        String sAsetId = getEntityId(sAset, PM_ASET);
        ModificationItem[] mods = new ModificationItem[1];

        if (sAttrId != null && sAttrId.length() > 0) {
            String sAttrName = getEntityName(sAttrId, PM_NODE_UATTR);
            if (sAttrName == null || !sAttrName.equals(sAttr)) {
                return failurePacket("No such attribute");
            }
        }

        if (sAsetId == null) {
            // Attrset does not exist. Add the attrset and the optional
            // attribute.
            Attributes attrs = new BasicAttributes(true);
            RandomGUID myGUID = new RandomGUID();
            sAsetId = myGUID.toStringNoDashes();
            attrs.put("objectClass", sAttrSetClass);
            attrs.put("pmId", sAsetId);
            attrs.put("pmName", sAset);
            String sAsetDn = "CN=" + sAsetId + "," + sAttrSetContainerDN;
            try {
                ctx.bind(sAsetDn, null, attrs);
            } catch (Exception e) {
                e.printStackTrace();
                return failurePacket("Unable to create attribute set \""
                        + sAset + "\"");
            }
            // If the attribute is present, add it to the attrset.
            if (sAttr != null && sAttr.length() > 0) {
                mods[0] = new ModificationItem(DirContext.ADD_ATTRIBUTE,
                        new BasicAttribute("pmAttr", sAttrId));
                try {
                    ctx.modifyAttributes(sAsetDn, mods);
                } catch (Exception e) {
                    e.printStackTrace();
                    return failurePacket("Unable to add attribute \"" + sAttr
                            + "\": " + e.getMessage());
                }
            }
        } else {
            // Attribute set exist, try to add the attribute, which cannot be
            // null or duplicate.
            if (sAttr == null || sAttr.length() == 0) {
                return failurePacket("The attribute name cannot be null or empty");
            }

            if (asetHasAttr(sAsetId, sAttrId)) {
                return failurePacket("Duplicate attribute in the attribute set");
            }

            // Add the attribute
            mods[0] = new ModificationItem(DirContext.ADD_ATTRIBUTE,
                    new BasicAttribute("pmAttr", sAttrId));
            try {
                ctx.modifyAttributes("CN=" + sAsetId + ","
                        + sAttrSetContainerDN, mods);
            } catch (Exception e) {
                e.printStackTrace();
                return failurePacket("Unable to add attribute \"" + sAttr
                        + "\"; " + e.getMessage());
            }
        }
        Packet res = new Packet();
        try {
            res.addItem(ItemType.RESPONSE_TEXT, sAset + PM_FIELD_DELIM
                    + sAsetId);
        } catch (Exception e) {
            e.printStackTrace();
            return failurePacket("Exception when building the result packet!");
        }
        return res;
    }

    // Each item of the return contains <uattr name>:<uattr id>.
    private Packet getUserAttributes(String sClientId) throws Exception {
        Packet res = new Packet();
        NamingEnumeration<?> uattrs;

        try {
            SearchControls constraints = new SearchControls();
            constraints.setSearchScope(SearchControls.ONELEVEL_SCOPE);
            constraints.setReturningAttributes(new String[]{"pmId", "pmName"});
            uattrs = ctx.search(sUserAttrContainerDN, "(objectClass=*)",
                    constraints);
        } catch (CommunicationException e) {
            if (debugFlag) {
                e.printStackTrace();
            }
            return failurePacket("AD connection error");
        } catch (Exception e) {
            if (debugFlag) {
                e.printStackTrace();
            }
            return failurePacket("Exception: " + e.getMessage());
        }

        while (uattrs != null && uattrs.hasMore()) {
            SearchResult sr = (SearchResult) uattrs.next();
            String sName = (String) sr.getAttributes().get("pmName").get();
            String sId = (String) sr.getAttributes().get("pmId").get();
            res.addItem(ItemType.RESPONSE_TEXT, sName + PM_FIELD_DELIM + sId);
        }
        return res;
    }

    private Packet getUsersAndAttrs(String sSessId) {
        NamingEnumeration<?> users;

        try {
            // First the users...
            SearchControls constraints = new SearchControls();
            constraints.setSearchScope(SearchControls.ONELEVEL_SCOPE);
            constraints.setReturningAttributes(new String[]{"pmName"});
            users = ctx.search(sUserContainerDN, "(objectClass=*)", constraints);

            Packet res = new Packet();
            while (users != null && users.hasMore()) {
                SearchResult sr = (SearchResult) users.next();
                res.addItem(ItemType.RESPONSE_TEXT, (String) sr.getAttributes().get("pmName").get());
            }

            // ...now the attributes.
            // constraints = new SearchControls();
            // constraints.setSearchScope(SearchControls.ONELEVEL_SCOPE);
            // constraints.setReturningAttributes(new String[] {"pmName"});
            users = ctx.search(sUserAttrContainerDN, "(objectClass=*)",
                    constraints);

            while (users != null && users.hasMore()) {
                SearchResult sr = (SearchResult) users.next();
                res.addItem(ItemType.RESPONSE_TEXT, (String) sr.getAttributes().get("pmName").get());
            }
            return res;
        } catch (CommunicationException e) {
            if (debugFlag) {
                e.printStackTrace();
            }
            return failurePacket("AD connection error");
        } catch (Exception e) {
            if (debugFlag) {
                e.printStackTrace();
            }
            return failurePacket("Exception: " + e.getMessage());
        }
    }

    // Each item is a string <user name>:<user id>
    private Packet getUsers(String sClientId) throws Exception {
        Packet res = new Packet();
        NamingEnumeration<?> users;

        try {
            SearchControls constraints = new SearchControls();
            constraints.setSearchScope(SearchControls.ONELEVEL_SCOPE);
            constraints.setReturningAttributes(new String[]{"pmId", "pmName"});
            users = ctx.search(sUserContainerDN, "(objectClass=*)", constraints);
        } catch (CommunicationException e) {
            if (debugFlag) {
                e.printStackTrace();
            }
            return failurePacket("AD connection error");
        } catch (Exception e) {
            if (debugFlag) {
                e.printStackTrace();
            }
            return failurePacket("Exception: " + e.getMessage());
        }

        while (users != null && users.hasMore()) {
            SearchResult sr = (SearchResult) users.next();
            String sName = (String) sr.getAttributes().get("pmName").get();
            String sId = (String) sr.getAttributes().get("pmId").get();
            res.addItem(ItemType.RESPONSE_TEXT, sName + PM_FIELD_DELIM + sId);
        }
        return res;
    }

    // Retuns the policy classes as a vector. Does not take any argument.
    private Vector<String> getPolicyClasses() {
        Vector<String> v = new Vector<String>();
        NamingEnumeration<?> policies;

        try {
            SearchControls constraints = new SearchControls();
            constraints.setSearchScope(SearchControls.ONELEVEL_SCOPE);
            constraints.setReturningAttributes(new String[]{"pmId"});
            policies = ctx.search(sPolicyContainerDN, "(objectClass=*)",
                    constraints);
            if (policies == null) {
                return v;
            }
            while (policies.hasMore()) {
                SearchResult sr = (SearchResult) policies.next();
                v.add((String) sr.getAttributes().get("pmId").get());
            }
        } catch (Exception e) {
            if (debugFlag) {
                e.printStackTrace();
            }
        }
        return v;
    }

    // Each item contains <policy name>:<policy id>
    private Packet getPolicyClasses(String sClientId) throws Exception {
        Packet result = new Packet();
        NamingEnumeration<?> policies;

        try {
            SearchControls constraints = new SearchControls();
            constraints.setSearchScope(SearchControls.ONELEVEL_SCOPE);
            constraints.setReturningAttributes(new String[]{"pmId", "pmName"});
            policies = ctx.search(sPolicyContainerDN, "(objectClass=*)",
                    constraints);
        } catch (CommunicationException e) {
            if (debugFlag) {
                e.printStackTrace();
            }
            return failurePacket("AD connection error");
        } catch (Exception e) {
            if (debugFlag) {
                e.printStackTrace();
            }
            return failurePacket("Exception in getPolicyClasses: "
                    + e.getMessage());
        }

        if (policies != null) {
            while (policies.hasMore()) {
                SearchResult sr = (SearchResult) policies.next();
                String sName = (String) sr.getAttributes().get("pmName").get();
                String sId = (String) sr.getAttributes().get("pmId").get();
                result.addItem(ItemType.RESPONSE_TEXT, sName + PM_FIELD_DELIM
                        + sId);
            }
        }
        return result;
    }

    // Add a policy class with the given name, description, info, and
    // properties.
    // First test permissions, then call the internal function.
    private Packet addPc(String sSessId, String sProcId, String sName,
                         String sDescr, String sInfo, String[] sProps) {

        // Test permissions.
        if (!requestAddPcPerms(sSessId, sProcId)) {
            return failurePacket(reqPermsMsg);
        }
        return addPcInternal(sName, null, sDescr, sInfo, sProps);
    }

    // sId may be null, in which case the engine generates an id. Sometimes,
    // we want the pc to have a certain id (e.g., when the initial objects
    // are created.
    private Packet addPcInternal(String sName, String sId, String sDescr,
                                 String sInfo, String[] sProps) {
        // Test if duplicate name.
        if (entityNameExists(sName, PM_NODE_POL)) {
            return failurePacket("Policy with duplicate name");
        }

        // Prepare the attributes of the new policy class object.
        Attributes attrs = new BasicAttributes(true);
        if (sId == null) {
            RandomGUID myGUID = new RandomGUID();
            sId = myGUID.toStringNoDashes();
        }
        attrs.put("objectClass", sPolicyClass);
        attrs.put("pmId", sId);
        attrs.put("pmName", sName);
        attrs.put("pmDescription", sDescr);
        attrs.put("pmOtherInfo", sInfo);
        attrs.put("pmToConnector", PM_CONNECTOR_ID);

        // Prepare the path and create.
        String sDn = "CN=" + sId + "," + sPolicyContainerDN;
        try {
            ctx.bind(sDn, null, attrs);
        } catch (InvalidNameException e) {
            if (debugFlag) {
                e.printStackTrace();
            }
            return failurePacket("Invalid object name (id)" + sId);
        } catch (NameAlreadyBoundException e) {
            if (debugFlag) {
                e.printStackTrace();
            }
            return failurePacket("Duplicate id " + sId);
        } catch (Exception e) {
            if (debugFlag) {
                e.printStackTrace();
            }
            return failurePacket("Probably invalid id " + sId);
        }

        // Prepare to add back link to the new policy in the connector node.
        // NOTE THAT THE ATTRIBUTE SHOULD BE NAMED pmFromPolicy,
        // BUT I WRONGLY DEFINED THAT ATTRIBUTE AS BEING SINGLE VALUED,
        // SO I HAD TO DEFINE A NEW ONE.
        String sConnectorDn = "CN=" + PM_CONNECTOR_ID + ","
                + sConnectorContainerDN;
        ModificationItem[] mods = new ModificationItem[1];
        mods[0] = new ModificationItem(DirContext.ADD_ATTRIBUTE,
                new BasicAttribute("pmFromPolicyClass", sId));
        // Add the back link.
        try {
            ctx.modifyAttributes(sConnectorDn, mods);
        } catch (Exception e) {
            if (debugFlag) {
                e.printStackTrace();
            }
            return failurePacket("Unable to set link to new policy in the connector node");
        }

        // Add the pc's properties, if any.
        if (sProps == null) {
            return successPacket();
        }
        int n = sProps.length;
        if (n <= 0) {
            return successPacket();
        }
        mods = new ModificationItem[n];
        for (int i = 0; i < n; i++) {
            System.out.println("Prop " + sProps[i]);
            mods[i] = new ModificationItem(DirContext.ADD_ATTRIBUTE,
                    new BasicAttribute("pmProperty", sProps[i]));
        }
        try {
            ctx.modifyAttributes("CN=" + sId + "," + sPolicyContainerDN, mods);
        } catch (Exception e) {
            if (debugFlag) {
                e.printStackTrace();
            }
            return failurePacket("Unable to set the new user attribute's properties!");
        }
        Packet res = new Packet();
        try {
            res.addItem(ItemType.RESPONSE_TEXT, sName + PM_FIELD_DELIM + sId);
        } catch (Exception e) {
            e.printStackTrace();
            return failurePacket("Unable to create the result package!");
        }
        return res;
    }

    private Packet deletePolicyClass(String sClientId, String sIdToDelete) {
        if (!entityExists(sIdToDelete, PM_NODE_POL)) {
            return failurePacket("No such policy id " + sIdToDelete);
        }
        if (!policyHasNoAscendant(sIdToDelete)) {
            return failurePacket("Policy class has ascendants");
        }

        Packet res;

        res =  deleteDoubleLink(sIdToDelete, PM_NODE_POL,
                PM_CONNECTOR_ID, PM_NODE_CONN);
        if (res.hasError()) {
            return res;
        }

        // Destroy the policy class object.
        try {
            ctx.destroySubcontext("CN=" + sIdToDelete + ","
                    + sPolicyContainerDN);
        } catch (Exception e) {
            if (debugFlag) {
                e.printStackTrace();
            }
            return failurePacket("Could not delete policy class " + sIdToDelete);
        }

        return successPacket();
    }

    private boolean policyHasNoAscendant(String sId) {
        Attributes attrs;
        try {
            attrs = ctx.getAttributes("CN=" + sId + "," + sPolicyContainerDN);
        } catch (NameNotFoundException e) {
            if (debugFlag) {
                e.printStackTrace();
            }
            return false;
        } catch (CommunicationException e) {
            if (debugFlag) {
                e.printStackTrace();
            }
            return false;
        } catch (Exception e) {
            if (debugFlag) {
                e.printStackTrace();
            }
            return false;
        }
        Attribute attr = attrs.get("pmFromUserAttr");
        if (attr != null && attr.size() > 0) {
            return false;
        }
        attr = attrs.get("pmFromObjAttr");
        if (attr != null && attr.size() > 0) {
            return false;
        }
        return true;
    }

    // Get the object attribute associated to an object given by its id.
    private String getAssocOattr(String sObjId) {
        Attributes attrs;
        Attribute attr;
        if (sObjId == null) {
            return null;
        }
        try {
            attrs = ctx.getAttributes("CN=" + sObjId + ","
                    + sVirtualObjContainerDN);
            attr = attrs.get("pmAssocAttr");
            if (attr == null || attr.size() <= 0) {
                return null;
            }
            return (String) attr.get();
        } catch (Exception e) {
            if (debugFlag) {
                e.printStackTrace();
            }
        }
        return null;
    }

    // An object attribute is ignored when computing an user's VOS iff:
    // the object attribute is associated to an object, AND (the object
    // either represents a PM entity, OR is a clipboard object).
    private boolean ignoreOattrInVos(String sOattrId) {
        Attributes attrs;
        Attribute attr;

        System.out.println("oooooooo ignoreOattrInVos for "
                + getEntityName(sOattrId, PM_NODE_OATTR));

        try {
            attrs = ctx.getAttributes("CN=" + sOattrId + ","
                    + sObjAttrContainerDN);
            attr = attrs.get("pmAssocObj");
            if (attr == null || attr.size() <= 0) {
                System.out.println("ignoreOattrInVos: pmAssocObj is null or empty");
                return false;
            }
            String sObjId = (String) attr.get();
            attrs = ctx.getAttributes("CN=" + sObjId + ","
                    + sVirtualObjContainerDN);
            attr = attrs.get("pmObjClass");
            if (attr == null || attr.size() <= 0) {
                System.out.println("ignoreOattrInVos: pmObjClass is null or empty");
                return false;
            }
            String sClass = (String) attr.get();
            System.out.println("ignoreOattrInVos: sClass is " + sClass);
            if (sClass.equalsIgnoreCase(PM_CLASS_CLASS_NAME)) {
                return true;
            }
            if (sClass.equalsIgnoreCase(PM_CLASS_USER_NAME)) {
                return true;
            }
            if (sClass.equalsIgnoreCase(PM_CLASS_UATTR_NAME)) {
                return true;
            }
            if (sClass.equalsIgnoreCase(PM_CLASS_OBJ_NAME)) {
                return true;
            }
            if (sClass.equalsIgnoreCase(PM_CLASS_OATTR_NAME)) {
                return true;
            }
            if (sClass.equalsIgnoreCase(PM_CLASS_CONN_NAME)) {
                return true;
            }
            if (sClass.equalsIgnoreCase(PM_CLASS_POL_NAME)) {
                return true;
            }
            if (sClass.equalsIgnoreCase(PM_CLASS_OPSET_NAME)) {
                return true;
            }
            if (sClass.equalsIgnoreCase(PM_CLASS_CLIPBOARD_NAME)) {
                System.out.println("ignoreOattrInVos: returned true.");
                return true;
            }
            return false;
        } catch (Exception e) {
            if (debugFlag) {
                e.printStackTrace();
            }
            return false;
        }
    }

    // Get the object associated to an object attribute or null if no such
    // object exists.
    private String getAssocObj(String sOattrId) {
        Attributes attrs;
        Attribute attr;
        try {
            attrs = ctx.getAttributes("CN=" + sOattrId + ","
                    + sObjAttrContainerDN);
            attr = attrs.get("pmAssocObj");
            // Should not happen, function should be called only for associated
            // attributes.
            if (attr == null || attr.size() <= 0) {
                return null;
            }
            return (String) attr.get();
        } catch (Exception e) {
            if (debugFlag) {
                e.printStackTrace();
            }
            return null;
        }
    }

    // Get the object associated to an object attribute given by its id.
    private Packet getAssocObj(String sClientId, String sOattrId) {
        Attributes attrs;
        Attribute attr;
        try {
            attrs = ctx.getAttributes("CN=" + sOattrId + ","
                    + sObjAttrContainerDN);
            attr = attrs.get("pmAssocObj");
            // Should not happen, function should be called only for associated
            // attributes.
            if (attr == null || attr.size() <= 0) {
                return null;
            }
            Packet res = new Packet();
            res.addItem(ItemType.RESPONSE_TEXT, (String) attr.get());
            return res;
        } catch (Exception e) {
            if (debugFlag) {
                e.printStackTrace();
            }
            return failurePacket("Couldn't get the object: " + e.getMessage());
        }
    }

    // Get the obj class name of an object associated to a given attribute.
    /*private String getAssocObjClassName(String sOattrId) {
    Attributes attrs;
    Attribute attr;
    try {
    attrs = ctx.getAttributes("CN=" + sOattrId + ","
    + sObjAttrContainerDN);
    attr = attrs.get("pmAssocObj");
    // Should not happen, function should be called only for associated
    // attributes.
    if (attr == null || attr.size() <= 0) {
    return null;
    }
    String sObjId = (String) attr.get();
    attrs = ctx.getAttributes("CN=" + sObjId + ","
    + sVirtualObjContainerDN);
    attr = attrs.get("pmObjClass");
    return (String) attr.get();
    } catch (Exception e) {
    if (debugFlag) {
    e.printStackTrace();
    }
    }
    return null;
    }*/
    private boolean hasAssocObj(String sId) {
        Attributes attrs;
        try {
            attrs = ctx.getAttributes("CN=" + sId + "," + sObjAttrContainerDN);
        } catch (Exception e) {
            if (debugFlag) {
                e.printStackTrace();
            }
            return false;
        }
        Attribute attr = attrs.get("pmAssocObj");
        if (attr == null || attr.size() <= 0) {
            return false;
        }
        return true;
    }

    /*private boolean opsetHasUserAttrs(String sId) {
    Attributes attrs;
    try {
    attrs = ctx.getAttributes("CN=" + sId + "," + sOpsetContainerDN);
    } catch (Exception e) {
    if (debugFlag) {
    e.printStackTrace();
    }
    return false;
    }
    Attribute attr = attrs.get("pmFromAttr");
    if (attr != null && attr.size() > 0) {
    return true;
    }
    return false;
    }

    private boolean opsetHasObjAttrs(String sId) {
    Attributes attrs;
    try {
    attrs = ctx.getAttributes("CN=" + sId + "," + sOpsetContainerDN);
    } catch (Exception e) {
    if (debugFlag) {
    e.printStackTrace();
    }
    return false;
    }
    Attribute attr = attrs.get("pmToAttr");
    if (attr != null && attr.size() > 0) {
    return true;
    }
    return false;
    }*/
    private boolean opsetIsIsolated(String sId) {
        Attributes attrs;
        try {
            attrs = ctx.getAttributes("CN=" + sId + "," + sOpsetContainerDN);
        } catch (Exception e) {
            if (debugFlag) {
                e.printStackTrace();
            }
            return false;
        }
        Attribute attr = attrs.get("pmFromAttr");
        if (attr != null && attr.size() > 0) {
            return false;
        }
        attr = attrs.get("pmToAttr");
        if (attr == null || attr.size() <= 0) {
            return true;
        }
        return false;
    }

    private boolean entityExists(String sId, String sType) {
        NamingEnumeration<?> objects;
        String sContainer;

        if (sType.equalsIgnoreCase(PM_NODE_CONN)) {
            sContainer = sConnectorContainerDN;
        } else if (sType.equalsIgnoreCase(PM_NODE_POL)) {
            sContainer = sPolicyContainerDN;
        } else if (sType.equalsIgnoreCase(PM_NODE_USER)) {
            sContainer = sUserContainerDN;
        } else if (sType.equalsIgnoreCase(PM_NODE_UATTR)) {
            sContainer = sUserAttrContainerDN;
        } else if (sType.equalsIgnoreCase(PM_NODE_OATTR)) {
            sContainer = sObjAttrContainerDN;
        } else if (sType.equalsIgnoreCase(PM_NODE_ASSOC)) {
            sContainer = sObjAttrContainerDN;
        } else if (sType.equalsIgnoreCase(PM_NODE_OPSET)) {
            sContainer = sOpsetContainerDN;
        } else if (sType.equalsIgnoreCase(PM_OBJ)) {
            sContainer = sVirtualObjContainerDN;
        } else if (sType.equalsIgnoreCase(PM_HOST)) {
            sContainer = sHostContainerDN;
        } else if (sType.equalsIgnoreCase(PM_OBJ_CLASS)) {
            sContainer = sObjClassContainerDN;
        } else if (sType.equalsIgnoreCase(PM_SESSION)) {
            sContainer = sSessionContainerDN;
        } else if (sType.equalsIgnoreCase(PM_EMAIL_ACCT)) {
            sContainer = sEmailAcctContainerDN;
        } else {
            return false;
        }

        try {
            SearchControls constraints = new SearchControls();
            constraints.setSearchScope(SearchControls.ONELEVEL_SCOPE);
            constraints.setReturningAttributes(null);
            objects = ctx.search(sContainer, "(pmId=" + sId + ")", constraints);
            if (objects == null || !objects.hasMore()) {
                return false;
            }
        } catch (Exception e) {
            e.printStackTrace();
            return false;
        }
        return true;
    }

    private boolean entityNameExists(String sName, String sType) {
        NamingEnumeration<?> objects;
        String sContainer;

        if (sType.equalsIgnoreCase(PM_NODE_CONN)) {
            sContainer = sConnectorContainerDN;
        } else if (sType.equalsIgnoreCase(PM_NODE_POL)) {
            sContainer = sPolicyContainerDN;
        } else if (sType.equalsIgnoreCase(PM_NODE_USER)) {
            sContainer = sUserContainerDN;
        } else if (sType.equalsIgnoreCase(PM_NODE_UATTR)) {
            sContainer = sUserAttrContainerDN;
        } else if (sType.equalsIgnoreCase(PM_NODE_OATTR)) {
            sContainer = sObjAttrContainerDN;
        } else if (sType.equalsIgnoreCase(PM_NODE_ASSOC)) {
            sContainer = sObjAttrContainerDN;
        } else if (sType.equalsIgnoreCase(PM_OBJ)) {
            sContainer = sVirtualObjContainerDN;
        } else if (sType.equalsIgnoreCase(PM_NODE_OPSET)) {
            sContainer = sOpsetContainerDN;
        } else if (sType.equalsIgnoreCase(PM_HOST)) {
            sContainer = sHostContainerDN;
        } else if (sType.equalsIgnoreCase(PM_OBJ_CLASS)) {
            sContainer = sObjClassContainerDN;
        } else {
            return false;
        }

        try {
            SearchControls constraints = new SearchControls();
            constraints.setSearchScope(SearchControls.ONELEVEL_SCOPE);
            constraints.setReturningAttributes(null);
            objects = ctx.search(sContainer, "(pmName=" + sName + ")",
                    constraints);
            if (objects == null || !objects.hasMore()) {
                return false;
            }
        } catch (Exception e) {
            e.printStackTrace();
            return false;
        }
        return true;
    }

    private Packet getObjNamePath(String sObjName) {
        String sObjId = getEntityId(sObjName, PM_OBJ);
        if (sObjId == null) {
            return failurePacket("No object " + sObjName + "!");
        }
        String sPath = getObjPath(sObjId);
        if (sPath == null) {
            return failurePacket("No path for object " + sObjName + "!");
        }
        Packet res = new Packet();
        try {
            res.addItem(ItemType.RESPONSE_TEXT, sPath);
        } catch (Exception e) {
            e.printStackTrace();
            return failurePacket("Exception when building the result packet!");
        }
        return res;
    }

    private String getObjPath(String sId) {
        Attributes attrs;
        Attribute attr;
        try {
            attrs = ctx.getAttributes("CN=" + sId + ","
                    + sVirtualObjContainerDN);
            attr = attrs.get("pmPath");
            if (attr == null) {
                return null;
            }
            return (String) attr.get();
        } catch (Exception e) {
            e.printStackTrace();
            return null;
        }
    }

    // Get all info about an opset: id, name, descr, info, class name, ops.
    private Packet getOpsetInfo(String sClientId, String sId) {
        Packet res = new Packet();
        Attributes attrs;
        Attribute attr;
        //String s;

        try {
            // 0: the id.
            res.addItem(ItemType.RESPONSE_TEXT, sId);

            attrs = ctx.getAttributes("CN=" + sId + "," + sOpsetContainerDN);

            // 1: the name.
            attr = attrs.get("pmName");
            res.addItem(ItemType.RESPONSE_TEXT, (String) attr.get());

            // 2: the description.
            attr = attrs.get("pmDescription");
            res.addItem(ItemType.RESPONSE_TEXT, (String) attr.get());

            // 3: the other info.
            attr = attrs.get("pmOtherInfo");
            res.addItem(ItemType.RESPONSE_TEXT, (String) attr.get());

            // 4: the class name is ignored.
            attr = attrs.get("pmObjClass");
            res.addItem(ItemType.RESPONSE_TEXT, (String) attr.get());

            // 5...: the operations.
            attr = attrs.get("pmOp");
            if (attr != null) {
                for (NamingEnumeration<?> enumer = attr.getAll(); enumer.hasMore(); ) {
                    res.addItem(ItemType.RESPONSE_TEXT, (String) enumer.next());
                }
            }
        } catch (Exception e) {
            e.printStackTrace();
            return failurePacket("Unable to retrieve complete information: "
                    + e.getMessage());
        }
        return res;
    }

    // Get the class id of a given operation set.
    /*private String getOpsetClassId(String sOpsetId) {
    String sClassId;

    try {
    Attributes attrs = ctx.getAttributes("CN=" + sOpsetId + ","
    + sOpsetContainerDN);
    Attribute attr = attrs.get("pmObjClass");
    sClassId = (String) attr.get();
    } catch (Exception e) {
    if (debugFlag) {
    e.printStackTrace();
    }
    return null;
    }
    return sClassId;
    }*/
    private Packet getOpsetClassName(String sClientId, String sOpsetId) {
        String sName = getOpsetClassName(sOpsetId);
        if (sName == null) {
            return failurePacket("Unable to find opset or its class");
        }
        Packet res = new Packet();
        try {
            res.addItem(ItemType.RESPONSE_TEXT, sName);
        } catch (Exception e) {
            e.printStackTrace();
            return failurePacket("Exception in getOpsetClassName: "
                    + e.getMessage());
        }
        return res;
    }

    // Get the class name of a given operation set.
    private String getOpsetClassName(String sOpsetId) {
        String sClassId;

        try {
            Attributes attrs = ctx.getAttributes("CN=" + sOpsetId + ","
                    + sOpsetContainerDN);
            Attribute attr = attrs.get("pmObjClass");
            sClassId = (String) attr.get();
        } catch (Exception e) {
            if (debugFlag) {
                e.printStackTrace();
            }
            return null;
        }
        return getEntityName(sClassId, PM_OBJ_CLASS);
    }

    // Get all operations of an operation set. The operation set is identified
    // by
    // its name!!!
    private Packet getOpsetOps(String sClientId, String sOpset) {
        Packet res = new Packet();
        NamingEnumeration<?> ops;

        try {
            SearchControls constraints = new SearchControls();
            constraints.setSearchScope(SearchControls.ONELEVEL_SCOPE);
            constraints.setReturningAttributes(new String[]{"pmOp"});
            ops = ctx.search(sOpsetContainerDN, "(pmName=" + sOpset + ")",
                    constraints);
            // ops should have exactly one entry.
            if (ops == null || !ops.hasMore()) {
                return failurePacket("No operation set " + sOpset);
            }
            SearchResult sr = (SearchResult) ops.next();
            Attributes attrs = sr.getAttributes();
            Attribute attr = attrs.get("pmOp");
            if (attr != null) {
                for (NamingEnumeration<?> enumer = attr.getAll(); enumer.hasMore(); ) {
                    res.addItem(ItemType.RESPONSE_TEXT, (String) enumer.next());
                }
            }
        } catch (Exception e) {
            e.printStackTrace();
            return failurePacket(e.getMessage());
        }
        return res;
    }

    private Packet getEntityId(String sSessId, String sName, String sType) {
        String sId = getEntityId(sName, sType);
        if (sId == null) {
            return failurePacket("No such entity or type!");
        }
        Packet result = new Packet();
        try {
            result.addItem(ItemType.RESPONSE_TEXT, sId);
        } catch (Exception e) {
            e.printStackTrace();
            return failurePacket("Exception when building the result packet");
        }
        return result;
    }

    private Packet getEntityName(String sSessId, String sId, String sType) {
        String sName = getEntityName(sId, sType);
        if (sName == null) {
            return failurePacket("No such entity or type!");
        }
        Packet result = new Packet();
        try {
            result.addItem(ItemType.RESPONSE_TEXT, sName);
        } catch (Exception e) {
            e.printStackTrace();
            return failurePacket("Exception when building the result packet");
        }
        return result;
    }

    /*private String getEntityIdFromNameAndClass(String sEntName, String sEntClass) {
    String sType = classToType(sEntClass);
    return getIdOfEntityWithNameAndType(sEntName, sType);
    }
     */
    // Given the name of an entity, return the id, if the entity exists,
    // otherwise null. Special care for entity name containing special
    // character *.
    private String getEntityId(String sName, String sType) {
        String sId = null;
        String sCont = null;

        if (sName == null) {
            return null;
        }
        if (sName.equals("*")) {
            return "*";
        }

        if (sType.equalsIgnoreCase(PM_NODE_USER)) {
            sCont = sUserContainerDN;
        } else if (sType.equalsIgnoreCase(PM_NODE_UATTR)) {
            sCont = sUserAttrContainerDN;
        } else if (sType.equalsIgnoreCase(PM_OBJ)) {
            sCont = sVirtualObjContainerDN;
        } else if (sType.equalsIgnoreCase(PM_NODE_OATTR)) {
            sCont = sObjAttrContainerDN;
        } else if (sType.equalsIgnoreCase(PM_NODE_ASSOC)) {
            sCont = sObjAttrContainerDN;
        } else if (sType.equalsIgnoreCase(PM_NODE_POL)) {
            sCont = sPolicyContainerDN;
        } else if (sType.equalsIgnoreCase(PM_NODE_OPSET)) {
            sCont = sOpsetContainerDN;
        } else if (sType.equalsIgnoreCase(PM_HOST)) {
            sCont = sHostContainerDN;
        } else if (sType.equalsIgnoreCase(PM_OBJ_CLASS)) {
            sCont = sObjClassContainerDN;
        } else if (sType.equalsIgnoreCase(PM_NODE_CONN)) {
            sCont = sConnectorContainerDN;
        } else if (sType.equalsIgnoreCase(PM_ASET)) {
            sCont = sAttrSetContainerDN;
        } else if (sType.equalsIgnoreCase(PM_SAC)) {
            sCont = sSacContainerDN;
        } else if (sType.equalsIgnoreCase(PM_DENY)) {
            sCont = sDenyContainerDN;
        } else if (sType.equalsIgnoreCase(PM_SCRIPT)) {
            sCont = sRuleContainerDN;
        } else if (sType.equalsIgnoreCase(PM_TASK)) {
            sCont = sTaskContainerDN;
        } else if (sType.equalsIgnoreCase(PM_SCON)) {
            sCont = sSconContainerDN;
        } else if (sType.equalsIgnoreCase(PM_SCONA)) {
            sCont = sSconaContainerDN;
        } else if (sType.equalsIgnoreCase(PM_TEMPLATE)) {
            sCont = sTemplateContainerDN;
        } else if (sType.equalsIgnoreCase(PM_SESSION)) {
            sCont = sSessionContainerDN;
        } else if (sType.equalsIgnoreCase(PM_PROCESS)) {
            return sName;
        } else {
            return null;
        }

        NamingEnumeration<?> entities;
        String sPreparedName = sName.replaceAll("\\*", "\\\\*");
        try {
            SearchControls constraints = new SearchControls();
            constraints.setSearchScope(SearchControls.ONELEVEL_SCOPE);
            constraints.setReturningAttributes(new String[]{"pmId"});
            entities = ctx.search(sCont, "(pmName=" + sPreparedName + ")",
                    constraints);
            if (entities == null || !entities.hasMore()) {
                return null;
            }

            SearchResult sr = (SearchResult) entities.next();
            Attributes attrs = sr.getAttributes();
            //Attribute attr = attrs.get("pmId");
            sId = (String) (attrs.get("pmId").get());
        } catch (Exception e) {
            e.printStackTrace();
            return null;
        }
        return sId;
    }

    // Test whether a given opset contains a given operation.
    private boolean opsetContainsOp(String sOpsetId, String sOp) {
        Attributes attrs;
        Attribute attr;

        try {
            attrs = ctx.getAttributes("CN=" + sOpsetId + ","
                    + sOpsetContainerDN);
            attr = attrs.get("pmOp");
            if (attr == null) {
                return false;
            }
            for (NamingEnumeration<?> attrEnum = attr.getAll(); attrEnum.hasMore(); ) {
                if (sOp.equalsIgnoreCase((String) attrEnum.next())) {
                    return true;
                }
            }
        } catch (Exception e) {
            e.printStackTrace();
            return false;
        }
        return false;
    }

    // Test whether a given attr set has a given attribute.
    private boolean asetHasAttr(String sAsetId, String sAttrId) {
        Attributes attrs;
        Attribute attr;

        try {
            attrs = ctx.getAttributes("CN=" + sAsetId + ","
                    + sAttrSetContainerDN);
            attr = attrs.get("pmAttr");
            if (attr == null) {
                return false;
            }
            for (NamingEnumeration<?> attrEnum = attr.getAll(); attrEnum.hasMore(); ) {
                if (sAttrId.equalsIgnoreCase((String) attrEnum.next())) {
                    return true;
                }
            }
        } catch (Exception e) {
            e.printStackTrace();
            return false;
        }
        return false;
    }

    private boolean denyHasOp(String sDenyId, String sOp) {
        Attributes attrs;
        Attribute attr;

        try {
            attrs = ctx.getAttributes("CN=" + sDenyId + "," + sDenyContainerDN);
            attr = attrs.get("pmOp");
            if (attr == null) {
                return false;
            }
            for (NamingEnumeration<?> attrEnum = attr.getAll(); attrEnum.hasMore(); ) {
                if (sOp.equalsIgnoreCase((String) attrEnum.next())) {
                    return true;
                }
            }
        } catch (Exception e) {
            e.printStackTrace();
            return false;
        }
        return false;
    }

    private boolean denyHasOattr(String sDenyId, String sOattrId) {
        Attributes attrs;
        Attribute attr;

        if (sOattrId.startsWith("!")) {
            sOattrId = sOattrId.substring(1);
        }
        try {
            attrs = ctx.getAttributes("CN=" + sDenyId + "," + sDenyContainerDN);
            attr = attrs.get("pmAttr");
            if (attr == null) {
                return false;
            }
            for (NamingEnumeration<?> attrEnum = attr.getAll(); attrEnum.hasMore(); ) {
                String sCrtId = (String) attrEnum.next();
                if (sCrtId.startsWith("!")) {
                    sCrtId = sCrtId.substring(1);
                }
                if (sOattrId.equalsIgnoreCase(sCrtId)) {
                    return true;
                }
            }
        } catch (Exception e) {
            e.printStackTrace();
            return false;
        }
        return false;
    }

    // Test whether a given SAC set has a given attribute set.
    private boolean sacHasAset(String sSacId, String sAsetId) {
        Attributes attrs;
        Attribute attr;

        try {
            attrs = ctx.getAttributes("CN=" + sSacId + "," + sSacContainerDN);
            attr = attrs.get("pmAttrSet");
            if (attr == null) {
                return false;
            }
            for (NamingEnumeration<?> attrEnum = attr.getAll(); attrEnum.hasMore(); ) {
                if (sAsetId.equalsIgnoreCase((String) attrEnum.next())) {
                    return true;
                }
            }
        } catch (Exception e) {
            e.printStackTrace();
            return false;
        }
        return false;
    }

    // Test whether a given class has a given operation.
    private boolean objClassHasOp(String sClassId, String sOp) {
        Attributes attrs;
        Attribute attr;
        //String sCont;

        try {
            attrs = ctx.getAttributes("CN=" + sClassId + ","
                    + sObjClassContainerDN);
            attr = attrs.get("pmOp");
            if (attr == null) {
                return false;
            }
            for (NamingEnumeration<?> attrEnum = attr.getAll(); attrEnum.hasMore(); ) {
                if (sOp.equalsIgnoreCase((String) attrEnum.next())) {
                    return true;
                }
            }
        } catch (Exception e) {
            e.printStackTrace();
            return false;
        }
        return false;
    }

    // Test whether a user is assigned to a (user) attribute.
    private boolean userIsAssigned(String sId1, String sId2) {
        Attributes attrs;
        Attribute attr;
        try {
            attrs = ctx.getAttributes("CN=" + sId1 + "," + sUserContainerDN);
            attr = attrs.get("pmToAttr");
            if (attr == null) {
                return false;
            }
            for (NamingEnumeration<?> attrEnum = attr.getAll(); attrEnum.hasMore(); ) {
                String sId = (String) attrEnum.next();
                if (sId2.equals(sId)) {
                    return true;
                }
            }
        } catch (Exception e) {
            return false;
        }
        return false;
    }

    // Test whether an operation set is assigned to the connector.
    private boolean opsetIsAssignedToConnector(String sId) {
        Attributes attrs;
        Attribute attr;
        try {
            attrs = ctx.getAttributes("CN=" + sId + "," + sOpsetContainerDN);
            attr = attrs.get("pmToConnector");
            if (attr == null) {
                return false;
            }
            String sConn = (String) attr.get();
            if (sConn == null) {
                return false;
            }
            if (sConn.equalsIgnoreCase(PM_CONNECTOR_ID)) {
                return true;
            }
            return false;
        } catch (Exception e) {
            return false;
        }
    }

    // Test whether a user is assigned (directly) to the connector.
    private boolean userIsAssignedToConnector(String sId) {
        Attributes attrs;
        Attribute attr;
        try {
            attrs = ctx.getAttributes("CN=" + sId + "," + sUserContainerDN);
            attr = attrs.get("pmToConnector");
            if (attr == null) {
                return false;
            }
            String sConn = (String) attr.get();
            if (sConn == null) {
                return false;
            }
            if (sConn.equalsIgnoreCase(PM_CONNECTOR_ID)) {
                return true;
            }
            return false;
        } catch (Exception e) {
            return false;
        }
    }

    // Test whether a user has no descendant.
    private boolean userHasNoDescendant(String sId) {
        Attributes attrs;
        Attribute attr;
        String s;

        try {
            // Check the connector.
            attrs = ctx.getAttributes("CN=" + sId + "," + sUserContainerDN);
            attr = attrs.get("pmToConnector");
            if (attr != null) {
                s = (String) attr.get();
                if (s != null && s.equalsIgnoreCase(PM_CONNECTOR_ID)) {
                    return false;
                }
            }

            // Check the user attributes.
            attr = attrs.get("pmToAttr");
            if (attr != null && attr.size() > 0) {
                return false;
            }

            return true;
        } catch (Exception e) {
            return false;
        }
    }

    private boolean attrHasAscendants(String sId, String sType) {
        Attributes attrs;
        String sDn;

        if (sType.equalsIgnoreCase(PM_NODE_UATTR)) {
            sDn = "CN=" + sId + "," + sUserAttrContainerDN;
        } else if (sType.equalsIgnoreCase(PM_NODE_OATTR)) {
            sDn = "CN=" + sId + "," + sObjAttrContainerDN;
        } else if (sType.equalsIgnoreCase(PM_NODE_ASSOC)) {
            sDn = "CN=" + sId + "," + sObjAttrContainerDN;
        } else {
            return false;
        }

        try {
            attrs = ctx.getAttributes(sDn);
        } catch (Exception e) {
            if (debugFlag) {
                e.printStackTrace();
            }
            return false;
        }

        Attribute attr = attrs.get("pmFromAttr");
        if (attr != null && attr.size() > 0) {
            return true;
        }

        if (sType.equalsIgnoreCase(PM_NODE_UATTR)) {
            attr = attrs.get("pmFromUser");
            if (attr != null && attr.size() > 0) {
                return true;
            }
        }

        return false;
    }

    // Test whether an attribute (user or object) has descendants of type
    // attribute,
    // policy class, or connector.
    private boolean attrHasDescendants(String sId, String sType) {
        Attributes attrs;
        Attribute attr;
        String sDn;
        String s;

        if (sType.equalsIgnoreCase(PM_NODE_UATTR)) {
            sDn = "CN=" + sId + "," + sUserAttrContainerDN;
        } else if (sType.equalsIgnoreCase(PM_NODE_OATTR)) {
            sDn = "CN=" + sId + "," + sObjAttrContainerDN;
        } else if (sType.equalsIgnoreCase(PM_NODE_ASSOC)) {
            sDn = "CN=" + sId + "," + sObjAttrContainerDN;
        } else {
            return false;
        }

        try {
            // Check the connector.
            attrs = ctx.getAttributes(sDn);
            attr = attrs.get("pmToConnector");
            if (attr != null) {
                s = (String) attr.get();
                if (s != null && s.equalsIgnoreCase(PM_CONNECTOR_ID)) {
                    return true;
                }
            }

            // Check attributes.
            attr = attrs.get("pmToAttr");
            if (attr != null && attr.size() > 0) {
                return true;
            }

            // Check policy classes.
            attr = attrs.get("pmToPolicy");
            if (attr != null && attr.size() > 0) {
                return true;
            }
        } catch (Exception e) {
            if (debugFlag) {
                e.printStackTrace();
            }
        }
        return false;
    }

    private boolean attrHasOpsets(String sId, String sType) {
        Attributes attrs;
        String sDn;
        String sAttr;

        if (sType.equalsIgnoreCase(PM_NODE_UATTR)) {
            sDn = "CN=" + sId + "," + sUserAttrContainerDN;
            sAttr = "pmToOpSet";
        } else if (sType.equalsIgnoreCase(PM_NODE_OATTR)
                || sType.equalsIgnoreCase(PM_NODE_ASSOC)) {
            sDn = "CN=" + sId + "," + sObjAttrContainerDN;
            sAttr = "pmFromOpSet";
        } else {
            return false;
        }

        try {
            attrs = ctx.getAttributes(sDn);
        } catch (Exception e) {
            if (debugFlag) {
                e.printStackTrace();
            }
            return false;
        }

        Attribute attr = attrs.get(sAttr);
        if (attr == null || attr.size() <= 0) {
            return false;
        }
        return true;
    }

    private Packet isAssigned(String sId1, String sType1, String sId2,
                              String sType2) {
        boolean r = false;

        if (sType1.equalsIgnoreCase(PM_NODE_USER)) {
            if (sType2.equalsIgnoreCase(PM_NODE_UATTR)) {
                r = userIsAssigned(sId1, sId2);
            } else if (sType2.equalsIgnoreCase(PM_NODE_CONN)) {
                r = userIsAssignedToConnector(sId1);
            } else {
                r = false;
            }
        } else if (sType1.equalsIgnoreCase(PM_NODE_UATTR)) {
            if (sType2.equalsIgnoreCase(PM_NODE_UATTR)) {
                r = attrIsAssignedToAttr(sId1, sId2, sType1);
            } else if (sType2.equalsIgnoreCase(PM_NODE_POL)) {
                r = attrIsAssignedToPolicy(sId1, sType1, sId2);
            } else if (sType2.equalsIgnoreCase(PM_NODE_CONN)) {
                r = attrIsAssignedToConnector(sId1, sType1);
            } else if (sType2.equalsIgnoreCase(PM_NODE_OPSET)) {
                r = attrIsAssignedToOpset(sId1, sId2);
            } else {
                r = false;
            }
        } else {
            r = false;
        }

        Packet res = new Packet();
        try {
            if (r) {
                res.addItem(ItemType.RESPONSE_TEXT, "yes");
            } else {
                res.addItem(ItemType.RESPONSE_TEXT, "no");
            }
        } catch (Exception e) {
            e.printStackTrace();
            return failurePacket("Exception when building the result packet");
        }
        return res;
    }

    // Test whether a user or object attribute is assigned (directly) to the
    // connector.
    private boolean attrIsAssignedToConnector(String sId, String sType) {
        Attributes attrs;
        Attribute attr;
        String sCont;

        if (sType.equalsIgnoreCase(PM_NODE_UATTR)) {
            sCont = sUserAttrContainerDN;
        } else if (sType.equalsIgnoreCase(PM_NODE_OATTR)
                || sType.equalsIgnoreCase(PM_NODE_ASSOC)) {
            sCont = sObjAttrContainerDN;
        } else {
            return false;
        }

        try {

            attrs = ctx.getAttributes("CN=" + sId + "," + sCont);
            attr = attrs.get("pmToConnector");
            if (attr == null) {
                return false;
            }
            String sConn = (String) attr.get();
            if (sConn == null) {
                return false;
            }
            if (sConn.equalsIgnoreCase(PM_CONNECTOR_ID)) {
                return true;
            }
            return false;
        } catch (Exception e) {
            return false;
        }
    }

    // Determines assignment between attributes (user or object).
    private boolean attrIsAssignedToAttr(String sId1, String sId2, String sType) {
        Attributes attrs;
        Attribute attr;
        String sCont;

        if (sType.equalsIgnoreCase(PM_NODE_UATTR)) {
            sCont = sUserAttrContainerDN;
        } else if (sType.equalsIgnoreCase(PM_NODE_OATTR)
                || sType.equalsIgnoreCase(PM_NODE_ASSOC)) {
            sCont = sObjAttrContainerDN;
        } else {
            return false;
        }

        try {
            attrs = ctx.getAttributes("CN=" + sId1 + "," + sCont);
            attr = attrs.get("pmToAttr");
            if (attr == null) {
                return false;
            }
            for (NamingEnumeration<?> attrEnum = attr.getAll(); attrEnum.hasMore(); ) {
                if (sId2.equals((String) attrEnum.next())) {
                    return true;
                }
            }
        } catch (Exception e) {
            return false;
        }
        return false;
    }

    private boolean attrIsAssignedToPolicy(String sId1, String sType1,
                                           String sId2) {
        Attributes attrs;
        Attribute attr;
        String sDn;

        if (sType1.equalsIgnoreCase(PM_NODE_UATTR)) {
            sDn = "CN=" + sId1 + "," + sUserAttrContainerDN;
        } else if (sType1.equalsIgnoreCase(PM_NODE_OATTR)
                || sType1.equalsIgnoreCase(PM_NODE_ASSOC)) {
            sDn = "CN=" + sId1 + "," + sObjAttrContainerDN;
        } else {
            return false;
        }

        try {
            attrs = ctx.getAttributes(sDn);
            attr = attrs.get("pmToPolicy");
            if (attr == null) {
                return false;
            }
            for (NamingEnumeration<?> attrEnum = attr.getAll(); attrEnum.hasMore(); ) {
                if (sId2.equals((String) attrEnum.next())) {
                    return true;
                }
            }
        } catch (Exception e) {
            return false;
        }
        return false;
    }

    // Determines whether a user attribute is assigned to an operation set.
    private boolean attrIsAssignedToOpset(String sId1, String sId2) {
        Attributes attrs;
        Attribute attr;

        try {
            attrs = ctx.getAttributes("CN=" + sId1 + "," + sUserAttrContainerDN);
            attr = attrs.get("pmToOpSet");
            if (attr == null) {
                return false;
            }
            for (NamingEnumeration<?> attrEnum = attr.getAll(); attrEnum.hasMore(); ) {
                if (sId2.equals((String) attrEnum.next())) {
                    return true;
                }
            }
        } catch (Exception e) {
            if (debugFlag) {
                e.printStackTrace();
            }
        }
        return false;
    }

    // Determines whether an operation set sId1 is assigned to an
    // object attribute sId2.
    private boolean opsetIsAssignedToAttr(String sId1, String sId2) {
        Attributes attrs;
        Attribute attr;

        try {
            attrs = ctx.getAttributes("CN=" + sId2 + "," + sObjAttrContainerDN);
            attr = attrs.get("pmFromOpSet");
            if (attr == null) {
                return false;
            }
            for (NamingEnumeration<?> attrEnum = attr.getAll(); attrEnum.hasMore(); ) {
                if (sId1.equals((String) attrEnum.next())) {
                    return true;
                }
            }
        } catch (Exception e) {
            if (debugFlag) {
                e.printStackTrace();
            }
        }
        return false;
    }

    // Test whether an object is an ascendant of a policy class.
    /*private boolean objIsAscendantToPolicy(String sObjId, String sPcId) {
   Attributes attrs;
   Attribute attr;
   try {
   // Get the id of the attribute associated to the object.
   attrs = ctx.getAttributes("CN=" + sObjId + ","
   + sVirtualObjContainerDN);
   attr = attrs.get("pmAssocAttr");
   if (attr == null) {
   return false;
   }
   String sAssocId = (String) attr.get();

   // Get all attributes assigned to the policy class.
   attrs = ctx.getAttributes("CN=" + sPcId + "," + sPolicyContainerDN);
   attr = attrs.get("pmFromObjAttr");
   if (attr == null) {
   return false;
   }

   // Test whether the attribute associated to the object is an
   // ascendant
   // of any attribute assigned to the policy class.
   for (NamingEnumeration<?> attrEnum = attr.getAll(); attrEnum
   .hasMore();) {
   String sId = (String) attrEnum.next();
   if (attrIsAscendant(sAssocId, sId, PM_NODE_OATTR)) {
   return true;
   }
   }
   } catch (Exception e) {
   e.printStackTrace();
   }
   return false;
   }
    */
    // Test whether a user attribute or an object attribute is an ascendant of a
    // policy class.
    private boolean attrIsAscendantToPolicy(String sId1, String sType1,
                                            String sId2) {
        Attributes attrs;
        Attribute attr;
        try {
            attrs = ctx.getAttributes("CN=" + sId2 + "," + sPolicyContainerDN);

            if (sType1.equalsIgnoreCase(PM_NODE_UATTR)) {
                attr = attrs.get("pmFromUserAttr");
            } else if (sType1.equalsIgnoreCase(PM_NODE_OATTR)
                    || sType1.equalsIgnoreCase(PM_NODE_ASSOC)) {
                attr = attrs.get("pmFromObjAttr");
            } else {
                return false;
            }

            if (attr == null) {
                return false;
            }
            for (NamingEnumeration<?> attrEnum = attr.getAll(); attrEnum.hasMore(); ) {
                String sId = (String) attrEnum.next();
                if (attrIsAscendant(sId1, sId, sType1)) {
                    return true;
                }
            }
        } catch (Exception e) {
            return false;
        }
        return false;
    }

    // Tests whether the user sId1 "inherits" the user attribute sId2.
    private boolean userIsAscendant(String sId1, String sId2) {
        Attributes attrs;
        Attribute attr;
        try {
            attrs = ctx.getAttributes("CN=" + sId1 + "," + sUserContainerDN);
            attr = attrs.get("pmToAttr");
            if (attr == null) {
                return false;
            }
            for (NamingEnumeration<?> attrEnum = attr.getAll(); attrEnum.hasMore(); ) {
                String sId = (String) attrEnum.next();
                if (attrIsAscendant(sId, sId2, PM_NODE_UATTR)) {
                    return true;
                }
            }
        } catch (Exception e) {
            return false;
        }
        return false;
    }

    // A user may be an ascendant of a policy only through some user attributes.
    private boolean userIsAscendantToPolicy(String sId1, String sId2) {
        Attributes attrs;
        Attribute attr;
        try {
            attrs = ctx.getAttributes("CN=" + sId1 + "," + sUserContainerDN);
            attr = attrs.get("pmToAttr");
            if (attr == null) {
                return false;
            }
            for (NamingEnumeration<?> attrEnum = attr.getAll(); attrEnum.hasMore(); ) {
                String sId = (String) attrEnum.next();
                if (attrIsAscendantToPolicy(sId, PM_NODE_UATTR, sId2)) {
                    return true;
                }
            }
        } catch (Exception e) {
            return false;
        }
        return false;
    }

    // Determine whether an attribute is ascendant of another attribute
    // (of the same type - user or object).
    private boolean attrIsAscendant(String sId1, String sId2, String sType) {
        Attributes attrs;
        Attribute attr;
        String sCont;

        if (sId1.equals(sId2)) {
            return true;
        }

        if (sType.equalsIgnoreCase(PM_NODE_UATTR)) {
            sCont = sUserAttrContainerDN;
        } else if (sType.equalsIgnoreCase(PM_NODE_OATTR)
                || sType.equalsIgnoreCase(PM_NODE_ASSOC)) {
            sCont = sObjAttrContainerDN;
        } else {
            return false;
        }

        try {
            attrs = ctx.getAttributes("CN=" + sId1 + "," + sCont);
            attr = attrs.get("pmToAttr");
            if (attr == null) {
                return false;
            }
            for (NamingEnumeration<?> attrEnum = attr.getAll(); attrEnum.hasMore(); ) {
                if (attrIsAscendant((String) attrEnum.next(), sId2, sType)) {
                    return true;
                }
            }
        } catch (Exception e) {
            e.printStackTrace();
            return false;
        }
        return false;
    }

    // Get all operations of an object class. The object class is identified by
    // its name!!!
    private Packet getObjClassOps(String sClientId, String sClass) {
        Packet res = new Packet();
        NamingEnumeration<?> cls;

        try {
            SearchControls constraints = new SearchControls();
            constraints.setSearchScope(SearchControls.ONELEVEL_SCOPE);
            constraints.setReturningAttributes(new String[]{"pmOp"});
            String sPreparedClass = sClass.replaceAll("\\*", "\\\\*");
            cls = ctx.search(sObjClassContainerDN, "(pmName=" + sPreparedClass
                    + ")", constraints);
            // cls should have exactly one entry.
            if (cls == null || !cls.hasMore()) {
                return failurePacket("No object class " + sClass);
            }
            SearchResult sr = (SearchResult) cls.next();
            Attributes attrs = sr.getAttributes();
            Attribute attr = attrs.get("pmOp");
            if (attr != null) {
                for (NamingEnumeration<?> enumer = attr.getAll(); enumer.hasMore(); ) {
                    res.addItem(ItemType.RESPONSE_TEXT, (String) enumer.next());
                }
            }
        } catch (Exception e) {
            e.printStackTrace();
            return failurePacket(e.getMessage());
        }
        return res;
    }

    private boolean isOperation(String sOpName) {
        NamingEnumeration<?> cls;
        try {
            SearchControls constraints = new SearchControls();
            constraints.setSearchScope(SearchControls.ONELEVEL_SCOPE);
            constraints.setReturningAttributes(new String[]{"pmName", "pmOp"});
            cls = ctx.search(sObjClassContainerDN, "(objectClass=*)",
                    constraints);
            while (cls != null && cls.hasMore()) {
                SearchResult sr = (SearchResult) cls.next();
                /*String sClassName = (String) sr.getAttributes().get("pmName")
                .get();*/

                // if (!sOpName.startsWith(sClassName)) continue;

                Attribute attr = sr.getAttributes().get("pmOp");
                if (attr == null) {
                    continue;
                }
                for (NamingEnumeration<?> enumer = attr.getAll(); enumer.hasMore(); ) {
                    String s = (String) enumer.next();
                    if (sOpName.equalsIgnoreCase(s)) {
                        return true;
                    }
                }
            }
            return false;
        } catch (Exception e) {
            if (debugFlag) {
                e.printStackTrace();
            }
            return false;
        }
    }

    // This method deletes all objects directly assigned to a container.
    // If the container itself is the oattr associated to an object, that
    // object is deleted.
    // Deleting an object deletes also the associated oattr, as well as all
    // assignments from opsets to that object (actually to the associated
    // oattr), and all assignments from that object (actually from the
    // associated oattr) to any other container. Note that in this last
    // case a container can be an oattr, a pc, or the connector.
    private Packet deleteContainerObjects(String sSessId, String sContName) {
        try {
            System.out.println("DeleteContainerObjects for " + sContName);
            // Check the container exists.
            String sContId = getEntityId(sContName, PM_NODE_OATTR);
            if (sContId == null) {
                return failurePacket("No such container: " + sContName);
            }

            // If the container is associated to an object, delete it (the
            // container,
            // the associated object, and the assignments).
            if (hasAssocObj(sContId)) {
                return deleteObjectInternal(sContId);
            }

            // The container is a true container. Get the collection of directly
            // contained oattrs.
            Attributes contAttrs = ctx.getAttributes("CN=" + sContId + ","
                    + sObjAttrContainerDN);
            Attribute attr = contAttrs.get("pmFromAttr");
            if (attr == null) {
                return successPacket();
            }

            // For each oattr contained in the given container:
            for (NamingEnumeration<?> enumer = attr.getAll(); enumer.hasMore(); ) {
                String sOattrId = (String) enumer.next();

                // If it's not an object, continue.
                if (!hasAssocObj(sOattrId)) {
                    continue;
                }
                System.out.println("Found object "
                        + getEntityName(sOattrId, PM_NODE_OATTR));

                // We found an oattr which is an object. Delete it!
                Packet res =  deleteObjectInternal(sOattrId);
                if (res.hasError()) {
                    return res;
                }
            }
            return successPacket();
        } catch (Exception e) {
            e.printStackTrace();
            return failurePacket("Exception in deleteContainerObjects(): "
                    + e.getMessage());
        }
    }

    // This mthod deletes an object completely. The argument is the id of the
    // oattr associated to the object.
    // We need to find all opsets assigned to it and delete these assignments.
    // If after this step an opset remains unassigned, it is also deleted.
    // Then we find all direct containers of this object and delete the
    // double assignment between the object and each container.
    // Note that container here means any object attribute, or policy,
    // or the connector, to which the object is assigned.
    // Finally, delete the object and the associated oattr.
    private Packet deleteObjectInternal(String sOattrId) {
        String sObjId = getAssocObj(sOattrId);
        if (sObjId == null) {
            return failurePacket("No object associated to attribute "
                    + sOattrId);
        }

        System.out.println("DeletObjectInternal called for "
                + getEntityName(sOattrId, PM_NODE_OATTR));
        try {
            // Get the opsets assigned to the oattr.
            Attribute attr = getFromOpsets(sOattrId, PM_NODE_OATTR);

            // For each opset:
            if (attr != null) {
                for (NamingEnumeration<?> enumer = attr.getAll(); enumer.hasMore(); ) {
                    String sOpsetId = (String) enumer.next();
                    System.out.println("Found opset "
                            + getEntityName(sOpsetId, PM_NODE_OPSET));

                    // How many object attributes is sOpsetId assigned to?
                    // If only one, then it's just the sOattrId, and we can
                    // delete
                    // the opset together with its assignments from user
                    // attributes.
                    // If more than one, delete just the assignment sOpsetId ->
                    // sOattrId.
                    Attribute attr2 = getToAttrs(sOpsetId, PM_NODE_OPSET);
                    if (attr2.size() == 1) {
                        // First delete the opset's assignments from user
                        // attributes.
                        Attribute attr3 = getFromAttrs(sOpsetId, PM_NODE_OPSET);
                        if (attr3 != null) {
                            for (NamingEnumeration<?> enum3 = attr3.getAll(); enum3.hasMore(); ) {
                                String sUattrId = (String) enum3.next();
                                System.out.println("Deleting dbl link "
                                        + getEntityName(sUattrId,
                                        PM_NODE_UATTR)
                                        + "--->"
                                        + getEntityName(sOpsetId,
                                        PM_NODE_OPSET));

                                // Delete the assignment sUattrId <--->
                                // sOpsetId.
                                deleteDoubleLink(sUattrId, PM_NODE_UATTR,
                                        sOpsetId, PM_NODE_OPSET);
                            }
                        }
                        // Delete the double link sOpsetId <--> sOattrId
                        // preventively:
                        deleteDoubleLink(sOpsetId, PM_NODE_OPSET, sOattrId,
                                PM_NODE_OATTR);
                        // Now delete the opset.
                        ctx.destroySubcontext("CN=" + sOpsetId + ","
                                + sOpsetContainerDN);
                    } else {
                        // The opset is assigned to other object attributes
                        // beside sOattrId.
                        // Just delete the assignment sOpsetId <---> sOattrId.
                        deleteDoubleLink(sOpsetId, PM_NODE_OPSET, sOattrId,
                                PM_NODE_OATTR);
                    }
                }
            }

            // Find all containers of type OATTR of sOattrId.
            attr = getToAttrs(sOattrId, PM_NODE_OATTR);
            if (attr != null) {
                for (NamingEnumeration<?> enumer = attr.getAll(); enumer.hasMore(); ) {
                    String sContId = (String) enumer.next();
                    System.out.println("Found container "
                            + getEntityName(sContId, PM_NODE_OATTR));

                    // Delete double link sOattrId <---> sContId.
                    deleteDoubleLink(sOattrId, PM_NODE_OATTR, sContId,
                            PM_NODE_OATTR);
                }
            }

            // Find all containers of type POL of sOattrId.
            attr = getToPolicies(sOattrId, PM_NODE_OATTR);
            if (attr != null) {
                for (NamingEnumeration<?> enumer = attr.getAll(); enumer.hasMore(); ) {
                    String sPolId = (String) enumer.next();
                    System.out.println("Found policy "
                            + getEntityName(sPolId, PM_NODE_POL));

                    // Delete double link sOattrId <---> sPolId.
                    deleteDoubleLink(sOattrId, PM_NODE_OATTR, sPolId,
                            PM_NODE_POL);
                }
            }

            // Find all containers of type CONNECTOR of sOattrId (at most one).
            attr = getToConnector(sOattrId, PM_NODE_OATTR);
            if (attr != null) {
                for (NamingEnumeration<?> enumer = attr.getAll(); enumer.hasMore(); ) {
                    String sConnId = (String) enumer.next();
                    System.out.println("Found connector "
                            + getEntityName(sConnId, PM_NODE_CONN));

                    // Delete double link sOattrId <---> sPConnId.
                    deleteDoubleLink(sOattrId, PM_NODE_OATTR, sConnId,
                            PM_NODE_CONN);
                }
            }

            // Delete the associated object and the oattr.
            ctx.destroySubcontext("CN=" + sObjId + "," + sVirtualObjContainerDN);
            ctx.destroySubcontext("CN=" + sOattrId + "," + sObjAttrContainerDN);
        } catch (Exception e) {
            e.printStackTrace();
            return failurePacket("Exception in deleteObjectInternal(): "
                    + e.getMessage());
        }

        return successPacket();
    }

    // Delete only the objects of a container. This method also deletes the
    // objects'
    // assignments to other containers or assignments from opsets to them.
    /*private Packet deleteObjectsFromContainer(String sSessId, String sContName) {
    try {
    String sContId = getIdOfEntityWithNameAndType(sContName, PM_NODE_OATTR);
    if (sContId == null) {
    return failurePacket("No such object attribute " + sContName);
    }

    Attributes contAttrs = ctx.getAttributes("CN=" + sContId + ","
    + sObjAttrContainerDN);
    Attribute attr = contAttrs.get("pmFromAttr");
    if (attr == null) {
    return successPacket();
    }
    for (NamingEnumeration<?> enumer = attr.getAll(); enumer.hasMore();) {
    // Get the id of an oattr contained in the container.
    String sOattrId = (String) enumer.next();
    // If it's not an object, continue.
    Attributes oattrAttrs = ctx.getAttributes("CN=" + sOattrId
    + "," + sObjAttrContainerDN);
    Attribute oattrAttr = oattrAttrs.get("pmAssocObj");
    if (oattrAttr == null || oattrAttr.size() <= 0) {
    continue;
    }
    // Delete the associated object.
    String sObjId = (String) oattrAttr.get();
    ctx.destroySubcontext("CN=" + sObjId + ","
    + sVirtualObjContainerDN);

    // Delete the opset assignments to the object attribute.
    oattrAttr = oattrAttrs.get("pmFromOpSet");
    if (oattrAttr != null) {
    for (NamingEnumeration<?> enum2 = oattrAttr.getAll(); enum2
    .hasMore();) {
    String sOpsetId = (String) enum2.next();
    deleteDoubleLink(sOpsetId, PM_NODE_OPSET, sOattrId,
    PM_NODE_OATTR);
    }
    }
    // Delete the assignment from the object attribute to the
    // container.
    deleteDoubleLink(sOattrId, PM_NODE_OATTR, sContId,
    PM_NODE_OATTR);
    // Delete the object attribute.
    ctx.destroySubcontext("CN=" + sOattrId + ","
    + sObjAttrContainerDN);
    }
    } catch (Exception e) {
    e.printStackTrace();
    return failurePacket(e.getMessage());
    }
    return successPacket();
    }*/
    // Delete an object o, even when opsets are still assigned to it.
    // If an opset is assigned to o's object attribute:
    // - if the opset is assigned to other oattrs, delete only its assignment to
    // oa.
    // - if the opset is only assigned to o's object attribute, delete the
    // opset.
    //
    private Packet deleteObjectStrong(String sSessId, String sObjId) {
        String sAssocId = getAssocOattr(sObjId);
        if (sAssocId == null) {
            return failurePacket("Inconsistency: no object or no associated attribute");
        }

        String sContainers = getContainerList(sAssocId, PM_NODE_OATTR);

        try {
            // Get the opsets assigned to the assoc oattr.
            Attribute attr = getFromOpsets(sAssocId, PM_NODE_OATTR);
            // For each opset:
            if (attr != null) {
                for (NamingEnumeration<?> enumer = attr.getAll(); enumer.hasMore(); ) {
                    String sOpsetId = (String) enumer.next();

                    // How many object attributes is this opset assigned to?
                    // If one, then it's the o's assoc oattr, and the opset must
                    // be deleted
                    // together with its assignments from user attributes. If
                    // more than
                    // one, delete just the assignment opset -> o's assoc oattr.
                    Attribute attr2 = getToAttrs(sOpsetId, PM_NODE_OPSET);
                    if (attr2.size() == 1) {
                        // First delete the opset's assignments from user
                        // attributes.
                        Attribute attr3 = getFromAttrs(sOpsetId, PM_NODE_OPSET);
                        if (attr3 != null) {
                            for (NamingEnumeration<?> enum3 = attr3.getAll(); enum3.hasMore(); ) {
                                String sUattrId = (String) enum3.next();
                                // Delete the assignment from uattr to opset.
                                deleteDoubleLink(sUattrId, PM_NODE_UATTR,
                                        sOpsetId, PM_NODE_OPSET);
                            }
                        }
                        // Now delete the opset.
                        ctx.destroySubcontext("CN=" + sOpsetId + ","
                                + sOpsetContainerDN);
                    } else {
                        // The opset is assigned to other object attributes in
                        // addition to
                        // o's assoc. Just delete the assignment from the opset
                        // to o's assoc.
                        deleteDoubleLink(sOpsetId, PM_NODE_OPSET, sAssocId,
                                PM_NODE_OATTR);
                    }
                }
            }

        } catch (Exception e) {
            e.printStackTrace();
        }

        // Save the object name for events.
        String sObjName = getEntityName(sAssocId, PM_NODE_OATTR);

        // Delete the associated object attribute.
        Packet res =  deleteOattr(sSessId, sAssocId, false);
        if (res.hasError()) {
            return res;
        }

        // Delete the object.
        try {
            ctx.destroySubcontext("CN=" + sObjId + "," + sVirtualObjContainerDN);
        } catch (Exception e) {
            if (debugFlag) {
                e.printStackTrace();
            }
            return failurePacket("Could not delete object " + sObjId + ": "
                    + e.getMessage());
        }

        res =  processEvent(sSessId, null, "Object delete", sObjName,
                sObjId, null, null, sContainers, sAssocId);
        return successPacket();
    }

    // Delete an object.
    // Conditions: no opset is assigned to the object
    // (i.e., to the associated object attribute).
    private Packet deleteObject(String sSessId, String sObjId) {
        // Find the associated attribute.
        String sAssocId = getAssocOattr(sObjId);
        if (sAssocId == null) {
            return failurePacket("Inconsistency: no object or no associated attribute");
        }

        String sContainers = getContainerList(sAssocId, PM_NODE_OATTR);

        // See whether the attribute has any opsets assigned to it.
        if (attrHasOpsets(sAssocId, PM_NODE_OATTR)) {
            return failurePacket("Associated attribute is assigned to operation sets");
        }

        // Save the object name for events.
        String sObjName = getEntityName(sAssocId, PM_NODE_OATTR);

        // Delete the associated object attribute.
        Packet res =  deleteOattr(sSessId, sAssocId, false);
        if (res.hasError()) {
            return res;
        }

        // Delete the object.
        try {
            ctx.destroySubcontext("CN=" + sObjId + "," + sVirtualObjContainerDN);
        } catch (Exception e) {
            if (debugFlag) {
                e.printStackTrace();
            }
            return failurePacket("Could not delete object " + sObjId + ": "
                    + e.getMessage());
        }

        res =  processEvent(sSessId, null, "Object delete", sObjName,
                sObjId, null, null, sContainers, sAssocId);
        return successPacket();
    }

    // sObjName is the name of the original object. The function creates a new
    // object with the name "copy<n>Of<sObjName>", where n is the null string,
    // or
    // 1, 2, etc.
    // The copy has the same class, type, containers as the original object.
    // The copy will have the content located on the session's host.
    //
    // Note that this function does not copy the object's content! This must be
    // done separately, probably in the K simulator.
    private Packet copyObject(String sSessId, String sProcId, String sObjName) {
        // Let's find the properties of the original object.
        String sObjId = getEntityId(sObjName, PM_OBJ);
        if (sObjId == null) {
            return failurePacket("No object of name " + sObjName);
        }
        Packet result =  getObjInfo(sObjId);
        if (result.hasError()) {
            return result;
        }

        String s = result.getStringValue(0);
        String[] pieces = s.split(PM_ALT_DELIM_PATTERN);
        String sClass = pieces[2];
        String sNameOrHost = null;
        if (pieces.length >= 5) {
            sNameOrHost = pieces[4];
        }
        String sIdOrPath = null;
        if (pieces.length >= 6) {
            sIdOrPath = pieces[5];
        }

        // Isolate the object type (rtf, eml, etc.) from sIdOrPath.
        // First get the underlying file name (the last element in the path).
        int nLastSep = sIdOrPath.lastIndexOf(File.separator);
        String sLookAt;
        String sCopyType;
        if (nLastSep < 0) {
            // The path has no file separators in it, look for type in the
            // entire
            // path.
            sLookAt = sIdOrPath;
        } else {
            sLookAt = sIdOrPath.substring(nLastSep + 1);
        }

        if (sLookAt == null || sLookAt.length() == 0) {
            sCopyType = "";
        } else {
            int nLastDot = sLookAt.lastIndexOf('.');
            if (nLastDot < 0) {
                sCopyType = "";
            } else {
                sCopyType = sLookAt.substring(nLastDot + 1);
            }
        }

        System.out.println("Class = " + sClass);
        System.out.println("Name or host = " + sNameOrHost);
        System.out.println("Id or path = " + sIdOrPath);

        String sCopyName = getCopyName(sObjName, PM_OBJ);
        String sCopyDescr = "Copy of object " + sObjName;
        String sCopyInfo = "None";
        String sCopyClass = pieces[2];
        String sCopyHost = getSessionHostName(sSessId);
        // String sCopyHost = "pmclient";
        String sPhysLoc = getHostRepositoryInternal(sCopyHost);
        String sCopyPath;
        if (sPhysLoc.endsWith(File.separator)) {
            sCopyPath = sPhysLoc + sCopyName + "." + sCopyType;
        } else {
            sCopyPath = sPhysLoc + File.separator + sCopyName + "." + sCopyType;
        }

        // Find the id of the attribute associated to the original object.
        String sOattrId = getEntityId(sObjName, PM_NODE_OATTR);
        if (sOattrId == null) {
            return failurePacket("The object " + sObjName
                    + " has no associated attribute!");
        }

        // Find the containers of the original object (note that PM or a policy
        // class can be an object container, not only other object attributes).
        String sContainers = getOattrContainers(sOattrId);
        System.out.println("Containers of object " + sObjName + " are: "
                + sContainers);

        String sCopyId = null;
        String sAssocId = null;

        // For each container:
        pieces = sContainers.split(PM_LIST_MEMBER_SEP);
        for (int i = 0; i < pieces.length; i++) {
            String[] sTypeLabel = pieces[i].split(PM_ALT_DELIM_PATTERN);
            System.out.println("Container no. " + i + ": " + sTypeLabel[0]
                    + "|" + sTypeLabel[1]);

            // Get container's id,
            String sContId = getEntityId(sTypeLabel[1], sTypeLabel[0]);
            if (sContId == null) {
                return failurePacket("No container " + sTypeLabel[1]
                        + " of type " + sTypeLabel[0]);
            }

            // create or insert the new object within the container.
            if (i == 0) {
                // For the first container, create the object within. Let the
                // engine
                // generate the object's and the assoc. object attribute's ids.
                result =  addObjectInternal(sCopyName, null, null,
                        sCopyDescr, sCopyInfo, sContId, sTypeLabel[0],
                        sCopyClass, sCopyType, sCopyHost, sCopyPath, null,
                        null, false, null, null, null, null, null, null, null);
                if (result.hasError()) {
                    return result;
                }
                String sLine = result.getStringValue(0);
                String[] splinters = sLine.split(PM_FIELD_DELIM);
                sCopyId = splinters[1];
                sAssocId = getAssocOattr(sCopyId);
            } else {
                // For the other containers, assign the oattr associated with
                // the
                // new object to each container, if not already there.
                result =  assignInternal(sAssocId, PM_NODE_OATTR,
                        sContId, sTypeLabel[0]);
                if (result.hasError()) {
                    return result;
                }
            }
        }
        result = new Packet();
        try {
            result.addItem(ItemType.RESPONSE_TEXT, sCopyName
                    + PM_ALT_FIELD_DELIM + sCopyId + PM_ALT_FIELD_DELIM
                    + sCopyClass + PM_ALT_FIELD_DELIM + "no"
                    + PM_ALT_FIELD_DELIM + sCopyHost + PM_ALT_FIELD_DELIM
                    + sCopyPath);
        } catch (Exception e) {
            e.printStackTrace();
            return failurePacket("Exception when building the result packet");
        }
        return result;
    }

    private String getCopyName(String sEntName, String sEntType) {
        String sCandidate = "copyOf" + sEntName;
        int i = 0;
        while (entityNameExists(sCandidate, sEntType)) {
            i++;
            sCandidate = "copy" + String.valueOf(i) + "Of" + sEntName;
        }
        return sCandidate;
    }

    // Called from a host's kernel to create a new object with specified name,
    // class, type, in the specified containers. Uses the process id to
    // check for the permission to create an object.
    //
    // The sContainers parameter contains a list of type|label separated by
    // commas.
    // The sPerms paramter contains the permissions requested by the process
    // (actually session) creating the object on the object (usually
    // "File write").
    //
    // This method calls addObject3(), which does a permission check (among
    // other things it calls requestPerms() to activate the user's attributes
    // that allow his process to create the object in the specified containers).
    //
    // After the object creation, the engine generates and processes an event
    // "Object create".
    private Packet createObject3(String sSessId, String sProcId,
                                 String sObjName, String sObjClass, String sObjType,
                                 String sContainers, String sPerms, String sSender,
                                 String sReceiver, String sSubject, String sAttached) {
        if (!sObjClass.equalsIgnoreCase(PM_CLASS_FILE_NAME)) {
            return failurePacket("Creation of non-File objects not yet implemented!");
        }

        // The host of the new object will be the session host.
        String sHost = getSessionHostName(sSessId);
        String sPhysCont = getHostRepositoryInternal(sHost);
        String sPath = null;
        if (sPhysCont.endsWith(File.separator)) {
            sPath = sPhysCont + sObjName + "." + sObjType;
        } else {
            sPath = sPhysCont + File.separator + sObjName + "." + sObjType;
        }
        Packet result = null;

        try {
            result =  addObject3(sSessId, sProcId, sObjName, sObjName,
                    sObjName, sContainers, sObjClass, null, sHost, sPath, null,
                    null, "no", sSender, sReceiver, sSubject, sAttached, null,
                    null, null);
        } catch (Exception e) {
            if (debugFlag) {
                e.printStackTrace();
            }
            return failurePacket("Exception during object creation: "
                    + e.getMessage());
        }

        // If successful, the result contains the name and id of the new object.
        if (result.hasError()) {
            return result;
        }
        String sLine = result.getStringValue(0);
        String[] pieces = sLine.split(PM_FIELD_DELIM);

        result =  processEvent(sSessId, null, PM_EVENT_OBJECT_CREATE,
                sObjName, pieces[1], sObjClass, sObjType, sContainers, sPerms);

        // If failure, delete the new object???
        // ...
        return result;
    }

    // Create a new object. Called from createObject3() or directly from the
    // Admin Tool.
    //
    // The engine creates an object attribute associated with the object.
    // This attribute will be assigned to the connector node, unless the
    // sContainers
    // is non-null. sContainers specifies the types and ids of object
    // attributes,
    // policies, or
    // connector node, which will be used
    // as immediate descendants of the object.
    private Packet addObject3(String sSessId, String sProcId, String sName,
                              String sDescr, String sInfo, String sContainers, String sClass,
                              String sType, String sHost, String sPath, String sOrigName,
                              String sOrigId, String sInh, String sSender, String sReceiver,
                              String sSubject, String sAttached, String sTplId,
                              String sComponents, String[] sKeys) throws Exception {

        if (sContainers == null || sContainers.length() == 0) {
            sContainers = PM_NODE_CONN + PM_ALT_FIELD_DELIM + PM_CONNECTOR_NAME;
        }

        System.out.print("addObject3(");
        System.out.print("sess=" + sSessId);
        System.out.print(", proc=" + sProcId);
        System.out.print(", name=" + sName);
        System.out.print(", descr=" + sDescr);
        System.out.print(", info=" + sInfo);
        System.out.print(", class=" + sClass);
        System.out.print(", type=" + sType);
        System.out.print(", containers=" + sContainers);
        System.out.print(", host=" + sHost);
        System.out.print(", path=" + sPath);
        System.out.print(", origname=" + sOrigName);
        System.out.print(", origid=" + sOrigId);
        System.out.println(", inh=" + sInh);
        System.out.println(", sender=" + sSender);
        System.out.println(", receiver=" + sReceiver);
        System.out.println(", subject=" + sSubject);
        System.out.println(", attached=" + sAttached);
        System.out.println(", template=" + sTplId);
        System.out.println(", components=" + sComponents);
        if (sKeys != null) {
            for (int i = 0; i < sKeys.length; i++) {
                System.out.println(", key=" + sKeys[i]);
            }
        }
        System.out.println(")");

        String[] pieces = sContainers.split(PM_LIST_MEMBER_SEP);
        Packet res;
        String sAssocId = null;
        String sObjId = null;

        // For each container:
        for (int i = 0; i < pieces.length; i++) {
            String[] sTypeLabel = pieces[i].split(PM_ALT_DELIM_PATTERN);
            System.out.println("Container no. " + i + ": " + sTypeLabel[0]
                    + "|" + sTypeLabel[1]);

            // Get container's id,
            String sContId = getEntityId(sTypeLabel[1], sTypeLabel[0]);
            if (sContId == null) {
                return failurePacket("No container " + sTypeLabel[1]
                        + " of type " + sTypeLabel[0]);
            }

            // check permission to create a new object within this container,
            if (!requestAddObjectPerms(sSessId, sProcId, sContId, sTypeLabel[0])) {
                return failurePacket(reqPermsMsg);
            }
            // check permission to represent a PM entity by the new object.
            if (!requestRepresentEntityPerms(sSessId, sProcId, sClass,
                    sOrigName, sOrigId)) {
                return failurePacket(reqPermsMsg);
            }

            // create or insert the new object within the container.
            if (i == 0) {
                // For the first container, create the object within. Let the
                // engine
                // generate the object and obj attr ids.
                res =  addObjectInternal(sName, null, null, sDescr,
                        sInfo, sContId, sTypeLabel[0], sClass, sType, sHost,
                        sPath, sOrigName, sOrigId, sInh.equals("yes"), sSender,
                        sReceiver, sSubject, sAttached, sTplId, sComponents,
                        sKeys);
                if (res.hasError()) {
                    return res;
                }
                String sLine = res.getStringValue(0);
                String[] splinters = sLine.split(PM_FIELD_DELIM);
                sObjId = splinters[1];
                sAssocId = getAssocOattr(sObjId);
            } else {
                // For the other containers, assign the oattr associated with
                // the
                // new object to them, if not already there.
                //
                res =  assignInternal(sAssocId, PM_NODE_OATTR, sContId,
                        sTypeLabel[0]);
                if (res.hasError()) {
                    return res;
                }
            }
        }
        res = new Packet();
        try {
            res.addItem(ItemType.RESPONSE_TEXT, sName + PM_FIELD_DELIM + sObjId);
        } catch (Exception e) {
            e.printStackTrace();
            return failurePacket("Exception when building the result packet!");
        }
        return res;
    }

    // Note that the parameter sComponents may contain either ids or names of
    // object attributes associated with objects, so we need to bring them
    // to the canonic form.
    private Packet addObjectInternal(String sName, String sId, String sAssocId,
                                     String sDescr, String sInfo, String sBaseId, String sBaseType,
                                     String sClass, String sType, String sHost, String sPath,
                                     String sOrigName, String sOrigId, boolean bInh, String sSender,
                                     String sReceiver, String sSubject, String sAttached,
                                     String sTemplateId, String sComponents, String[] sKeys) {
        System.out.print("addObjectInternal(");
        System.out.print("objname=" + sName);
        System.out.print(", objid=" + sId);
        System.out.print(", associd=" + sAssocId);
        System.out.print(", descr=" + sDescr);
        System.out.print(", info=" + sInfo);
        System.out.print(", baseid=" + sBaseId);
        System.out.print(", basetype=" + sBaseType);
        System.out.print(", class=" + sClass);
        System.out.print(", type=" + sType);
        System.out.print(", host=" + sHost);
        System.out.print(", path=" + sPath);
        System.out.print(", origname=" + sOrigName);
        System.out.print(", origid=" + sOrigId);
        System.out.println(", inh=" + bInh);
        System.out.println(", sender=" + sSender);
        System.out.println(", receiver=" + sReceiver);
        System.out.println(", subject=" + sSubject);
        System.out.println(", attached=" + sAttached);
        System.out.println(", template=" + sTemplateId);
        System.out.println(", components=" + sComponents);
        if (sKeys != null) {
            for (int i = 0; i < sKeys.length; i++) {
                System.out.println(", key=" + sKeys[i]);
            }
        }

        String sDn;

        // If the id of the new object is null, generate it.
        if (sId == null) {
            RandomGUID myGUID = new RandomGUID();
            sId = myGUID.toStringNoDashes();
        }

        // Create the associated object attribute. sAssocId could be null,
        // meaning an id will be generated for it, or not null, meaning
        // that the specified id will be used.
        Packet res =  addOattrInternal(sName, sAssocId,
                "Attribute associated to object " + sName, "No other info",
                sBaseId, sBaseType, sId, null);
        if (res.hasError()) {
            return res;
        }

        // We've been successful in adding the associated object attribute.
        // The result from addObjAttribute contains <name>:<id> of the
        // new associated attribute. Extract the id from it and create
        // the object.
        String sLine = res.getStringValue(0);
        String[] pieces = sLine.split(PM_FIELD_DELIM);

        Attributes attrs = new BasicAttributes(true);
        attrs.put("objectClass", sVirtualObjClass);
        attrs.put("pmId", sId);
        attrs.put("pmName", sName);
        attrs.put("pmDescription", sDescr);
        attrs.put("pmOtherInfo", sInfo);
        attrs.put("pmAssocAttr", pieces[1]);
        attrs.put("pmObjClass", sClass);
        if (sHost != null) {
            attrs.put("pmHost", sHost);
        }
        if (sPath != null) {
            attrs.put("pmPath", sPath);
        }
        if (sOrigName != null) {
            attrs.put("pmOriginalName", sOrigName);
        }
        if (sOrigId != null) {
            attrs.put("pmOriginalId", sOrigId);
        }
        attrs.put("pmIncludesAscendants", (bInh ? "TRUE" : "FALSE"));
        if (sSender != null && sSender.length() > 0) {
            attrs.put("pmEmlSender", sSender);
        }
        if (sReceiver != null && sReceiver.length() > 0) {
            attrs.put("pmEmlRecip", sReceiver);
        }
        if (sSubject != null && sSubject.length() > 0) {
            attrs.put("pmEmlSubject", sSubject);
        }
        if (sAttached != null && sAttached.length() > 0) {
            attrs.put("pmEmlAttached", sAttached);
        }
        if (sSender != null && sSender.length() > 0) {
            String sTimestamp = dfUpdate.format(new Date());
            attrs.put("pmTimestamp", sTimestamp);
        }
        if (sTemplateId != null) {
            attrs.put("pmTemplateId", sTemplateId);
        }
        if (sComponents != null) {
            String sCanonicCompos = getCanonicList(sComponents);
            attrs.put("pmComponents", sCanonicCompos);
        }

        // Prepare the path and create.
        sDn = "CN=" + sId + "," + sVirtualObjContainerDN;
        try {
            ctx.bind(sDn, null, attrs);
        } catch (InvalidNameException e) {
            if (debugFlag) {
                e.printStackTrace();
            }
            return failurePacket("Invalid object id " + sId);
        } catch (NameAlreadyBoundException e) {
            if (debugFlag) {
                e.printStackTrace();
            }
            return failurePacket("Duplicate object id " + sId);
        } catch (Exception e) {
            if (debugFlag) {
                e.printStackTrace();
            }
            return failurePacket("Probably invalid id " + sId);
        }

        // If this object represents a PM entity or a set of PM entities,
        // propagate it to all set members.
        // HashSet visited = new HashSet();
        // propagateRep(sClass, sOrigId, sInh, sId, visited); mods = new
        // ModificationItem[n];

        if (sKeys != null && sKeys.length > 0) {
            int n = sKeys.length;
            ModificationItem[] mods = new ModificationItem[n];
            for (int i = 0; i < n; i++) {
                mods[i] = new ModificationItem(DirContext.ADD_ATTRIBUTE,
                        new BasicAttribute("pmKey", sKeys[i]));
            }
            try {
                ctx.modifyAttributes(
                        "CN=" + sId + "," + sVirtualObjContainerDN, mods);
            } catch (Exception e) {
                if (debugFlag) {
                    e.printStackTrace();
                }
                return failurePacket("Unable to set the new object's keys!");
            }
        }

        // removeRep(sClass, sOrigId, sInh, sId, visited);

        setLastUpdateTimestamp();

        res = new Packet();
        try {
            res.addItem(ItemType.RESPONSE_TEXT, sName + PM_FIELD_DELIM + sId);
        } catch (Exception e) {
            e.printStackTrace();
            return failurePacket("Exception when building the result packet!");
        }
        return res;
    }

    private String getCanonicList(String sCompos) {
        if (sCompos == null) {
            return null;
        }
        String[] pieces = sCompos.split(PM_FIELD_DELIM);
        StringBuffer sb = new StringBuffer();
        boolean first = true;
        for (int i = 0; i < pieces.length; i++) {
            String sId = null;
            String sName = getEntityName(pieces[i], PM_NODE_OATTR);
            if (sName == null) {
                sId = getEntityId(pieces[i], PM_NODE_OATTR);
                if (sId == null) {
                    return null;
                }
            } else {
                sId = pieces[i];
            }
            if (first) {
                first = false;
                sb.append(sId);
            } else {
                sb.append(PM_FIELD_DELIM + sId);
            }
        }
        return sb.toString();
    }

    /*
     * // Propagate the representative object sRepId to all nodes members of the
     * view // with the root sRootId of class sRootClass. private Packet
     * propagateRep(String sRootClass, String sRootId, String sInh, String
     * sRepId, HashSet visited) {
     *
     * System.out.println("Propagating rep obj to entity " + sRootId +
     * " of class " + sRootClass);
     *
     * if (visited.contains(sRootId)) return successPacket();
     *
     * String sDn = null; if (sRootClass.equalsIgnoreCase(PM_CLASS_USER_NAME)) {
     * sDn = "CN=" + sRootId + "," + sUserContainerDN; } else if
     * (sRootClass.equalsIgnoreCase(PM_CLASS_UATTR_NAME)) { sDn = "CN=" +
     * sRootId + "," + sUserAttrContainerDN; } else if
     * (sRootClass.equalsIgnoreCase(PM_CLASS_OBJ_NAME)) { sDn = "CN=" + sRootId
     * + "," + sVirtualObjContainerDN; } else if
     * (sRootClass.equalsIgnoreCase(PM_CLASS_OATTR_NAME)) { sDn = "CN=" +
     * sRootId + "," + sObjAttrContainerDN; } else if
     * (sRootClass.equalsIgnoreCase(PM_CLASS_CONN_NAME)) { sDn = "CN=" + sRootId
     * + "," + sConnectorContainerDN; } else if
     * (sRootClass.equalsIgnoreCase(PM_CLASS_POL_NAME)) { sDn = "CN=" + sRootId
     * + "," + sPolicyContainerDN; } else if
     * (sRootClass.equalsIgnoreCase(PM_CLASS_OPSET_NAME)) { sDn = "CN=" +
     * sRootId + "," + sOpsetContainerDN; } else { return successPacket(); }
     * ModificationItem[] mods = new ModificationItem[1]; mods[0] = new
     * ModificationItem(DirContext.ADD_ATTRIBUTE, new BasicAttribute("pmRepObj",
     * sInh + PM_ALT_FIELD_DELIM + sRepId)); try { ctx.modifyAttributes(sDn,
     * mods); } catch (Exception e) { if (debugFlag) e.printStackTrace(); return
     * failurePacket("Unable to add the representative object to " + sRootId +
     * " of class " + sRootClass); } visited.add(sRootId);
     *
     * if (!sInh.equalsIgnoreCase("yes")) return successPacket();
     *
     * // Do it for all ascendants. Attribute attr; String sAscClass; String
     * sAscId; try { if (sRootClass.equalsIgnoreCase(PM_CLASS_UATTR_NAME)) {
     * attr = getFromUsers(sRootId, PM_NODE_UATTR); if (attr != null) { for
     * (NamingEnumeration enumer = attr.getAll(); enumer.hasMore(); ) { sAscId =
     * (String)enumer.next(); propagateRep(PM_CLASS_USER_NAME, sAscId, sInh,
     * sRepId, visited); } } attr = getFromAttrs(sRootId, PM_NODE_UATTR); if
     * (attr != null) { for (NamingEnumeration enumer = attr.getAll();
     * enumer.hasMore(); ) { sAscId = (String)enumer.next();
     * propagateRep(PM_CLASS_UATTR_NAME, sAscId, sInh, sRepId, visited); } } }
     * else if (sRootClass.equalsIgnoreCase(PM_CLASS_OATTR_NAME)) { attr =
     * getFromAttrs(sRootId, PM_NODE_OATTR); if (attr != null) { for
     * (NamingEnumeration enumer = attr.getAll(); enumer.hasMore(); ) { sAscId =
     * (String)enumer.next(); propagateRep(PM_CLASS_OATTR_NAME, sAscId, sInh,
     * sRepId, visited); } } attr = getFromOpsets(sRootId, PM_NODE_OATTR); if
     * (attr != null) { for (NamingEnumeration enumer = attr.getAll();
     * enumer.hasMore(); ) { sAscId = (String)enumer.next();
     * propagateRep(PM_CLASS_OPSET_NAME, sAscId, sInh, sRepId, visited); } } }
     * else if (sRootClass.equalsIgnoreCase(PM_CLASS_CONN_NAME)) { attr =
     * getFromUserAttrs(sRootId, PM_NODE_CONN); if (attr != null) { for
     * (NamingEnumeration enumer = attr.getAll(); enumer.hasMore(); ) { sAscId =
     * (String)enumer.next(); propagateRep(PM_CLASS_UATTR_NAME, sAscId, sInh,
     * sRepId, visited); } } attr = getFromUsers(sRootId, PM_NODE_CONN); if
     * (attr != null) { for (NamingEnumeration enumer = attr.getAll();
     * enumer.hasMore(); ) { sAscId = (String)enumer.next();
     * propagateRep(PM_CLASS_USER_NAME, sAscId, sInh, sRepId, visited); } } attr
     * = getFromPolicies(sRootId, PM_NODE_CONN); if (attr != null) { for
     * (NamingEnumeration enumer = attr.getAll(); enumer.hasMore(); ) { sAscId =
     * (String)enumer.next(); propagateRep(PM_CLASS_POL_NAME, sAscId, sInh,
     * sRepId, visited); } } attr = getFromObjAttrs(sRootId, PM_NODE_CONN); if
     * (attr != null) { for (NamingEnumeration enumer = attr.getAll();
     * enumer.hasMore(); ) { sAscId = (String)enumer.next();
     * propagateRep(PM_CLASS_OATTR_NAME, sAscId, sInh, sRepId, visited); } }
     * attr = getFromOpsets(sRootId, PM_NODE_CONN); if (attr != null) { for
     * (NamingEnumeration enumer = attr.getAll(); enumer.hasMore(); ) { sAscId =
     * (String)enumer.next(); propagateRep(PM_CLASS_OPSET_NAME, sAscId, sInh,
     * sRepId, visited); } } } else if
     * (sRootClass.equalsIgnoreCase(PM_CLASS_POL_NAME)) { attr =
     * getFromUserAttrs(sRootId, PM_NODE_POL); if (attr != null) { for
     * (NamingEnumeration enumer = attr.getAll(); enumer.hasMore(); ) { sAscId =
     * (String)enumer.next(); propagateRep(PM_CLASS_UATTR_NAME, sAscId, sInh,
     * sRepId, visited); } } attr = getFromObjAttrs(sRootId, PM_NODE_POL); if
     * (attr != null) { for (NamingEnumeration enumer = attr.getAll();
     * enumer.hasMore(); ) { sAscId = (String)enumer.next();
     * propagateRep(PM_CLASS_OATTR_NAME, sAscId, sInh, sRepId, visited); } } }
     * else if (sRootClass.equalsIgnoreCase(PM_CLASS_OPSET_NAME)) { attr =
     * getFromAttrs(sRootId, PM_NODE_OPSET); if (attr != null) { for
     * (NamingEnumeration enumer = attr.getAll(); enumer.hasMore(); ) { sAscId =
     * (String)enumer.next(); propagateRep(PM_CLASS_UATTR_NAME, sAscId, sInh,
     * sRepId, visited); } } } return successPacket(); } catch (Exception e) {
     * e.printStackTrace(); return
     * failurePacket("Exception while propagating representative object: " +
     * e.getMessage()); } }
     *
     * private Packet removeRep(String sRootClass, String sRootId, String sInh,
     * String sRepId, HashSet visited) {
     *
     * System.out.println("Removing rep obj from entity " + sRootId +
     * " of class " + sRootClass);
     *
     * if (visited.contains(sRootId)) return successPacket();
     *
     * String sDn = null; if (sRootClass.equalsIgnoreCase(PM_CLASS_USER_NAME)) {
     * sDn = "CN=" + sRootId + "," + sUserContainerDN; } else if
     * (sRootClass.equalsIgnoreCase(PM_CLASS_UATTR_NAME)) { sDn = "CN=" +
     * sRootId + "," + sUserAttrContainerDN; } else if
     * (sRootClass.equalsIgnoreCase(PM_CLASS_OBJ_NAME)) { sDn = "CN=" + sRootId
     * + "," + sVirtualObjContainerDN; } else if
     * (sRootClass.equalsIgnoreCase(PM_CLASS_OATTR_NAME)) { sDn = "CN=" +
     * sRootId + "," + sObjAttrContainerDN; } else if
     * (sRootClass.equalsIgnoreCase(PM_CLASS_CONN_NAME)) { sDn = "CN=" + sRootId
     * + "," + sConnectorContainerDN; } else if
     * (sRootClass.equalsIgnoreCase(PM_CLASS_POL_NAME)) { sDn = "CN=" + sRootId
     * + "," + sPolicyContainerDN; } else if
     * (sRootClass.equalsIgnoreCase(PM_CLASS_OPSET_NAME)) { sDn = "CN=" +
     * sRootId + "," + sOpsetContainerDN; } else { return successPacket(); }
     * ModificationItem[] mods = new ModificationItem[1]; mods[0] = new
     * ModificationItem(DirContext.REMOVE_ATTRIBUTE, new
     * BasicAttribute("pmRepObj", sInh + PM_ALT_FIELD_DELIM + sRepId)); try {
     * ctx.modifyAttributes(sDn, mods); } catch (Exception e) { if (debugFlag)
     * e.printStackTrace(); // Continue with the other nodes. }
     * visited.add(sRootId);
     *
     * if (!sInh.equalsIgnoreCase("yes")) return successPacket();
     *
     * // Do it for all ascendants. Attribute attr; String sAscClass; String
     * sAscId; try { if (sRootClass.equalsIgnoreCase(PM_CLASS_UATTR_NAME)) {
     * attr = getFromUsers(sRootId, PM_NODE_UATTR); if (attr != null) { for
     * (NamingEnumeration enumer = attr.getAll(); enumer.hasMore(); ) { sAscId =
     * (String)enumer.next(); removeRep(PM_CLASS_USER_NAME, sAscId, sInh,
     * sRepId, visited); } } attr = getFromAttrs(sRootId, PM_NODE_UATTR); if
     * (attr != null) { for (NamingEnumeration enumer = attr.getAll();
     * enumer.hasMore(); ) { sAscId = (String)enumer.next();
     * removeRep(PM_CLASS_UATTR_NAME, sAscId, sInh, sRepId, visited); } } } else
     * if (sRootClass.equalsIgnoreCase(PM_CLASS_OATTR_NAME)) { attr =
     * getFromAttrs(sRootId, PM_NODE_OATTR); if (attr != null) { for
     * (NamingEnumeration enumer = attr.getAll(); enumer.hasMore(); ) { sAscId =
     * (String)enumer.next(); removeRep(PM_CLASS_OATTR_NAME, sAscId, sInh,
     * sRepId, visited); } } attr = getFromOpsets(sRootId, PM_NODE_OATTR); if
     * (attr != null) { for (NamingEnumeration enumer = attr.getAll();
     * enumer.hasMore(); ) { sAscId = (String)enumer.next();
     * removeRep(PM_CLASS_OPSET_NAME, sAscId, sInh, sRepId, visited); } } } else
     * if (sRootClass.equalsIgnoreCase(PM_CLASS_CONN_NAME)) { attr =
     * getFromUserAttrs(sRootId, PM_NODE_CONN); if (attr != null) { for
     * (NamingEnumeration enumer = attr.getAll(); enumer.hasMore(); ) { sAscId =
     * (String)enumer.next(); removeRep(PM_CLASS_UATTR_NAME, sAscId, sInh,
     * sRepId, visited); } } attr = getFromUsers(sRootId, PM_NODE_CONN); if
     * (attr != null) { for (NamingEnumeration enumer = attr.getAll();
     * enumer.hasMore(); ) { sAscId = (String)enumer.next();
     * removeRep(PM_CLASS_USER_NAME, sAscId, sInh, sRepId, visited); } } attr =
     * getFromPolicies(sRootId, PM_NODE_CONN); if (attr != null) { for
     * (NamingEnumeration enumer = attr.getAll(); enumer.hasMore(); ) { sAscId =
     * (String)enumer.next(); removeRep(PM_CLASS_POL_NAME, sAscId, sInh, sRepId,
     * visited); } } attr = getFromObjAttrs(sRootId, PM_NODE_CONN); if (attr !=
     * null) { for (NamingEnumeration enumer = attr.getAll(); enumer.hasMore();
     * ) { sAscId = (String)enumer.next(); removeRep(PM_CLASS_OATTR_NAME,
     * sAscId, sInh, sRepId, visited); } } attr = getFromOpsets(sRootId,
     * PM_NODE_CONN); if (attr != null) { for (NamingEnumeration enumer =
     * attr.getAll(); enumer.hasMore(); ) { sAscId = (String)enumer.next();
     * removeRep(PM_CLASS_OPSET_NAME, sAscId, sInh, sRepId, visited); } } } else
     * if (sRootClass.equalsIgnoreCase(PM_CLASS_POL_NAME)) { attr =
     * getFromUserAttrs(sRootId, PM_NODE_POL); if (attr != null) { for
     * (NamingEnumeration enumer = attr.getAll(); enumer.hasMore(); ) { sAscId =
     * (String)enumer.next(); removeRep(PM_CLASS_UATTR_NAME, sAscId, sInh,
     * sRepId, visited); } } attr = getFromObjAttrs(sRootId, PM_NODE_POL); if
     * (attr != null) { for (NamingEnumeration enumer = attr.getAll();
     * enumer.hasMore(); ) { sAscId = (String)enumer.next();
     * removeRep(PM_CLASS_OATTR_NAME, sAscId, sInh, sRepId, visited); } } } else
     * if (sRootClass.equalsIgnoreCase(PM_CLASS_OPSET_NAME)) { attr =
     * getFromAttrs(sRootId, PM_NODE_OPSET); if (attr != null) { for
     * (NamingEnumeration enumer = attr.getAll(); enumer.hasMore(); ) { sAscId =
     * (String)enumer.next(); removeRep(PM_CLASS_UATTR_NAME, sAscId, sInh,
     * sRepId, visited); } } } return successPacket(); } catch (Exception e) {
     * e.printStackTrace(); return
     * failurePacket("Exception while propagating representative object: " +
     * e.getMessage()); } }
     */
    // Get the attributes of a PM entity (user, user attribute, policy class,
    // etc.)
    // with a given id and of a given class.
    /*private Attributes getPmEntity(String sObjId, String sClass) {
    Attributes attrs;
    String sCont;
    if (sClass.equals(PM_CLASS_USER_NAME)) {
    sCont = sUserContainerDN;
    } else if (sClass.equals(PM_CLASS_UATTR_NAME)) {
    sCont = sUserAttrContainerDN;
    } else if (sClass.equals(PM_CLASS_OBJ_NAME)) {
    sCont = sVirtualObjContainerDN;
    } else if (sClass.equals(PM_CLASS_OATTR_NAME)) {
    sCont = sObjAttrContainerDN;
    } else if (sClass.equals(PM_CLASS_POL_NAME)) {
    sCont = sPolicyContainerDN;
    } else if (sClass.equals(PM_CLASS_CONN_NAME)) {
    sCont = sConnectorContainerDN;
    } else if (sClass.equals(PM_CLASS_OPSET_NAME)) {
    sCont = sOpsetContainerDN;
    } else {
    return null;
    }
    try {
    return ctx.getAttributes("CN=" + sObjId + "," + sCont);
    } catch (Exception e) {
    if (debugFlag) {
    e.printStackTrace();
    }
    return null;
    }
    }*/
    // Get PM objects of a given class (users, user attributes, etc.
    // The result is a list of name:id.
    private Packet getPmEntitiesOfClass(String sClientId, String sClass)
            throws Exception {
        Packet res = new Packet();
        NamingEnumeration<?> objs;
        String sContainer;

        if (sClass.equals(PM_CLASS_USER_NAME)) {
            sContainer = sUserContainerDN;
        } else if (sClass.equals(PM_CLASS_UATTR_NAME)) {
            sContainer = sUserAttrContainerDN;
        } else if (sClass.equals(PM_CLASS_OBJ_NAME)) {
            sContainer = sVirtualObjContainerDN;
        } else if (sClass.equals(PM_CLASS_OATTR_NAME)) {
            sContainer = sObjAttrContainerDN;
        } else if (sClass.equals(PM_CLASS_CONN_NAME)) {
            sContainer = sConnectorContainerDN;
        } else if (sClass.equals(PM_CLASS_POL_NAME)) {
            sContainer = sPolicyContainerDN;
        } else if (sClass.equals(PM_CLASS_OPSET_NAME)) {
            sContainer = sOpsetContainerDN;
        } else {
            return res;
        }

        try {
            SearchControls constraints = new SearchControls();
            constraints.setSearchScope(SearchControls.ONELEVEL_SCOPE);
            constraints.setReturningAttributes(new String[]{"pmId", "pmName"});
            objs = ctx.search(sContainer, "(objectClass=*)", constraints);
        } catch (CommunicationException e) {
            if (debugFlag) {
                e.printStackTrace();
            }
            return failurePacket("AD connection error");
        } catch (Exception e) {
            if (debugFlag) {
                e.printStackTrace();
            }
            return failurePacket("Exception: " + e.getMessage());
        }

        while (objs != null && objs.hasMore()) {
            SearchResult sr = (SearchResult) objs.next();
            String sName = (String) sr.getAttributes().get("pmName").get();
            String sId = (String) sr.getAttributes().get("pmId").get();
            res.addItem(ItemType.RESPONSE_TEXT, sName + PM_FIELD_DELIM + sId);
        }
        return res;
    }

    // Return all objects, one per item. Each item contains:
    // For File/Dir: name|id|class|"no"|host|path.
    // For PM entities: name|id|class|inh|original name|original id.
    // For composites: name|id|"Composite"|"no"|template id|components|keys.
    // The components have the format: comp1:...:compn, where each compi is
    // the id of the oattr associated with a component object of the composite.
    // The keys have the format: key1=value1:...:keyn=valuen.
    private Packet getObjects(String sClientId) throws Exception {
        Packet res = new Packet();
        NamingEnumeration<?> objs;

        try {
            SearchControls constraints = new SearchControls();
            constraints.setSearchScope(SearchControls.ONELEVEL_SCOPE);
            constraints.setReturningAttributes(new String[]{"pmId", "pmName",
                    "pmObjClass", "pmIncludesAscendants", "pmHost", "pmPath",
                    "pmOriginalId", "pmOriginalName", "pmTemplateId",
                    "pmComponents", "pmKey"});
            objs = ctx.search(sVirtualObjContainerDN, "(objectClass=*)",
                    constraints);

            while (objs != null && objs.hasMore()) {
                SearchResult sr = (SearchResult) objs.next();
                Attributes virattrs = sr.getAttributes();
                String sName = (String) virattrs.get("pmName").get();
                String sId = (String) virattrs.get("pmId").get();
                String sClass = (String) virattrs.get("pmObjClass").get();
                String sIncludes = (String) virattrs.get("pmIncludesAscendants").get();
                sIncludes = (sIncludes.equals("TRUE") ? "yes" : "no");
                if (sClass.equals(PM_CLASS_FILE_NAME)
                        || sClass.equals(PM_CLASS_DIR_NAME)) {
                    String sHost = (String) virattrs.get("pmHost").get();
                    String sPath = (String) virattrs.get("pmPath").get();
                    res.addItem(ItemType.RESPONSE_TEXT, sName
                            + PM_ALT_FIELD_DELIM + sId + PM_ALT_FIELD_DELIM
                            + sClass + PM_ALT_FIELD_DELIM + sIncludes
                            + PM_ALT_FIELD_DELIM + sHost + PM_ALT_FIELD_DELIM
                            + sPath);
                } else if (sClass.equals(PM_CLASS_USER_NAME)
                        || sClass.equals(PM_CLASS_UATTR_NAME)
                        || sClass.equals(PM_CLASS_OBJ_NAME)
                        || sClass.equals(PM_CLASS_OATTR_NAME)
                        || sClass.equals(PM_CLASS_POL_NAME)
                        || sClass.equals(PM_CLASS_CONN_NAME)
                        || sClass.equals(PM_CLASS_OPSET_NAME)) {
                    String sOrigName = (String) virattrs.get("pmOriginalName").get();
                    String sOrigId = (String) virattrs.get("pmOriginalId").get();
                    res.addItem(ItemType.RESPONSE_TEXT, sName
                            + PM_ALT_FIELD_DELIM + sId + PM_ALT_FIELD_DELIM
                            + sClass + PM_ALT_FIELD_DELIM + sIncludes
                            + PM_ALT_FIELD_DELIM + sOrigName
                            + PM_ALT_FIELD_DELIM + sOrigId);
                } else if (sClass.equals(PM_CLASS_CLIPBOARD_NAME)) {
                    String sHost = (String) virattrs.get("pmHost").get();
                    res.addItem(ItemType.RESPONSE_TEXT, sName
                            + PM_ALT_FIELD_DELIM + sId + PM_ALT_FIELD_DELIM
                            + sClass + PM_ALT_FIELD_DELIM + sIncludes
                            + PM_ALT_FIELD_DELIM + sHost);
                } else {
                    res.addItem(ItemType.RESPONSE_TEXT, sName
                            + PM_ALT_FIELD_DELIM + sId + PM_ALT_FIELD_DELIM
                            + sClass + PM_ALT_FIELD_DELIM + sIncludes);
                }
            }
            return res;
        } catch (CommunicationException e) {
            if (debugFlag) {
                e.printStackTrace();
            }
            return failurePacket("AD connection error");
        } catch (Exception e) {
            if (debugFlag) {
                e.printStackTrace();
            }
            return failurePacket("Exception: " + e.getMessage());
        }
    }

    private Packet getOpsetOattrs(String sSessId, String sOpsetName) {
        String sOpsetId = getEntityId(sOpsetName, PM_NODE_OPSET);
        if (sOpsetId == null) {
            return failurePacket("No operation set " + sOpsetName);
        }
        Packet result = new Packet();
        try {
            Attributes attrs = ctx.getAttributes("CN=" + sOpsetId + ","
                    + sOpsetContainerDN);
            Attribute attr = attrs.get("pmToAttr");
            if (attr != null) {
                for (NamingEnumeration<?> enumer = attr.getAll(); enumer.hasMore(); ) {
                    String sOattrId = (String) enumer.next();
                    String sOattrName = getEntityName(sOattrId, PM_NODE_OATTR);
                    result.addItem(ItemType.RESPONSE_TEXT, sOattrName
                            + PM_FIELD_DELIM + sOattrId);
                }
            }
        } catch (Exception e) {
            e.printStackTrace();
            return failurePacket("Exception in getOpsetOattrs: "
                    + e.getMessage());
        }
        return result;
    }

    // entity type representative objects
    // ---------------------------------------------------------------------------
    // o all objects that represent the associated object attribute.
    // b all objects that represent the object attribute.
    // etc.
    private Packet getOpsetsBetween(String sSessId, String sUattrName,
                                    String sEntName, String sEntType) {
        // A few checks.
        String sUattrId = getEntityId(sUattrName, PM_NODE_UATTR);
        if (sUattrId == null) {
            return failurePacket("No user attribute " + sUattrName);
        }

        // If sEntType is "o", getIdOfEntityWithNameAndType will return the id of the associated
        // object attribute.
        String sEntId = getEntityId(sEntName, sEntType);
        if (sEntId == null) {
            return failurePacket("No entity " + sEntName + " of type "
                    + sEntType);
        }

        // Find all objects that represent the entity, even when the entity is
        // an
        // object or object attribute.
        HashSet<String> repSet = getObjectsRepresentingEntity(sEntId, sEntType);
        printSet(repSet, PM_OBJ,
                "Set of virtual objects representing the entity "
                        + getEntityName(sEntId, sEntType));

        // Create an empty result.
        Packet result = new Packet();

        // If sEntType is b or o, find the opsets between them.
        // Find the opsets between sUattrName and each element in repSet.
        if (sEntType.equalsIgnoreCase(PM_NODE_OATTR)
                || sEntType.equalsIgnoreCase(PM_NODE_ASSOC)) {
            getOpsetsBetween(sUattrId, sEntId, result);
        }

        // Now for every virtual object that directly represents the entity,
        // find the
        // associated object attribute, then get the opsets between the user
        // attribute
        // and the object attribute.
        Iterator<String> hsiter = repSet.iterator();
        while (hsiter.hasNext()) {
            String sObjId = hsiter.next();
            String sAssocId = getAssocOattr(sObjId);
            getOpsetsBetween(sUattrId, sAssocId, result);
        }
        return result;
    }

    // Delete all opsets directly assigned to an user attribute and an object
    // attribute
    private Packet deleteOpsetsBetween(String sSessId, String sProcId,
                                       String sUattrName, String sOattrName) {
        Packet opsetids = new Packet();
        String sUattrId = getEntityId(sUattrName, PM_NODE_UATTR);
        String sOattrId = getEntityId(sOattrName, PM_NODE_OATTR);
        getOpsetsBetween(sUattrId, sOattrId, opsetids);
        for (int i = 0; i < opsetids.size(); i++) {
            String s = opsetids.getStringValue(i);
            String[] pieces = s.split(PM_FIELD_DELIM);
            String sOpsetId = pieces[1];
            deleteDoubleLink(sUattrId, PM_NODE_UATTR, sOpsetId, PM_NODE_OPSET);
            deleteDoubleLink(sOpsetId, PM_NODE_OPSET, sOattrId, PM_NODE_OATTR);
            try {
                ctx.destroySubcontext("CN=" + sOpsetId + ","
                        + sOpsetContainerDN);
            } catch (Exception e) {
                if (debugFlag) {
                    e.printStackTrace();
                }
                return failurePacket("Error while deleting opset " + sOpsetId
                        + ": " + e.getMessage());
            }
        }
        return successPacket();
    }

    // Get all opsets between a given uattr and a given oattr.
    // Add their <name>:<id> to the array list specified as the third parameter.
    private void getOpsetsBetween(String sUattrId, String sOattrId, Packet res) {
        try {
            Attributes uattrAttrs = ctx.getAttributes("CN=" + sUattrId + ","
                    + sUserAttrContainerDN);
            Attribute uattrAttr = uattrAttrs.get("pmToOpset");
            // From all these opsets, retain those assigned to the oattr.
            if (uattrAttr != null) {
                for (NamingEnumeration<?> enumer = uattrAttr.getAll(); enumer.hasMore(); ) {
                    String sOpsetId = (String) enumer.next();
                    Attributes opsetAttrs = ctx.getAttributes("CN=" + sOpsetId
                            + "," + sOpsetContainerDN);
                    Attribute opsetAttr = opsetAttrs.get("pmToAttr");
                    if (opsetAttr != null) {
                        for (NamingEnumeration<?> enum2 = opsetAttr.getAll(); enum2.hasMore(); ) {
                            String sToAttrId = (String) enum2.next();
                            if (sOattrId.equalsIgnoreCase(sToAttrId)) {
                                res.addItem(ItemType.RESPONSE_TEXT,
                                        (String) opsetAttrs.get("pmName").get()
                                                + PM_FIELD_DELIM + sOpsetId);
                                break;
                            }
                        }
                    }
                }
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    // Return the set of all OBJECTS (NOT object attributes) that DIRECTLY
    // represent
    // the specified entity (regardless of whether they represent only the
    // entity
    // or its entire subgraph).
    private HashSet<String> getObjectsRepresentingEntity(String sEntId,
                                                         String sEntType) {
        HashSet<String> prSet = new HashSet<String>();
        String sObjId;
        // Search PmVirtualObjContainer for objects x such that:
        // x represents a PM entity and
        // x.origid = entity.id.
        NamingEnumeration<?> objects;
        try {
            SearchControls constraints = new SearchControls();
            constraints.setSearchScope(SearchControls.ONELEVEL_SCOPE);
            constraints.setReturningAttributes(new String[]{"pmId",
                    "pmOriginalId"});
            objects = ctx.search(sVirtualObjContainerDN, "(objectClass=*)",
                    constraints);
            while (objects != null && objects.hasMore()) {
                SearchResult sr = (SearchResult) objects.next();
                sObjId = (String) sr.getAttributes().get("pmId").get();
                Attribute attr = sr.getAttributes().get("pmOriginalId");
                if (attr == null) {
                    continue;
                }
                String sOrigId = (String) attr.get();
                if (sOrigId.equalsIgnoreCase(sEntId)) {
                    prSet.add(sObjId);
                }
            }
        } catch (Exception e) {
            if (debugFlag) {
                e.printStackTrace();
            }
        }
        return prSet;
    }

    // Return the set of all object attributes associated to objects that
    // DIRECTLY represent the specified entity, according to the isSubgraph
    // parameter. If "isSubgraph" is true,
    // the function returns only those object attributes that represent
    // a subgraph with the entity as root. Otherwise, the function returns
    // only the object attributes that represent the entity.
    /*private HashSet<String> getOattrsRepresentingEntity(String sEntId,
    String sEntType, boolean isSubgraph) {
    HashSet<String> prSet = new HashSet<String>();
    String sObjId;
    // Search PmVirtualObjContainer for objects x such that:
    // x represents a PM entity and
    // x.origid = entity.id and
    // onlySubgraphs => x.includesAscs
    NamingEnumeration<?> objects;
    try {
    SearchControls constraints = new SearchControls();
    constraints.setSearchScope(SearchControls.ONELEVEL_SCOPE);
    constraints.setReturningAttributes(new String[] { "pmId",
    "pmOriginalId", "pmIncludesAscendants" });
    objects = ctx.search(sVirtualObjContainerDN, "(objectClass=*)",
    constraints);
    while (objects != null && objects.hasMore()) {
    SearchResult sr = (SearchResult) objects.next();
    Attributes attrs = sr.getAttributes();
    sObjId = (String) attrs.get("pmId").get();
    Attribute attr = attrs.get("pmOriginalId");
    if (attr == null) {
    continue;
    }
    String sOrigId = (String) attr.get();
    if (!sOrigId.equalsIgnoreCase(sEntId)) {
    continue;
    }
    attr = attrs.get("pmIncludesAscendants");
    if (((String) attr.get()).equalsIgnoreCase("TRUE") == isSubgraph) {
    String sOattrId = getAssocOattr(sObjId);
    if (sOattrId == null) {
    continue;
    }
    prSet.add(sOattrId);
    }
    }
    } catch (Exception e) {
    if (debugFlag) {
    e.printStackTrace();
    }
    }
    return prSet;
    }*/
    // Get all operation sets. Each item of the return contains
    // <operation set name>:<operation set id>.
    private Packet getOpsets(String sClientId) throws Exception {
        Packet res = new Packet();
        NamingEnumeration<?> osets;

        try {
            SearchControls constraints = new SearchControls();
            constraints.setSearchScope(SearchControls.ONELEVEL_SCOPE);
            constraints.setReturningAttributes(new String[]{"pmId", "pmName"});
            osets = ctx.search(sOpsetContainerDN, "(objectClass=*)",
                    constraints);
        } catch (CommunicationException e) {
            if (debugFlag) {
                e.printStackTrace();
            }
            return failurePacket("AD connection error");
        } catch (Exception e) {
            if (debugFlag) {
                e.printStackTrace();
            }
            return failurePacket("Exception: " + e.getMessage());
        }

        while (osets != null && osets.hasMore()) {
            SearchResult sr = (SearchResult) osets.next();
            String sName = (String) sr.getAttributes().get("pmName").get();
            String sId = (String) sr.getAttributes().get("pmId").get();
            res.addItem(ItemType.RESPONSE_TEXT, sName + PM_FIELD_DELIM + sId);
        }
        return res;
    }

    // Add a new op set and/or a new operation.
    // If the op set does not exist, add a new one and the operation (if the op
    // is present in the command).
    // If the op set already exists, add a new operation (which must be
    // present in the command).
    // The last two arguments are the id and type of a graph node where the
    // new opset must be assigned (it can be the connector, a user attribute, or
    // an object attribute - including oattr associated to objects).
    // The base id and type can be null; then we will add the opset to the
    // connector node.
    // Note that the base node is used only when the opset is
    // created (and not when we add only an operation).
    private Packet addOpsetAndOp(String sSessId, String sOpset, String sDescr,
                                 String sInfo, String sOp, String sBaseId, String sBaseType) {
        System.out.println("addOpsetAndOp(name=" + sOpset + ", descr=" + sDescr
                + ", info=" + sInfo + ", op=" + sOp + ", baseid=" + sBaseId
                + ", basetype=" + sBaseType + ")");

        if (sBaseId == null) {
            sBaseId = PM_CONNECTOR_ID;
            sBaseType = PM_NODE_CONN;
        }

        if (sBaseType.equalsIgnoreCase(PM_NODE_ASSOC)) {
            sBaseType = PM_NODE_OATTR;
        }

        // Check permissions.
        // If the opset does not exist, check permission to create it.
        // Otherwise, check permission to add an operation to the opset.
        String sId = getEntityId(sOpset, PM_NODE_OPSET);
        if (sId == null) {
            if (!requestAddOpsetPerms(sSessId, null, sBaseId, sBaseType)) {
                return failurePacket(reqPermsMsg);
            }
        }

        // Test the base node type.
        if (sBaseType.equalsIgnoreCase(PM_NODE_CONN)
                || sBaseType.equalsIgnoreCase(PM_NODE_OATTR)) {
            return addOpsetAndOpInternal(sOpset, null, sDescr, sInfo, sOp,
                    null, null, sBaseId, sBaseType);
        } else if (sBaseType.equalsIgnoreCase(PM_NODE_UATTR)) {
            return addOpsetAndOpInternal(sOpset, null, sDescr, sInfo, sOp,
                    sBaseId, sBaseType, null, null);
        } else {
            return failurePacket("Cannot add/assign an operation set to this type of node");
        }
    }

    // Create a new opset with predefined id: use new name and id.
    // Create a new opset and let the engine set its id: use a new name and null
    // id.
    // Add an op to an old opset: use the old name (the id may be null).
    private Packet addOpsetAndOpInternal(String sOpsetName, String sOpsetId,
                                         String sDescr, String sInfo, String sOp, String sAscId,
                                         String sAscType, String sDescId, String sDescType) {
        System.out.println("addOpsetAndOpInternal(name=" + sOpsetName + ", id="
                + sOpsetId + ", descr=" + sDescr + ", info=" + sInfo + ", op="
                + sOp + ", ascid=" + sAscId + ", asctype=" + sAscType
                + ", descid=" + sDescId + ", desctype=" + sDescType + ")");

        // Test if the opset exists.
        boolean newOpset = false;
        String sId = getEntityId(sOpsetName, PM_NODE_OPSET);
        if (sId == null) {
            // THIS IS A NEW OPSET.
            newOpset = true;

            // Create the opset and assign it.
            Attributes attrs = new BasicAttributes(true);
            if (sOpsetId == null) {
                RandomGUID myGUID = new RandomGUID();
                sOpsetId = myGUID.toStringNoDashes();
            }
            attrs.put("objectClass", sOpsetClass);
            attrs.put("pmId", sOpsetId);
            attrs.put("pmName", sOpsetName);
            attrs.put("pmDescription", sDescr);
            attrs.put("pmOtherInfo", sInfo);
            attrs.put("pmObjClass", "Ignored");

            // Create the opset object.
            try {
                ctx.bind("CN=" + sOpsetId + "," + sOpsetContainerDN, null,
                        attrs);
            } catch (Exception e) {
                e.printStackTrace();
                return failurePacket("Unable to create opset \"" + sOpsetName
                        + "\"");
            }

            // Set the links.
            Packet res;
            if (sDescId == null) {
                sDescId = PM_CONNECTOR_ID;
                sDescType = PM_NODE_CONN;
            }
            if (sAscId != null) {
                res =  addDoubleLink(sAscId, sAscType, sOpsetId,
                        PM_NODE_OPSET);
                if (res.hasError()) {
                    return res;
                }
            }
            res =  addDoubleLink(sOpsetId, PM_NODE_OPSET, sDescId,
                    sDescType);
            if (res.hasError()) {
                return res;
            }
        } else {
            sOpsetId = sId;
        }

        // Prepare the result for the successful case.
        Packet okRes = new Packet();
        try {
            okRes.addItem(ItemType.RESPONSE_TEXT, sOpsetName + PM_FIELD_DELIM
                    + sOpsetId);
        } catch (Exception e) {
            e.printStackTrace();
            return failurePacket("Exception in addOpsetAndOpInternal: "
                    + e.getMessage());
        }

        // The operation couldn't be null if the opset already existed.
        if (sOp == null || sOp.length() == 0) {
            if (newOpset) {
                return okRes;
            } else {
                return failurePacket("Operation cannot be null!");
            }
        }

        // Operation must be a valid (existing) operation.
        if (!isOperation(sOp)) {
            return failurePacket(sOp + " is not an operation!");
        }
        // Operation cannot be duplicate.
        if (opsetContainsOp(sOpsetId, sOp)) {
            return failurePacket("Operation already in the operation set!");
        }

        // Add the operation to the opset.
        ModificationItem[] mods = new ModificationItem[1];
        mods[0] = new ModificationItem(DirContext.ADD_ATTRIBUTE,
                new BasicAttribute("pmOp", sOp));
        try {
            ctx.modifyAttributes("CN=" + sOpsetId + "," + sOpsetContainerDN,
                    mods);
        } catch (Exception e) {
            e.printStackTrace();
            return failurePacket("Unable to add operation \"" + sOp + "\": "
                    + e.getMessage());
        }

        // Check the static constraints.
        // The check is not necessary if the opset is not between a user
        // attribute
        // and an object attribute.
        Packet res =  checkScons();
        if (!res.hasError()) {
            return okRes;
        }

        // The SCons are violated. Tell the client the admin op is rolled back.
        String sErr = res.getErrorMessage() + " Rolling back Add Operation.";

        // Roll back the AddOp operation.
        mods[0] = new ModificationItem(DirContext.REMOVE_ATTRIBUTE,
                new BasicAttribute("pmOp", sOp));
        try {
            ctx.modifyAttributes("CN=" + sId + "," + sOpsetContainerDN, mods);
            return failurePacket(sErr);
        } catch (Exception e) {
            if (debugFlag) {
                e.printStackTrace();
            }
            return failurePacket(sErr + " Couldn't roll back Add Op");
        }
    }

    // Returns a Packet that contains the <name>:<id> of the entity
    // in its first item.
    private Packet getEntityWithProp(String sSessId, String sEntType,
                                     String sProp) {
        String sId = getEntityWithPropInternal(sEntType, sProp);
        if (sId == null) {
            return failurePacket("No such entity found!");
        }
        String sName = getEntityName(sId, sEntType);
        Packet res = new Packet();
        try {
            res.addItem(ItemType.RESPONSE_TEXT, sName + PM_FIELD_DELIM + sId);
        } catch (Exception e) {
            e.printStackTrace();
            return failurePacket("Exception when building the result packet");
        }
        return res;
    }

    // Returns the id of the entity of the specified type with the specified
    // property, or null if no such entity exists.
    private String getEntityWithPropInternal(String sType, String sProp) {
        NamingEnumeration<?> attrs;
        String sContainer;
        String sClass;
        if (sType.equalsIgnoreCase(PM_NODE_OATTR)) {
            sContainer = sObjAttrContainerDN;
            sClass = sObjAttrClass;
        } else if (sType.equalsIgnoreCase(PM_NODE_UATTR)) {
            sContainer = sUserAttrContainerDN;
            sClass = sUserAttrClass;
        } else if (sType.equalsIgnoreCase(PM_NODE_POL)) {
            sContainer = sPolicyContainerDN;
            sClass = sPolicyClass;
        } else {
            return null;
        }

        try {
            SearchControls constraints = new SearchControls();
            constraints.setSearchScope(SearchControls.ONELEVEL_SCOPE);
            constraints.setReturningAttributes(new String[]{"pmId"});
            attrs = ctx.search(sContainer, "(&(objectClass=" + sClass
                    + ")(pmProperty=" + sProp + "))", constraints);
            while (attrs != null && attrs.hasMore()) {
                SearchResult sr = (SearchResult) attrs.next();
                String sId = (String) sr.getAttributes().get("pmId").get();
                return sId;
            }
            return null;
        } catch (Exception e) {
            e.printStackTrace();
            return null;
        }
    }

    // Return all object attributes proper (excluding those associated to
    // objects).
    private Packet getObjAttrsProper(String sClientId) throws Exception {
        Packet result = new Packet();
        NamingEnumeration<?> oattrs;

        try {
            SearchControls constraints = new SearchControls();
            constraints.setSearchScope(SearchControls.ONELEVEL_SCOPE);
            constraints.setReturningAttributes(new String[]{"pmName", "pmId",
                    "pmAssocObj"});
            oattrs = ctx.search(sObjAttrContainerDN, "(objectClass=*)",
                    constraints);
            while (oattrs != null && oattrs.hasMore()) {
                SearchResult sr = (SearchResult) oattrs.next();
                Attribute assocattr = sr.getAttributes().get("pmAssocObj");
                if (assocattr != null) {
                    continue;
                }
                String sName = (String) sr.getAttributes().get("pmName").get();
                String sId = (String) sr.getAttributes().get("pmId").get();
                result.addItem(ItemType.RESPONSE_TEXT, sName + PM_FIELD_DELIM
                        + sId);
            }
        } catch (CommunicationException e) {
            if (debugFlag) {
                e.printStackTrace();
            }
            return failurePacket("AD connection error");
        } catch (Exception e) {
            if (debugFlag) {
                e.printStackTrace();
            }
            return failurePacket("Exception: " + e.getMessage());
        }
        return result;
    }

    // Return all object attributes (including those associated to objects).
    private Packet getOattrs(String sClientId) throws Exception {
        Packet result = new Packet();
        NamingEnumeration<?> oattrs;

        try {
            SearchControls constraints = new SearchControls();
            constraints.setSearchScope(SearchControls.ONELEVEL_SCOPE);
            constraints.setReturningAttributes(new String[]{"pmName", "pmId"});
            oattrs = ctx.search(sObjAttrContainerDN, "(objectClass=*)",
                    constraints);
            while (oattrs != null && oattrs.hasMore()) {
                SearchResult sr = (SearchResult) oattrs.next();
                String sName = (String) sr.getAttributes().get("pmName").get();
                String sId = (String) sr.getAttributes().get("pmId").get();
                result.addItem(ItemType.RESPONSE_TEXT, sName + PM_FIELD_DELIM
                        + sId);
            }
        } catch (CommunicationException e) {
            if (debugFlag) {
                e.printStackTrace();
            }
            return failurePacket("AD connection error");
        } catch (Exception e) {
            if (debugFlag) {
                e.printStackTrace();
            }
            return failurePacket("Exception: " + e.getMessage());
        }
        return result;
    }

    private boolean isEvent(String sName) {
        for (int i = 0; i < sEventNames.length; i++) {
            if (sEventNames[i].equalsIgnoreCase(sName)) {
                return true;
            }
        }
        return false;
    }

    private Packet getAllOps(String sClientId) throws Exception {
        Packet result = new Packet();
        NamingEnumeration<?> cls;
        NamingEnumeration<?> ops;

        try {
            SearchControls constraints = new SearchControls();
            constraints.setSearchScope(SearchControls.ONELEVEL_SCOPE);
            constraints.setReturningAttributes(new String[]{"pmOp"});
            cls = ctx.search(sObjClassContainerDN, "(objectClass=*)",
                    constraints);
            while (cls != null && cls.hasMore()) {
                SearchResult sr = (SearchResult) cls.next();
                Attribute attr = sr.getAttributes().get("pmOp");
                if (attr != null) {
                    for (ops = attr.getAll(); ops.hasMore(); ) {
                        result.addItem(ItemType.RESPONSE_TEXT,
                                (String) ops.next());
                    }
                }
            }
        } catch (CommunicationException e) {
            if (debugFlag) {
                e.printStackTrace();
            }
            return failurePacket("AD connection error");
        } catch (Exception e) {
            if (debugFlag) {
                e.printStackTrace();
            }
            return failurePacket("Exception: " + e.getMessage());
        }
        return result;
    }

    // Get all object classes. Each item of the return value contains
    // an object class name.
    private Packet getObjClasses(String sClientId) throws Exception {
        Packet res = new Packet();
        NamingEnumeration<?> cls;

        try {
            SearchControls constraints = new SearchControls();
            constraints.setSearchScope(SearchControls.ONELEVEL_SCOPE);
            constraints.setReturningAttributes(new String[]{"pmId", "pmName"});
            cls = ctx.search(sObjClassContainerDN, "(objectClass=*)",
                    constraints);
        } catch (CommunicationException e) {
            if (debugFlag) {
                e.printStackTrace();
            }
            return failurePacket("AD connection error");
        } catch (Exception e) {
            if (debugFlag) {
                e.printStackTrace();
            }
            return failurePacket("Exception: " + e.getMessage());
        }

        while (cls != null && cls.hasMore()) {
            SearchResult sr = (SearchResult) cls.next();
            String sName = (String) sr.getAttributes().get("pmName").get();
            //String sId = (String) sr.getAttributes().get("pmId").get();
            // result.add(PM_DATA + sName + PM_FIELD_DELIM + sId);
            res.addItem(ItemType.RESPONSE_TEXT, sName);
        }
        return res;
    }

    private Packet deleteObjClassAndOp(String sClientId, String sClass,
                                       String sOp) {
        // The class name cannot be null or empty.
        // The class cannot be a predefined class.
        // The class must exist.
        // If the operation is present, delete the operation from the class.
        // Otherwise delete the class.
        if (sClass == null || sClass.length() == 0) {
            return failurePacket("The class name cannot be null or empty");
        }

        if (sClass.equalsIgnoreCase(PM_CLASS_CLASS_NAME)
                || sClass.equalsIgnoreCase(PM_CLASS_FILE_NAME)
                || sClass.equalsIgnoreCase(PM_CLASS_DIR_NAME)) {
            return failurePacket("Cannot delete or modify a predefined class");
        }

        String sId = getEntityId(sClass, PM_OBJ_CLASS);
        if (sId == null) {
            return failurePacket("Unknown class " + sClass);
        }

        if (sOp == null || sOp.length() == 0) {
            // No operation was selected, delete the class.
            try {
                ctx.destroySubcontext("CN=" + sId + "," + sObjClassContainerDN);
            } catch (Exception e) {
                if (debugFlag) {
                    e.printStackTrace();
                }
                return failurePacket("Error while deleting class " + sClass
                        + ": " + e.getMessage());
            }
        } else {
            // Delete the operation.
            ModificationItem[] mods = new ModificationItem[1];
            mods[0] = new ModificationItem(DirContext.REMOVE_ATTRIBUTE,
                    new BasicAttribute("pmOp", sOp));
            try {
                ctx.modifyAttributes("CN=" + sId + "," + sObjClassContainerDN,
                        mods);
            } catch (Exception e) {
                if (debugFlag) {
                    e.printStackTrace();
                }
                return failurePacket("Error while deleting operation " + sOp
                        + ": " + e.getMessage());
            }
        }
        return successPacket();
    }

    // The op set id cannot be null or empty.
    // The op set must exist.
    // If the operation is present, delete the operation from the opset.
    // Otherwise delete the opset.
    private Packet deleteOpsetAndOp(String sClientId, String sId, String sOp) {
        if (sId == null || sId.length() == 0) {
            return failurePacket("The operation set id cannot be null or empty");
        }

        String sName = getEntityName(sId, PM_NODE_OPSET);
        if (sName == null) {
            return failurePacket("Unknown operation set " + sId);
        }
        if (sOp == null || sOp.length() == 0) {
            // No operation was selected, try to delete the operation set.
            if (!opsetIsIsolated(sId)) {
                return failurePacket("Operation set has assignments");
            }
            // The opset is only assigned to the connector node, and can be
            // deleted.
            Packet res =  deleteDoubleLink(sId, PM_NODE_OPSET,
                    PM_CONNECTOR_ID, PM_NODE_CONN);
            if (res.hasError()) {
                return res;
            }
            try {
                ctx.destroySubcontext("CN=" + sId + "," + sOpsetContainerDN);
            } catch (Exception e) {
                if (debugFlag) {
                    e.printStackTrace();
                }
                return failurePacket("Error while deleting op set " + sName
                        + ": " + e.getMessage());
            }
        } else {

            // An operation of the opset is also selected. Delete the operation
            // only.
            ModificationItem[] mods = new ModificationItem[1];
            mods[0] = new ModificationItem(DirContext.REMOVE_ATTRIBUTE,
                    new BasicAttribute("pmOp", sOp));
            try {
                ctx.modifyAttributes("CN=" + sId + "," + sOpsetContainerDN,
                        mods);
            } catch (Exception e) {
                if (debugFlag) {
                    e.printStackTrace();
                }
                return failurePacket("Error while deleting operation " + sOp
                        + ": " + e.getMessage());
            }
        }
        return successPacket();
    }

    // Add a new object class and/or a new operation.
    // If the object class does not exist, add a new one and the operation,
    // if present in the command.
    // If the object class already exists, add a new operation (which must be
    // present in the command.
    private Packet addObjClassAndOp(String sClientId, String sClass,
                                    String sDescr, String sInfo, String sOp) {
        // Test if the class exists.
        String sClassId = getEntityId(sClass, PM_OBJ_CLASS);
        System.out.println("Class id is " + sClassId);
        if (sClassId == null) {
            // Class does not exist. Add the class and the optional operation.
            Attributes attrs = new BasicAttributes(true);
            RandomGUID myGUID = new RandomGUID();
            sClassId = myGUID.toStringNoDashes();
            attrs.put("objectClass", sObjClassClass);
            attrs.put("pmId", sClassId);
            attrs.put("pmName", sClass);
            attrs.put("pmDescription", sDescr);
            attrs.put("pmOtherInfo", sInfo);

            String sClassDn = "CN=" + sClassId + "," + sObjClassContainerDN;

            try {
                ctx.bind(sClassDn, null, attrs);
            } catch (Exception e) {
                e.printStackTrace();
                return failurePacket("Unable to create class \"" + sClass
                        + "\"");
            }

            if (sOp == null) {
                System.out.println("the op is null");
            } else {
                System.out.println("the op is NOT null and has length "
                        + sOp.length());
            }

            if (sOp != null && sOp.length() > 0) {
                ModificationItem[] mods = new ModificationItem[1];
                mods[0] = new ModificationItem(DirContext.ADD_ATTRIBUTE,
                        new BasicAttribute("pmOp", sOp));
                try {
                    ctx.modifyAttributes(sClassDn, mods);
                } catch (Exception e) {
                    e.printStackTrace();
                    return failurePacket("Unable to add operation \"" + sOp
                            + "\": " + e.getMessage());
                }
            }
        } else {
            // Class exist, try to add the operation, which cannot be null or
            // duplicate.
            if (sOp == null || sOp.length() == 0) {
                return failurePacket("The operation name cannot be null or empty for an existing class");
            }

            if (objClassHasOp(sClassId, sOp)) {
                return failurePacket("Duplicate operation in the same object class");
            }

            // Add the operation
            ModificationItem[] mods = new ModificationItem[1];
            //String sClassDn = "CN=" + sClassId + "," + sObjClassContainerDN;
            mods[0] = new ModificationItem(DirContext.ADD_ATTRIBUTE,
                    new BasicAttribute("pmOp", sOp));
            try {
                ctx.modifyAttributes("CN=" + sClassId + ","
                        + sObjClassContainerDN, mods);
            } catch (Exception e) {
                e.printStackTrace();
                return failurePacket("Unable to add operation \"" + sOp
                        + "\"; " + e.getMessage());
            }
        }
        return successPacket();
    }

    // Add an object attribute.
    // The base node can be the connector node, an object attribute, or a
    // policy.
    // Return: failure or <name>:<id> of the new object attribute.
    private Packet addOattr(String sSessId, String sProcId, String sName,
                            String sDescr, String sInfo, String sBaseId, String sBaseType,
                            String sBaseIsVos, String sAssocObjId, String[] sProps) {
        if (sBaseIsVos.equalsIgnoreCase("yes")) {
            sBaseId = getAdminVosNodeOrigId(sBaseId);
        }

        if (!sBaseType.equalsIgnoreCase(PM_NODE_OATTR)
                && !sBaseType.equalsIgnoreCase(PM_NODE_CONN)
                && !sBaseType.equalsIgnoreCase(PM_NODE_POL)) {
            return failurePacket("You cannot create an object attribute in this type of node");
        }

        // Check permissions.
        if (!requestAddOattrPerms(sSessId, sProcId, sBaseId, sBaseType)) {
            return failurePacket(reqPermsMsg);
        }

        Packet res =  addOattrInternal(sName, null, sDescr, sInfo,
                sBaseId, sBaseType, sAssocObjId, sProps);
        if (!res.hasError()) {
            setLastUpdateTimestamp();
        }
        return res;
    }

    // In general, the argument sId is null, but sometimes we may want to create
    // an object attribute with a predefined id.
    private Packet addOattrInternal(String sName, String sId, String sDescr,
                                    String sInfo, String sBaseId, String sBaseType, String sAssocObjId,
                                    String[] sProps) {
        // Test if duplicate name.
        if (attrNameExists(sName, PM_NODE_OATTR)) {
            return failurePacket("Attribute with duplicate name");
        }

        String sDn;

        if (sId == null) {
            RandomGUID myGUID = new RandomGUID();
            sId = myGUID.toStringNoDashes();
        }

        // Prepare the attributes of the new attribute object.
        Attributes attrs = new BasicAttributes(true);
        attrs.put("objectClass", sObjAttrClass);
        attrs.put("pmId", sId);
        attrs.put("pmName", sName);
        attrs.put("pmDescription", sDescr);
        attrs.put("pmOtherInfo", sInfo);
        if (sAssocObjId != null) {
            attrs.put("pmAssocObj", sAssocObjId);
        }

        // Set the back link towards the base node in the new attribute.
        // At the same time, prepare the base node's DN
        // and the attribute to be added to the base node.
        String sBaseDn;
        ModificationItem[] mods = new ModificationItem[1];
        if (sBaseType.equalsIgnoreCase(PM_NODE_OATTR)) {
            attrs.put("pmToAttr", sBaseId);
            sBaseDn = "CN=" + sBaseId + "," + sObjAttrContainerDN;
            mods[0] = new ModificationItem(DirContext.ADD_ATTRIBUTE,
                    new BasicAttribute("pmFromAttr", sId));
        } else if (sBaseType.equalsIgnoreCase(PM_NODE_POL)) {
            attrs.put("pmToPolicy", sBaseId);
            sBaseDn = "CN=" + sBaseId + "," + sPolicyContainerDN;
            mods[0] = new ModificationItem(DirContext.ADD_ATTRIBUTE,
                    new BasicAttribute("pmFromObjAttr", sId));
        } else if (sBaseType.equalsIgnoreCase(PM_NODE_CONN)) {
            attrs.put("pmToConnector", sBaseId);
            sBaseDn = "CN=" + sBaseId + "," + sConnectorContainerDN;
            mods[0] = new ModificationItem(DirContext.ADD_ATTRIBUTE,
                    new BasicAttribute("pmFromObjAttr", sId));
        } else {
            return failurePacket("Base node's type incompatible with object attribute");
        }

        // Set the base node's link to the new user attribute.
        try {
            ctx.modifyAttributes(sBaseDn, mods);
        } catch (Exception e) {
            if (debugFlag) {
                e.printStackTrace();
            }
            return failurePacket("Unable to set link to new user attribute in its base node");
        }

        // Prepare the path and create.
        sDn = "CN=" + sId + "," + sObjAttrContainerDN;
        try {
            ctx.bind(sDn, null, attrs);
        } catch (InvalidNameException e) {
            if (debugFlag) {
                e.printStackTrace();
            }
            return failurePacket("Invalid object name (id)" + sId);
        } catch (NameAlreadyBoundException e) {
            if (debugFlag) {
                e.printStackTrace();
            }
            return failurePacket("Duplicate id " + sId);
        } catch (Exception e) {
            if (debugFlag) {
                e.printStackTrace();
            }
            return failurePacket("Probably invalid id " + sId);
        }

        // Add the attribute's properties, if any.
        if (sProps != null) {
            int n = sProps.length;
            if (n > 0) {
                mods = new ModificationItem[n];
                for (int i = 0; i < n; i++) {
                    System.out.println("Property " + sProps[i]);
                    mods[i] = new ModificationItem(DirContext.ADD_ATTRIBUTE,
                            new BasicAttribute("pmProperty", sProps[i]));
                }
                try {
                    ctx.modifyAttributes("CN=" + sId + ","
                            + sObjAttrContainerDN, mods);
                } catch (Exception e) {
                    if (debugFlag) {
                        e.printStackTrace();
                    }
                    return failurePacket("Unable to set the new object attribute's properties!");
                }
            }
        }

        Packet res = new Packet();
        try {
            res.addItem(ItemType.RESPONSE_TEXT, sName + PM_FIELD_DELIM + sId);
        } catch (Exception e) {
            e.printStackTrace();
            return failurePacket("Exception when building the result packet!");
        }
        return res;
    }

    /**
	 * @uml.property  name="reqPermsMsg"
	 */
    String reqPermsMsg;

    boolean requestAddPcPerms(String sSessId, String sProcId) {
        HashSet<String> resPerms;
        String sReqPerms;

        if (!entityExists(sSessId, PM_SESSION)) {
            reqPermsMsg = "You're not in a Policy Machine session!";
            return false;
        }

        sReqPerms = PM_CONN_CREATE_POL;
        resPerms = getPermittedOpsOnEntityInternal(sSessId, sProcId,
                PM_CONNECTOR_ID, PM_NODE_CONN);
        printSet(resPerms, PM_PERM, "Permissions on connector");
        if (!resPerms.contains(PM_ANY_ANY) && !resPerms.contains(sReqPerms)) {
            reqPermsMsg = "You're not authorized to create a policy class (assigned to connector)!";
            return false;
        }
        return true;
    }

    boolean requestAssignPerms(String sSessId, String sProcId, String sId1,
                               String sType1, String sId2, String sType2) {
        HashSet<String> resPerms;
        String sReqPerms1;
        String sReqPerms2;

        if (!entityExists(sSessId, PM_SESSION)) {
            reqPermsMsg = "You're not in a Policy Machine session!";
            return false;
        }

        if (sType1.equalsIgnoreCase(PM_NODE_OATTR)
                || sType1.equalsIgnoreCase(PM_NODE_ASSOC)) {
            sReqPerms1 = PM_OATTR_ASSIGN;
            if (sType2.equalsIgnoreCase(PM_NODE_OATTR)) {
                sReqPerms2 = PM_OATTR_ASSIGN_TO;
            } else if (sType2.equalsIgnoreCase(PM_NODE_POL)) {
                sReqPerms2 = PM_POL_ASSIGN_TO;
            } else {
                reqPermsMsg = "Incorrect types for assignment: " + sType1
                        + "--->" + sType2;
                return false;
            }
        } else if (sType1.equalsIgnoreCase(PM_NODE_USER)) {
            sReqPerms1 = PM_USER_ASSIGN;
            if (sType2.equalsIgnoreCase(PM_NODE_UATTR)) {
                sReqPerms2 = PM_UATTR_ASSIGN_TO;
            } else {
                reqPermsMsg = "Incorrect types for assignment: " + sType1
                        + "--->" + sType2;
                return false;
            }
        } else if (sType1.equalsIgnoreCase(PM_NODE_UATTR)) {
            sReqPerms1 = PM_UATTR_ASSIGN;
            if (sType2.equalsIgnoreCase(PM_NODE_UATTR)) {
                sReqPerms2 = PM_UATTR_ASSIGN_TO;
            } else if (sType2.equalsIgnoreCase(PM_NODE_POL)) {
                sReqPerms2 = PM_POL_ASSIGN_TO;
            } else if (sType2.equalsIgnoreCase(PM_NODE_OPSET)) {
                sReqPerms1 = PM_UATTR_ASSIGN_TO_OPSET;
                sReqPerms2 = PM_OPSET_ASSIGN_TO;
            } else {
                reqPermsMsg = "Incorrect types for assignment: " + sType1
                        + "--->" + sType2;
                return false;
            }
        } else if (sType1.equalsIgnoreCase(PM_NODE_OPSET)) {
            sReqPerms1 = PM_OPSET_ASSIGN;
            if (sType2.equalsIgnoreCase(PM_NODE_OATTR)
                    || sType2.equalsIgnoreCase(PM_NODE_ASSOC)) {
                sReqPerms2 = PM_OPSET_ASSIGN_TO;
            } else {
                reqPermsMsg = "Incorrect types for assignment: " + sType1
                        + "--->" + sType2;
                return false;
            }
        } else {
            reqPermsMsg = "Incorrect types for assignment: " + sType1 + "--->"
                    + sType2;
            return false;
        }

        resPerms = getPermittedOpsOnEntityInternal(sSessId, sProcId, sId1,
                sType1);
        printSet(resPerms, PM_PERM, "Permissions on entity of type " + sType1);
        if (!resPerms.contains(PM_ANY_ANY) && !resPerms.contains(sReqPerms1)) {
            reqPermsMsg = "You're not authorized to assign entity "
                    + getEntityName(sId1, sType1);
            return false;
        }
        resPerms = getPermittedOpsOnEntityInternal(sSessId, sProcId, sId2,
                sType2);
        printSet(resPerms, PM_PERM, "Permissions on entity of type " + sType2);
        if (!resPerms.contains(PM_ANY_ANY) && !resPerms.contains(sReqPerms2)) {
            reqPermsMsg = "You're not authorized to assign to entity "
                    + getEntityName(sId2, sType2);
            return false;
        }
        return true;
    }

    boolean requestAddOpsetPerms(String sSessId, String sProcId,
                                 String sBaseId, String sBaseType) {
        HashSet<String> resPerms;
        String sReqPerms;

        if (!entityExists(sSessId, PM_SESSION)) {
            reqPermsMsg = "You're not in a Policy Machine session!";
            return false;
        }

        resPerms = getPermittedOpsOnEntityInternal(sSessId, sProcId, sBaseId,
                sBaseType);
        printSet(resPerms, PM_PERM,
                "Permissions on entity " + getEntityName(sBaseId, sBaseType));

        if (sBaseType.equalsIgnoreCase(PM_NODE_OATTR)) {
            sReqPerms = PM_OATTR_CREATE_OPSET;
            if (!resPerms.contains(PM_ANY_ANY) && !resPerms.contains(sReqPerms)) {
                reqPermsMsg = "You're not authorized to create an operation set assigned to "
                        + getEntityName(sBaseId, sBaseType);
                return false;
            }
        } else if (sBaseType.equalsIgnoreCase(PM_NODE_UATTR)) {
            sReqPerms = PM_UATTR_CREATE_OPSET;
            if (!resPerms.contains(PM_ANY_ANY) && !resPerms.contains(sReqPerms)) {
                reqPermsMsg = "You're not authorized to create an operation set assigned to "
                        + getEntityName(sBaseId, sBaseType);
                return false;
            }
        } else if (sBaseType.equalsIgnoreCase(PM_NODE_CONN)) {
            sReqPerms = PM_CONN_CREATE_OPSET;
            if (!resPerms.contains(PM_ANY_ANY) && !resPerms.contains(sReqPerms)) {
                reqPermsMsg = "You're not authorized to create an operation set assigned to "
                        + getEntityName(sBaseId, sBaseType);
                return false;
            }
        } else {
            reqPermsMsg = "Invalid type (" + sBaseType + ") of the base node "
                    + getEntityName(sBaseId, sBaseType);
            return false;
        }
        return true;
    }

    boolean requestRepresentEntityPerms(String sSessId, String sProcId,
                                        String sClass, String sName, String sId) {
        HashSet<String> resPerms;
        String sReqPerms;

        if (!entityExists(sSessId, PM_SESSION)) {
            reqPermsMsg = "You're not in a Policy Machine session!";
            return false;
        }

        if (!sClass.equals(PM_CLASS_USER_NAME)
                && !sClass.equals(PM_CLASS_UATTR_NAME)
                && !sClass.equals(PM_CLASS_OBJ_NAME)
                && !sClass.equals(PM_CLASS_OATTR_NAME)
                && !sClass.equals(PM_CLASS_POL_NAME)
                && !sClass.equals(PM_CLASS_CONN_NAME)
                && !sClass.equals(PM_CLASS_OPSET_NAME)) {
            return true;
        }

        sReqPerms = PM_ENTITY_REPRESENT;
        String sType = classToType(sClass);
        resPerms = getPermittedOpsOnEntityInternal(sSessId, sProcId, sId, sType);
        printSet(resPerms, PM_PERM,
                "Permissions on " + getEntityName(sId, sType));
        if (!resPerms.contains(PM_ANY_ANY) && !resPerms.contains(sReqPerms)) {
            reqPermsMsg = "You're not authorized to represent entity "
                    + getEntityName(sId, sType) + " of type " + sType;
            return false;
        }
        return true;
    }

    boolean requestAddObjectPerms(String sSessId, String sProcId,
                                  String sBaseId, String sBaseType) {
        HashSet<String> resPerms;
        String sReqPerms;

        if (!entityExists(sSessId, PM_SESSION)) {
            reqPermsMsg = "You're not in a Policy Machine session!";
            return false;
        }

        resPerms = getPermittedOpsOnEntityInternal(sSessId, sProcId, sBaseId,
                sBaseType);
        printSet(resPerms, PM_PERM,
                "Obtained Permissions on " + getEntityName(sBaseId, sBaseType));

        if (sBaseType.equalsIgnoreCase(PM_NODE_OATTR)) {
            sReqPerms = PM_OATTR_CREATE_OBJ;

            if (!resPerms.contains(PM_ANY_ANY) && !resPerms.contains(sReqPerms)) {
                reqPermsMsg = "You're not authorized to create an object in "
                        + getEntityName(sBaseId, sBaseType);
                return false;
            }
        } else if (sBaseType.equalsIgnoreCase(PM_NODE_POL)) {
            sReqPerms = PM_POL_CREATE_OBJ;

            if (!resPerms.contains(PM_ANY_ANY) && !resPerms.contains(sReqPerms)) {
                reqPermsMsg = "You're not authorized to create an object in "
                        + getEntityName(sBaseId, sBaseType);
                return false;
            }
        } else if (sBaseType.equalsIgnoreCase(PM_NODE_CONN)) {
            sReqPerms = PM_CONN_CREATE_OBJ;

            if (!resPerms.contains(PM_ANY_ANY) && !resPerms.contains(sReqPerms)) {
                reqPermsMsg = "You're not authorized to create an object in "
                        + getEntityName(sBaseId, sBaseType);
                return false;
            }
        }
        return true;
    }

    boolean requestAddUserPerms(String sSessId, String sProcId, String sBaseId,
                                String sBaseType) {
        HashSet<String> resPerms;
        String sReqPerms;

        if (!entityExists(sSessId, PM_SESSION)) {
            reqPermsMsg = "You're not in a Policy Machine session!";
            return false;
        }

        resPerms = getPermittedOpsOnEntityInternal(sSessId, sProcId, sBaseId,
                sBaseType);
        printSet(resPerms, PM_PERM,
                "Permissions on " + getEntityName(sBaseId, sBaseType));

        if (sBaseType.equalsIgnoreCase(PM_NODE_UATTR)) {
            sReqPerms = PM_UATTR_CREATE_USER;

            if (!resPerms.contains(PM_ANY_ANY) && !resPerms.contains(sReqPerms)) {
                reqPermsMsg = "You're not authorized to create a user in this user attribute!";
                return false;
            }
        } else if (sBaseType.equalsIgnoreCase(PM_NODE_CONN)) {
            sReqPerms = PM_CONN_CREATE_USER;

            if (!resPerms.contains(PM_ANY_ANY) && !resPerms.contains(sReqPerms)) {
                reqPermsMsg = "You're not authorized to create a user in the connector!";
                return false;
            }
        }
        return true;
    }

    boolean requestAddUattrPerms(String sSessId, String sProcId,
                                 String sBaseId, String sBaseType) {
        HashSet<String> resPerms;
        String sReqPerms;

        // if (sClientId.equals("super") || sClientId.equals("serban")) return
        // true;

        if (!entityExists(sSessId, PM_SESSION)) {
            reqPermsMsg = "You're not in a Policy Machine session!";
            return false;
        }

        resPerms = getPermittedOpsOnEntityInternal(sSessId, sProcId, sBaseId,
                sBaseType);
        printSet(resPerms, PM_PERM,
                "Permissions on entity " + getEntityName(sBaseId, sBaseType));

        if (sBaseType.equalsIgnoreCase(PM_NODE_USER)) {
            sReqPerms = PM_USER_CREATE_UATTR;

            if (!resPerms.contains(PM_ANY_ANY) && !resPerms.contains(sReqPerms)) {
                reqPermsMsg = "You're not authorized to create a user attribute for this user!";
                return false;
            }
            sReqPerms = PM_CONN_CREATE_UATTR;
            resPerms = getPermittedOpsOnEntityInternal(sSessId, sProcId,
                    PM_CONNECTOR_ID, PM_NODE_CONN);
            printSet(resPerms, PM_PERM, "Permissions on connector");

            if (!resPerms.contains(PM_ANY_ANY) && !resPerms.contains(sReqPerms)) {
                reqPermsMsg = "You're not authorized to create a user attribute assigned to connector!";
                return false;
            }
        } else if (sBaseType.equalsIgnoreCase(PM_NODE_UATTR)) {
            sReqPerms = PM_UATTR_CREATE_UATTR;

            if (!resPerms.contains(PM_ANY_ANY) && !resPerms.contains(sReqPerms)) {
                reqPermsMsg = "You're not authorized to create a user attribute contained in this user attribute!";
                return false;
            }
        } else if (sBaseType.equalsIgnoreCase(PM_NODE_POL)) {
            sReqPerms = PM_POL_CREATE_UATTR;

            if (!resPerms.contains(PM_ANY_ANY) && !resPerms.contains(sReqPerms)) {
                reqPermsMsg = "You're not authorized to create a user attribute in this policy class!";
                return false;
            }
        } else if (sBaseType.equalsIgnoreCase(PM_NODE_CONN)) {
            sReqPerms = PM_CONN_CREATE_UATTR;

            if (!resPerms.contains(PM_ANY_ANY) && !resPerms.contains(sReqPerms)) {
                reqPermsMsg = "You're not authorized to create a user attribute on the connector!";
                return false;
            }
        }
        return true;
    }

    boolean requestAddOattrPerms(String sSessId, String sProcId,
                                 String sBaseId, String sBaseType) {
        HashSet<String> resPerms;
        String sReqPerms;

        // if (sClientId.equals("super") || sClientId.equals("serban")) return
        // true;

        if (!entityExists(sSessId, PM_SESSION)) {
            reqPermsMsg = "You're not in a Policy Machine session!";
            System.out.println(reqPermsMsg);
            return false;
        }

        resPerms = getPermittedOpsOnEntityInternal(sSessId, sProcId, sBaseId,
                sBaseType);
        printSet(resPerms, PM_PERM,
                "Permissions on entity " + getEntityName(sBaseId, sBaseType));

        if (sBaseType.equalsIgnoreCase(PM_NODE_OATTR)) {
            sReqPerms = PM_OATTR_CREATE_OATTR;

            if (!resPerms.contains(PM_ANY_ANY) && !resPerms.contains(sReqPerms)) {
                reqPermsMsg = "You're not authorized to create an object attribute in this object attribute!";
                System.out.println(reqPermsMsg);
                return false;
            }
        } else if (sBaseType.equalsIgnoreCase(PM_NODE_POL)) {
            sReqPerms = PM_POL_CREATE_OATTR;

            if (!resPerms.contains(PM_ANY_ANY) && !resPerms.contains(sReqPerms)) {
                reqPermsMsg = "You're not authorized to create an object attribute in this policy class!";
                System.out.println(reqPermsMsg);
                return false;
            }
        } else if (sBaseType.equalsIgnoreCase(PM_NODE_CONN)) {
            sReqPerms = PM_CONN_CREATE_OATTR;

            if (!resPerms.contains(PM_ANY_ANY) && !resPerms.contains(sReqPerms)) {
                reqPermsMsg = "You're not authorized to create an object attribute on the connector!";
                System.out.println(reqPermsMsg);
                return false;
            }
        }
        return true;
    }

    // If the clicked - also called base - node is:
    // - the connector node, the new attribute will be added as an ascendant
    // of the connector;
    // - a user, the new attribute will be added as a descendant of it and
    // ascendant of the connector node;
    // - a user attribute, the new attribute will be added as an ascendant of
    // it;
    // - a policy, the new attribute will be added as an ascendant of it.
    // Permissions.
    // sSessId needs the following permissions:
    // If the base node is a user:
    // "User create user attribute" on the base node
    // "Connector create user attribute" on the connector.
    // If the base node is a user attribute:
    // "User attribute create user attribute" on the base node.
    // If the base node is a policy class:
    // "Policy class create user attribute" on the base node.
    // If the base node is the connector:
    // "Connector create user attribute" on the base node.
    private Packet addUattr(String sClientId, String sSessId, String sProcId,
                            String sName, String sDescr, String sInfo, String sBaseId,
                            String sBaseType, String sBaseIsVos, String[] sProps) {

        if (sBaseIsVos.equalsIgnoreCase("yes")) {
            sBaseId = getAdminVosNodeOrigId(sBaseId);
        }

        // Test permissions.
        if (!requestAddUattrPerms(sSessId, sProcId, sBaseId, sBaseType)) {
            return failurePacket(reqPermsMsg);
        }

        Packet res =  addUattrInternal(sName, sDescr, sInfo, sBaseId,
                sBaseType, sProps);
        if (!res.hasError()) {
            setLastUpdateTimestamp();
        }
        return res;
    }

    private Packet addUattrInternal(String sName, String sDescr, String sInfo,
                                    String sBaseId, String sBaseType, String[] sProps) {
        // Test if duplicate name.
        if (attrNameExists(sName, PM_NODE_UATTR)) {
            return failurePacket("Attribute with duplicate name");
        }

        String sDn;

        // Prepare the attributes of the new attribute object.
        Attributes attrs = new BasicAttributes(true);
        RandomGUID myGUID = new RandomGUID();
        String sId = myGUID.toStringNoDashes();
        attrs.put("objectClass", sUserAttrClass);
        attrs.put("pmId", sId);
        attrs.put("pmName", sName);
        attrs.put("pmDescription", sDescr);
        attrs.put("pmOtherInfo", sInfo);

        // Set the back link towards the base node in the new attribute.
        // At the same time, prepare the base node's DN
        // and the attribute to be added to the base node.
        String sBaseDn;
        ModificationItem[] mods = new ModificationItem[1];
        if (sBaseType.equalsIgnoreCase(PM_NODE_USER)) {
            attrs.put("pmFromUser", sBaseId);
            attrs.put("pmToConnector", PM_CONNECTOR_ID);
            sBaseDn = "CN=" + sBaseId + "," + sUserContainerDN;
            mods[0] = new ModificationItem(DirContext.ADD_ATTRIBUTE,
                    new BasicAttribute("pmToAttr", sId));
        } else if (sBaseType.equalsIgnoreCase(PM_NODE_UATTR)) {
            attrs.put("pmToAttr", sBaseId);
            sBaseDn = "CN=" + sBaseId + "," + sUserAttrContainerDN;
            mods[0] = new ModificationItem(DirContext.ADD_ATTRIBUTE,
                    new BasicAttribute("pmFromAttr", sId));
        } else if (sBaseType.equalsIgnoreCase(PM_NODE_POL)) {
            attrs.put("pmToPolicy", sBaseId);
            sBaseDn = "CN=" + sBaseId + "," + sPolicyContainerDN;
            mods[0] = new ModificationItem(DirContext.ADD_ATTRIBUTE,
                    new BasicAttribute("pmFromUserAttr", sId));
        } else if (sBaseType.equalsIgnoreCase(PM_NODE_CONN)) {
            attrs.put("pmToConnector", sBaseId);
            sBaseDn = "CN=" + sBaseId + "," + sConnectorContainerDN;
            mods[0] = new ModificationItem(DirContext.ADD_ATTRIBUTE,
                    new BasicAttribute("pmFromUserAttr", sId));
        } else {
            return failurePacket("Base node type incompatible with user attribute");
        }

        // Set the clicked (base) node's link to the new user attribute.
        try {
            ctx.modifyAttributes(sBaseDn, mods);
        } catch (Exception e) {
            if (debugFlag) {
                e.printStackTrace();
            }
            return failurePacket("Unable to set link to new user attribute in the base node");
        }

        // If the base node is a user, the new user attribute must also be an
        // ascendant
        // of the connector node.
        if (sBaseType.equalsIgnoreCase(PM_NODE_USER)) {
            sDn = "CN=" + PM_CONNECTOR_ID + "," + sConnectorContainerDN;
            mods[0] = new ModificationItem(DirContext.ADD_ATTRIBUTE,
                    new BasicAttribute("pmFromUserAttr", sId));
            try {
                ctx.modifyAttributes(sDn, mods);
            } catch (Exception e) {
                if (debugFlag) {
                    e.printStackTrace();
                }
                return failurePacket("Unable to set link to new user attribute in the connector node");
            }
        }

        // Prepare the path and create.
        sDn = "CN=" + sId + "," + sUserAttrContainerDN;
        try {
            ctx.bind(sDn, null, attrs);
        } catch (InvalidNameException e) {
            if (debugFlag) {
                e.printStackTrace();
            }
            return failurePacket("Invalid object name (id)" + sId);
        } catch (NameAlreadyBoundException e) {
            if (debugFlag) {
                e.printStackTrace();
            }
            return failurePacket("Duplicate id " + sId);
        } catch (Exception e) {
            if (debugFlag) {
                e.printStackTrace();
            }
            return failurePacket("Probably invalid id " + sId);
        }

        // Add the attribute's properties, if any.
        if (sProps != null) {
            int n = sProps.length;
            if (n <= 0) {
                return successPacket();
            }
            mods = new ModificationItem[n];
            for (int i = 0; i < n; i++) {
                System.out.println("Prop " + sProps[i]);
                mods[i] = new ModificationItem(DirContext.ADD_ATTRIBUTE,
                        new BasicAttribute("pmProperty", sProps[i]));
            }
            try {
                ctx.modifyAttributes("CN=" + sId + "," + sUserAttrContainerDN,
                        mods);
            } catch (Exception e) {
                if (debugFlag) {
                    e.printStackTrace();
                }
                return failurePacket("Unable to set the new user attribute's properties!");
            }
        }

        // Return the attribute name and id.
        Packet res = new Packet();
        try {
            res.addItem(ItemType.RESPONSE_TEXT, sName + PM_FIELD_DELIM + sId);
        } catch (Exception e) {
            e.printStackTrace();
            return failurePacket("Exception when building the resulting packet!");
        }
        return res;
    }

    /*private boolean objClassNameExists(String sName) {
    NamingEnumeration<?> classes;

    try {
    SearchControls constraints = new SearchControls();
    constraints.setSearchScope(SearchControls.ONELEVEL_SCOPE);
    constraints.setReturningAttributes(null);
    classes = ctx.search(sObjClassContainerDN,
    "(pmName=" + sName + ")", constraints);
    if (classes == null || !classes.hasMore()) {
    return false;
    }
    } catch (Exception e) {
    e.printStackTrace();
    return false;
    }
    return true;
    }*/
    private boolean attrNameExists(String sName, String sType) {
        NamingEnumeration<?> objects;
        String sContainer;

        if (sType.equalsIgnoreCase(PM_NODE_UATTR)) {
            sContainer = sUserAttrContainerDN;
        } else if (sType.equalsIgnoreCase(PM_NODE_OATTR)
                || sType.equalsIgnoreCase(PM_NODE_ASSOC)) {
            sContainer = sObjAttrContainerDN;
        } else {
            return false;
        }

        try {
            SearchControls constraints = new SearchControls();
            constraints.setSearchScope(SearchControls.ONELEVEL_SCOPE);
            constraints.setReturningAttributes(null);
            objects = ctx.search(sContainer, "(pmName=" + sName + ")",
                    constraints);
            if (objects == null || !objects.hasMore()) {
                return false;
            }
        } catch (Exception e) {
            e.printStackTrace();
            return false;
        }
        return true;
    }

    // Get the ascendants count for a user attribute/object
    // attribute/policy/connector/
    // opset. Count the opsets assigned to the connector only if the connector
    // is
    // selected. Coount the opsets assigned to an object attribute only if the
    // object attribute is selected.
    private int getAscsCount(QueueElement qe, String sGraphType,
                             boolean bCountOpsets) {
        try {

            if (debugFlag) {
                System.out.println("Queue node is "
                        + getEntityName(qe.getId(), qe.getType()) + " of type "
                        + qe.getType());
                System.out.println("Graph type is " + sGraphType
                        + " and we count opsets: " + bCountOpsets);
            }

            Attributes attrs;
            Attribute attr = null;
            int count = 0;
            String sType = qe.getType();
            if (sType.equalsIgnoreCase(PM_NODE_UATTR)) {
                attrs = ctx.getAttributes("CN=" + qe.getId() + ","
                        + sUserAttrContainerDN);
                attr = attrs.get("pmFromUser");
                if (attr != null) {
                    count += attr.size();
                }
                attr = attrs.get("pmFromAttr");
                if (attr != null) {
                    count += attr.size();
                }
                return count;
            } else if (sType.equalsIgnoreCase(PM_NODE_OATTR)) {
                attrs = ctx.getAttributes("CN=" + qe.getId() + ","
                        + sObjAttrContainerDN);
                attr = attrs.get("pmFromAttr");
                if (attr != null) {
                    count += attr.size();
                }

                if (sGraphType.equalsIgnoreCase(PM_GRAPH_ACES)
                        || sGraphType.equalsIgnoreCase(PM_GRAPH_CAPS)) {
                    if (bCountOpsets) {
                        attr = attrs.get("pmFromOpSet");
                        if (attr != null) {
                            count += attr.size();
                        }
                    }
                }
                return count;
            } else if (sType.equalsIgnoreCase(PM_NODE_POL)) {
                attrs = ctx.getAttributes("CN=" + qe.getId() + ","
                        + sPolicyContainerDN);
                if (sGraphType.equalsIgnoreCase(PM_GRAPH_UATTR)
                        || sGraphType.equalsIgnoreCase(PM_GRAPH_CAPS)) {
                    attr = attrs.get("pmFromUserAttr");
                } else if (sGraphType.equalsIgnoreCase(PM_GRAPH_OATTR)
                        || sGraphType.equalsIgnoreCase(PM_GRAPH_ACES)) {
                    attr = attrs.get("pmFromObjAttr");
                } else {
                    attr = null;
                }
                if (attr != null) {
                    count += attr.size();
                }
                return count;
            } else if (sType.equalsIgnoreCase(PM_NODE_CONN)) {
                attrs = ctx.getAttributes("CN=" + qe.getId() + ","
                        + sConnectorContainerDN);
                if (sGraphType.equalsIgnoreCase(PM_GRAPH_UATTR)) {
                    attr = attrs.get("pmFromUserAttr");
                    if (attr != null) {
                        count += attr.size();
                    }
                    attr = attrs.get("pmFromUser");
                    if (attr != null) {
                        count += attr.size();
                    }
                    attr = attrs.get("pmFromPolicyClass");
                    if (attr != null) {
                        count += attr.size();
                    }
                } else if (sGraphType.equalsIgnoreCase(PM_GRAPH_CAPS)) {
                    attr = attrs.get("pmFromUserAttr");
                    if (attr != null) {
                        count += attr.size();
                    }
                    attr = attrs.get("pmFromUser");
                    if (attr != null) {
                        count += attr.size();
                    }
                    attr = attrs.get("pmFromPolicyClass");
                    if (attr != null) {
                        count += attr.size();
                    }
                    if (bCountOpsets) {
                        attr = attrs.get("pmFromOpSet");
                        if (attr != null) {
                            count += attr.size();
                        }
                    }
                } else if (sGraphType.equalsIgnoreCase(PM_GRAPH_OATTR)) {
                    attr = attrs.get("pmFromObjAttr");
                    if (attr != null) {
                        count += attr.size();
                    }
                    attr = attrs.get("pmFromPolicyClass");
                    if (attr != null) {
                        count += attr.size();
                    }
                } else if (sGraphType.equalsIgnoreCase(PM_GRAPH_ACES)) {
                    attr = attrs.get("pmFromObjAttr");
                    if (attr != null) {
                        count += attr.size();
                    }
                    attr = attrs.get("pmFromPolicyClass");
                    if (attr != null) {
                        count += attr.size();
                    }
                    if (bCountOpsets) {
                        attr = attrs.get("pmFromOpSet");
                        if (attr != null) {
                            count += attr.size();
                        }
                    }
                } else {// Graph type is PM_GRAPH_PERMS
                    // We'll think about it.
                }
                return count;
            } else if (sType.equalsIgnoreCase(PM_NODE_OPSET)) {
                attrs = ctx.getAttributes("CN=" + qe.getId() + ","
                        + sOpsetContainerDN);
                attr = attrs.get("pmFromAttr");
                if (attr != null) {
                    count += attr.size();
                }
                return count;
            } else {
                return 0;
            }
        } catch (Exception e) {
            e.printStackTrace();
            return 0;
        }
    }

    // For a given user attribute or the connector node, get the users (ids)
    // assigned to it.
    private Attribute getFromUsers(QueueElement qe) throws Exception {
        Attributes attrs;
        //Attribute attr;
        String sType = qe.getType();
        if (sType.equalsIgnoreCase(PM_NODE_UATTR)) {
            attrs = ctx.getAttributes("CN=" + qe.getId() + ","
                    + sUserAttrContainerDN);
        } else if (sType.equalsIgnoreCase(PM_NODE_CONN)) {
            attrs = ctx.getAttributes("CN=" + qe.getId() + ","
                    + sConnectorContainerDN);
        } else {
            return null;
        }
        return attrs.get("pmFromUser");
    }

    // For a given user attribute or the connector node, get the users (ids)
    // assigned to it.
    private Attribute getFromUsers(String sBaseId, String sBaseType) {
        Attributes attrs;
        //Attribute attr;
        try {
            if (sBaseType.equalsIgnoreCase(PM_NODE_UATTR)) {
                attrs = ctx.getAttributes("CN=" + sBaseId + ","
                        + sUserAttrContainerDN);
            } else if (sBaseType.equalsIgnoreCase(PM_NODE_CONN)) {
                attrs = ctx.getAttributes("CN=" + sBaseId + ","
                        + sConnectorContainerDN);
            } else {
                return null;
            }
            return attrs.get("pmFromUser");
        } catch (Exception e) {
            e.printStackTrace();
            return null;
        }
    }

    // For a given user attribute or object attribute get the direct ascendant
    // attributes.
    // For a given operation set, get the user attributes assigned to it.
    private Attribute getFromAttrs(QueueElement qe) throws Exception {
        String sContainer = null;
        if (qe.getType().equalsIgnoreCase(PM_NODE_UATTR)) {
            sContainer = sUserAttrContainerDN;
        } else if (qe.getType().equalsIgnoreCase(PM_NODE_OATTR)
                || qe.getType().equalsIgnoreCase(PM_NODE_ASSOC)) {
            sContainer = sObjAttrContainerDN;
        } else if (qe.getType().equalsIgnoreCase(PM_NODE_OPSET)) {
            sContainer = sOpsetContainerDN;
        } else {
            return null;
        }
        Attributes attrs = ctx.getAttributes("CN=" + qe.getId() + ","
                + sContainer);
        Attribute attr = attrs.get("pmFromAttr");
        return attr;
    }

    // For a given user attribute or object attribute get the direct ascendant
    // attributes.
    // For a given operation set, get the user attributes assigned to it.
    private Attribute getFromAttrs(String sId, String sType) throws Exception {
        String sContainer = null;
        if (sType.equalsIgnoreCase(PM_NODE_UATTR)) {
            sContainer = sUserAttrContainerDN;
        } else if (sType.equalsIgnoreCase(PM_NODE_OATTR)
                || sType.equalsIgnoreCase(PM_NODE_ASSOC)) {
            sContainer = sObjAttrContainerDN;
        } else if (sType.equalsIgnoreCase(PM_NODE_OPSET)) {
            sContainer = sOpsetContainerDN;
        } else {
            return null;
        }
        Attributes attrs = ctx.getAttributes("CN=" + sId + "," + sContainer);
        Attribute attr = attrs.get("pmFromAttr");
        return attr;
    }

    // For a given user, user attribute, or object attribute, get its direct
    // descendant attributes.
    // For a given operation set, get the object attributes this opset is
    // assigned to.
    private Attribute getToAttrs(QueueElement qe) throws Exception {
        String sContainer = null;
        if (qe.getType().equalsIgnoreCase(PM_NODE_USER)) {
            sContainer = sUserContainerDN;
        } else if (qe.getType().equalsIgnoreCase(PM_NODE_UATTR)) {
            sContainer = sUserAttrContainerDN;
        } else if (qe.getType().equalsIgnoreCase(PM_NODE_OATTR)) {
            sContainer = sObjAttrContainerDN;
        } else if (qe.getType().equalsIgnoreCase(PM_NODE_ASSOC)) {
            sContainer = sObjAttrContainerDN;
        } else if (qe.getType().equalsIgnoreCase(PM_NODE_OPSET)) {
            sContainer = sOpsetContainerDN;
        } else {
            return null;
        }
        Attributes attrs = ctx.getAttributes("CN=" + qe.getId() + ","
                + sContainer);
        Attribute attr = attrs.get("pmToAttr");
        return attr;
    }

    private Vector<String> getUserDescendantsInternalVector(String sUserId) {
        Attributes attrs;
        Attribute attr;

        Vector<String> vector = new Vector<String>();

        try {
            attrs = ctx.getAttributes("CN=" + sUserId + "," + sUserContainerDN);
            attr = attrs.get("pmToAttr");
            if (attr == null) {
                return vector;
            }
            for (NamingEnumeration<?> enumer = attr.getAll(); enumer.hasMore(); ) {
                getDescAttrsVector((String) enumer.next(), vector);
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
        return vector;
    }

    // sAttrId is the id of a user attribute.
    private void getDescAttrsVector(String sAttrId, Vector<String> vector) {
        Attributes attrs;
        Attribute attr;

        // If the argument attribute is in the set, all its descendants already
        // are there.
        if (vector.contains(sAttrId)) {
            return;
        }
        // Add sAttrId to the vector, together with all its descendants.
        vector.add(sAttrId);
        try {
            attrs = ctx.getAttributes("CN=" + sAttrId + ","
                    + sUserAttrContainerDN);
            attr = attrs.get("pmToAttr");
            if (attr == null) {
                return;
            }
            for (NamingEnumeration<?> enumer = attr.getAll(); enumer.hasMore(); ) {
                getDescAttrsVector((String) enumer.next(), vector);
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    private HashSet<String> getUserDescendantsInternal(String sUserId) {
        Attributes attrs;
        Attribute attr;

        HashSet<String> set = new HashSet<String>();

        try {
            attrs = ctx.getAttributes("CN=" + sUserId + "," + sUserContainerDN);
            attr = attrs.get("pmToAttr");
            if (attr == null) {
                return set;
            }
            for (NamingEnumeration<?> enumer = attr.getAll(); enumer.hasMore(); ) {
                getDescAttrs((String) enumer.next(), set);
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
        return set;
    }

    // sAttrId is the id of a user attribute.
    private void getDescAttrs(String sAttrId, HashSet<String> set) {
        Attributes attrs;
        Attribute attr;

        // If the argument attribute is in the set, all its descendants already
        // are there.
        if (set.contains(sAttrId)) {
            return;
        }
        // Add sAttrId to the set, together with all its descendants.
        set.add(sAttrId);
        try {
            attrs = ctx.getAttributes("CN=" + sAttrId + ","
                    + sUserAttrContainerDN);
            attr = attrs.get("pmToAttr");
            if (attr == null) {
                return;
            }
            for (NamingEnumeration<?> enumer = attr.getAll(); enumer.hasMore(); ) {
                getDescAttrs((String) enumer.next(), set);
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    private void getAscAttrs(String sAttrId, String sType, HashSet<String> set) {
        Attributes attrs;
        Attribute attr;
        String sCont;

        if (sType.equalsIgnoreCase(PM_NODE_UATTR)) {
            sCont = sUserAttrContainerDN;
        } else if (sType.equalsIgnoreCase(PM_NODE_OATTR)) {
            sCont = sObjAttrContainerDN;
        } else if (sType.equalsIgnoreCase(PM_NODE_ASSOC)) {
            sCont = sObjAttrContainerDN;
        } else {
            return;
        }

        // If the argument attribute is in the set, all its ascendants already
        // are there.
        if (set.contains(sAttrId)) {
            return;
        }
        // Add sAttrId to the set, together with all its ascendants.
        set.add(sAttrId);
        try {
            attrs = ctx.getAttributes("CN=" + sAttrId + "," + sCont);
            attr = attrs.get("pmFromAttr");
            if (attr == null) {
                return;
            }
            for (NamingEnumeration<?> enumer = attr.getAll(); enumer.hasMore(); ) {
                getAscAttrs((String) enumer.next(), sType, set);
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    // For a given user, user attribute, object attribute, or opset,
    // get its direct descendant attributes.
    private Attribute getToAttrs(String sId, String sType) throws Exception {
        String sContainer = null;
        if (sType.equalsIgnoreCase(PM_NODE_USER)) {
            sContainer = sUserContainerDN;
        } else if (sType.equalsIgnoreCase(PM_NODE_UATTR)) {
            sContainer = sUserAttrContainerDN;
        } else if (sType.equalsIgnoreCase(PM_NODE_OATTR)) {
            sContainer = sObjAttrContainerDN;
        } else if (sType.equalsIgnoreCase(PM_NODE_ASSOC)) {
            sContainer = sObjAttrContainerDN;
        } else if (sType.equalsIgnoreCase(PM_NODE_OPSET)) {
            sContainer = sOpsetContainerDN;
        } else {
            return null;
        }
        Attributes attrs = ctx.getAttributes("CN=" + sId + "," + sContainer);
        Attribute attr = attrs.get("pmToAttr");
        return attr;
    }

    // Returns the list of direct containers of a user, user attribute, or
    // object attribute.
    private String getContainerList(String sId, String sType) {
        String sContainer = null;
        if (sType.equalsIgnoreCase(PM_NODE_USER)) {
            sContainer = sUserContainerDN;
        } else if (sType.equalsIgnoreCase(PM_NODE_UATTR)) {
            sContainer = sUserAttrContainerDN;
        } else if (sType.equalsIgnoreCase(PM_NODE_OATTR)) {
            sContainer = sObjAttrContainerDN;
        } else if (sType.equalsIgnoreCase(PM_NODE_ASSOC)) {
            sContainer = sObjAttrContainerDN;
        } else {
            return null;
        }
        try {
            Attributes attrs = ctx.getAttributes("CN=" + sId + "," + sContainer);
            Attribute attr = attrs.get("pmToAttr");
            if (attr == null) {
                return null;
            }
            StringBuffer sb = new StringBuffer();
            boolean first = true;
            for (NamingEnumeration<?> enumer = attr.getAll(); enumer.hasMore(); ) {
                if (first) {
                    sb.append((String) enumer.next());
                    first = false;
                } else {
                    sb.append("," + (String) enumer.next());
                }
            }
            return sb.toString();
        } catch (Exception e) {
            if (debugFlag) {
                e.printStackTrace();
            }
            return null;
        }
    }

    /*private Packet testGetMemberUsers(String sSessId, String sUattrId) {
    HashSet<String> users = new HashSet<String>();
    getMemberUsers(sUattrId, users);
    Iterator<String> iter = users.iterator();
    while (iter.hasNext()) {
    String sUserId = iter.next();
    System.out.println("User = " + sUserId + ","
    + getNameOfEntityWithIdAndType(sUserId, PM_NODE_USER));
    }
    return successPacket();
    }*/
    // Test getUsersWithCap(). sOattrName is the name of an object container.
    // Replace getUsersWithCap() by getUsersWithObjCap() if sContainerName is
    // an object attribute associated to an object and you want to get only
    // users having caps on that object.
    private Packet testGUWC(String sSessId, String sOp, String sContainerName,
                            String sPcName) {
        String sContainerId = getEntityId(sContainerName, PM_NODE_OATTR);
        String sPcId = getEntityId(sPcName, PM_NODE_POL);
        HashSet<String> users = getUsersWithCap(sOp, sContainerId, sPcId);
        Iterator<String> iter = users.iterator();
        Packet result = new Packet();
        try {
            while (iter.hasNext()) {
                String sUserId = iter.next();
                result.addItem(ItemType.RESPONSE_TEXT,
                        getEntityName(sUserId, PM_NODE_USER) + PM_FIELD_DELIM
                                + sUserId);
            }
        } catch (Exception e) {
            e.printStackTrace();
            return failurePacket("Exception when building the result packet");
        }
        return result;
    }

    // Returns the set of users (their ids) that have at least one of the
    // capabilities denoted by the triple (sOp, sContainerId, sPcId).
    // Parameters:
    // sOp: the name of an operation;
    // sContainerId: the id of an object container, i.e., object attribute.
    // sPcId: the id of a policy class.
    // The capabilities denoted by (sOp, sContainerId, sPcId) are all
    // capabilities (op, obj), where op is the operation sOp, and obj is any
    // object within the container sContainerId, computed within the policy
    // sPcId.
    private HashSet<String> getUsersWithCap(String sOp, String sContainerId,
                                            String sPcId) {
        HashSet<String> users = new HashSet<String>();
        String sAssocId = null;
        HashSet<String> descs;

        try {
            // First get all object attributes associated to objects included in
            // the container.
            HashSet<String> assocOattrs = new HashSet<String>();
            getMemberObjects(sContainerId, assocOattrs);

            // Now for each such object attribute
            Iterator<String> assocIter = assocOattrs.iterator();
            while (assocIter.hasNext()) {
                sAssocId = assocIter.next();

                // Get the set of all descendant attributes of the associated oa
                // (including
                // itself). Use a non-recursive version for speed.
                descs = getDescOattrsInPc(sAssocId, sPcId);

                // For each descendant oattr
                Iterator<String> descIter = descs.iterator();
                while (descIter.hasNext()) {
                    String sDescId = descIter.next();
                    // System.out.println("For descendant = " + sDescId + "," +
                    // getNameOfEntityWithIdAndType(sDescId, PM_NODE_OATTR));

                    // For each opset ops such that ops -> desc
                    Attributes oaAttrs = ctx.getAttributes("CN=" + sDescId
                            + "," + sObjAttrContainerDN);
                    Attribute oaAttr = oaAttrs.get("pmFromOpset");
                    if (oaAttr != null) {
                        for (NamingEnumeration<?> oaEnum = oaAttr.getAll(); oaEnum.hasMore(); ) {
                            String sOpsetId = (String) oaEnum.next();
                            // System.out.println("  Found opset " + sOpsetId +
                            // "," + getNameOfEntityWithIdAndType(sOpsetId, PM_NODE_OPSET));

                            // Check whether the opset contains the operation.
                            if (!opsetContainsOp(sOpsetId, sOp)) {
                                continue;
                            }

                            // For each user attribute ua such that ua -> opset.
                            Attributes opsetAttrs = ctx.getAttributes("CN="
                                    + sOpsetId + "," + sOpsetContainerDN);
                            Attribute opsetAttr = opsetAttrs.get("pmFromAttr");
                            if (opsetAttr != null) {
                                for (NamingEnumeration<?> opsetEnum = opsetAttr.getAll(); opsetEnum.hasMore(); ) {
                                    String sUaId = (String) opsetEnum.next();
                                    // System.out.println("  Found uattr " +
                                    // sUaId + "," + getNameOfEntityWithIdAndType(sUaId,
                                    // PM_NODE_UATTR));

                                    // Check whether ua ->+ pc.
                                    if (!attrIsAscendantToPolicy(sUaId,
                                            PM_NODE_UATTR, sPcId)) {
                                        continue;
                                    }

                                    // Find users u such that u ->+ ua.
                                    getMemberUsers(sUaId, users);
                                }
                            }
                        }
                    }
                }
            }
        } catch (Exception e) {
            if (debugFlag) {
                e.printStackTrace();
            }
        }
        return users;
    }

    // Returns the set of users (their ids) that have (are authorized to)
    // the capability denoted by the triple (sOp, sAssocId, sPcId).
    // The parameters are:
    // sOp: the name of the operation;
    // sAssocId: the id of the user attribute associated to an object;
    // sPcId: the id of a policy class.
    // The capability denoted by the triple (sOp, sAssocId, sPcId) is the
    // capability (op, obj) where op is the operation, and obj is the object
    // associated to sAssocId, within the policy class sPcId.
    private HashSet<String> getUsersWithObjCap(String sOp, String sAssocId,
                                               String sPcId) {
        HashSet<String> users = new HashSet<String>();
        HashSet<String> descs;

        if (sAssocId == null) {
            return users;
        }
        try {
            // Get the set of all descendant attributes of the assoc. oa
            // (including
            // itself). Use a non-recursive version for speed.
            descs = getDescOattrsInPc(sAssocId, sPcId);

            // For each descendant oattr
            Iterator<String> iter = descs.iterator();
            while (iter.hasNext()) {
                String sDescId = iter.next();
                // System.out.println("For descendant = " + sDescId + "," +
                // getNameOfEntityWithIdAndType(sDescId, PM_NODE_OATTR));

                // For each opset ops such that ops -> desc
                Attributes oaAttrs = ctx.getAttributes("CN=" + sDescId + ","
                        + sObjAttrContainerDN);
                Attribute oaAttr = oaAttrs.get("pmFromOpset");
                if (oaAttr != null) {
                    for (NamingEnumeration<?> oaEnum = oaAttr.getAll(); oaEnum.hasMore(); ) {
                        String sOpsetId = (String) oaEnum.next();
                        // System.out.println("  Found opset " + sOpsetId + ","
                        // + getNameOfEntityWithIdAndType(sOpsetId, PM_NODE_OPSET));

                        // Check whether the opset contains the operation.
                        if (!opsetContainsOp(sOpsetId, sOp)) {
                            continue;
                        }

                        // For each user attribute ua such that ua -> opset.
                        Attributes opsetAttrs = ctx.getAttributes("CN="
                                + sOpsetId + "," + sOpsetContainerDN);
                        Attribute opsetAttr = opsetAttrs.get("pmFromAttr");
                        if (opsetAttr != null) {
                            for (NamingEnumeration<?> opsetEnum = opsetAttr.getAll(); opsetEnum.hasMore(); ) {
                                String sUaId = (String) opsetEnum.next();
                                // System.out.println("  Found uattr " + sUaId +
                                // "," + getNameOfEntityWithIdAndType(sUaId, PM_NODE_UATTR));

                                // Check whether ua ->+ pc.
                                if (!attrIsAscendantToPolicy(sUaId,
                                        PM_NODE_UATTR, sPcId)) {
                                    continue;
                                }

                                // Find users u such that u ->+ ua.
                                getMemberUsers(sUaId, users);
                            }
                        }
                    }
                }
            }
            return users;
        } catch (Exception e) {
            if (debugFlag) {
                e.printStackTrace();
            }
            return users;
        }
    }

    private Packet testGetPmViews(String sSessId, String sUserId, String sType) {
        if (!sType.equalsIgnoreCase(PM_NODE_USER)) {
            return failurePacket("Argument is not a user!");
        }

        Packet result =  computeAdminVos(sSessId, sUserId, sSessId);
        return result;
    }

    private Packet testGetMemberObjects(String sSessId, String sContainerId,
                                        String sType) {
        if (!sType.equalsIgnoreCase(PM_NODE_OATTR)
                && !sType.equalsIgnoreCase(PM_NODE_ASSOC)) {
            return failurePacket("Wrong type of container!");
        }

        Packet result = new Packet();
        HashSet<String> assocOattrs = new HashSet<String>();
        getMemberObjects(sContainerId, assocOattrs);

        try {
            Iterator<String> iter = assocOattrs.iterator();
            while (iter.hasNext()) {
                String sId = iter.next();
                result.addItem(ItemType.RESPONSE_TEXT,
                        getEntityName(sId, PM_NODE_OATTR) + PM_FIELD_DELIM
                                + sId);
            }
        } catch (Exception e) {
            e.printStackTrace();
            return failurePacket("Exception when building the result packet");
        }
        return result;
    }

    // Get all object attributes associated with objects of a container.
    private void getMemberObjects(String sContId, HashSet<String> assocOattrs) {
        Vector<String> queue = new Vector<String>();
        HashSet<String> visited = new HashSet<String>();
        try {
            // Insert the container into the queue.
            queue.add(sContId);

            // While the queue contains something...
            while (!queue.isEmpty()) {
                // ... remove an element from queue,
                String sOaId = queue.remove(0);
                // ... and continue if it's already visited.
                if (visited.contains(sOaId)) {
                    continue;
                }

                // Mark this element as visited.
                visited.add(sOaId);

                // If it's associated to an object, add it to the result.
                Attributes attrs = ctx.getAttributes("CN=" + sOaId + ","
                        + sObjAttrContainerDN);
                Attribute oaAttr = attrs.get("pmFromAttr");
                Attribute assocAttr = attrs.get("pmAssocObj");
                if (assocAttr != null) {
                    assocOattrs.add(sOaId);
                } else {
                    if (oaAttr != null) {
                        for (NamingEnumeration<?> enumer = oaAttr.getAll(); enumer.hasMore(); ) {
                            queue.add((String) enumer.next());
                        }
                    }
                }
            }
        } catch (Exception e) {
            if (debugFlag) {
                e.printStackTrace();
            }
        }
    }

    private Packet getUsersOf(String sUattr) {
        String sUattrId = getEntityId(sUattr, PM_NODE_UATTR);
        if (sUattrId == null) {
            return failurePacket("No user attribute " + sUattr);
        }
        HashSet<String> users = new HashSet<String>();
        getMemberUsers(sUattrId, users);
        Iterator<String> iter = users.iterator();
        Packet result = new Packet();
        try {
            while (iter.hasNext()) {
                String sUserId = iter.next();
                String sUserName = getEntityName(sUserId, PM_NODE_USER);
                result.addItem(ItemType.RESPONSE_TEXT, sUserName
                        + PM_FIELD_DELIM + sUserId);
            }
        } catch (Exception e) {
            e.printStackTrace();
            return failurePacket("Exception when building result packet!");
        }
        return result;
    }

    // A non-recursive version for obtaining the users that are members of a
    // user attribute.
    // They are added to the HashSet users. Should be called like this:
    // HashSet users = new HashSet(); getMemberUsers(sUaId, users);
    private void getMemberUsers(String sUattrId, HashSet<String> users) {
        Vector<String> queue = new Vector<String>();
        HashSet<String> visited = new HashSet<String>();
        try {
            Attributes attrs = ctx.getAttributes("CN=" + sUattrId + ","
                    + sUserAttrContainerDN);
            // Get all users assigned to this user attribute and insert them
            // into the "users" set.
            Attribute userAttr = attrs.get("pmFromUser");
            if (userAttr != null) {
                for (NamingEnumeration<?> enumer = userAttr.getAll(); enumer.hasMore(); ) {
                    users.add((String) enumer.next());
                }
            }
            // Get all user attributes assigned to this user attribute and
            // insert them
            // into the queue.
            Attribute uaAttr = attrs.get("pmFromAttr");
            if (uaAttr != null) {
                for (NamingEnumeration<?> enumer = uaAttr.getAll(); enumer.hasMore(); ) {
                    queue.add((String) enumer.next());
                }
            }
            // Mark this user attribute as visited.
            visited.add(sUattrId);

            // While the queue contains something, remove and visit one element
            // from it.
            while (!queue.isEmpty()) {
                String sUaId = queue.remove(0);
                if (!visited.contains(sUaId)) {
                    attrs = ctx.getAttributes("CN=" + sUaId + ","
                            + sUserAttrContainerDN);
                    userAttr = attrs.get("pmFromUser");
                    if (userAttr != null) {
                        for (NamingEnumeration<?> enumer = userAttr.getAll(); enumer.hasMore(); ) {
                            users.add((String) enumer.next());
                        }
                    }
                    uaAttr = attrs.get("pmFromAttr");
                    if (uaAttr != null) {
                        for (NamingEnumeration<?> enumer = uaAttr.getAll(); enumer.hasMore(); ) {
                            queue.add((String) enumer.next());
                        }
                    }
                    visited.add(sUaId);
                }
            }
        } catch (Exception e) {
            if (debugFlag) {
                e.printStackTrace();
            }
        }
    }

    // Get the descendants of an object attribute in a given policy class.
    private HashSet<String> getDescOattrsInPc(String sOattrId, String sPcId) {
        Vector<String> queue = new Vector<String>();
        HashSet<String> visited = new HashSet<String>();
        try {
            Attributes attrs = ctx.getAttributes("CN=" + sOattrId + ","
                    + sObjAttrContainerDN);
            Attribute attr = attrs.get("pmToAttr");
            if (attr == null) {
                return visited;
            }

            // The assoc attribute has children attributes. Check whether the
            // assoc. is in pc.
            if (!attrIsAscendantToPolicy(sOattrId, PM_NODE_OATTR, sPcId)) {
                return visited;
            }

            // Insert its children into the queue.
            for (NamingEnumeration<?> enumer = attr.getAll(); enumer.hasMore(); ) {
                queue.add((String) enumer.next());
            }

            // Mark the assoc attribute as visited.
            visited.add(sOattrId);

            // Loop on the queue elements.
            while (!queue.isEmpty()) {
                // Extract the first from queue.
                String sOaId = queue.remove(0);

                // If this element was already visited, skip it.
                if (visited.contains(sOaId)) {
                    continue;
                }

                // If this element is not in pc, skip it.
                if (!attrIsAscendantToPolicy(sOaId, PM_NODE_OATTR, sPcId)) {
                    continue;
                }

                // Insert its children into the queue.
                attrs = ctx.getAttributes("CN=" + sOaId + ","
                        + sObjAttrContainerDN);
                attr = attrs.get("pmToAttr");
                if (attr != null) {
                    for (NamingEnumeration<?> enumer = attr.getAll(); enumer.hasMore(); ) {
                        queue.add((String) enumer.next());
                    }
                }
                // Mark this element as visited.
                visited.add(sOaId);
            }
        } catch (Exception e) {
            if (debugFlag) {
                e.printStackTrace();
            }
        }
        return visited;
    }

    /*private void visitDescOattr(String sOaId, Vector<String> queue) {
    System.out.println("Visiting " + sOaId + "-"
    + getNameOfEntityWithIdAndType(sOaId, PM_NODE_OATTR));

    try {
    Attributes attrs = ctx.getAttributes("CN=" + sOaId + ","
    + sObjAttrContainerDN);
    Attribute attr = attrs.get("pmToAttr");
    if (attr != null) {
    for (NamingEnumeration<?> enumer = attr.getAll(); enumer
    .hasMore();) {
    queue.add((String) enumer.next());
    }
    }
    } catch (Exception e) {
    if (debugFlag) {
    e.printStackTrace();
    }
    }
    }*/
    // Get the vector of object attributes an opset is assigned to.
    private Vector<String> getToAttrs(String sOpsetId) {
        Vector<String> v = new Vector<String>();
        try {
            Attributes attrs = ctx.getAttributes("CN=" + sOpsetId + ","
                    + sOpsetContainerDN);
            Attribute attr = attrs.get("pmToAttr");
            if (attr == null) {
                return v;
            }
            for (NamingEnumeration<?> enumer = attr.getAll(); enumer.hasMore(); ) {
                v.add((String) enumer.next());
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
        return v;
    }

    // Get the vector of user attributes assigned to an opset.
    private Vector<String> getFromAttrs(String sOpsetId) {
        Vector<String> v = new Vector<String>();
        try {
            Attributes attrs = ctx.getAttributes("CN=" + sOpsetId + ","
                    + sOpsetContainerDN);
            Attribute attr = attrs.get("pmFromAttr");
            if (attr == null) {
                return v;
            }
            for (NamingEnumeration<?> enumer = attr.getAll(); enumer.hasMore(); ) {
                v.add((String) enumer.next());
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
        return v;
    }

    // For a given user attribute, get the operation sets this attribute is
    // assigned to.
    private Attribute getToOpsets(QueueElement qe) throws Exception {
        Attributes attrs = ctx.getAttributes("CN=" + qe.getId() + ","
                + sUserAttrContainerDN);
        Attribute attr = attrs.get("pmToOpset");
        return attr;
    }

    // For an object attribute, get the operation sets assigned to this oattr.
    private Vector<String> getFromOpsets(String sAttrId) {
        Vector<String> v = new Vector<String>();
        try {
            Attributes attrs = ctx.getAttributes("CN=" + sAttrId + ","
                    + sObjAttrContainerDN);
            Attribute attr = attrs.get("pmFromOpset");
            if (attr == null) {
                return v;
            }
            for (NamingEnumeration<?> enumer = attr.getAll(); enumer.hasMore(); ) {
                v.add((String) enumer.next());
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
        return v;
    }

    // For a user attribute, get the operation sets this attribute is assigned
    // to, as a vector.
    private Vector<String> getToOpsets(String sAttrId) {
        Vector<String> v = new Vector<String>();
        try {
            Attributes attrs = ctx.getAttributes("CN=" + sAttrId + ","
                    + sUserAttrContainerDN);
            Attribute attr = attrs.get("pmToOpset");
            if (attr == null) {
                return v;
            }
            for (NamingEnumeration<?> enumer = attr.getAll(); enumer.hasMore(); ) {
                v.add((String) enumer.next());
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
        return v;
    }

    // For a given user attribute or object attribute, get the policy classes
    // this attribute is assigned to (directly).
    private Attribute getToPolicies(QueueElement qe) throws Exception {
        String sContainer = null;
        if (qe.getType().equalsIgnoreCase(PM_NODE_UATTR)) {
            sContainer = sUserAttrContainerDN;
        } else if (qe.getType().equalsIgnoreCase(PM_NODE_OATTR)) {
            sContainer = sObjAttrContainerDN;
        } else if (qe.getType().equalsIgnoreCase(PM_NODE_ASSOC)) {
            sContainer = sObjAttrContainerDN;
        } else {
            return null;
        }
        Attributes attrs = ctx.getAttributes("CN=" + qe.getId() + ","
                + sContainer);
        Attribute attr = attrs.get("pmToPolicy");
        return attr;
    }

    // For a given user or object attribute, get the policy classes the
    // attribute is assigned to.
    // Argument sType should be PM_NODE_UATTR or PM_NODE_OATTR or PM_NODE_ASSOC.
    private Attribute getToPolicies(String sId, String sType) throws Exception {
        Attributes attrs = null;

        if (sType.equalsIgnoreCase(PM_NODE_UATTR)) {
            attrs = ctx.getAttributes("CN=" + sId + "," + sUserAttrContainerDN);
        } else if (sType.equalsIgnoreCase(PM_NODE_OATTR)
                || sType.equalsIgnoreCase(PM_NODE_ASSOC)) {
            attrs = ctx.getAttributes("CN=" + sId + "," + sObjAttrContainerDN);
        } else {
            return null;
        }

        Attribute attr = attrs.get("pmToPolicy");
        return attr;
    }

    private Attribute getToConnector(String sId, String sType) throws Exception {
        Attributes attrs = null;

        if (sType.equalsIgnoreCase(PM_NODE_UATTR)) {
            attrs = ctx.getAttributes("CN=" + sId + "," + sUserAttrContainerDN);
        } else if (sType.equalsIgnoreCase(PM_NODE_OATTR)
                || sType.equalsIgnoreCase(PM_NODE_ASSOC)) {
            attrs = ctx.getAttributes("CN=" + sId + "," + sObjAttrContainerDN);
        } else {
            return null;
        }

        Attribute attr = attrs.get("pmToConnector");
        return attr;
    }

    // For the connector node, get the policy classes assigned to it (i.e.,
    // all).
    // NOTE THAT THE ATTRIBUTE SHOULD BE CALLED pmFromPolicy, BUT I WRONGLY
    // DEFINED IT AS BEING SINGLE VALUED, SO I HAD TO DEFINE A NEW ONE,
    // MULTI-VALUED.
    private Attribute getFromPolicies(QueueElement qe) throws Exception {
        Attributes attrs = ctx.getAttributes("CN=" + qe.getId() + ","
                + sConnectorContainerDN);
        Attribute attr = attrs.get("pmFromPolicyClass");
        return attr;
    }

    private Attribute getFromPolicies(String sBaseId, String sBaseType)
            throws Exception {
        Attributes attrs = ctx.getAttributes("CN=" + sBaseId + ","
                + sConnectorContainerDN);
        Attribute attr = attrs.get("pmFromPolicyClass");
        return attr;
    }

    // For the connector node or an object attribute, get the operation sets
    // assigned to it.
    private Attribute getFromOpsets(QueueElement qe) throws Exception {
        Attributes attrs;
        String sDn;
        String sType = qe.getType();

        if (sType.equalsIgnoreCase(PM_NODE_CONN)) {
            sDn = "CN=" + qe.getId() + "," + sConnectorContainerDN;
        } else if (sType.equalsIgnoreCase(PM_NODE_OATTR)
                || sType.equalsIgnoreCase(PM_NODE_ASSOC)) {
            sDn = "CN=" + qe.getId() + "," + sObjAttrContainerDN;
        } else {
            return null;
        }
        attrs = ctx.getAttributes(sDn);
        return attrs.get("pmFromOpSet");
    }

    private Attribute getFromOpsets(String sBaseId, String sBaseType)
            throws Exception {
        Attributes attrs;
        String sDn;

        if (sBaseType.equalsIgnoreCase(PM_NODE_CONN)) {
            sDn = "CN=" + sBaseId + "," + sConnectorContainerDN;
        } else if (sBaseType.equalsIgnoreCase(PM_NODE_OATTR)
                || sBaseType.equalsIgnoreCase(PM_NODE_ASSOC)) {
            sDn = "CN=" + sBaseId + "," + sObjAttrContainerDN;
        } else {
            return null;
        }
        attrs = ctx.getAttributes(sDn);
        return attrs.get("pmFromOpSet");
    }

    // For a policy class or connector node, get the user attributes
    // (directly) assigned to it. Params:
    // qe: a QueueElement that contains the id and type of the base node.
    private Attribute getFromUserAttrs(QueueElement qe) throws Exception {
        Attributes attrs;
        //Attribute attr;
        String sType = qe.getType();
        if (sType.equalsIgnoreCase(PM_NODE_POL)) {
            attrs = ctx.getAttributes("CN=" + qe.getId() + ","
                    + sPolicyContainerDN);
        } else if (sType.equalsIgnoreCase(PM_NODE_CONN)) {
            attrs = ctx.getAttributes("CN=" + qe.getId() + ","
                    + sConnectorContainerDN);
        } else {
            return null;
        }
        return attrs.get("pmFromUserAttr");
    }

    // For a policy class or connector node, get the user attributes
    // (directly) assigned to it.
    private Attribute getFromUserAttrs(String sBaseId, String sBaseType)
            throws Exception {
        Attributes attrs;
        //Attribute attr;
        if (sBaseType.equalsIgnoreCase(PM_NODE_POL)) {
            attrs = ctx.getAttributes("CN=" + sBaseId + ","
                    + sPolicyContainerDN);
        } else if (sBaseType.equalsIgnoreCase(PM_NODE_CONN)) {
            attrs = ctx.getAttributes("CN=" + sBaseId + ","
                    + sConnectorContainerDN);
        } else {
            return null;
        }
        return attrs.get("pmFromUserAttr");
    }

    // Get the user attributes that are direct ascendants of a base node. The
    // base node
    // can be a user attribute, the connector, a policy class, or an operation
    // set.
    private Packet getDascUattrs(String sBaseName, String sBaseType) {
        String sBaseId = getEntityId(sBaseName, sBaseType);
        if (sBaseId == null) {
            return failurePacket("No PM entity \"" + sBaseName + "\" of type "
                    + sBaseType);
        }
        String sCont = null;
        if (sBaseType.equalsIgnoreCase(PM_NODE_CONN)) {
            sCont = sConnectorContainerDN;
        } else if (sBaseType.equalsIgnoreCase(PM_NODE_POL)) {
            sCont = sPolicyContainerDN;
        } else if (sBaseType.equalsIgnoreCase(PM_NODE_UATTR)) {
            sCont = sUserAttrContainerDN;
        } else if (sBaseType.equalsIgnoreCase(PM_NODE_OPSET)) {
            sCont = sOpsetContainerDN;
        } else {
            return failurePacket("Invalid type " + sBaseType
                    + " in getDascUattrs");
        }
        try {
            Attributes attrs = ctx.getAttributes("CN=" + sBaseId + "," + sCont);
            Attribute attr = null;
            if (sBaseType.equalsIgnoreCase(PM_NODE_CONN)
                    || sBaseType.equalsIgnoreCase(PM_NODE_POL)) {
                attr = attrs.get("pmFromUserAttr");
            } else if (sBaseType.equalsIgnoreCase(PM_NODE_UATTR)
                    || sBaseType.equalsIgnoreCase(PM_NODE_OPSET)) {
                attr = attrs.get("pmFromAttr");
            }

            Packet result = new Packet();
            if (attr != null) {
                for (NamingEnumeration<?> enumer = attr.getAll(); enumer.hasMore(); ) {
                    String sId = (String) enumer.next();
                    String sName = getEntityName(sId, PM_NODE_UATTR);
                    result.addItem(ItemType.RESPONSE_TEXT, sName
                            + PM_FIELD_DELIM + sId);
                }
            }
            return result;
        } catch (Exception e) {
            e.printStackTrace();
            return failurePacket("Exception in getDascUattrs");
        }
    }

    // Get the users that are direct ascendants of a base node. The base node
    // can be a user attribute or the connector.
    private Packet getDascUsers(String sBaseName, String sBaseType) {
        String sBaseId = getEntityId(sBaseName, sBaseType);
        if (sBaseId == null) {
            return failurePacket("No PM entity \"" + sBaseName + "\" of type "
                    + sBaseType);
        }
        String sCont = null;
        if (sBaseType.equalsIgnoreCase(PM_NODE_CONN)) {
            sCont = sConnectorContainerDN;
        } else if (sBaseType.equalsIgnoreCase(PM_NODE_UATTR)) {
            sCont = sUserAttrContainerDN;
        } else {
            return failurePacket("Invalid type " + sBaseType
                    + " in getDascUsers");
        }
        try {
            Attributes attrs = ctx.getAttributes("CN=" + sBaseId + "," + sCont);
            Attribute attr = attrs.get("pmFromUser");

            Packet result = new Packet();
            if (attr != null) {
                for (NamingEnumeration<?> enumer = attr.getAll(); enumer.hasMore(); ) {
                    String sId = (String) enumer.next();
                    String sName = getEntityName(sId, PM_NODE_USER);
                    result.addItem(ItemType.RESPONSE_TEXT, sName
                            + PM_FIELD_DELIM + sId);
                }
            }
            return result;
        } catch (Exception e) {
            e.printStackTrace();
            return failurePacket("Exception in getDascUsers");
        }
    }

    // Get the object attributes that are direct ascendants of a base node AND
    // NOT OBJECTS.
    // The base node can be an object attribute, the connector, or a policy
    // class.
    private Packet getDascOattrs(String sBaseName, String sBaseType) {
        String sBaseId = getEntityId(sBaseName, sBaseType);
        if (sBaseId == null) {
            return failurePacket("No PM entity \"" + sBaseName + "\" of type "
                    + sBaseType);
        }
        String sCont = null;
        if (sBaseType.equalsIgnoreCase(PM_NODE_CONN)) {
            sCont = sConnectorContainerDN;
        } else if (sBaseType.equalsIgnoreCase(PM_NODE_POL)) {
            sCont = sPolicyContainerDN;
        } else if (sBaseType.equalsIgnoreCase(PM_NODE_OATTR)) {
            sCont = sObjAttrContainerDN;
        } else {
            return failurePacket("Invalid type " + sBaseType
                    + " in getDascOattrs");
        }
        try {
            Attributes attrs = ctx.getAttributes("CN=" + sBaseId + "," + sCont);
            Attribute attr = null;
            if (sBaseType.equalsIgnoreCase(PM_NODE_CONN)
                    || sBaseType.equalsIgnoreCase(PM_NODE_POL)) {
                attr = attrs.get("pmFromObjAttr");
            } else if (sBaseType.equalsIgnoreCase(PM_NODE_OATTR)) {
                attr = attrs.get("pmFromAttr");
            }

            Packet result = new Packet();
            if (attr != null) {
                for (NamingEnumeration<?> enumer = attr.getAll(); enumer.hasMore(); ) {
                    String sId = (String) enumer.next();
                    if (hasAssocObj(sId)) {
                        continue;
                    }
                    String sName = getEntityName(sId, PM_NODE_OATTR);
                    result.addItem(ItemType.RESPONSE_TEXT, sName
                            + PM_FIELD_DELIM + sId);
                }
            }
            return result;
        } catch (Exception e) {
            e.printStackTrace();
            return failurePacket("Exception in getDascOattrs");
        }
    }

    // Get the object attributes that are direct ascendants of a base node AND
    // ALSO OBJECTS.
    // The base node can be an object attribute, the connector, or a policy
    // class.
    private Packet getDascObjects(String sBaseName, String sBaseType) {
        String sBaseId = getEntityId(sBaseName, sBaseType);
        if (sBaseId == null) {
            return failurePacket("No PM entity \"" + sBaseName + "\" of type "
                    + sBaseType);
        }
        String sCont = null;
        if (sBaseType.equalsIgnoreCase(PM_NODE_CONN)) {
            sCont = sConnectorContainerDN;
        } else if (sBaseType.equalsIgnoreCase(PM_NODE_POL)) {
            sCont = sPolicyContainerDN;
        } else if (sBaseType.equalsIgnoreCase(PM_NODE_OATTR)) {
            sCont = sObjAttrContainerDN;
        } else {
            return failurePacket("Invalid type " + sBaseType
                    + " in getDascObjects");
        }
        try {
            Attributes attrs = ctx.getAttributes("CN=" + sBaseId + "," + sCont);
            Attribute attr = null;
            if (sBaseType.equalsIgnoreCase(PM_NODE_CONN)
                    || sBaseType.equalsIgnoreCase(PM_NODE_POL)) {
                attr = attrs.get("pmFromObjAttr");
            } else if (sBaseType.equalsIgnoreCase(PM_NODE_OATTR)) {
                attr = attrs.get("pmFromAttr");
            }

            Packet result = new Packet();
            if (attr != null) {
                for (NamingEnumeration<?> enumer = attr.getAll(); enumer.hasMore(); ) {
                    String sId = (String) enumer.next();
                    if (!hasAssocObj(sId)) {
                        continue;
                    }
                    String sName = getEntityName(sId, PM_NODE_OATTR);
                    result.addItem(ItemType.RESPONSE_TEXT, sName
                            + PM_FIELD_DELIM + sId);
                }
            }
            return result;
        } catch (Exception e) {
            e.printStackTrace();
            return failurePacket("Exception in getDascObjects");
        }
    }

    // Get the operation sets that are direct ascendants of a base node. The
    // base node
    // can be an object attribute or the connector.
    private Packet getDascOpsets(String sBaseName, String sBaseType) {
        String sBaseId = getEntityId(sBaseName, sBaseType);
        if (sBaseId == null) {
            return failurePacket("No PM entity \"" + sBaseName + "\" of type "
                    + sBaseType);
        }
        String sCont;
        if (sBaseType.equalsIgnoreCase(PM_NODE_CONN)) {
            sCont = sConnectorContainerDN;
        } else if (sBaseType.equalsIgnoreCase(PM_NODE_OATTR)) {
            sCont = sObjAttrContainerDN;
        } else {
            return failurePacket("Invalid base node type " + sBaseType
                    + " in getDascOpsets");
        }
        try {
            Attributes attrs = ctx.getAttributes("CN=" + sBaseId + "," + sCont);
            Attribute attr = attrs.get("pmFromOpSet");

            Packet result = new Packet();
            if (attr != null) {
                for (NamingEnumeration<?> enumer = attr.getAll(); enumer.hasMore(); ) {
                    String sId = (String) enumer.next();
                    String sName = getEntityName(sId, PM_NODE_OPSET);
                    result.addItem(ItemType.RESPONSE_TEXT, sName
                            + PM_FIELD_DELIM + sId);
                }
            }
            return result;
        } catch (Exception e) {
            e.printStackTrace();
            return failurePacket("Exception in getDascOpsets");
        }
    }

    // For a policy class or the connector node, get the object attributes
    // (directly) assigned to it. Params:
    // qe: a QueueElement that contains the id and type of the policy class
    // or the connector node.
    private Attribute getFromObjAttrs(QueueElement qe) throws Exception {
        Attributes attrs;
        //Attribute attr;
        String sType = qe.getType();
        if (sType.equalsIgnoreCase(PM_NODE_POL)) {
            attrs = ctx.getAttributes("CN=" + qe.getId() + ","
                    + sPolicyContainerDN);
        } else if (sType.equalsIgnoreCase(PM_NODE_CONN)) {
            attrs = ctx.getAttributes("CN=" + qe.getId() + ","
                    + sConnectorContainerDN);
        } else {
            return null;
        }
        return attrs.get("pmFromObjAttr");
    }

    private Attribute getFromObjAttrs(String sBaseId, String sBaseType)
            throws Exception {
        Attributes attrs;
        if (sBaseType.equalsIgnoreCase(PM_NODE_POL)) {
            attrs = ctx.getAttributes("CN=" + sBaseId + ","
                    + sPolicyContainerDN);
        } else if (sBaseType.equalsIgnoreCase(PM_NODE_CONN)) {
            attrs = ctx.getAttributes("CN=" + sBaseId + ","
                    + sConnectorContainerDN);
        } else {
            return null;
        }
        return attrs.get("pmFromObjAttr");
    }

    private void setLastUpdateTimestamp() {
        sLastUpdateTimestamp = dfUpdate.format(new Date());
    }

    // Argument n is a byte with a small positive or zero value - actually
    // between 0 and 15 - representing the decimal value of a hex digit.
    // The method returns a byte that corresponds to the character representing
    // the hex digit. For example, if n = 7, the method returns 0x37, i.e. '7'.
    // If n = 12, the method returns 'C'.
    byte byte2HexDigit(byte n) {
        if (n < 10) {
            return (byte) ('0' + n);
        } else {
            return (byte) ('A' + n - 10);
        }
    }

    String byteArray2HexString(byte[] inp, int length) {
        byte[] buf = new byte[2 * length];
        int inpix, outix;
        int n;
        byte q, r;

        for (inpix = outix = 0; inpix < length; inpix++) {
            n = inp[inpix] & 0x000000FF;
            q = (byte) (n / 16);
            r = (byte) (n % 16);
            buf[outix++] = byte2HexDigit(q);
            buf[outix++] = byte2HexDigit(r);
        }
        return new String(buf);
    }

    String byteArray2HexString(byte[] inp) {
        byte[] buf = new byte[2 * inp.length];
        int inpix, outix;
        int n;
        byte q, r;

        for (inpix = outix = 0; inpix < inp.length; inpix++) {
            n = inp[inpix] & 0x000000FF;
            q = (byte) (n / 16);
            r = (byte) (n % 16);
            buf[outix++] = byte2HexDigit(q);
            buf[outix++] = byte2HexDigit(r);
        }
        return new String(buf);
    }

    byte hexDigit2Byte(char c) {
        if (c >= '0' && c <= '9') {
            return (byte) (c - '0');
        } else if (c >= 'a' && c <= 'f') {
            return (byte) (c - 'a' + 10);
        } else if (c >= 'A' && c <= 'F') {
            return (byte) (c - 'A' + 10);
        } else {
            return (byte) 0;
        }
    }

    byte[] hexString2ByteArray(String inp) {
        //int len;
        int inpix, outix;

        if (inp == null || inp.length() == 0 || inp.length() % 2 != 0) {
            return null;
        }
        byte[] out = new byte[inp.length() / 2];

        for (inpix = 0, outix = 0; inpix < inp.length(); ) {
            int msn = hexDigit2Byte(inp.charAt(inpix++));
            int lsn = hexDigit2Byte(inp.charAt(inpix++));

            out[outix++] = (byte) ((msn << 4) | lsn);
        }
        return out;
    }

    // Characters (x means invalid)
    // Char RCC-DOT AD WIN URL
    // ` %60 Note: displayed as \` by dot
    // ~ %7E
    // ! %21
    // @ %40
    // # x
    // $ %24
    // % %25
    // ^ %5E
    // & %26
    // * x
    // ( %28
    // ) %29
    // - -
    // _ _
    // + x x
    // = x x
    // { %7B
    // } %7C
    // [ x
    // ] x
    // | x
    // \ x x
    // ; x x
    // : x x
    // ' %27 Note: displayed as \' by dot
    // " x x
    // , x x
    // . .
    // < x
    // > x
    // ? x
    // / x
    // sp +
    //
    // At this time we accept letters, digits, underscore, space, period
    /*private boolean nameIsValid(String sName) {
   if (sName == null || sName.length() == 0) {
   return false;
   }
   String s = sName.trim();
   if (s.length() == 0) {
   return false;
   }
   char[] buf = s.toCharArray();
   for (int i = 0; i < buf.length; i++) {
   if (Character.isLetterOrDigit(buf[i])) {
   continue;
   }
   if (buf[i] == ' ' || buf[i] == '_' || buf[i] == '.') {
   continue;
   }
   // Add here as you support more...
   return false;
   }
   return true;
   }
    */
    private boolean hostNameIsValid(String sName) {
        if (sName == null || sName.length() == 0) {
            return false;
        }
        String s = sName.trim();
        if (s.length() == 0) {
            return false;
        }
        char[] buf = s.toCharArray();
        for (char aBuf : buf) {
            if (Character.isLetterOrDigit(aBuf)) {
                continue;
            }
            if (aBuf == '_' || aBuf == '.') {
                continue;
            }
            if (aBuf == '-') {
                continue;
            }
            return false;
        }
        return true;
    }

    public static boolean isFailurePacket(Packet p) {
        return !(p == null || p.size() == 0) && p.hasError();
    }

    public static boolean isSuccessPacket(Packet p) {
        return !(p == null || p.size() == 0) && !p.hasError();
    }

    // Get the items string contents from a packet starting at given index as an
    // array of strings.
    private String[] getItemsFromPacket(Packet p, int index) {
        if (p == null || p.size() <= index) {
            return null;
        }
        int n = p.size() - index;
        String[] res = new String[n];
        for (int i = 0; i < n; i++) {
            res[i] = p.getStringValue(index + i);
        }
        return res;
    }

    public static void main(String[] args) {
        boolean bDebug = false;
        int nPort = 8080;

        for (int i = 0; i < args.length; i++) {
            if (args[i].equals("-debug")) {
                bDebug = true;
            } else if (args[i].equals("-engineport")) {
                nPort = Integer.valueOf(args[++i]);
            }
        }

        try {
            final PmEngine engine = new PmEngine(bDebug, nPort);

            DialogUtils.getAllSystemProperties("Server");

            SSLSocketServer sslServer = new SSLSocketServer(nPort,
                    bDebug, "s,E") {

                @Override
                public Packet executeCommand(String clientName, Packet command, InputStream fromClient, OutputStream toClient) {
                    return engine.executeCommand(clientName, command, fromClient, toClient);
                }
            };
            System.out.println("PM Server running...");
            sslServer.service();
        } catch (Exception e) {
            e.printStackTrace();
            System.exit(1);
        }
    }
}

class QueueElement {

    /**
	 * @uml.property  name="sType"
	 */
    private String sType;
    /**
	 * @uml.property  name="sId"
	 */
    private String sId;
    /**
	 * @uml.property  name="nLevel"
	 */
    private int nLevel;

    public QueueElement(String sType, String sId, int nLevel) {
        this.sType = sType;
        this.sId = sId;
        this.nLevel = nLevel;
    }

    public String getType() {
        return sType;
    }

    public String getId() {
        return sId;
    }

    public int getLevel() {
        return nLevel;
    }
}

class AdminVosQueueElement {
    // The nodes inserted in the queue are: policy classes, user attributes,
    // users, object attributes, object attributes associated to objects,
    // operation sets.
    // Node type. Its value may be PM_NODE_POL, PM_NODE_UATTR, PM_NODE_USER,
    // PM_NODE_OATTR, PM_NODE_ASSOC, PM_NODE_OPSET.

    /**
	 * @uml.property  name="sType"
	 */
    private String sType;
    // The original id of the node:
    /**
	 * @uml.property  name="sId"
	 */
    private String sId;
    // The new id (which is also the CN in the VOS container). Link the direct
    // ascendants of sId to this id:
    /**
	 * @uml.property  name="sDescId"
	 */
    private String sDescId;

    public AdminVosQueueElement(String sType, String sId, String sDescId) {
        this.sType = sType;
        this.sId = sId;
        this.sDescId = sDescId;
    }

    public String getType() {
        return sType;
    }

    public String getId() {
        return sId;
    }

    public String getDesc() {
        return sDescId;
    }
}

class VosQueueElement {
    // The nodes inserted in the queue are always object attributes.
    // There is no need for type, nor for level.
    // This is the original id of the node inserted in queue:

    /**
	 * @uml.property  name="sOaId"
	 */
    private String sOaId;
    // This is the new id (which is also the CN in the VOS container) of the
    // descendant to use to link the direct ascendants of sOaId to.
    /**
	 * @uml.property  name="sDescId"
	 */
    private String sDescId;

    public VosQueueElement(String sOaId, String sDescId) {
        this.sOaId = sOaId;
        this.sDescId = sDescId;
    }

    public String getId() {
        return sOaId;
    }

    public String getDesc() {
        return sDescId;
    }
}

// Class Action's Operand
class ActOpnd {

    /**
	 * @uml.property  name="sName"
	 */
    private String sName;
    /**
	 * @uml.property  name="sType"
	 */
    private String sType;
    /**
	 * @uml.property  name="sId"
	 */
    private String sId;
    /**
	 * @uml.property  name="bSubgraph"
	 */
    private boolean bSubgraph;
    /**
	 * @uml.property  name="bComplement"
	 */
    private boolean bComplement;
    /**
	 * @uml.property  name="sError"
	 */
    private String sError;

    public ActOpnd(String sName, String sType, String sId, boolean bSubgraph,
                   boolean bComplement, String sError) {
        this.sName = sName;
        this.sType = sType;
        this.sId = sId;
        this.bSubgraph = bSubgraph;
        this.bComplement = bComplement;
        this.sError = sError;
    }

    public String getName() {
        return sName;
    }

    public String getId() {
        return sId;
    }

    public String getType() {
        return sType;
    }

    public boolean isSubgraph() {
        return bSubgraph;
    }

    public boolean isComplement() {
        return bComplement;
    }

    public String getError() {
        return sError;
    }

    public void setName(String sName) {
        this.sName = sName;
    }

    public void setId(String sId) {
        this.sId = sId;
    }

    public void setType(String sType) {
        this.sType = sType;
    }

    public void setSubgraph(boolean bSubgraph) {
        this.bSubgraph = bSubgraph;
    }

    public void setComplement(boolean bComplement) {
        this.bComplement = bComplement;
    }

    public void setError(String sError) {
        this.sError = sError;
    }
}

class EventContext {

    /**
	 * @uml.property  name="sSessId"
	 */
    private String sSessId;
    /**
	 * @uml.property  name="sProcId"
	 */
    private String sProcId;
    /**
	 * @uml.property  name="sEventName"
	 */
    private String sEventName;
    /**
	 * @uml.property  name="sObjName"
	 */
    private String sObjName;
    /**
	 * @uml.property  name="sObjClass"
	 */
    private String sObjClass;
    /**
	 * @uml.property  name="sObjType"
	 */
    private String sObjType;
    /**
	 * @uml.property  name="sObjId"
	 */
    private String sObjId;
    /**
	 * @uml.property  name="sCtx1"
	 */
    private String sCtx1;
    /**
	 * @uml.property  name="sCtx2"
	 */
    private String sCtx2;

    public EventContext(String sSessId, String sProcId, String sEventName,
                        String sObjName, String sObjClass, String sObjType, String sObjId,
                        String sCtx1, String sCtx2) {
        this.sSessId = sSessId;
        this.sProcId = sProcId;
        this.sEventName = sEventName;
        this.sObjName = sObjName;
        this.sObjClass = sObjClass;
        this.sObjType = sObjType;
        this.sObjId = sObjId;
        this.sCtx1 = sCtx1;
        this.sCtx2 = sCtx2;
    }

    public String getSessId() {
        return sSessId;
    }

    public String getProcId() {
        return sProcId;
    }

    public String getEventName() {
        return sEventName;
    }

    public String getObjName() {
        return sObjName;
    }

    public String getObjId() {
        return sObjId;
    }

    public String getObjClass() {
        return sObjClass;
    }

    public String getObjType() {
        return sObjType;
    }

    public String getCtx1() {
        return sCtx1;
    }

    public String getCtx2() {
        return sCtx2;
    }
}

class EvrFunction {

    /**
	 * @uml.property  name="sName"
	 */
    private String sName;
    /**
	 * @uml.property  name="sType"
	 */
    private String sType;
    /**
	 * @uml.property  name="sParamTypes"
	 */
    private String sParamTypes;

    public EvrFunction(String sName, String sType, String sParamTypes) {
        this.sName = sName;
        this.sType = sType;
        this.sParamTypes = sParamTypes;
    }

    public String getName() {
        return sName;
    }

    public String getType() {
        return sType;
    }

    public String getParamTypes() {
        return sParamTypes;
    }
}
